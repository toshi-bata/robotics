function Jw(s, t) {
  for (var e = 0; e < t.length; e++) {
    const i = t[e];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const n in i)
        if (n !== "default" && !(n in s)) {
          const r = Object.getOwnPropertyDescriptor(i, n);
          r && Object.defineProperty(s, n, r.get ? r : {
            enumerable: !0,
            get: () => i[n]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }));
}
const WC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Yw = "¹", Sp = "²", Mp = "³", Zd = "⁻", Zw = "Ω";
var gi = /* @__PURE__ */ ((s) => (s[s.unitUnknown = 0] = "unitUnknown", s[s.unitLength = 1] = "unitLength", s[s.unitMass = 2] = "unitMass", s[s.unitTime = 3] = "unitTime", s[s.unitElectricCurrent = 4] = "unitElectricCurrent", s[s.unitThermoTemperature = 5] = "unitThermoTemperature", s[s.unitSubstanceAmount = 6] = "unitSubstanceAmount", s[s.unitLuminosityIntensity = 7] = "unitLuminosityIntensity", s[s.unitPlaneAngle = 8] = "unitPlaneAngle", s[s.unitSolidAngle = 9] = "unitSolidAngle", s[s.unitFrequency = 10] = "unitFrequency", s[s.unitForce = 11] = "unitForce", s[s.unitPressure = 12] = "unitPressure", s[s.unitEnergy = 13] = "unitEnergy", s[s.unitPower = 14] = "unitPower", s[s.unitElectricCharge = 15] = "unitElectricCharge", s[s.unitElectromotiveForce = 16] = "unitElectromotiveForce", s[s.unitCapacitance = 17] = "unitCapacitance", s[s.unitElectricResistance = 18] = "unitElectricResistance", s[s.unitElectricConductance = 19] = "unitElectricConductance", s[s.unitMagneticFlux = 20] = "unitMagneticFlux", s[s.unitMagneticFluxDensity = 21] = "unitMagneticFluxDensity", s[s.unitInductance = 22] = "unitInductance", s[s.unitLuminousFlux = 23] = "unitLuminousFlux", s[s.unitIlluminance = 24] = "unitIlluminance", s[s.unitActivityRadionuclide = 25] = "unitActivityRadionuclide", s[s.unitKerma = 26] = "unitKerma", s[s.unitDoseEquivalent = 27] = "unitDoseEquivalent", s[s.unitCatalyticActivity = 28] = "unitCatalyticActivity", s))(gi || {});
function vm(s) {
  return s !== null && typeof s == "object" && "x" in s && typeof s.x == "number" && "y" in s && typeof s.y == "number";
}
function bm(s) {
  return s !== null && typeof s == "object" && "z" in s && typeof s.z == "number" && vm(s);
}
function GC(s) {
  return s !== null && typeof s == "object" && "w" in s && typeof s.w == "number" && bm(s);
}
class m {
  /**
   * Creates a new point object.
   * @param x X value
   * @param y Y value
   * @param z Z value
   */
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i;
  }
  /**
   * Sets this point equal to another point.
   * @param point The point to assign.
   * @returns This point object.
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  /**
   * Sets the values of this point.
   * @param x X value to set.
   * @param y Y value to set.
   * @param z Z value to set.
   * @returns This point object.
   */
  set(t, e, i) {
    return this.x = t, this.y = e, this.z = i, this;
  }
  /**
   * Sets an array from this point.
   * @param arr Array to assign.
   */
  toArray(t = [0, 0, 0]) {
    return t[0] = this.x, t[1] = this.y, t[2] = this.z, t;
  }
  /**
   * Sets this point from an array.
   * @param arr Array to assign from.
   * @returns This point object.
   */
  fromArray(t) {
    return this.x = t[0], this.y = t[1], this.z = t[2], this;
  }
  /**
   * Adds another point to this point.
   * @param point Point to add.
   * @returns This point object.
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  /**
   * Subtracts another point from this point.
   * @param point Point to subtract.
   * @returns This point object.
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  /**
   * Creates a copy of this point.
   * @returns Copy of this point object.
   */
  copy() {
    return new m(this.x, this.y, this.z);
  }
  /**
   * Creates a new [[Point3]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (bm(t))
      return new m(t.x, t.y, t.z);
    throw new TypeError("Point3.fromJson: data does not satisfy type IPoint3 constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
  /**
   * Returns a boolean value indicating if this vector lies on a major axis.
   */
  isAxis() {
    return Math.abs(this.x) === 1 && this.y === 0 && this.z === 0 || this.x === 0 && Math.abs(this.y) === 1 && this.z === 0 || this.x === 0 && this.y === 0 && Math.abs(this.z) === 1;
  }
  /**
   * Returns the length of this vector.
   * @returns Vector length.
   */
  length() {
    return m.magnitude(this);
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return m.squaredLength(this);
  }
  /**
   * Scale the point by constant value.
   * @param k Constant value to scale by.
   * @returns Point object.
   */
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  /**
   * Normalizes the vector.
   * @returns This object.
   */
  normalize() {
    const t = this.length();
    return t === 0 ? this : this.scale(1 / t);
  }
  /**
   * Negates the point.
   * @returns This object.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Creates a new Point initialized to (0,0,0).
   * @returns New point with all elements set to 0.
   */
  static zero() {
    return new m(0, 0, 0);
  }
  /**
   * Adds two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Sum of p1 and p2.
   */
  static add(t, e) {
    return new m(t.x + e.x, t.y + e.y, t.z + e.z);
  }
  /**
   * Subtract two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Difference of p1 and p2.
   */
  static subtract(t, e) {
    return new m(t.x - e.x, t.y - e.y, t.z - e.z);
  }
  /**
   * Calculate dot product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Dot product of p1 and p2.
   */
  static dot(t, e) {
    return t.x * e.x + t.y * e.y + t.z * e.z;
  }
  /**
   * Calculate cross product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Cross product of p1 and p2.
   */
  static cross(t, e) {
    return new m(
      t.y * e.z - t.z * e.y,
      t.z * e.x - t.x * e.z,
      t.x * e.y - t.y * e.x
    );
  }
  /**
   * Returns the length of a vector.
   * @returns Vector length.
   */
  static magnitude(t) {
    return Math.sqrt(m.squaredLength(t));
  }
  /**
   * Returns the squared length of a vector.
   * @returns Vector squared length.
   */
  static squaredLength(t) {
    return t.x * t.x + t.y * t.y + t.z * t.z;
  }
  /**
   * Normalize a vector.
   * @param v First point.
   * @returns A vector that is colinear to v with a length of 1.
   */
  static normalize(t) {
    return new m(t.x, t.y, t.z).normalize();
  }
  /**
   * Calculate distance between two points
   * @param p1 First point
   * @param p2 Second point
   * @returns Distance between p1 and p2
   */
  static distance(t, e) {
    return m.subtract(e, t).length();
  }
  /**
   * Scale a point by a constant factor
   * @param p1 Point to scale
   * @param k Constant value to scale byS
   * @returns Copy of p scaled by a constant factor
   */
  static scale(t, e) {
    return new m(t.x * e, t.y * e, t.z * e);
  }
  /**
   * Creates a point from an array of numbers
   * @param Array to assign from
   * @returns new point set from array elements
   */
  static createFromArray(t) {
    return new m(t[0], t[1], t[2]);
  }
}
class Ur {
  constructor(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  set(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  assign(t) {
    this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w;
  }
  static zero() {
    return new Ur(0, 0, 0, 0);
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
}
let wt = class lr {
  /**
   * Creates a new matrix set to the identity matrix.
   */
  constructor() {
    this.loadIdentity();
  }
  /**
   * Sets the matrix to the identity matrix.
   * @returns This matrix object.
   */
  loadIdentity() {
    return this.m = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], this;
  }
  isIdentity() {
    const t = this.m;
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  /**
   * Strictly compares this matrix with another.
   * @param other Matrix to compare with.
   * @returns True if the values of this matrix equal those of the other.
   */
  equals(t) {
    for (let e = 0; e < 16; ++e) {
      const i = this.m[e], n = t.m[e];
      if (i !== n)
        return !1;
    }
    return !0;
  }
  /**
   * Compares this matrix with another using a tolerance.
   * @param other Matrix to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this matrix equal those of the other.
   */
  equalsWithTolerance(t, e) {
    e = Math.abs(e);
    for (let i = 0; i < 16; ++i)
      if (Math.abs(this.m[i] - t.m[i]) > e)
        return !1;
    return !0;
  }
  /**
   * Sets the scale components of this matrix.
   * @param x X scale value.
   * @param y Y scale value.
   * @param z Z scale value.
   * @returns This matrix object.
   */
  setScaleComponent(t, e, i) {
    return this.m[0] = t, this.m[5] = e, this.m[10] = i, this;
  }
  /**
   * Sets the translation components of this matrix.
   * @param x X translation value.
   * @param y Y translation value.
   * @param z Z translation value.
   * @returns This matrix object.
   */
  setTranslationComponent(t, e, i) {
    return this.m[12] = t, this.m[13] = e, this.m[14] = i, this;
  }
  /**
   * Creates a copy of this matrix.
   * @returns Copy of this matrix.
   */
  copy() {
    const t = new lr();
    return t.m = this.m.slice(), t;
  }
  /**
   * Sets the value of this matrix to another.
   * @param matrix the matrix whose values will be set.
   * @returns This matrix object.
   */
  assign(t) {
    for (let e = 0; e < t.m.length; e++)
      this.m[e] = t.m[e];
    return this;
  }
  /**
   * Multiply the matrix by given scalar.
   * @param scalar Scalar to multiply the matrix with.
   * @return This matrix object.
   */
  multiplyByScalar(t) {
    for (let e = 0; e < 16; e++)
      this.m[e] *= t;
    return this;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform(t, e) {
    return e = e ?? m.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12],
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13],
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14]
    ), e;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform4(t, e) {
    return e = e ?? Ur.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12] * t.w,
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13] * t.w,
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14] * t.w,
      t.x * this.m[3] + t.y * this.m[7] + t.z * this.m[11] + this.m[15] * t.w
    ), e;
  }
  /**
   * Transforms an array of points according to this matrix.
   * @param inPoints an array of points to be transformed.
   * @param outPoints an array that will be populated with transformed points. Note that the results will be pushed onto the end of the array.
   */
  transformArray(t, e) {
    for (let i = 0; i < t.length; i++) {
      const n = t[i], r = new m(
        n.x * this.m[0] + n.y * this.m[4] + n.z * this.m[8] + this.m[12],
        n.x * this.m[1] + n.y * this.m[5] + n.z * this.m[9] + this.m[13],
        n.x * this.m[2] + n.y * this.m[6] + n.z * this.m[10] + this.m[14]
      );
      e[i] = r;
    }
  }
  transformBox(t) {
    if (t.isDegenerate())
      return wn.invalid();
    const e = t.getCorners();
    for (const n of e)
      this.transform(n, n);
    const i = new wn(e[0], e[0]);
    for (let n = 1; n < e.length; ++n) {
      const r = e[n];
      i.addPoint(r);
    }
    return i;
  }
  /**
   * Sets this matrix equal to its transpose.
   * @returns This matrix object.
   */
  // prettier-ignore
  transpose() {
    let t;
    return t = this.m[1], this.m[1] = this.m[4], this.m[4] = t, t = this.m[2], this.m[2] = this.m[8], this.m[8] = t, t = this.m[3], this.m[3] = this.m[12], this.m[12] = t, t = this.m[6], this.m[6] = this.m[9], this.m[9] = t, t = this.m[7], this.m[7] = this.m[13], this.m[13] = t, t = this.m[11], this.m[11] = this.m[14], this.m[14] = t, this;
  }
  /**
   * Creates a matrix from an array of numbers.
   * @param arr 16 element array of numbers.
   * @returns New matrix with elements set to the values of the array parameter. Array elements will be in column-major order.
   */
  static createFromArray(t) {
    const e = new lr();
    return e.m = t.slice(), e;
  }
  /**
   * Creates a rotation matrix from an arbitrary axis.
   * @param axis Axis to rotate about.
   * @param degrees Amount of degrees to rotate about the provided axis.
   * @returns Rotation matrix which represents the rotation about the supplied axis.
   */
  static createFromOffAxisRotation(t, e) {
    const i = e * (Math.PI / 180), n = Math.sin(i), r = Math.cos(i), o = new lr(), l = t.copy().normalize(), h = 1 - r, u = h * l.x * l.y, f = h * l.x * l.z, g = h * l.y * l.z;
    return o.m[0] = h * l.x * l.x + r, o.m[1] = n * l.z + u, o.m[2] = f - n * l.y, o.m[3] = 0, o.m[4] = u - n * l.z, o.m[5] = h * l.y * l.y + r, o.m[6] = n * l.x + g, o.m[7] = 0, o.m[8] = n * l.y + f, o.m[9] = g - n * l.x, o.m[10] = h * l.z * l.z + r, o.m[11] = 0, o.m[12] = 0, o.m[13] = 0, o.m[14] = 0, o.m[15] = 1, o;
  }
  /**
   * Creates a matrix from three [[Point3]]s, which will be used as the
   * columns of the matrix.
   *
   * @param xAxis The first column.
   * @param yAxis The second column.
   * @param zAxis The third column.
   */
  static createFromBasis(t, e, i) {
    const n = new lr();
    return n.m[0] = t.x, n.m[1] = t.y, n.m[2] = t.z, n.m[4] = e.x, n.m[5] = e.y, n.m[6] = e.z, n.m[8] = i.x, n.m[9] = i.y, n.m[10] = i.z, n;
  }
  /**
   * Multiplies two matrices.
   *
   * (p' = ABp <=> p' = multiply(B, A).transform(p))
   *
   * @param m1 The first matrix.
   * @param m2 The second matrix.
   * @returns Matrix which is the result of the multiplication.
   */
  static multiply(t, e) {
    const i = new lr();
    return i.m[0] = t.m[0] * e.m[0] + t.m[1] * e.m[4] + t.m[2] * e.m[8] + t.m[3] * e.m[12], i.m[1] = t.m[0] * e.m[1] + t.m[1] * e.m[5] + t.m[2] * e.m[9] + t.m[3] * e.m[13], i.m[2] = t.m[0] * e.m[2] + t.m[1] * e.m[6] + t.m[2] * e.m[10] + t.m[3] * e.m[14], i.m[3] = t.m[0] * e.m[3] + t.m[1] * e.m[7] + t.m[2] * e.m[11] + t.m[3] * e.m[15], i.m[4] = t.m[4] * e.m[0] + t.m[5] * e.m[4] + t.m[6] * e.m[8] + t.m[7] * e.m[12], i.m[5] = t.m[4] * e.m[1] + t.m[5] * e.m[5] + t.m[6] * e.m[9] + t.m[7] * e.m[13], i.m[6] = t.m[4] * e.m[2] + t.m[5] * e.m[6] + t.m[6] * e.m[10] + t.m[7] * e.m[14], i.m[7] = t.m[4] * e.m[3] + t.m[5] * e.m[7] + t.m[6] * e.m[11] + t.m[7] * e.m[15], i.m[8] = t.m[8] * e.m[0] + t.m[9] * e.m[4] + t.m[10] * e.m[8] + t.m[11] * e.m[12], i.m[9] = t.m[8] * e.m[1] + t.m[9] * e.m[5] + t.m[10] * e.m[9] + t.m[11] * e.m[13], i.m[10] = t.m[8] * e.m[2] + t.m[9] * e.m[6] + t.m[10] * e.m[10] + t.m[11] * e.m[14], i.m[11] = t.m[8] * e.m[3] + t.m[9] * e.m[7] + t.m[10] * e.m[11] + t.m[11] * e.m[15], i.m[12] = t.m[12] * e.m[0] + t.m[13] * e.m[4] + t.m[14] * e.m[8] + t.m[15] * e.m[12], i.m[13] = t.m[12] * e.m[1] + t.m[13] * e.m[5] + t.m[14] * e.m[9] + t.m[15] * e.m[13], i.m[14] = t.m[12] * e.m[2] + t.m[13] * e.m[6] + t.m[14] * e.m[10] + t.m[15] * e.m[14], i.m[15] = t.m[12] * e.m[3] + t.m[13] * e.m[7] + t.m[14] * e.m[11] + t.m[15] * e.m[15], i;
  }
  /**
   * Computes the determinant and inverse of a matrix, if possible.
   * @returns An array containing the inverse (or null if not invertible) followed by the determinant
   */
  inverseAndDeterminant() {
    const t = this.m[4] * this.m[9] - this.m[5] * this.m[8], e = this.m[4] * this.m[10] - this.m[6] * this.m[8], i = this.m[4] * this.m[11] - this.m[7] * this.m[8], n = this.m[4] * this.m[13] - this.m[5] * this.m[12], r = this.m[4] * this.m[14] - this.m[6] * this.m[12], o = this.m[4] * this.m[15] - this.m[7] * this.m[12], l = this.m[5] * this.m[10] - this.m[6] * this.m[9], h = this.m[5] * this.m[11] - this.m[7] * this.m[9], u = this.m[5] * this.m[14] - this.m[6] * this.m[13], f = this.m[5] * this.m[15] - this.m[7] * this.m[13], g = this.m[6] * this.m[11] - this.m[7] * this.m[10], y = this.m[6] * this.m[15] - this.m[7] * this.m[14], _ = this.m[8] * this.m[13] - this.m[9] * this.m[12], x = this.m[8] * this.m[14] - this.m[10] * this.m[12], b = this.m[8] * this.m[15] - this.m[11] * this.m[12], I = this.m[9] * this.m[14] - this.m[10] * this.m[13], C = this.m[9] * this.m[15] - this.m[11] * this.m[13], M = this.m[10] * this.m[15] - this.m[11] * this.m[14], P = new lr();
    P.m[0] = this.m[5] * M - this.m[6] * C + this.m[7] * I, P.m[1] = this.m[2] * C - this.m[3] * I - this.m[1] * M, P.m[2] = this.m[1] * y - this.m[2] * f + this.m[3] * u, P.m[3] = this.m[2] * h - this.m[3] * l - this.m[1] * g, P.m[4] = this.m[6] * b - this.m[7] * x - this.m[4] * M, P.m[5] = this.m[0] * M - this.m[2] * b + this.m[3] * x, P.m[6] = this.m[2] * o - this.m[3] * r - this.m[0] * y, P.m[7] = this.m[0] * g - this.m[2] * i + this.m[3] * e, P.m[8] = this.m[4] * C - this.m[5] * b + this.m[7] * _, P.m[9] = this.m[1] * b - this.m[3] * _ - this.m[0] * C, P.m[10] = this.m[0] * f - this.m[1] * o + this.m[3] * n, P.m[11] = this.m[1] * i - this.m[3] * t - this.m[0] * h, P.m[12] = this.m[5] * x - this.m[6] * _ - this.m[4] * I, P.m[13] = this.m[0] * I - this.m[1] * x + this.m[2] * _, P.m[14] = this.m[1] * r - this.m[2] * n - this.m[0] * u, P.m[15] = this.m[0] * l - this.m[1] * e + this.m[2] * t;
    const O = P.m[0], B = -P.m[4], j = P.m[8], F = -P.m[12], K = this.m[0] * O - this.m[1] * B + this.m[2] * j - this.m[3] * F;
    if (K === 0) return [null, 0];
    const J = 1 / K;
    return P.multiplyByScalar(J), [P, K];
  }
  /**
   * Computes the inverse of a matrix if possible.
   * @param matrix Matrix whose inverse will be computed.
   * @returns Matrix set to the inverse of the supplied matrix.
   */
  static inverse(t) {
    return t.inverseAndDeterminant()[0];
  }
  /**
   * Computes the determinant of the upper-left 3x3 subsection of this matrix.
   */
  upperLeft3x3Determinant() {
    return this.m[0] * (this.m[5] * this.m[10] - this.m[9] * this.m[6]) - this.m[4] * (this.m[1] * this.m[10] - this.m[9] * this.m[2]) + this.m[8] * (this.m[1] * this.m[6] - this.m[5] * this.m[2]);
  }
  /**
   * @returns the version of this matrix suitable for applying to normals,
   * i.e. the inverse transpose of the upper-left 3x3 submatrix.
   */
  normalMatrix() {
    const t = this.copy().setTranslationComponent(0, 0, 0).inverseAndDeterminant()[0];
    return t ? t.transpose() : null;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.m.slice();
  }
  /**
   * Creates a new [[Matrix]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    return lr.createFromArray(t);
  }
  /** @hidden */
  static toMatrix12(t) {
    return [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10], t[12], t[13], t[14]];
  }
  /**
   * Returns the matrix for a clockwise rotation around the X-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static xAxisRotation(t) {
    const e = new lr(), i = Lo(t), n = Math.cos(i), r = Math.sin(i);
    return e.m[5] = n, e.m[6] = -r, e.m[9] = r, e.m[10] = n, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Y-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static yAxisRotation(t) {
    const e = new lr(), i = Lo(t), n = Math.cos(i), r = Math.sin(i);
    return e.m[0] = n, e.m[2] = r, e.m[8] = -r, e.m[10] = n, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Z-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static zAxisRotation(t) {
    const e = new lr(), i = Lo(t), n = Math.cos(i), r = Math.sin(i);
    return e.m[0] = n, e.m[1] = -r, e.m[4] = r, e.m[5] = n, e;
  }
}, ln = class sc {
  constructor() {
    this.normal = m.zero(), this.d = 0;
  }
  setFromPointAndNormal(t, e) {
    return this.normal.assign(e), this.d = -m.dot(e, t), this;
  }
  /**
   * Update the plane to pass through the three points
   */
  setFromPoints(t, e, i) {
    this.normal = m.cross(m.subtract(e, t), m.subtract(i, t)).normalize(), this.d = -m.dot(t, this.normal);
  }
  setFromCoefficients(t, e, i, n) {
    this.normal.set(t, e, i), this.d = n;
  }
  getCoefficients() {
    const t = this.normal;
    return [t.x, t.y, t.z, this.d];
  }
  distanceToPoint(t) {
    return m.dot(this.normal, t) + this.d;
  }
  rayIntersection(t) {
    const e = m.zero();
    return this.intersectsRay(t, e) ? e : null;
  }
  intersectsRay(t, e) {
    const i = this.distanceToPoint(t.origin);
    if (Math.abs(i) <= 1e-6)
      return e && e.assign(t.origin), !0;
    const n = m.dot(this.normal, t.direction);
    if (Math.abs(n) <= 1e-6)
      return !1;
    const r = -i / n;
    if (r < 0)
      return !1;
    if (e) {
      const o = t.direction.copy().scale(r);
      e.set(t.origin.x + o.x, t.origin.y + o.y, t.origin.z + o.z);
    }
    return !0;
  }
  /**
   * Returns true if the point is on the side of the plane that the plane's normal is directed. Returns false otherwise.
   * @param p The point to test.
   */
  determineSide(t) {
    return this.normal.x * t.x + this.normal.y * t.y + this.normal.z * t.z + this.d > 0;
  }
  /**
   * Creates a copy of this plane
   * @returns a copy of this plane object
   */
  copy() {
    const t = new sc();
    return t.normal.assign(this.normal), t.d = this.d, t;
  }
  /**
   * Sets this plane equal to another plane
   * @param plane the plane to assign
   */
  assign(t) {
    this.normal.assign(t.normal), this.d = t.d;
  }
  /**
   * Returns true if the normal and d value are the same.
   * @param plane
   */
  equals(t) {
    return this.normal.equals(t.normal) && this.d === t.d;
  }
  static createFromPointAndNormal(t, e) {
    return new sc().setFromPointAndNormal(t, e);
  }
  static createFromPoints(t, e, i) {
    const n = new sc();
    return n.setFromPoints(t, e, i), n;
  }
  static createFromCoefficients(t, e, i, n) {
    const r = new sc();
    return r.setFromCoefficients(t, e, i, n), r;
  }
};
class X {
  /**
   * Creates a new point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   */
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  /**
   * Sets this point equal to another point
   * @param {Point2} pt the point whose values will be used to set this object
   * @returns {Point2} the point object
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  /**
   * Adds a point to this one
   * @param {Point2} pt the point whose values will be added
   * @returns {Point2} the point object
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  /**
   * Subtracts a point from this one
   * @param {Point2} pt the point whose values will be subtracted
   * @returns {Point2} the point object
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  /**
   * Scales the point by a constant value
   * @param {number} k the value to scale by
   * @returns {Point2} the point object
   */
  scale(t) {
    return this.x *= t, this.y *= t, this;
  }
  /**
   * Compares this point with another point
   * @param {Point2} pt the point to compare with
   * @returns {Boolean} True if the values of this point equal the other. False otherwise.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * Sets the values of this point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   * @returns {Point2} the point object
   */
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  /**
   * Creates a copy of this point
   * @returns {Point} Copy of this point
   */
  copy() {
    return new X(this.x, this.y);
  }
  /**
   * Returns the length of this point
   * @returns {number} the point length
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y
    };
  }
  /**
   * Creates a new [[Point2]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (vm(t))
      return new X(t.x, t.y);
    throw new TypeError("Point2.fromJson: data does not satisfy type IPoint2 constraints");
  }
  /**
   * Subtracts a point from another
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to subtract
   * @returns {Point2} new point set to pt1 - pt2
   */
  static subtract(t, e) {
    return new X(t.x - e.x, t.y - e.y);
  }
  /**
   * Adds two points
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to add
   * @returns {Point2} new point set to pt1 + pt2
   */
  static add(t, e) {
    return new X(t.x + e.x, t.y + e.y);
  }
  /**
   * Scale a point by a constant factor
   * @param {Point2} pt Point to be scaled
   * @param {number} k Amount to scale by
   * @returns {Point2} The scaled point
   */
  static scale(t, e) {
    return new X(t.x * e, t.y * e);
  }
  /**
   * Calculate distance between two points
   * @param {Point2} p1 first point
   * @param {Point2} p2 second point
   * @returns {number} the distance between p1 and p2
   */
  static distance(t, e) {
    return X.subtract(e, t).length();
  }
  /**
   * Creates a point initialized to (0,0)
   * @returns {Point} The new point
   */
  static zero() {
    return new X(0, 0);
  }
  static fromPoint3(t) {
    return new X(t.x, t.y);
  }
}
function Qw(s) {
  const t = Math.abs(s.x), e = Math.abs(s.y), i = Math.abs(s.z);
  return t <= e && t <= i ? new m(1, 0, 0) : e <= t && e <= i ? new m(0, 1, 0) : new m(0, 0, 1);
}
function xm(s, t) {
  const e = Qw(s), i = m.cross(e, s);
  return t ? (t.assign(i), t) : i;
}
function Im(s, t, e, i) {
  const n = e.normal.x * (t.x - s.x) + e.normal.y * (t.y - s.y) + e.normal.z * (t.z - s.z);
  if (Math.abs(n) < 1e-5)
    return !1;
  const r = -(e.d + e.normal.x * s.x + e.normal.y * s.y + e.normal.z * s.z) / n;
  return i.x = s.x + r * (t.x - s.x), i.y = s.y + r * (t.y - s.y), i.z = s.z + r * (t.z - s.z), !(r < 0 || r > 1);
}
function io(s, t, e, i) {
  const n = m.subtract(e, t), r = n.squaredLength();
  let o = 0;
  r > 0 && (o = ((s.x - t.x) * (e.x - t.x) + (s.y - t.y) * (e.y - t.y) + (s.z - t.z) * (e.z - t.z)) / r), n.set(n.x * o, n.y * o, n.z * o), i.set(t.x + n.x, t.y + n.y, t.z + n.z);
  let l = new m(0, 0, 0);
  return l = m.subtract(s, i), l.length();
}
function tv(s) {
  return Math.abs(s - 25.4 / 72) < 0.01 ? "points" : Math.abs(s - 25.4) < 0.01 ? "inch" : Math.abs(s - 1) < 0.01 ? "mm" : Math.abs(s - 10) < 0.01 ? "cm" : Math.abs(s - 25.4 / 6) < 0.01 ? "picas" : Math.abs(s - 12 * 25.4) < 0.01 ? "ft" : Math.abs(s - 3 * 12 * 25.4) < 0.01 ? "yd" : Math.abs(s - 1e3) < 0.01 ? "m" : Math.abs(s - 1e6) < 0.01 ? "km" : Math.abs(s - 1760 * 3 * 12 * 25.4) < 0.01 ? "mi" : (console.log(`warning: unit multiplier doesn't map to known type: unit=${s}`), "");
}
function Hc(s, t) {
  const e = tv(t);
  let i = "";
  for (let n = 2; n < 9 && (i = s.toFixed(n), parseFloat(i) === 0); n++)
    ;
  return parseFloat(i) === 0 && (i = "0"), i + e;
}
function Lo(s) {
  return s * (Math.PI / 180);
}
function Qf(s) {
  return s * (180 / Math.PI);
}
function rc(s, t, e) {
  const i = s.copy().normalize(), n = Lo(t), r = Math.cos(n), o = Math.sin(n), l = 1 - r, h = l * i.x * i.y, u = l * i.x * i.z, f = l * i.y * i.z;
  return e === void 0 && (e = new wt()), e.m[0] = l * i.x * i.x + r, e.m[1] = o * i.z + h, e.m[2] = u - o * i.y, e.m[3] = 0, e.m[4] = h - o * i.z, e.m[5] = l * i.y * i.y + r, e.m[6] = o * i.x + f, e.m[7] = 0, e.m[8] = o * i.y + u, e.m[9] = f - o * i.x, e.m[10] = l * i.z * i.z + r, e.m[11] = 0, e.m[12] = 0, e.m[13] = 0, e.m[14] = 0, e.m[15] = 1, e;
}
function ev(s, t, e, i, n, r) {
  const o = m.cross(s.normal, e.normal), l = Math.abs(o.x), h = Math.abs(o.y), u = Math.abs(o.z);
  if (l + h + u < 1e-7) {
    const x = m.subtract(i, t);
    return m.dot(s.normal, x) === 0 ? 1 : 0;
  }
  let f;
  l > h ? l > u ? f = 1 : f = 3 : h > u ? f = 2 : f = 3;
  const g = m.zero(), y = -m.dot(s.normal, t), _ = -m.dot(e.normal, i);
  switch (f) {
    // intersect with x=0
    case 1:
      g.x = 0, g.y = (_ * s.normal.z - y * e.normal.z) / o.x, g.z = (y * e.normal.y - _ * s.normal.y) / o.x;
      break;
    // intersect with y=0
    case 2:
      g.x = (y * e.normal.z - _ * s.normal.z) / o.y, g.y = 0, g.z = (_ * s.normal.x - y * e.normal.x) / o.y;
      break;
    // intersect with z=0
    case 3:
      g.x = (_ * s.normal.y - y * e.normal.y) / o.z, g.y = (y * e.normal.x - _ * s.normal.x) / o.z, g.z = 0;
  }
  return n.assign(g), r.set(g.x + o.x, g.y + o.y, g.z + o.z), 2;
}
function iv(s, t, e) {
  const i = new ln();
  return i.normal.x = (t.y - s.y) * (e.z - s.z) - (t.z - s.z) * (e.y - s.y), i.normal.y = (t.z - s.z) * (e.x - s.x) - (t.x - s.x) * (e.z - s.z), i.normal.z = (t.x - s.x) * (e.y - s.y) - (t.y - s.y) * (e.x - s.x), i.normal.normalize(), i.d = -i.normal.x * s.x - i.normal.y * s.y - i.normal.z * s.z, i;
}
function Vo(s, t, e, i, n, r) {
  const o = iv(e, i, n);
  return Im(s, t, o, r);
}
function wr(s, t) {
  const e = s.copy().normalize(), i = t.copy().normalize(), r = m.cross(e, i).length(), o = m.dot(e, i), l = Math.atan2(r, o);
  return Qf(l);
}
function nv(s, t, e, i, n) {
  const r = 2 * Math.PI / i;
  for (let f = 0; f < i; f++) {
    const y = e * Math.cos(r * f), _ = e * Math.sin(r * f);
    s[f] = new m(0, y, _);
  }
  s[i] = s[0].copy();
  const o = xm(n);
  o.normalize();
  const l = m.cross(o, n);
  l.normalize();
  const h = new wt(), u = h.m;
  u[0] = n.x, u[1] = n.y, u[2] = n.z, u[3] = 0, u[4] = o.x, u[5] = o.y, u[6] = o.z, u[7] = 0, u[8] = l.x, u[9] = l.y, u[10] = l.z, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, h.transformArray(s, s);
  for (let f = 0; f <= i; f++)
    s[f].set(
      s[f].x + t.x,
      s[f].y + t.y,
      s[f].z + t.z
    );
}
function sv(s, t, e, i, n, r) {
  const o = s, l = t, h = e, u = i;
  let f = 0, g = 0;
  const y = m.subtract(l, o), _ = m.subtract(u, h), x = m.dot(y, o), b = m.dot(y, _), I = m.dot(y, y), C = m.dot(y, h), M = m.dot(_, _), P = m.dot(_, h), O = m.dot(_, o), B = m.dot(y, u), j = m.dot(_, l), F = I * M - b * b;
  if (F === 0) {
    let rt, ft, H, $;
    I !== 0 ? (rt = (C - x) / I, rt < 0 ? rt = 0 : rt > 1 && (rt = 1), H = (B - x) / I, H < 0 ? H = 0 : H > 1 && (H = 1)) : (rt = 0, H = 0), M !== 0 ? (ft = (O - P) / M, ft < 0 ? ft = 0 : ft > 1 && (ft = 1), $ = (j - P) / M, $ < 0 ? $ = 0 : $ > 1 && ($ = 1)) : (ft = 0, $ = 0), f = (rt + H) / 2, g = (ft + $) / 2;
  } else {
    const rt = b * O - b * P - M * x + M * C, ft = I * O - I * P + b * C - b * x, H = rt / F, $ = ft / F, D = (C - x) / I, R = (O - P) / M, U = (B - x) / I, it = (j - P) / M;
    0 <= H && H <= 1 && 0 <= $ && $ <= 1 ? (f = H, g = $) : H < 0 && 0 <= $ && $ <= 1 ? (f = H, g = R) : 1 < H && 0 <= $ && $ <= 1 ? (f = H, g = it) : 0 <= H && H <= 1 && $ < 0 ? (f = D, g = $) : 0 <= H && H <= 1 && 1 < $ ? (f = U, g = $) : H < 0 && $ < 0 ? (f = D, g = R) : H < 0 && 1 < $ ? (f = U, g = R) : 1 < H && $ < 0 ? (f = D, g = it) : 1 < H && 1 < $ && (f = U, g = it), f < 0 ? f = 0 : f > 1 && (f = 1), g < 0 ? g = 0 : g > 1 && (g = 1);
  }
  return n.x = f * y.x + o.x, n.y = f * y.y + o.y, n.z = f * y.z + o.z, r.x = g * _.x + h.x, r.y = g * _.y + h.y, r.z = g * _.z + h.z, m.subtract(r, n).length();
}
function Cm(s, t, e, i) {
  const r = m.zero(), o = m.zero(), l = m.zero(), h = m.zero(), u = m.zero();
  if (l.x = s.x - e.x, l.y = s.y - e.y, l.z = s.z - e.z, h.x = i.x - e.x, h.y = i.y - e.y, h.z = i.z - e.z, Math.abs(h.x) < 1e-12 && Math.abs(h.y) < 1e-12 && Math.abs(h.z) < 1e-12 || (u.x = t.x - s.x, u.y = t.y - s.y, u.z = t.z - s.z, Math.abs(u.x) < 1e-12 && Math.abs(u.y) < 1e-12 && Math.abs(u.z) < 1e-12))
    return null;
  const f = l.x * h.x + l.y * h.y + l.z * h.z, g = h.x * u.x + h.y * u.y + h.z * u.z, y = l.x * u.x + l.y * u.y + l.z * u.z, _ = h.x * h.x + h.y * h.y + h.z * h.z, b = (u.x * u.x + u.y * u.y + u.z * u.z) * _ - g * g;
  if (Math.abs(b) < 1e-12)
    return null;
  const C = (f * g - y * _) / b, M = (f + g * C) / _;
  return r.x = s.x + C * u.x, r.y = s.y + C * u.y, r.z = s.z + C * u.z, o.x = e.x + M * h.x, o.y = e.y + M * h.y, o.z = e.z + M * h.z, r;
}
function Sm(s, t, e) {
  const i = m.subtract(t, s), n = m.subtract(e, s), o = m.dot(n, i) / i.squaredLength();
  return Math.max(0, Math.min(1, o));
}
function rv(s, t, e) {
  const i = Sm(s, t, e), n = m.subtract(t, s).scale(i);
  return m.add(s, n);
}
function ov(s, t, e, i) {
  const n = Sm(s, t, e);
  if (n < 0 || n > 1)
    return !1;
  const r = m.subtract(t, s).scale(n), o = m.add(s, r);
  return m.subtract(o, e).squaredLength() <= i * i;
}
function av(s, t, e) {
  const i = X.subtract(e, t), n = i.length();
  let r = (s.x - t.x) * (e.x - t.x) + (s.y - t.y) * (e.y - t.y);
  return r /= n * n, i.scale(r), X.add(t, i);
}
function oc(s, t, e, i) {
  const n = av(s, t, e);
  if (X.distance(s, n) <= i) {
    const o = Math.min(t.x, e.x), l = Math.max(t.x, e.x), h = Math.min(t.y, e.y), u = Math.max(t.y, e.y);
    return !(n.x < o || n.x > l || n.y < h || n.y > u);
  } else return !1;
}
function Mm(s, t, e, i = 0) {
  return !(s.x + i < t.x || s.x > t.x + e.x + i || s.y + i < t.y || s.y > t.y + e.y + i);
}
function mf(s, t, e, i, n) {
  const r = [], o = m.zero(), l = new wt(), h = t / n;
  for (let u = 0, f = 0; u <= n; ++u, f += h)
    rc(s, f, l), l.transform(i, o), r.push(m.add(e, o));
  return r;
}
function lv(s) {
  const t = s.sort((n, r) => n.exponent < r.exponent ? 1 : -1);
  let e = "";
  const i = ".";
  for (let n = 0; n < t.length; n++) {
    switch (t[n].basicUnit) {
      case gi.unitLength:
        e += Ci(t[n].factor, "m");
        break;
      case gi.unitMass:
        e += cv(t[n].factor, "g");
        break;
      case gi.unitTime:
        e += Ci(t[n].factor, "s");
        break;
      case gi.unitElectricCurrent:
        e += Ci(t[n].factor, "A");
        break;
      case gi.unitThermoTemperature:
        e += Ci(t[n].factor, "K");
        break;
      case gi.unitSubstanceAmount:
        e += Ci(t[n].factor, "mol");
        break;
      case gi.unitLuminosityIntensity:
        e += Ci(t[n].factor, "cd");
        break;
      case gi.unitPlaneAngle:
        e += Ci(t[n].factor, "rad");
        break;
      case gi.unitSolidAngle:
        e += Ci(t[n].factor, "sr");
        break;
      case gi.unitFrequency:
        e += Ci(t[n].factor, "Hz");
        break;
      case gi.unitForce:
        e += Ci(t[n].factor, "N");
        break;
      case gi.unitPressure:
        e += Ci(t[n].factor, "Pa");
        break;
      case gi.unitEnergy:
        e += Ci(t[n].factor, "J");
        break;
      case gi.unitPower:
        e += Ci(t[n].factor, "W");
        break;
      case gi.unitElectricCharge:
        e += Ci(t[n].factor, "C");
        break;
      case gi.unitElectromotiveForce:
        e += Ci(t[n].factor, "V");
        break;
      case gi.unitCapacitance:
        e += Ci(t[n].factor, "F");
        break;
      case gi.unitElectricResistance:
        e += Ci(t[n].factor, Zw);
        break;
      case gi.unitElectricConductance:
        e += Ci(t[n].factor, "S");
        break;
      case gi.unitMagneticFlux:
        e += Ci(t[n].factor, "Wb");
        break;
      case gi.unitMagneticFluxDensity:
        e += Ci(t[n].factor, "T");
        break;
      case gi.unitInductance:
        e += Ci(t[n].factor, "H");
        break;
      case gi.unitLuminousFlux:
        e += Ci(t[n].factor, "lm");
        break;
      case gi.unitIlluminance:
        e += Ci(t[n].factor, "lx");
        break;
      case gi.unitActivityRadionuclide:
        e += Ci(t[n].factor, "Bq");
        break;
      case gi.unitKerma:
        e += Ci(t[n].factor, "Gy");
        break;
      case gi.unitDoseEquivalent:
        e += Ci(t[n].factor, "Sv");
        break;
      case gi.unitCatalyticActivity:
        e += Ci(t[n].factor, "kat");
        break;
    }
    switch (t[n].exponent) {
      case 2:
        e += Sp;
        break;
      case 3:
        e += Mp;
        break;
      case -1:
        e += Zd, e += Yw;
        break;
      case -2:
        e += Zd, e += Sp;
        break;
      case -3:
        e += Zd, e += Mp;
        break;
    }
    n + 1 < t.length && (e += i);
  }
  return e;
}
function Ci(s, t) {
  let e = "";
  switch (s) {
    case 0.3048:
      e = "ft";
      break;
    case 0.0254:
      e = "inch";
      break;
    case 1e-3:
      e = `m${t}`;
      break;
    case 0.01:
      e = `c${t}`;
      break;
    case 0.1:
      e = `d${t}`;
      break;
    case 1:
      e = t;
      break;
    case 10:
      e = `da${t}`;
      break;
    case 100:
      e = `h${t}`;
      break;
    case 1e3:
      e = `k${t}`;
      break;
    case 60:
      e = "min";
      break;
    case 3600:
      e = "h";
      break;
    case 86400:
      e = "d";
      break;
    case 274.15:
      e = "°C";
      break;
    case 255.927778:
      e = "°F";
      break;
    case 0.555556:
      e = "°R";
      break;
  }
  return e;
}
function cv(s, t) {
  let e = "";
  switch (s) {
    case 1e-6:
      e = `m${t}`;
      break;
    case 1e-5:
      e = `d${t}`;
      break;
    case 1e-4:
      e = `c${t}`;
      break;
    case 1e-3:
      e = t;
      break;
    case 0.01:
      e = `da${t}`;
      break;
    case 0.1:
      e = `h${t}`;
      break;
    case 1:
      e = `k${t}`;
      break;
    case 100:
      e = "q";
      break;
    case 1e3:
      e = "t";
      break;
  }
  return e;
}
function hv(s) {
  const t = Math.abs(s.x), e = Math.abs(s.y), i = Math.abs(s.z), n = 1e-4, r = Math.sign(s.x), o = Math.sign(s.y), l = Math.sign(s.z);
  switch (!0) {
    case (t < n && e < n && i < n):
      throw new Error("Zero vector cannot have an orthogonal vector");
    case (t < n && e < n):
      return { x: 1 * l, y: 0, z: 0 };
    case (t < n && i < n):
      return { x: 0, y: 0, z: 1 * o };
    case (e < n && i < n):
      return { x: 0, y: 1 * r, z: 0 };
    case t < n:
      return { x: 1 * o * l, y: 0, z: 0 };
    case e < n:
      return { x: 0, y: 1 * r * l, z: 0 };
    case i < n:
      return { x: 0, y: 0, z: 1 * r * o };
    default:
      return { x: -s.y, y: s.x, z: 0 };
  }
}
function uv(s) {
  const t = m.normalize(s), e = hv(t);
  return [t, e, m.cross(t, e)];
}
function dv(s, t) {
  const e = s.reduce((i, n) => m.add(i, n), new m(0, 0, 0)).scale(1 / s.length);
  return [...s].sort((i, n) => {
    const r = m.subtract(i, e), o = m.subtract(n, e), l = Math.atan2(m.dot(r, t[2]), m.dot(r, t[1])), h = Math.atan2(m.dot(o, t[2]), m.dot(o, t[1]));
    return l - h;
  });
}
const Ks = class Ks {
  constructor(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  set(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  assign(t) {
    this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w;
  }
  copy() {
    return new Ks(this.x, this.y, this.z, this.w);
  }
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w;
  }
  equalsWithTolerance(t, e) {
    return this.x - t.x < e && this.x - t.x > -e && this.y - t.y < e && this.y - t.y > -e && this.z - t.z < e && this.z - t.z > -e && this.w - t.w < e && this.w - t.w > -e;
  }
  fromArray(t) {
    return this.x = t[0], this.y = t[1], this.z = t[2], this.w = t[3], this;
  }
  toArray(t) {
    return t[0] = this.x, t[1] = this.y, t[2] = this.z, t[3] = this.w, this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  normalize() {
    const t = this.magnitude();
    return t === 0 ? this : (this.x = this.x / t, this.y = this.y / t, this.z = this.z / t, this.w = this.w / t, this);
  }
  static add(t, e) {
    return new Ks(t.x + e.x, t.y + e.y, t.z + e.z, t.w + e.w);
  }
  static subtract(t, e) {
    return new Ks(t.x - e.x, t.y - e.y, t.z - e.z, t.w - e.w);
  }
  static identity() {
    return new Ks(0, 0, 0, 1);
  }
  static toMatrix(t) {
    let e = t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w;
    e = 2 / e;
    const i = t.x * e, n = t.y * e, r = t.z * e, o = t.w * i, l = t.w * n, h = t.w * r, u = t.x * i, f = t.x * n, g = t.x * r, y = t.y * n, _ = t.y * r, x = t.z * r, b = new wt();
    return b.m[0] = 1 - (y + x), b.m[1] = f + h, b.m[2] = g - l, b.m[3] = 0, b.m[4] = f - h, b.m[5] = 1 - (u + x), b.m[6] = _ + o, b.m[7] = 0, b.m[8] = g + l, b.m[9] = _ - o, b.m[10] = 1 - (u + y), b.m[11] = 0, b.m[12] = 0, b.m[13] = 0, b.m[14] = 0, b.m[15] = 1, b;
  }
  static createFromMatrix(t) {
    const o = [], l = t.m[0] + t.m[5] + t.m[10];
    if (l > 0) {
      let h = Math.sqrt(l + 1);
      o[3] = 0.5 * h, h = 0.5 / h, o[0] = h * (t.m[6] - t.m[9]), o[1] = h * (t.m[8] - t.m[2]), o[2] = h * (t.m[1] - t.m[4]);
    } else {
      let h = 0;
      t.m[4 * 1 + 1] > t.m[4 * 0 + 0] && (h = 1), t.m[4 * 2 + 2] > t.m[4 * h + h] && (h = 2);
      const u = [1, 2, 0], f = u[h], g = u[f];
      let y = Math.sqrt(t.m[4 * h + h] - (t.m[4 * f + f] + t.m[4 * g + g]) + 1);
      o[h] = 0.5 * y, y = 0.5 / y, o[3] = y * (t.m[4 * f + g] - t.m[4 * g + f]), o[f] = y * (t.m[4 * h + f] + t.m[4 * f + h]), o[g] = y * (t.m[4 * h + g] + t.m[4 * g + h]);
    }
    return Ks.identity().fromArray(o);
  }
  static interpolate(t, e, i) {
    const h = [], u = [], f = [];
    t.toArray(h), e.toArray(u);
    let g, y;
    const _ = h[0] * u[0] + h[1] * u[1] + h[2] * u[2] + h[3] * u[3];
    if (1 + _ > Ks._epsilon) {
      if (1 - _ > Ks._epsilon) {
        const x = Ks._arccos(_), I = 1 / Math.sin(x);
        g = I * Math.sin((1 - i) * x), y = I * Math.sin(i * x);
      } else
        g = 1 - i, y = i;
      for (let x = 0; x < 4; ++x)
        f[x] = g * h[x] + y * u[x];
    } else {
      f[0] = -h[1], f[1] = h[0], f[2] = -h[3], f[3] = h[2], g = Math.sin(0.5 * Math.PI * (1 - i)), y = Math.sin(0.5 * Math.PI * i);
      for (let x = 0; x < 3; ++x)
        f[x] = g * h[x] + y * f[x];
    }
    return Ks.identity().fromArray(f);
  }
  static _arccos(t) {
    return t < -1 ? Math.PI : t > 1 ? 0 : Math.acos(t);
  }
};
Ks._epsilon = 1e-5;
let ts = Ks;
class vr {
  constructor(t, e) {
    this.origin = m.zero(), this.direction = new m(0, 0, 1), t && this.origin.assign(t), e && this.direction.assign(e);
  }
  /**
   * Creates a copy of this ray
   * @returns {Ray} a copy of this ray object
   */
  copy() {
    return new vr(this.origin, this.direction);
  }
  /**
   * Sets this ray equal to another ray
   * @param {Ray} ray the ray to assign
   */
  assign(t) {
    return this.origin.assign(t.origin), this.direction.assign(t.direction), this;
  }
  /**
   * Flips the ray's direction.
   */
  negate() {
    return this.direction.negate(), this;
  }
}
class wn {
  /**
   * Creates a new box.
   * @param min The minimum extent of the box. Defaults to the origin.
   * @param max The maximum extent of the box. Defaults to the origin.
   */
  constructor(t = m.zero(), e = m.zero()) {
    this.min = t.copy(), this.max = e.copy();
  }
  /**
   * Creates a copy of the box.
   * @returns A copy of this box.
   */
  copy() {
    return new wn(this.min, this.max);
  }
  /**
   * Strictly compares this box with another box.
   * @param box Box to compare with.
   * @returns True if the values of this box equals the other. False otherwise.
   */
  equals(t) {
    return this.min.equals(t.min) && this.max.equals(t.max);
  }
  /**
   * Gets the center point for the box.
   * @returns The center point of this box.
   */
  center() {
    const t = m.add(this.min, this.max);
    return t.scale(0.5), t;
  }
  /**
   * Gets the extents of the box.
   * @returns A point with members set to extent values for each corresponding axis.
   */
  extents() {
    return m.subtract(this.max, this.min);
  }
  /**
   * Expands the extents of the box so that it will contain another box.
   * @param box The box to add.
   */
  addBox(t) {
    t.isDegenerate() || (this.addPoint(t.min), this.addPoint(t.max));
  }
  /**
   * Expands the extents of the box so that it will contain a particular point.
   * @param point The point to add.
   */
  addPoint(t) {
    t.x < this.min.x && (this.min.x = t.x), t.y < this.min.y && (this.min.y = t.y), t.z < this.min.z && (this.min.z = t.z), t.x > this.max.x && (this.max.x = t.x), t.y > this.max.y && (this.max.y = t.y), t.z > this.max.z && (this.max.z = t.z);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      min: this.min.toJson(),
      max: this.max.toJson()
    };
  }
  /**
   * Creates a new [[Box]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = m.fromJson(e.min), n = m.fromJson(e.max);
    return new wn(i, n);
  }
  /**
   * Gets all eight corner points for the box.
   * @returns The corner points of this box.
   */
  getCorners() {
    const t = [];
    return t[0] = this.min.copy(), t[1] = this.min.copy(), t[2] = this.min.copy(), t[1].x = this.max.x, t[2].y = this.max.y, t[3] = t[2].copy(), t[3].x = this.max.x, t[4] = t[0].copy(), t[5] = t[1].copy(), t[6] = t[2].copy(), t[7] = t[3].copy(), t[4].z = this.max.z, t[5].z = this.max.z, t[6].z = this.max.z, t[7].z = this.max.z, t;
  }
  /**
   * Returns whether a point is contained within the box
   * @returns whether a point is contained within the box
   */
  containsPoint(t) {
    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
  }
  /**
   * Creates and returns an invalid bounding box.
   * @returns an invalid bounding box.
   */
  static invalid() {
    return new wn(
      new m(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
      new m(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)
    );
  }
  /**
   * Returns whether or not the box is degenerate.
   * @returns whether or not the box is degenerate.
   */
  isDegenerate() {
    return this.min.x > this.max.x || this.min.y > this.max.y || this.min.z > this.max.z;
  }
}
function fv(s) {
  return s !== null && typeof s == "object" && "r" in s && typeof s.r == "number" && "g" in s && typeof s.g == "number" && "b" in s && typeof s.b == "number";
}
class yt {
  /**
   * Creates a new color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  constructor(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets this color equal to another color
   * @param color the point whose values will be used to set this color
   * @returns the color object
   */
  assign(t) {
    return this.set(t.r, t.g, t.b), this;
  }
  /**
   * Creates a copy of this color
   * @returns Copy of this color
   */
  copy() {
    return new yt(this.r, this.g, this.b);
  }
  /**
   * Compares this color with another color
   * @param color the color to compare with
   * @returns True if the values of this color equal the other. False otherwise.
   */
  equals(t) {
    return this.r === t.r && this.g === t.g && this.b === t.b;
  }
  /**
   * Sets the color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  set(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets the color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  setFromFloat(t, e, i) {
    this.r = Math.round(255 * t), this.g = Math.round(255 * e), this.b = Math.round(255 * i);
  }
  /**
   * Sets this color from an array of normalized floating point values
   * @param the array to assign from
   */
  fromFloatArray(t) {
    return this.setFromFloat(t[0], t[1], t[2]);
  }
  /**
   * Gets an array of floating point values representing this color. Values are clamped in the 0.0 - 1.0 range.
   * @returns array of floating point values for this color.
   */
  getFloatArray() {
    return [this.r / 255, this.g / 255, this.b / 255];
  }
  /**
   * Populates an array with floating point values for this color. Values are clamped in the 0.0 - 1.0 range.
   * @param arr array whose first three elements will be populated with the r,g, and b values of this color respectively.
   */
  toFloatArray(t = [0, 0, 0]) {
    return t[0] = this.r / 255, t[1] = this.g / 255, t[2] = this.b / 255, t;
  }
  /**
   * Creates a new [[Color]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (fv(t))
      return new yt(t.r, t.g, t.b);
    throw new TypeError("Color.fromJson: data does not satisfy type IColor constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      r: this.r,
      g: this.g,
      b: this.b
    };
  }
  /**
   * Converts the color to a hexadecimal string.
   * @returns Hexadecimal string representation of the color.
   */
  toHexString() {
    const t = this.r.toString(16).padStart(2, "0"), e = this.g.toString(16).padStart(2, "0"), i = this.b.toString(16).padStart(2, "0");
    return `#${t}${e}${i}`;
  }
  /**
   * Creates a color object from a hexadecimal string.
   * @param hexString Hexadecimal string representation of the color.
   * @returns new color object
   */
  static fromHexString(t) {
    if (t.startsWith("#") && (t = t.slice(1)), t.length !== 6)
      throw new Error("Invalid hex color string");
    const e = parseInt(t.slice(0, 2), 16), i = parseInt(t.slice(2, 4), 16), n = parseInt(t.slice(4, 6), 16);
    return new yt(e, i, n);
  }
  /**
   * Creates a color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   * @returns new color object
   */
  static createFromFloat(t, e, i) {
    const n = yt.black();
    return n.setFromFloat(t, e, i), n;
  }
  /**
   * Creates a color object from an array of floating point values.
   * Values are specified in the 0.0-1.0 range.
   */
  static createFromFloatArray(t) {
    const e = yt.black();
    return e.fromFloatArray(t), e;
  }
  /**
   * Creates a new color object initialized to red.
   * @returns new color object
   */
  static red() {
    return new yt(255, 0, 0);
  }
  /**
   * Creates a new color object initialized to green.
   * @returns new color object
   */
  static green() {
    return new yt(0, 255, 0);
  }
  /**
   * Creates a new color object initialized to blue.
   * @returns new color object
   */
  static blue() {
    return new yt(0, 0, 255);
  }
  /**
   * Creates a new color object initialized to yellow.
   * @returns new color object
   */
  static yellow() {
    return new yt(255, 255, 0);
  }
  /**
   * Creates a new color object initialized to white.
   * @returns new color object
   */
  static white() {
    return new yt(255, 255, 255);
  }
  /**
   * Creates a new color object initialized to black.
   * @returns new color object
   */
  static black() {
    return new yt(0, 0, 0);
  }
}
var Os = /* @__PURE__ */ ((s) => (s[s.Scalar = 1] = "Scalar", s[s.Vec3 = 3] = "Vec3", s[s.Quat = 4] = "Quat", s))(Os || {});
class dh {
  /**
   * Creates a new buffer for storing keyframe data.
   * @param keyType The type of keyframes that will be stored in the buffer.
   */
  constructor(t) {
    this.keyType = t, this.times = [], this.values = [], this.tangents = [], this._hasTangents = null, this.keyOffset = t;
  }
  _validateKey(t) {
    if (this.keyType !== t)
      throw new Error(
        `Cannot add keyframe of type: ${Os[t]} to buffer of type: ${Os[this.keyType]}`
      );
  }
  _validateTangents(t) {
    if (this._hasTangents === null)
      this._hasTangents = t;
    else if (this._hasTangents !== t)
      throw new Error(
        `Cannot add keyframe with${t ? "" : "out"} tangents to buffer with${t ? "out" : ""} tangents`
      );
  }
  _findIndexFromTime(t) {
    for (let e = 0; e < this.times.length; e++)
      if (this.times[e] >= t) return e;
    return this.times.length;
  }
  /** Returns the index of the keyframe at the specified time. */
  getKeyframeIndex(t) {
    return this.times.indexOf(t);
  }
  /** Deletes a keyframe at the specified index. */
  deleteKeyframe(t) {
    this.times.splice(t, 1), this.tangents.splice(t * this.keyOffset * 2, this.keyOffset * 2), this.values.splice(t * this.keyOffset, this.keyOffset);
  }
  /**
   * Inserts a Scalar keyframe with the specified time. The type of this buffer should be [[KeyType.Scalar]]
   * @returns Index at which keyframe was inserted
   */
  insertScalarKeyframe(t, e, i, n) {
    this._validateKey(
      1
      /* Scalar */
    );
    const r = this._findIndexFromTime(t);
    return this.times.splice(r, 0, t), this.values.splice(r, 0, e), i !== void 0 && n !== void 0 ? (this._validateTangents(!0), this.tangents.splice(r * 2, 0, i, n)) : this._validateTangents(!1), r;
  }
  /** Updates a Scalar keyframe at the specified index. The type of this buffer should be [[KeyType.Scalar]] */
  updateScalarKeyframe(t, e, i, n, r) {
    this.values[t] = i, this.times[t] = e, n !== void 0 && r !== void 0 && (this.tangents[t * 2] = n, this.tangents[t * 2 + 1] = r);
  }
  /**
   * Inserts a Vec3 keyframe with the specified time. The type of this buffer should be [[KeyType.Vec3]]
   * @returns Index at which keyframe was inserted
   */
  insertVec3Keyframe(t, e, i, n, r, o, l, h, u, f) {
    this._validateKey(
      3
      /* Vec3 */
    );
    const g = this._findIndexFromTime(t);
    return this.times.splice(g, 0, t), this.values.splice(g * this.keyOffset, 0, e, i, n), r !== void 0 && o !== void 0 && l !== void 0 && h !== void 0 && u !== void 0 && f !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      g * this.keyOffset * 2,
      0,
      r,
      o,
      l,
      h,
      u,
      f
    )) : this._validateTangents(!1), g;
  }
  /** Updates a Vec3 keyframe at the specified index. The type of this buffer should be [[KeyType.Vec3]] */
  updateVec3Keyframe(t, e, i, n, r, o, l, h, u, f, g) {
    return this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = n, this.values[t * this.keyOffset + 2] = r, o !== void 0 && l !== void 0 && h !== void 0 && u !== void 0 && f !== void 0 && g !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      o,
      l,
      h,
      u,
      f,
      g
    ), this.tangents[t * this.keyOffset * 2] = o, this.tangents[t * this.keyOffset * 2 + 1] = l, this.tangents[t * this.keyOffset * 2 + 2] = h, this.tangents[t * this.keyOffset * 2 + 3] = u, this.tangents[t * this.keyOffset * 2 + 4] = f, this.tangents[t * this.keyOffset * 2 + 5] = g) : this._validateTangents(!1), t;
  }
  /**
   * Inserts a Quat keyframe with the specified time. The type of this buffer should be [[KeyType.Quat]]
   * @returns Index at which keyframe was inserted
   */
  insertQuatKeyframe(t, e, i, n, r, o, l, h, u, f, g, y, _) {
    this._validateKey(
      4
      /* Quat */
    );
    const x = this._findIndexFromTime(t);
    this.times.splice(x, 0, t), this.values.splice(x * this.keyOffset, 0, e, i, n, r), o !== void 0 && l !== void 0 && h !== void 0 && u !== void 0 && f !== void 0 && g !== void 0 && y !== void 0 && _ !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      x * this.keyOffset * 2,
      0,
      o,
      l,
      h,
      u,
      f,
      g,
      y,
      _
    )) : this._validateTangents(!1);
  }
  /** Updates a Quat keyframe at the specified index. The type of this buffer should be [[KeyType.Quat]] */
  updateQuatKeyframe(t, e, i, n, r, o, l, h, u, f, g, y, _, x) {
    this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = n, this.values[t * this.keyOffset + 2] = r, this.values[t * this.keyOffset + 3] = o, l !== void 0 && h !== void 0 && u !== void 0 && f !== void 0 && g !== void 0 && y !== void 0 && _ !== void 0 && x !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      l,
      h,
      u,
      g,
      y,
      _
    ), this.tangents[t * this.keyOffset * 2] = l, this.tangents[t * this.keyOffset * 2 + 1] = h, this.tangents[t * this.keyOffset * 2 + 2] = u, this.tangents[t * this.keyOffset * 2 + 3] = x, this.tangents[t * this.keyOffset * 2 + 4] = g, this.tangents[t * this.keyOffset * 2 + 5] = y, this.tangents[t * this.keyOffset * 2 + 6] = _, this.tangents[t * this.keyOffset * 2 + 7] = x) : this._validateTangents(!1);
  }
  /** @hidden */
  _export() {
    const t = {};
    return this.tangents.length !== 0 && (t.tangents = this.tangents.slice()), {
      keyType: Os[this.keyType],
      times: this.times.slice(),
      values: this.values.slice(),
      ...t
    };
  }
  /** @hidden */
  static _import(t) {
    const e = new dh(Os[t.keyType]);
    return e.times = t.times.slice(), e.values = t.values.slice(), t.tangents !== void 0 && (e.tangents = t.tangents.slice()), e;
  }
}
var Dn = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Transform = 1] = "Transform", s[s.Opacity = 2] = "Opacity", s[s.Visibility = 4] = "Visibility", s[s.Color = 8] = "Color", s))(Dn || {});
class Pm {
  constructor(t) {
    this.nodeId = t, this.translate = m.zero(), this.rotation = ts.identity(), this.scale = new m(1, 1, 1), this.color = new m(1, 1, 1), this.pivotPoint = null, this.opacity = 1, this.visibility = 1, this.matrix = new wt(), this.flags = 0;
  }
  updateMatrix() {
    this.pivotPoint ? this._updateMatrixWithOrigin() : this._updateMatrix();
  }
  // http://glmatrix.net/docs/mat4.js.html#line1354
  _updateMatrixWithOrigin() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, n = this.rotation.w, r = t + t, o = e + e, l = i + i, h = t * r, u = t * o, f = t * l, g = e * o, y = e * l, _ = i * l, x = n * r, b = n * o, I = n * l, C = this.scale.x, M = this.scale.y, P = this.scale.z, O = this.pivotPoint.x, B = this.pivotPoint.y, j = this.pivotPoint.z, F = (1 - (g + _)) * C, K = (u + I) * C, J = (f - b) * C, rt = (u - I) * M, ft = (1 - (h + _)) * M, H = (y + x) * M, $ = (f + b) * P, D = (y - x) * P, R = (1 - (h + g)) * P;
    this.matrix.m[0] = F, this.matrix.m[1] = K, this.matrix.m[2] = J, this.matrix.m[3] = 0, this.matrix.m[4] = rt, this.matrix.m[5] = ft, this.matrix.m[6] = H, this.matrix.m[7] = 0, this.matrix.m[8] = $, this.matrix.m[9] = D, this.matrix.m[10] = R, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x + O - (F * O + rt * B + $ * j), this.matrix.m[13] = this.translate.y + B - (K * O + ft * B + D * j), this.matrix.m[14] = this.translate.z + j - (J * O + H * B + R * j), this.matrix.m[15] = 1;
  }
  // http://glmatrix.net/docs/mat4.js.html#line1291
  _updateMatrix() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, n = this.rotation.w, r = t + t, o = e + e, l = i + i, h = t * r, u = t * o, f = t * l, g = e * o, y = e * l, _ = i * l, x = n * r, b = n * o, I = n * l, C = this.scale.x, M = this.scale.y, P = this.scale.z;
    this.matrix.m[0] = (1 - (g + _)) * C, this.matrix.m[1] = (u + I) * C, this.matrix.m[2] = (f - b) * C, this.matrix.m[3] = 0, this.matrix.m[4] = (u - I) * M, this.matrix.m[5] = (1 - (h + _)) * M, this.matrix.m[6] = (y + x) * M, this.matrix.m[7] = 0, this.matrix.m[8] = (f + b) * P, this.matrix.m[9] = (y - x) * P, this.matrix.m[10] = (1 - (h + g)) * P, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x, this.matrix.m[13] = this.translate.y, this.matrix.m[14] = this.translate.z, this.matrix.m[15] = 1;
  }
}
class km {
  constructor() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /** Reset this object to its initial state. */
  clear() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /**
   * Set the stored values on the supplied [[Camera]].
   * @returns True if the camera was modified.
   */
  apply(t) {
    let e = !1;
    return this.position !== null && (t.setPosition(this.position), e = !0), this.target !== null && (t.setTarget(this.target), e = !0), this.up !== null && (t.setUp(this.up), e = !0), this.width !== null && (t.setWidth(this.width), e = !0), this.height !== null && (t.setHeight(this.height), e = !0), e;
  }
}
class Em {
  constructor() {
    this.opacities = /* @__PURE__ */ new Map(), this.colors = /* @__PURE__ */ new Map(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Reset this object to its initial state. */
  clear() {
    this.opacities.clear(), this.colors.clear(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    const e = t.model;
    this.opacities.size > 0 && e.setNodesOpacities(this.opacities), this.colors.size > 0 && e.setNodesColors(this.colors), this.matrixNodeIds.length > 0 && e._setNodesMatrices(this.matrixNodeIds, this.matrices), this.visibilityOn.length > 0 && e.setNodesVisibility(this.visibilityOn, !0), this.visibilityOff.length > 0 && e.setNodesVisibility(this.visibilityOff, !1);
  }
}
class Nu {
  constructor() {
    this.node = new Em(), this.camera = new km();
  }
  /** Reset this object to its initial state. */
  clear() {
    this.node.clear(), this.camera.clear();
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    this.node.apply(t);
    const e = t.view, i = e.getCamera();
    this.camera.apply(i) && e.setCamera(i);
  }
}
var Ou = /* @__PURE__ */ ((s) => (s[s.Translation = 0] = "Translation", s[s.Rotation = 1] = "Rotation", s[s.Scale = 2] = "Scale", s[s.Opacity = 3] = "Opacity", s[s.Visibility = 4] = "Visibility", s[s.Color = 5] = "Color", s[s.ColorMap = 6] = "ColorMap", s))(Ou || {});
class Uc {
  constructor(t, e, i, n) {
    switch (this.name = t, this.nodeId = e, this.property = i, this.sampler = n, this.property) {
      case 0:
      case 2:
      case 5:
        if (n.buffer.keyType !== Os.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 1:
        if (n.buffer.keyType !== Os.Quat)
          throw new Error("Key type mismatch. Expected Quat");
        break;
      case 3:
      case 4:
      case 6:
        if (n.buffer.keyType !== Os.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        this.sampler.interpolateVec3(t, e.translate), e.flags |= Dn.Transform;
        break;
      case 1:
        this.sampler.interpolateQuat(t, e.rotation), e.flags |= Dn.Transform;
        break;
      case 2:
        this.sampler.interpolateVec3(t, e.scale), e.flags |= Dn.Transform;
        break;
      case 3:
        e.opacity = this.sampler.interpolateScalar(t), e.flags |= Dn.Opacity;
        break;
      case 4:
        e.visibility = this.sampler.interpolateScalar(t), e.flags |= Dn.Visibility;
        break;
      case 5:
        this.sampler.interpolateVec3(t, e.color), e.flags |= Dn.Color;
        break;
      case 6:
        {
          const i = this.sampler.interpolateScalar(t), n = this._getColorFromMap(i);
          n !== null && (e.color.set(n.r, n.g, n.b), e.flags |= Dn.Color);
        }
        break;
    }
  }
  _getColorFromMap(t) {
    const e = (n, r, o, l, h) => {
      const u = (n - r) / (o - r);
      return new yt(
        (1 - u) * l.r + u * h.r,
        (1 - u) * l.g + u * h.g,
        (1 - u) * l.b + u * h.b
      );
    };
    if (this.colorMap === void 0)
      return null;
    t < 0 && (t = 0), t > 1 && (t = 1);
    let i = 0;
    for (; i < this.colorMap.length - 1; ) {
      const n = this.colorMap[i].position, r = this.colorMap[i].color, o = this.colorMap[i + 1].position, l = this.colorMap[i + 1].color;
      if (t <= n)
        return r;
      if (t <= o)
        return e(t, n, o, r, l);
      if (t >= o && i === this.colorMap.length - 2)
        return l;
      ++i;
    }
    return null;
  }
  /** @hidden */
  _gatherForExport(t) {
    this.colorMap !== void 0 && t.colorMaps.add(this.colorMap), t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), this.colorMap !== void 0 && (e.colorMap = t.colorMaps.getIndex(this.colorMap)), {
      nodeId: this.nodeId,
      property: Ou[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new Uc(
      e.name || "",
      e.nodeId,
      Ou[e.property],
      t.samplers[e.sampler]
    );
    return e.colorMap !== void 0 && (i.colorMap = t.colorMaps[e.colorMap]), i;
  }
}
var gr = /* @__PURE__ */ ((s) => (s[s.Position = 0] = "Position", s[s.Target = 1] = "Target", s[s.Up = 2] = "Up", s[s.Width = 3] = "Width", s[s.Height = 4] = "Height", s))(gr || {});
class jc {
  /**
   * Do not use directly.  Create via Animation class API.
   * @hidden
   * */
  constructor(t, e, i) {
    switch (this.name = t, this.property = e, this.sampler = i, this.property) {
      case 0:
      case 1:
      case 2:
        if (i.buffer.keyType !== Os.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 3:
      case 4:
        if (i.buffer.keyType !== Os.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        e.position === null && (e.position = new m(0, 0, 0)), this.sampler.interpolateVec3(t, e.position);
        break;
      case 1:
        e.target === null && (e.target = new m(0, 0, -1)), this.sampler.interpolateVec3(t, e.target);
        break;
      case 2:
        e.up === null && (e.up = new m(0, 1, 0)), this.sampler.interpolateVec3(t, e.up);
        break;
      case 3:
        e.width = this.sampler.interpolateScalar(t);
        break;
      case 4:
        e.height = this.sampler.interpolateScalar(t);
    }
  }
  /** @hidden */
  _gatherForExport(t) {
    t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), {
      property: gr[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    return new jc(
      e.name || "",
      gr[e.property],
      t.samplers[e.sampler]
    );
  }
}
class ad {
  /**
   * Creates a new, empty Animation
   * @param name friendly name for the animation
   */
  constructor(t) {
    this.name = t, this.nodeChannels = [], this.cameraChannels = [], this.pivotPoints = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a new node animation channel.
   * @param name friendly name for the channel.
   * @param target id of node that will receive interpolated values.
   * @param property the node property that will be animated.
   * @param sampler sampler describing the buffer and interpolation type.
   */
  createNodeChannel(t, e, i, n) {
    const r = new Uc(t, e, i, n);
    return this._registerNodeChannel(r), r;
  }
  _registerNodeChannel(t) {
    this.nodeChannels.push(t);
  }
  /**
   * Creates a new camera animation channel.
   * @param name friendly name for the channel.
   * @param property the property that will be animated by this channel.
   * @param sampler sampler describing the buffer and interpolation type used.
   */
  createCameraChannel(t, e, i) {
    const n = new jc(t, e, i);
    return this._registerCameraChannel(n), n;
  }
  _registerCameraChannel(t) {
    this.cameraChannels.push(t);
  }
  /**
   * Removes a channel from this animation.
   *
   * Call [[Player.reload]] on any players that are referencing this animation.
   */
  deleteChannel(t) {
    for (let e = 0; e < this.nodeChannels.length; e++)
      if (this.nodeChannels[e] === t) {
        this.nodeChannels.splice(e, 1);
        return;
      }
    for (let e = 0; e < this.cameraChannels.length; e++)
      if (this.cameraChannels[e] === t) {
        this.cameraChannels.splice(e, 1);
        return;
      }
  }
  /** @hidden */
  _gatherForExport(t) {
    for (const e of this.nodeChannels)
      e._gatherForExport(t);
    for (const e of this.cameraChannels)
      e._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = [], i = {};
    this.name !== "" && (i.name = this.name);
    const n = {}, r = (o) => {
      if (this[o].length === 0)
        return;
      const l = [];
      for (const h of this[o])
        l.push(h._export(t));
      n[o] = l;
    };
    return this.pivotPoints.forEach((o, l) => {
      e.push({ node: l, point: o });
    }), e.length !== 0 && (i.pivotPoints = e), r("nodeChannels"), r("cameraChannels"), {
      ...i,
      ...n
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new ad(e.name || "");
    if (e.nodeChannels !== void 0)
      for (const n of e.nodeChannels)
        i._registerNodeChannel(Uc._import(t, n));
    if (e.cameraChannels !== void 0)
      for (const n of e.cameraChannels)
        i._registerCameraChannel(jc._import(t, n));
    if (e.pivotPoints !== void 0)
      for (const n of e.pivotPoints) {
        const r = m.fromJson(n.point);
        i.pivotPoints.set(n.node, r);
      }
    return i;
  }
}
var Ru = /* @__PURE__ */ ((s) => (s[s.Constant = 0] = "Constant", s[s.Linear = 1] = "Linear", s[s.CubicSpline = 2] = "CubicSpline", s))(Ru || {});
const jt = class jt {
  /**
   * Creates a new sampler for a [[KeyframeBuffer]]
   * @param buffer The buffer that will be sampled.
   * @param interpolationType The Type of interpolation that will be used
   */
  constructor(t, e) {
    this.buffer = t, this.interpolationType = e;
  }
  /**
   * Returns the index of the next keyframe for a given frame T.
   * Note that this assumes that all keyframes in the buffer
   * are arranged in ascending order by frame time.
   */
  _getNextKeyframeIndex(t) {
    for (let e = 0; e < this.buffer.times.length; e += 1)
      if (this.buffer.times[e] > t)
        return e;
    return this.buffer.times.length;
  }
  /** Computes an interpolated quaternion for the given frame. */
  interpolateQuat(t, e) {
    const i = this._getNextKeyframeIndex(t);
    if (i === 0) {
      this._setQuatFromKeyframeIndex(0, e);
      return;
    } else if (i === this.buffer.times.length) {
      this._setQuatFromKeyframeIndex(i - 1, e);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setQuatFromKeyframeIndex(i - 1, e);
        break;
      case 1:
        this.interpolateQuatSlerp(i - 1, i, t, e);
        break;
      case 2:
        this.interpolateQuatCubicSpline(i - 1, i, t, e);
        break;
    }
  }
  /** Computes an interpolated Vector 3 value for the given frame. */
  interpolateVec3(t, e) {
    const i = this._getNextKeyframeIndex(t);
    if (i === 0) {
      this._setVecFromKeyframeIndex(0, e);
      return;
    } else if (i === this.buffer.times.length) {
      this._setVecFromKeyframeIndex(i - 1, e);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setVecFromKeyframeIndex(i - 1, e);
        break;
      case 1:
        this.interpolateVec3Linear(i - 1, i, t, e);
        break;
      case 2:
        this.interpolateVec3CubicSpline(i - 1, i, t, e);
        break;
    }
  }
  /** Computes an interpolated scalar value for the given frame. */
  interpolateScalar(t) {
    const e = this._getNextKeyframeIndex(t);
    if (e === 0)
      return this.buffer.values[0];
    if (e === this.buffer.times.length)
      return this.buffer.values[e - 1];
    switch (this.interpolationType) {
      case 0:
        return this.buffer.values[e - 1];
      case 1:
        return this.interpolateScalarLinear(e - 1, e, t);
      case 2:
        return this.interpolateScalarCubicSpline(e - 1, e, t);
    }
  }
  /** Performs linear interpolation of two scalar values beginning at indices k0 and k1. */
  interpolateScalarLinear(t, e, i) {
    const n = this.buffer.times[e] - this.buffer.times[t], r = (i - this.buffer.times[t]) / n, o = this.buffer.values[t], l = this.buffer.values[e];
    return o + (l - o) * r;
  }
  /** Performs spherical linear interpolation on the quaternion values beginning at indices k0 and k1. */
  interpolateQuatSlerp(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setQuatFromKeyframeIndex(t, jt.q0), this._setQuatFromKeyframeIndex(e, jt.q1), n.assign(ts.interpolate(jt.q0, jt.q1, o));
  }
  static _interpVec3(t, e, i, n) {
    e.subtract(t), e.scale(i), e.add(t), n.assign(e);
  }
  /** Performs linear interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3Linear(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setVecFromKeyframeIndex(t, jt.v0), this._setVecFromKeyframeIndex(e, jt.v1), jt._interpVec3(jt.v0, jt.v1, o, n);
  }
  _interpCubicSpline(t, e, i, n, r) {
    const o = t ** 2, l = t ** 3;
    return (2 * l - 3 * o + 1) * e + (l - 2 * o + t) * n + (-2 * l + 3 * o) * i + (l - o) * r;
  }
  /** Performs Cubic Spline Interpolation on two scalar values beginning at indices k0 and k1 */
  interpolateScalarCubicSpline(t, e, i) {
    const n = this.buffer.times[e] - this.buffer.times[t], r = (i - this.buffer.times[t]) / n, o = this.buffer.values[t], l = this.buffer.values[e];
    let h = 0, u = 0;
    return this.buffer.tangents.length !== 0 && (h = this.buffer.tangents[t] * n, u = this.buffer.tangents[e] * n), this._interpCubicSpline(r, o, l, h, u);
  }
  /** Performs Cubic Spline Interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3CubicSpline(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setVecFromKeyframeIndex(t, jt.v0), this._setVecFromKeyframeIndex(e, jt.v1), this._setVecTanFromKeyframeIndex(t, jt.v2), this._setVecTanFromKeyframeIndex(e, jt.v3), jt.v2.scale(r), jt.v3.scale(r), n.set(
      this._interpCubicSpline(o, jt.v0.x, jt.v1.x, jt.v2.x, jt.v3.x),
      this._interpCubicSpline(o, jt.v0.y, jt.v1.y, jt.v2.y, jt.v3.y),
      this._interpCubicSpline(o, jt.v0.z, jt.v1.z, jt.v2.z, jt.v3.z)
    );
  }
  /** Performs Cubic Spline Interpolation on the Quaternion values beginning at indices k0 and k1 */
  interpolateQuatCubicSpline(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setQuatFromKeyframeIndex(t, jt.q0), this._setQuatFromKeyframeIndex(e, jt.q1), this._setQuatTanFromKeyframeIndex(t, jt.q2), this._setQuatTanFromKeyframeIndex(e, jt.q3), jt.q4.set(
      jt.q2.x * r,
      jt.q2.y * r,
      jt.q2.z * r,
      jt.q2.w * r
    ), jt.q5.set(
      jt.q3.x * r,
      jt.q3.y * r,
      jt.q3.z * r,
      jt.q3.w * r
    ), n.set(
      this._interpCubicSpline(o, jt.q0.x, jt.q1.x, jt.q4.x, jt.q5.x),
      this._interpCubicSpline(o, jt.q0.y, jt.q1.y, jt.q4.y, jt.q5.y),
      this._interpCubicSpline(o, jt.q0.z, jt.q1.z, jt.q4.z, jt.q5.z),
      this._interpCubicSpline(o, jt.q0.w, jt.q1.w, jt.q4.w, jt.q5.w)
    ), n.normalize();
  }
  _setVecFromKeyframeIndex(t, e) {
    const i = t * 3;
    e.set(
      this.buffer.values[i],
      this.buffer.values[i + 1],
      this.buffer.values[i + 2]
    );
  }
  _setVecTanFromKeyframeIndex(t, e) {
    if (this.buffer.tangents.length === 0)
      e.set(0, 0, 0);
    else {
      const i = t * 3;
      e.set(
        this.buffer.tangents[i],
        this.buffer.tangents[i + 1],
        this.buffer.tangents[i + 2]
      );
    }
  }
  _setQuatFromKeyframeIndex(t, e) {
    const i = t * 4;
    e.set(
      this.buffer.values[i],
      this.buffer.values[i + 1],
      this.buffer.values[i + 2],
      this.buffer.values[i + 3]
    );
  }
  _setQuatTanFromKeyframeIndex(t, e) {
    if (this.buffer.tangents.length === 0)
      e.set(0, 0, 0, 1);
    else {
      const i = t * 4;
      e.set(
        this.buffer.tangents[i],
        this.buffer.tangents[i + 1],
        this.buffer.tangents[i + 2],
        this.buffer.tangents[i + 3]
      );
    }
  }
  /** @hidden */
  _gatherForExport(t) {
    t.buffers.add(this.buffer);
  }
  /** @hidden */
  _export(t) {
    return {
      buffer: t.buffers.getIndex(this.buffer),
      interpolationType: Ru[this.interpolationType]
    };
  }
  /** @hidden */
  static _import(t, e) {
    return new jt(t.buffers[e.buffer], Ru[e.interpolationType]);
  }
};
jt.q0 = ts.identity(), jt.q1 = ts.identity(), jt.q2 = ts.identity(), jt.q3 = ts.identity(), jt.q4 = ts.identity(), jt.q5 = ts.identity(), jt.v0 = m.zero(), jt.v1 = m.zero(), jt.v2 = m.zero(), jt.v3 = m.zero();
let Wc = jt;
var ul = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Catia = 2] = "Catia", s[s.CatiaV5 = 3] = "CatiaV5", s[s.Cadds = 4] = "Cadds", s[s.Unigraphics = 5] = "Unigraphics", s[s.Parasolid = 6] = "Parasolid", s[s.Euclid = 7] = "Euclid", s[s.Iges = 9] = "Iges", s[s.Unisurf = 10] = "Unisurf", s[s.Vda = 11] = "Vda", s[s.Stl = 12] = "Stl", s[s.Wrl = 13] = "Wrl", s[s.Dxf = 14] = "Dxf", s[s.Acis = 15] = "Acis", s[s.ProE = 16] = "ProE", s[s.Step = 18] = "Step", s[s.Ideas = 19] = "Ideas", s[s.Jt = 20] = "Jt", s[s.Slw = 22] = "Slw", s[s.Cgr = 23] = "Cgr", s[s.Prc = 24] = "Prc", s[s.Xvl = 25] = "Xvl", s[s.Hpgl = 26] = "Hpgl", s[s.TopSolid = 27] = "TopSolid", s[s.OneSpaceDesigner = 28] = "OneSpaceDesigner", s[s._3dxml = 29] = "_3dxml", s[s.Inventor = 30] = "Inventor", s[s.PostScript = 31] = "PostScript", s[s.Pdp = 32] = "Pdp", s[s.U3d = 33] = "U3d", s[s.Ifc = 34] = "Ifc", s[s.Dwg = 35] = "Dwg", s[s.Dwf = 36] = "Dwf", s[s.Se = 37] = "Se", s[s.Obj = 38] = "Obj", s[s.Kmz = 39] = "Kmz", s[s.Dae = 40] = "Dae", s[s._3ds = 41] = "_3ds", s[s.Rhino = 43] = "Rhino", s[s.Xml = 44] = "Xml", s[s._3mf = 45] = "_3mf", s[s.Scs = 46] = "Scs", s[s._3dHtml = 47] = "_3dHtml", s[s.Hsf = 48] = "Hsf", s[s.Gltf = 49] = "Gltf", s[s.Revit = 50] = "Revit", s[s.Fbx = 51] = "Fbx", s))(ul || {}), pi = /* @__PURE__ */ ((s) => (s[s.IsLoaded = -2147483648] = "IsLoaded", s[s.InitiallyShown = 1073741824] = "InitiallyShown", s[s.InitiallyRemoved = 536870912] = "InitiallyRemoved", s[s.OutOfHierarchy = 268435456] = "OutOfHierarchy", s[s.IsAnnotationView = 134217728] = "IsAnnotationView", s[s.IsCameraSet = 67108864] = "IsCameraSet", s[s.IsPmiFilteringSet = 33554432] = "IsPmiFilteringSet", s[s.IsGeomFilteringSet = 16777216] = "IsGeomFilteringSet", s[s.IsCrossSectionSet = 8388608] = "IsCrossSectionSet", s[s.IsExplosionSet = 4194304] = "IsExplosionSet", s[s.IsCombineState = 2097152] = "IsCombineState", s[s.IsPerspective = 1048576] = "IsPerspective", s[s.IsShownSpecified = 524288] = "IsShownSpecified", s[s.IsShown = 262144] = "IsShown", s[s.BranchVisibilityHidden = 131072] = "BranchVisibilityHidden", s[s.BranchVisibilityShown = 65536] = "BranchVisibilityShown", s[s.BranchVisibilityDirty = 32768] = "BranchVisibilityDirty", s[s.PreventFromResetting = 16384] = "PreventFromResetting", s[s.HasDynamicFrame = 8192] = "HasDynamicFrame", s[s.IsMissing = 4096] = "IsMissing", s[s.IsExternalModelRoot = 2048] = "IsExternalModelRoot", s[s.Requested = 1024] = "Requested", s[s.ImplicitBody = 512] = "ImplicitBody", s[s.IsDefaultView = 256] = "IsDefaultView", s[s.Unused2 = 128] = "Unused2", s[s.Unused1 = 64] = "Unused1", s[s.NodeTypeDrawingSheet = 32] = "NodeTypeDrawingSheet", s[s.IsADefaultNodeType = 16] = "IsADefaultNodeType", s[s.NodeTypeDrawingView = 8] = "NodeTypeDrawingView", s[s.NodeTypeGroup = 4] = "NodeTypeGroup", s[s.NodeTypeProduct = 2] = "NodeTypeProduct", s[s.IsAConfigurationNode = 1] = "IsAConfigurationNode", s))(pi || {}), Vr = /* @__PURE__ */ ((s) => (s[
  s.OutOfHierarchy = 268435456
  /* OutOfHierarchy */
] = "OutOfHierarchy", s[
  s.PreventFromResetting = 16384
  /* PreventFromResetting */
] = "PreventFromResetting", s[
  s.Requested = 1024
  /* Requested */
] = "Requested", s[
  s.ImplicitBody = 512
  /* ImplicitBody */
] = "ImplicitBody", s))(Vr || {}), _f = /* @__PURE__ */ ((s) => (s[
  s.IgnoreParentScale = 1
  /* IgnoreParentScale */
] = "IgnoreParentScale", s[
  s.IgnoreParentRotation = 2
  /* IgnoreParentRotation */
] = "IgnoreParentRotation", s))(_f || {}), Wt = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.BodyInstance = 1] = "BodyInstance", s[s.PmiBody = 2] = "PmiBody", s[s.ViewFrame = 4] = "ViewFrame", s[s.All = 7] = "All", s))(Wt || {}), Cn = /* @__PURE__ */ ((s) => (s[s.ProductOccurrence = 0] = "ProductOccurrence", s[s.AnyBody = 1] = "AnyBody", s[s.BodyInstance = 2] = "BodyInstance", s[s.CadView = 3] = "CadView", s))(Cn || {}), Hi = ((s) => (s[s.InitiallyShown = pi.InitiallyShown] = "InitiallyShown", s[s.InitiallyRemoved = pi.InitiallyRemoved] = "InitiallyRemoved", s[s.IsShownSpecified = pi.IsShownSpecified] = "IsShownSpecified", s[s.IsShown = pi.IsShown] = "IsShown", s[s.IsLoaded = pi.IsLoaded] = "IsLoaded", s))(Hi || {}), yf = ((s) => (s[s.IsMissing = pi.IsMissing] = "IsMissing", s))(yf || {}), Si = ((s) => (s[s.IsAnnotationView = pi.IsAnnotationView] = "IsAnnotationView", s[s.IsCameraSet = pi.IsCameraSet] = "IsCameraSet", s[s.IsPmiFilteringSet = pi.IsPmiFilteringSet] = "IsPmiFilteringSet", s[s.IsGeomFilteringSet = pi.IsGeomFilteringSet] = "IsGeomFilteringSet", s[s.IsCrossSectionSet = pi.IsCrossSectionSet] = "IsCrossSectionSet", s[s.IsExplosionSet = pi.IsExplosionSet] = "IsExplosionSet", s[s.IsCombineState = pi.IsCombineState] = "IsCombineState", s[s.IsPerspective = pi.IsPerspective] = "IsPerspective", s[s.HasDynamicFrame = pi.HasDynamicFrame] = "HasDynamicFrame", s[s.IsDefaultView = pi.IsDefaultView] = "IsDefaultView", s))(Si || {}), Mo = /* @__PURE__ */ ((s) => (s[s.Rgba32 = 0] = "Rgba32", s[s.Rgb24 = 1] = "Rgb24", s[s.Gray8 = 2] = "Gray8", s[s.GrayAlpha16 = 3] = "GrayAlpha16", s[s.Jpeg = 4] = "Jpeg", s[s.Png = 5] = "Png", s))(Mo || {}), tg = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(tg || {}), jr = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s[s.Local = 0] = "Local", s))(jr || {}), el = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(el || {}), Lu = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Lu || {}), Am = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Am || {}), Tm = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Tm || {}), Ni = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s[s.Local = 0] = "Local", s))(Ni || {}), eg = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(eg || {}), Dm = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Dm || {}), Nm = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Nm || {}), vc = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(vc || {}), Is = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s[s.Empty = 4294967294] = "Empty", s[s.Local = 0] = "Local", s))(Is || {}), Om = /* @__PURE__ */ ((s) => (s[s.World = 0] = "World", s[s.Camera = 1] = "Camera", s))(Om || {}), Fu = /* @__PURE__ */ ((s) => (s[s.Directional = 0] = "Directional", s[s.Point = 1] = "Point", s))(Fu || {}), ba = /* @__PURE__ */ ((s) => (s[s.OfInitialEmptyModel = 0] = "OfInitialEmptyModel", s))(ba || {}), il = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.SMAA = 1] = "SMAA", s))(il || {}), bc = /* @__PURE__ */ ((s) => (s[s.Floor = 0] = "Floor", s[s.Wall = 1] = "Wall", s[s.Door = 2] = "Door", s))(bc || {}), xc = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfWidth = 1] = "ProportionOfWidth", s[s.ProportionOfHeight = 2] = "ProportionOfHeight", s))(xc || {}), Rm = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s))(Rm || {}), fr = /* @__PURE__ */ ((s) => (s[s.Default = 0] = "Default", s[s.Highlight = 1] = "Highlight", s[s.HiddenLine = 2] = "HiddenLine", s[s.XRay = 3] = "XRay", s[s.Gooch = 4] = "Gooch", s[s.Toon = 5] = "Toon", s))(fr || {}), Lm = /* @__PURE__ */ ((s) => (s[s.FixedFramerate = 0] = "FixedFramerate", s[s.OcclusionCulling = 1] = "OcclusionCulling", s))(Lm || {}), an = /* @__PURE__ */ ((s) => (s[s.Faces = 0] = "Faces", s[s.Lines = 1] = "Lines", s[s.Points = 2] = "Points", s))(an || {}), Fm = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Faces = 1] = "Faces", s[s.Lines = 2] = "Lines", s[s.Points = 4] = "Points", s[s.All = 7] = "All", s))(Fm || {}), An = /* @__PURE__ */ ((s) => (s[s.Base = 0] = "Base", s[s.Specular = 1] = "Specular", s[s.Emissive = 2] = "Emissive", s[s.Ambient = 3] = "Ambient", s))(An || {}), Rr = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Modulate = 1] = "Modulate", s[s.Desaturate = 2] = "Desaturate", s[s.Colorize = 3] = "Colorize", s))(Rr || {}), Bu = /* @__PURE__ */ ((s) => (s[s.Visible = 0] = "Visible", s[s.VisibleWithFullOutline = 1] = "VisibleWithFullOutline", s))(Bu || {}), Bm = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s[s.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", s))(Bm || {}), Vm = /* @__PURE__ */ ((s) => (s[s.Square = 0] = "Square", s[s.Disk = 1] = "Disk", s[s.Sphere = 2] = "Sphere", s))(Vm || {}), zm = /* @__PURE__ */ ((s) => (s[s.ScreenPixels = 0] = "ScreenPixels", s[s.CSSPixels = 1] = "CSSPixels", s[s.World = 2] = "World", s[s.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", s[s.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", s))(zm || {}), Gc = /* @__PURE__ */ ((s) => (s[s.Perspective = 0] = "Perspective", s[s.Orthographic = 1] = "Orthographic", s[s.Stretched = 2] = "Stretched", s))(Gc || {}), nn = /* @__PURE__ */ ((s) => (s[s.Uninitialized = 0] = "Uninitialized", s[s.Network = 1] = "Network", s[s.Scs = 2] = "Scs", s))(nn || {}), ao = /* @__PURE__ */ ((s) => (s[s.Hide = 0] = "Hide", s[s.Show = 1] = "Show", s[s.Initial = 2] = "Initial", s))(ao || {}), ig = /* @__PURE__ */ ((s) => (s[s.World = 0] = "World", s[s.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", s))(ig || {}), Hm = /* @__PURE__ */ ((s) => (s[s.Low = 0] = "Low", s[s.Medium = 1] = "Medium", s[s.High = 2] = "High", s[s.Ultra = 3] = "Ultra", s))(Hm || {}), ng = /* @__PURE__ */ ((s) => (s[s.SessionNotStarted = 0] = "SessionNotStarted", s[s.Cancelled = 1] = "Cancelled", s[s.CorruptRpcMessage = 2] = "CorruptRpcMessage", s))(ng || {}), Vu = /* @__PURE__ */ ((s) => (s[s.On = 0] = "On", s[s.Off = 1] = "Off", s))(Vu || {}), zu = /* @__PURE__ */ ((s) => (s[s.On = 0] = "On", s[s.Off = 1] = "Off", s))(zu || {}), Ic = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Decal = 1] = "Decal", s))(Ic || {}), Hu = /* @__PURE__ */ ((s) => (s[s.UV = 0] = "UV", s))(Hu || {}), Uu = /* @__PURE__ */ ((s) => (s[s.Repeat = 0] = "Repeat", s[s.Clamp = 1] = "Clamp", s[s.Trim = 2] = "Trim", s))(Uu || {}), Um = /* @__PURE__ */ ((s) => (s[s.Unsorted = 0] = "Unsorted", s[s.SingleLayer = 1] = "SingleLayer", s))(Um || {}), ju = /* @__PURE__ */ ((s) => (s[s.Selected = 0] = "Selected", s[s.Unselected = 1] = "Unselected", s))(ju || {}), _n = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Floor = 1] = "Floor", s[s.Wall = 2] = "Wall", s[s.Door = 4] = "Door", s))(_n || {}), Ae = /* @__PURE__ */ ((s) => (s[s.Invalid = -1] = "Invalid", s[s.Default = 0] = "Default", s))(Ae || {}), dr = /* @__PURE__ */ ((s) => (s[s.UpperLeftCorner = 0] = "UpperLeftCorner", s[s.LowerLeftCorner = 1] = "LowerLeftCorner", s[s.LowerRightCorner = 2] = "LowerRightCorner", s[s.UpperRightCorner = 3] = "UpperRightCorner", s[s.TopCenter = 4] = "TopCenter", s[s.LeftCenter = 5] = "LeftCenter", s[s.RightCenter = 6] = "RightCenter", s[s.BottomCenter = 7] = "BottomCenter", s[s.Center = 8] = "Center", s))(dr || {}), nl = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfScreen = 1] = "ProportionOfScreen", s[s.MinimumProportionOfScreen = 2] = "MinimumProportionOfScreen", s[s.ProportionOfOtherDimension = 3] = "ProportionOfOtherDimension", s))(nl || {});
const Ds = 0;
function ca(s) {
  return s !== null && typeof s == "object" && "scFunction" in s && typeof s.scFunction == "string";
}
function jm(s) {
  const t = s.data;
  return t !== null && typeof t == "object" && "scStateFailure" in t ? t.scStateFailure : null;
}
var ac = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ld(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var wu = { exports: {} };
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */
var gv = wu.exports, Pp;
function pv() {
  return Pp || (Pp = 1, function(s) {
    (function(t, e, i) {
      s.exports ? s.exports = i() : t[e] = i();
    })(gv, "bowser", function() {
      var t = !0;
      function e(u) {
        function f(mt) {
          var Nt = u.match(mt);
          return Nt && Nt.length > 1 && Nt[1] || "";
        }
        function g(mt) {
          var Nt = u.match(mt);
          return Nt && Nt.length > 1 && Nt[2] || "";
        }
        var y = f(/(ipod|iphone|ipad)/i).toLowerCase(), _ = /like android/i.test(u), x = !_ && /android/i.test(u), b = /nexus\s*[0-6]\s*/i.test(u), I = !b && /nexus\s*[0-9]+/i.test(u), C = /CrOS/.test(u), M = /silk/i.test(u), P = /sailfish/i.test(u), O = /tizen/i.test(u), B = /(web|hpw)(o|0)s/i.test(u), j = /windows phone/i.test(u), F = !j && /windows/i.test(u), K = !y && !M && /macintosh/i.test(u), J = !x && !P && !O && !B && /linux/i.test(u), rt = g(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), ft = f(/version\/(\d+(\.\d+)?)/i), H = /tablet/i.test(u) && !/tablet pc/i.test(u), $ = !H && /[^-]mobi/i.test(u), D = /xbox/i.test(u), R;
        /opera/i.test(u) ? R = {
          name: "Opera",
          opera: t,
          version: ft || f(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
        } : /opr\/|opios/i.test(u) ? R = {
          name: "Opera",
          opera: t,
          version: f(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || ft
        } : /SamsungBrowser/i.test(u) ? R = {
          name: "Samsung Internet for Android",
          samsungBrowser: t,
          version: ft || f(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
        } : /Whale/i.test(u) ? R = {
          name: "NAVER Whale browser",
          whale: t,
          version: f(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
        } : /MZBrowser/i.test(u) ? R = {
          name: "MZ Browser",
          mzbrowser: t,
          version: f(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
        } : /coast/i.test(u) ? R = {
          name: "Opera Coast",
          coast: t,
          version: ft || f(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
        } : /focus/i.test(u) ? R = {
          name: "Focus",
          focus: t,
          version: f(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
        } : /yabrowser/i.test(u) ? R = {
          name: "Yandex Browser",
          yandexbrowser: t,
          version: ft || f(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
        } : /ucbrowser/i.test(u) ? R = {
          name: "UC Browser",
          ucbrowser: t,
          version: f(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
        } : /mxios/i.test(u) ? R = {
          name: "Maxthon",
          maxthon: t,
          version: f(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
        } : /epiphany/i.test(u) ? R = {
          name: "Epiphany",
          epiphany: t,
          version: f(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
        } : /puffin/i.test(u) ? R = {
          name: "Puffin",
          puffin: t,
          version: f(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
        } : /sleipnir/i.test(u) ? R = {
          name: "Sleipnir",
          sleipnir: t,
          version: f(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
        } : /k-meleon/i.test(u) ? R = {
          name: "K-Meleon",
          kMeleon: t,
          version: f(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
        } : j ? (R = {
          name: "Windows Phone",
          osname: "Windows Phone",
          windowsphone: t
        }, rt ? (R.msedge = t, R.version = rt) : (R.msie = t, R.version = f(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(u) ? R = {
          name: "Internet Explorer",
          msie: t,
          version: f(/(?:msie |rv:)(\d+(\.\d+)?)/i)
        } : C ? R = {
          name: "Chrome",
          osname: "Chrome OS",
          chromeos: t,
          chromeBook: t,
          chrome: t,
          version: f(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
        } : /edg([ea]|ios)/i.test(u) ? R = {
          name: "Microsoft Edge",
          msedge: t,
          version: rt
        } : /vivaldi/i.test(u) ? R = {
          name: "Vivaldi",
          vivaldi: t,
          version: f(/vivaldi\/(\d+(\.\d+)?)/i) || ft
        } : P ? R = {
          name: "Sailfish",
          osname: "Sailfish OS",
          sailfish: t,
          version: f(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
        } : /seamonkey\//i.test(u) ? R = {
          name: "SeaMonkey",
          seamonkey: t,
          version: f(/seamonkey\/(\d+(\.\d+)?)/i)
        } : /firefox|iceweasel|fxios/i.test(u) ? (R = {
          name: "Firefox",
          firefox: t,
          version: f(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
        }, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(u) && (R.firefoxos = t, R.osname = "Firefox OS")) : M ? R = {
          name: "Amazon Silk",
          silk: t,
          version: f(/silk\/(\d+(\.\d+)?)/i)
        } : /phantom/i.test(u) ? R = {
          name: "PhantomJS",
          phantom: t,
          version: f(/phantomjs\/(\d+(\.\d+)?)/i)
        } : /slimerjs/i.test(u) ? R = {
          name: "SlimerJS",
          slimer: t,
          version: f(/slimerjs\/(\d+(\.\d+)?)/i)
        } : /blackberry|\bbb\d+/i.test(u) || /rim\stablet/i.test(u) ? R = {
          name: "BlackBerry",
          osname: "BlackBerry OS",
          blackberry: t,
          version: ft || f(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
        } : B ? (R = {
          name: "WebOS",
          osname: "WebOS",
          webos: t,
          version: ft || f(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
        }, /touchpad\//i.test(u) && (R.touchpad = t)) : /bada/i.test(u) ? R = {
          name: "Bada",
          osname: "Bada",
          bada: t,
          version: f(/dolfin\/(\d+(\.\d+)?)/i)
        } : O ? R = {
          name: "Tizen",
          osname: "Tizen",
          tizen: t,
          version: f(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || ft
        } : /qupzilla/i.test(u) ? R = {
          name: "QupZilla",
          qupzilla: t,
          version: f(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || ft
        } : /chromium/i.test(u) ? R = {
          name: "Chromium",
          chromium: t,
          version: f(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || ft
        } : /chrome|crios|crmo/i.test(u) ? R = {
          name: "Chrome",
          chrome: t,
          version: f(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
        } : x ? R = {
          name: "Android",
          version: ft
        } : /safari|applewebkit/i.test(u) ? (R = {
          name: "Safari",
          safari: t
        }, ft && (R.version = ft)) : y ? (R = {
          name: y == "iphone" ? "iPhone" : y == "ipad" ? "iPad" : "iPod"
        }, ft && (R.version = ft)) : /googlebot/i.test(u) ? R = {
          name: "Googlebot",
          googlebot: t,
          version: f(/googlebot\/(\d+(\.\d+))/i) || ft
        } : R = {
          name: f(/^(.*)\/(.*) /),
          version: g(/^(.*)\/(.*) /)
        }, !R.msedge && /(apple)?webkit/i.test(u) ? (/(apple)?webkit\/537\.36/i.test(u) ? (R.name = R.name || "Blink", R.blink = t) : (R.name = R.name || "Webkit", R.webkit = t), !R.version && ft && (R.version = ft)) : !R.opera && /gecko\//i.test(u) && (R.name = R.name || "Gecko", R.gecko = t, R.version = R.version || f(/gecko\/(\d+(\.\d+)?)/i)), !R.windowsphone && (x || R.silk) ? (R.android = t, R.osname = "Android") : !R.windowsphone && y ? (R[y] = t, R.ios = t, R.osname = "iOS") : K ? (R.mac = t, R.osname = "macOS") : D ? (R.xbox = t, R.osname = "Xbox") : F ? (R.windows = t, R.osname = "Windows") : J && (R.linux = t, R.osname = "Linux");
        function U(mt) {
          switch (mt) {
            case "NT":
              return "NT";
            case "XP":
              return "XP";
            case "NT 5.0":
              return "2000";
            case "NT 5.1":
              return "XP";
            case "NT 5.2":
              return "2003";
            case "NT 6.0":
              return "Vista";
            case "NT 6.1":
              return "7";
            case "NT 6.2":
              return "8";
            case "NT 6.3":
              return "8.1";
            case "NT 10.0":
              return "10";
            default:
              return;
          }
        }
        var it = "";
        R.windows ? it = U(f(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : R.windowsphone ? it = f(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : R.mac ? (it = f(/Mac OS X (\d+([_\.\s]\d+)*)/i), it = it.replace(/[_\s]/g, ".")) : y ? (it = f(/os (\d+([_\s]\d+)*) like mac os x/i), it = it.replace(/[_\s]/g, ".")) : x ? it = f(/android[ \/-](\d+(\.\d+)*)/i) : R.webos ? it = f(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : R.blackberry ? it = f(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : R.bada ? it = f(/bada\/(\d+(\.\d+)*)/i) : R.tizen && (it = f(/tizen[\/\s](\d+(\.\d+)*)/i)), it && (R.osversion = it);
        var at = !R.windows && it.split(".")[0];
        return H || I || y == "ipad" || x && (at == 3 || at >= 4 && !$) || R.silk ? R.tablet = t : ($ || y == "iphone" || y == "ipod" || x || b || R.blackberry || R.webos || R.bada) && (R.mobile = t), R.msedge || R.msie && R.version >= 10 || R.yandexbrowser && R.version >= 15 || R.vivaldi && R.version >= 1 || R.chrome && R.version >= 20 || R.samsungBrowser && R.version >= 4 || R.whale && o([R.version, "1.0"]) === 1 || R.mzbrowser && o([R.version, "6.0"]) === 1 || R.focus && o([R.version, "1.0"]) === 1 || R.firefox && R.version >= 20 || R.safari && R.version >= 6 || R.opera && R.version >= 10 || R.ios && R.osversion && R.osversion.split(".")[0] >= 6 || R.blackberry && R.version >= 10.1 || R.chromium && R.version >= 20 ? R.a = t : R.msie && R.version < 10 || R.chrome && R.version < 20 || R.firefox && R.version < 20 || R.safari && R.version < 6 || R.opera && R.version < 10 || R.ios && R.osversion && R.osversion.split(".")[0] < 6 || R.chromium && R.version < 20 ? R.c = t : R.x = t, R;
      }
      var i = e(typeof navigator < "u" && navigator.userAgent || "");
      i.test = function(u) {
        for (var f = 0; f < u.length; ++f) {
          var g = u[f];
          if (typeof g == "string" && g in i)
            return !0;
        }
        return !1;
      };
      function n(u) {
        return u.split(".").length;
      }
      function r(u, f) {
        var g = [], y;
        if (Array.prototype.map)
          return Array.prototype.map.call(u, f);
        for (y = 0; y < u.length; y++)
          g.push(f(u[y]));
        return g;
      }
      function o(u) {
        for (var f = Math.max(n(u[0]), n(u[1])), g = r(u, function(y) {
          var _ = f - n(y);
          return y = y + new Array(_ + 1).join(".0"), r(y.split("."), function(x) {
            return new Array(20 - x.length).join("0") + x;
          }).reverse();
        }); --f >= 0; ) {
          if (g[0][f] > g[1][f])
            return 1;
          if (g[0][f] === g[1][f]) {
            if (f === 0)
              return 0;
          } else
            return -1;
        }
      }
      function l(u, f, g) {
        var y = i;
        typeof f == "string" && (g = f, f = void 0), f === void 0 && (f = !1), g && (y = e(g));
        var _ = "" + y.version;
        for (var x in u)
          if (u.hasOwnProperty(x) && y[x]) {
            if (typeof u[x] != "string")
              throw new Error("Browser version in the minVersion map should be a string: " + x + ": " + String(u));
            return o([_, u[x]]) < 0;
          }
        return f;
      }
      function h(u, f, g) {
        return !l(u, f, g);
      }
      return i.isUnsupportedBrowser = l, i.compareVersions = o, i.check = h, i._detect = e, i.detect = e, i;
    });
  }(wu)), wu.exports;
}
var Wm = pv();
const mv = /* @__PURE__ */ ld(Wm), _v = /* @__PURE__ */ Jw({
  __proto__: null,
  default: mv
}, [Wm]);
var yv = (() => {
  var s = import.meta.url;
  return function(t) {
    t = t || {};
    var e;
    e || (e = typeof t < "u" ? t : {});
    var i, n;
    e.ready = new Promise(function(a, c) {
      i = a, n = c;
    }), e.$$setReady = function() {
      e.kk(), e.$$onReady.apply(window, arguments), e.$$onReady = void 0, e.onAbort = void 0;
    }, e.kk = function() {
      function a(Bt) {
        if (!Bt) return 0;
        var Dt = e.$$es.allocateUint8Buffer(8 * Bt.length);
        if (Dt) mt.set(Bt, Dt >> 3);
        else throw Error("Out of memory.");
        return Dt;
      }
      function c(Bt) {
        if (!Bt) return 0;
        var Dt = e.$$es.allocateUint8Buffer(4 * Bt.length);
        if (Dt) it.set(Bt, Dt >> 2);
        else throw Error("Out of memory.");
        return Dt;
      }
      function d(Bt) {
        if (!Bt) return 0;
        var Dt = e.$$es.allocateUint8Buffer(Bt.length);
        if (Dt) $.set(Bt, Dt);
        else throw Error("Out of memory.");
        return Dt;
      }
      function p(Bt) {
        e.$$es.deallocateUint8Buffer(Bt);
      }
      function w(Bt) {
        return function() {
          return z(
            Bt,
            arguments
          );
        };
      }
      function k(Bt, Dt, je) {
        function ie(Xn) {
          return function() {
            return Ut(), Me && bt.callRecord.push(Xn + " " + ut(arguments)), L(this, e[Bt][Xn], arguments);
          };
        }
        function Di() {
          Ut(), this.$$memory = new Uint8Array(e[Bt]["sizeof_" + Dt]()), L(this, e[Bt][ke + "create"], arguments);
        }
        var ke = Dt + "_";
        Di.prototype = { $$stackify: !0 }, Di.copy = function(Xn) {
          Ut();
          var ps = Object.create(Di.prototype);
          return ps.$$memory = new Uint8Array($.subarray(Xn, Xn + e[Bt]["sizeof_" + Dt]())), ps;
        }, Di.clone = function(Xn) {
          var ps = Object.create(Di.prototype);
          return ps.$$memory = new Uint8Array(Xn.$$memory), ps;
        }, Di.assign = function(Xn, ps) {
          Xn.$$memory.set(ps.$$memory);
        };
        for (var zn = 0; zn < je.length; zn++) Di.prototype[je[zn]] = ie(ke + je[zn]);
        return bt[Dt] = Di;
      }
      function L(Bt, Dt, je) {
        return je = Array.prototype.slice.call(je), je.unshift(Bt), z(Dt, je);
      }
      function z(Bt, Dt) {
        for (var je = !1, ie = 0; ie < Dt.length; ++ie) if (Dt[ie].$$stackify) {
          je = !0;
          break;
        }
        if (!je) return Bt.apply(e, Dt);
        je = nu();
        try {
          var Di = Array.prototype.slice.call(Dt);
          for (ie = 0; ie < Dt.length; ie++) if (Dt[ie].$$stackify) {
            var ke = Zl(Dt[ie].$$memory.length);
            $.set(Dt[ie].$$memory, ke), Di[ie] = ke;
          }
          var zn = Bt.apply(
            e,
            Di
          );
          for (ie = 0; ie < Dt.length; ie++) Dt[ie].$$stackify && Dt[ie].$$memory.set($.subarray(Di[ie], Di[ie] + Dt[ie].$$memory.length));
        } finally {
          su(je);
        }
        return zn;
      }
      function Z(Bt) {
        this.value = Bt;
      }
      function ct(Bt) {
        bt.suspendDrawing(Bt), e.ki("webgl_context_lost");
      }
      function ut() {
        return JSON.stringify(arguments, At);
      }
      function At(Bt, Dt) {
        return Dt !== null && typeof Dt == "object" && Dt.$$memory ? "stackified" : Dt;
      }
      function Ut() {
        if (bt !== e.$$facade) throw new ReferenceError("member called after shutdown");
      }
      var et = "$$cs";
      e.$$es.initializeLibrary();
      var bt = e.$$facade, $t = e.Oj ? new e.Oj() : void 0;
      e.tj = $t, bt.isValid = function() {
        return bt === e.$$facade;
      };
      var Me = !1;
      bt.callRecord = [], bt.startRecording = function() {
        Me = !0;
      }, bt.stopRecording = function() {
        Me = !1;
      }, bt.logCallRecord = function() {
        for (var Bt = bt.callRecord, Dt = 0; Dt < Bt.length; ++Dt) console.log(Bt[Dt]);
      }, bt.shutDown = function() {
        Ut(), Me && bt.callRecord.push("shutDown"), et === "$$cs" && e.canvas.removeEventListener("webglcontextlost", ct), e.$$es.shutDownLibrary(), $t && $t.Xk(), e.$$legacyClient ? (bt.container.innerHTML = "", e.$$wrapper.innerHTML = "") : (bt.containers.forEach((Bt) => {
          Bt.innerHTML = "";
        }), bt.wrappers.forEach((Bt) => {
          Bt.innerHTML = "";
        })), e.$$facade = void 0, e.tj = void 0, e.$$available = !0;
      }, bt.ByMeshInstance = new Z(0), bt.ByGroup = new Z(1), bt.ByExpandedGroup = new Z(2), function() {
        function Bt(G, Q) {
          if (ie([Kt.Scs]), !G) throw new ke("InvalidConfig", "Invalid load configuration");
          var ht, gt, Mt = new Promise(function(Ie, Ke) {
            ht = Ie, gt = Ke;
          });
          Hn = Kt.Scs;
          var Xt = new XMLHttpRequest();
          if (Xt.open("GET", Q), Xt.responseType = "arraybuffer", Xt.onload = function() {
            try {
              Dt(G, new Uint8Array(this.response)).then(function(Ie) {
                ht(Ie);
              }, function(Ie) {
                gt(Ie);
              });
            } catch {
            }
          }, typeof G.XHRonprogress == "function" && (Xt.onprogress = G.XHRonprogress), typeof G.XHRonerror == "function" && (Xt.onerror = G.XHRonerror), typeof G.XHRonloadend == "function") {
            var Ye = G.XHRonloadend;
            Xt.onloadend = function(Ie) {
              Ye(Ie, Xt.status, Q);
            };
          }
          return Xt.send(), Mt;
        }
        function Dt(G, Q) {
          if (ie([Kt.Scs]), !G) throw new ke("InvalidConfig", "Invalid load configuration");
          if (Q.constructor !== Uint8Array) throw new ke("InvalidConfig", "'buffer' must be a Uint8Array");
          if (0 >= Q.byteLength) throw new ke("EmptyBuffer", "'buffer' has a length of 0");
          var ht = e.$$es.allocateUint8Buffer(Q.byteLength);
          $.set(Q, ht);
          try {
            return je(G, ht, Q.byteLength);
          } catch (gt) {
            throw e.$$es.deallocateUint8Buffer(ht), gt;
          }
        }
        function je(G, Q, ht) {
          ie([Kt.Scs]);
          var gt = G.attachScope, Mt = G.attachMeasurementUnit, Xt = G.attachInvisibly, Ye = G.resolveOnFullyLoaded, Ie = G.inclusionMatrix, Ke = G.cancelUnitMatrix;
          G = G.autoUnitScale;
          var Jn = 0;
          if (Ie) {
            if (Ie.constructor !== Array && Ie.constructor !== Float64Array) throw new TypeError("'inclusionMatrix' is not an Array or Float64Array.");
            if (Ie.length !== 12) throw new TypeError("'inclusionMatrix' needs to have exactly 12 elements.");
            if (Jn = a(Ie), !Jn) throw Error("Internal logic error.");
          }
          Hn = Kt.Scs;
          var Un, jn;
          Ie = new Promise(function(rs, _s) {
            Un = rs, jn = function(Gs) {
              try {
                Di(Gs), _s(null);
              } catch (_i) {
                _s(_i);
              }
            };
          });
          try {
            e.$$es.attachScsBuffer(gt, Q, ht, Jn, Mt, Xt, Ye, Ke, G, Un, jn);
          } catch (rs) {
            jn(rs);
          } finally {
            p(Jn);
          }
          return Ie;
        }
        function ie(G) {
          if (Hn !== Kt.Uninitialized) {
            if (G !== void 0) {
              for (var Q = 0; Q < G.length; ++Q) if (Hn === G[Q]) return;
            }
            throw new ke("AlreadyCalled", "load() already called with an incompatible session type");
          }
        }
        function Di(G) {
          switch (G) {
            case e.LoadResult.WebGLMissing:
              throw new ke(
                "WebGLError",
                "WebGL initialization failed"
              );
            case e.LoadResult.SessionAlreadyStarted:
              throw new ke("AlreadyCalled", "load() already called");
          }
        }
        function ke(G, Q) {
          this.code = G, this.message = Q, this.stack = Error().stack;
        }
        function zn(G) {
          var Q = JSON.parse(F(G, 0));
          if ("rpc" in Q) {
            if (G = Q.rpc, Q = G.length / 2, Q === Math.floor(Q)) {
              for (var ht = new Uint8Array(Q), gt = 0; gt < Q; ++gt) ht[gt] = parseInt(G.substr(gt + gt, 2), 16);
              G = ht, Q = new DataView(G.buffer).getUint32(0, !0), ht = G[4], G = G.subarray(5), gt = d(G), e[et].notifyRpcClientResult(Q, ht, gt, G.length);
            }
          } else if ("event" in Q) switch (G = Q.event, Q = Q.data, G) {
            case "camera_set":
              qa = ia(Q), e.ki(G);
              break;
            default:
              Array.isArray(Q) ? (Q.unshift(G), e.ki.apply(e, Q)) : e.ki(G, Q);
          }
        }
        function Xn(G) {
          var Q = d(G);
          e.$$es.parseMetaData($a, Q, G.length);
        }
        function ps(G) {
          G = F(G, 0), e.ki("post_draw_json", G);
        }
        function ia(G) {
          var Q = new ms();
          return Q.reset.apply(Q, G), Q;
        }
        function Ga(G) {
          function Q(_i, Ar, ge, Xe) {
            if (0 > Xe || Xe >= Ar.elementCount) throw new RangeError("invalid element index");
            var fn = { vertexCount: Ye[_i][3 * Xe + 1], bits: Ye[_i][3 * Xe + 2], iterate: function(ks) {
              return gt(
                _i,
                Ar,
                ge,
                Xe,
                this,
                ks
              );
            } };
            return typeof Symbol < "u" && typeof Symbol.iterator < "u" && (fn[Symbol.iterator] = ht), fn;
          }
          function ht() {
            return this.iterate(!0);
          }
          function gt(_i, Ar, ge, Xe, fn, ks) {
            function Io() {
              var En = { position: void 0, normal: void 0, UV: void 0, RGBA: void 0 };
              ++Tr;
              for (var Fi = 0; Fi < Qr.length; ++Fi) Qr[Fi](En);
              return En;
            }
            if (typeof Xe == "number") var au = ge + Ye[_i][3 * Xe], lu = fn.vertexCount;
            else au = ge, lu = Ar.vertexCount;
            var Yd = au + lu, Tr = au, Qr = [];
            if (Ke ? Qr.push(function(En) {
              var Fi = [Mt[Es], Mt[Es + 1], Mt[Es + 2]];
              En.position = [Ke[0] * Fi[0] + Ke[4] * Fi[1] + Ke[8] * Fi[2] + Ke[12], Ke[1] * Fi[0] + Ke[5] * Fi[1] + Ke[9] * Fi[2] + Ke[13], Ke[2] * Fi[0] + Ke[6] * Fi[1] + Ke[10] * Fi[2] + Ke[14]];
            }) : Qr.push(function(En) {
              En.position = [Mt[Es], Mt[Es + 1], Mt[Es + 2]];
            }), Ar.hasNormals && Qr.push(function(En) {
              var Fi = Es + Jn;
              En.normal = [Mt[Fi], Mt[Fi + 1], Mt[Fi + 2]];
            }), Ar.hasUVs && Qr.push(function(En) {
              var Fi = Es + Un;
              En.UV = [Mt[Fi], Mt[Fi + 1]];
            }), Ar.hasRGBAs) {
              var cu = new Uint8Array(Mt.buffer);
              Qr.push(function(En) {
                var Fi = Es + jn << 2;
                En.RGBA = [cu[Fi], cu[Fi + 1], cu[Fi + 2], cu[Fi + 3]];
              });
            }
            if (Xt) {
              var Es = Xt[Tr] * Ie;
              Qr.push(function() {
                Es = Xt[Tr] * Ie;
              });
            } else Es = Tr * Ie, Qr.push(function() {
              Es += Ie;
            });
            return { done: function() {
              return Tr >= Yd;
            }, next: ks ? function() {
              return Tr < Yd ? { value: Io(), done: !1 } : { done: !0 };
            } : function() {
              if (Tr < Yd) return Io();
            }, goTo: function(En) {
              0 > En ? En = 0 : En >= lu && (En = lu), Tr = au + En, Es = Xt ? Xt[Tr] * Ie : Tr * Ie;
            } };
          }
          var Mt = G.vertices, Xt = G.indices, Ye = G.elements, Ie = G.stride, Ke = G.duplicateMatrix, Jn = G.normalOffset, Un = G.UVOffset, jn = G.RGBA32Offset, rs = G.faceVertexCount, _s = rs + G.lineVertexCount, Gs = { faces: { vertexCount: G.faceVertexCount, hasNormals: !!G.faceNormals, hasUVs: !!G.faceUVs, hasRGBAs: !!G.faceRGBA32s, elementCount: Ye[0] ? Ye[0].length / 3 : 0, iterate: function(_i) {
            return gt(0, this, 0, void 0, void 0, _i);
          }, element: function(_i) {
            return Q(0, this, 0, _i);
          } }, lines: { vertexCount: G.lineVertexCount, hasNormals: !!G.lineNormals, hasUVs: !!G.lineUVs, hasRGBAs: !!G.lineRGBA32s, elementCount: Ye[1] ? Ye[1].length / 3 : 0, iterate: function(_i) {
            return gt(1, this, rs, void 0, void 0, _i);
          }, element: function(_i) {
            return Q(1, this, rs, _i);
          } }, points: { vertexCount: G.pointVertexCount, hasNormals: !!G.pointNormals, hasUVs: !!G.pointUVs, hasRGBAs: !!G.pointRGBA32s, elementCount: Ye[2] ? Ye[2].length / 3 : 0, iterate: function(_i) {
            return gt(2, this, _s, void 0, void 0, _i);
          }, element: function(_i) {
            return Q(2, this, _s, _i);
          } } };
          typeof Symbol < "u" && typeof Symbol.iterator < "u" && (Gs.faces[Symbol.iterator] = ht, Gs.lines[Symbol.iterator] = ht, Gs.points[Symbol.iterator] = ht), G = G.forward;
          for (let _i in G) G.hasOwnProperty(_i) && (Gs[_i] = G[_i]);
          return Gs;
        }
        function $a(G, Q, ht) {
          var gt = Er[G];
          gt || (gt = Er[G] = {}), gt[Q] = ht, e.ki(
            "meta_data",
            G,
            Q,
            ht
          );
        }
        function rn(G, Q) {
          if (et === "$$cs") return Oe.getMetaData(G);
          kr(G);
          for (var ht = [], gt = 0; gt < G.length; gt += 2) {
            var Mt = G[gt], Xt = G[gt + 1], Ye = Er[Mt];
            (Ye ? Ye[Xt] : void 0) === void 0 && ht.push(Mt, Xt);
          }
          if (ht.length === 0) {
            for (Q = [], gt = 0; gt < G.length; gt += 2) Mt = G[gt], Xt = G[gt + 1], Q.push(Er[Mt][Xt]);
            return Promise.resolve(Q);
          }
          return Q ? (gt = new we("getMetaData", ht), Promise.reject(gt)) : Oe.requestMetaData(ht).then(function() {
            return Ut(), rn(G, !0);
          });
        }
        function or() {
          et === "$$cs" && e.$$es.disconnectNetwork();
        }
        function N(G, Q, ht) {
          if (typeof ht == "function") Zr(G, Q, ht);
          else {
            ht = ht || 0;
            var gt = typeof G == "string" ? G + "_" + Q : Q, Mt;
            e.$$es[gt] ? Mt = e.$$es[gt] : Mt = function() {
              return e[et][gt].apply(e, arguments);
            };
            var Xt = Mt;
            ht & 1 && (Xt = function(ge) {
              return ge == 0 ? e.$$cs[gt].apply(e, arguments) : Mt.apply(e, arguments);
            });
            var Ye = Xt;
            ht & 2 && (Ye = function(ge) {
              typeof ge == "number" && (ge = [ge]);
              var Xe = c(ge);
              if (!Xe) throw new TypeError("`keys' is not an Array or Uint32Array");
              var fn = Array.prototype.slice.call(arguments, 1);
              return fn.unshift(Xe, ge.length), Xt.apply(e, fn);
            });
            var Ie = Ye;
            ht & 4 && (Ie = function(ge) {
              kr(ge);
              var Xe = c(ge);
              if (!Xe) throw new TypeError("`ids' is not an Array or Uint32Array.");
              var fn = Array.prototype.slice.call(arguments, 1);
              return fn.unshift(Xe, ge.length >> 1), Ye.apply(e, fn);
            });
            var Ke = Ie;
            ht & 8 && (Ke = function(ge) {
              ge.length === 4 && typeof ge[0] == "number" && (ge = [ge]);
              var Xe = ge, fn = e.$$es.allocateUint8Buffer(32 * Xe.length);
              if (fn) for (var ks = 0; ks < Xe.length; ++ks) {
                var Io = Xe[ks];
                if (Io.length !== 4) throw Error("Planes are expected be exactly 4 numbers.");
                mt.set(Io, (fn >> 3) + 4 * ks);
              }
              return Xe = Array.prototype.slice.call(arguments, 1), Xe.unshift(fn, ge.length), Ie.apply(e, Xe);
            });
            var Jn = Ke;
            ht & 16 && (Jn = function(ge) {
              ge.length === 3 && typeof ge[0] == "number" && (ge = [ge]);
              var Xe = ge, fn = e.$$es.allocateUint8Buffer(24 * Xe.length);
              if (fn) for (var ks = 0; ks < Xe.length; ++ks) {
                var Io = Xe[ks];
                if (Io.length !== 3) throw Error("Points are expected be exactly 3 components.");
                mt.set(Io, (fn >> 3) + 3 * ks);
              }
              return Xe = Array.prototype.slice.call(arguments, 1), Xe.unshift(fn, ge.length), Ke.apply(e, Xe);
            });
            var Un = Jn;
            ht & 32 && (Un = w(Ke));
            var jn = Un;
            ht & 64 && (jn = function() {
              return console.log("WARNING: Using deprecated function `" + (typeof G == "string" ? G + "." + Q : Q) + "'"), Un.apply(
                e,
                arguments
              );
            });
            var rs = jn;
            ht & 128 && (rs = function() {
              var ge = arguments, Xe = ge[ge.length - 1];
              return Xe.constructor === Z ? ge[ge.length - 1] = Xe.value : (ge = Array.prototype.slice.call(ge), ge.push(0)), jn.apply(e, ge);
            });
            var _s = rs;
            ht & 256 && (_s = function() {
              var ge = Array.prototype.slice.call(arguments);
              return new Promise(function(Xe, fn) {
                ge.push(Xe), ge.push(De(gt, fn)), rs.apply(e, ge);
              });
            });
            var Gs = _s;
            ht & 512 && (Gs = ht & 256 ? function() {
              return _s.apply(e, arguments).then(function(ge) {
                return Ut(), ms.copy(ge);
              });
            } : function() {
              return ms.copy(_s.apply(e, arguments));
            });
            var _i = Gs;
            ht & 1024 && (_i = ht & 256 ? function() {
              return Gs.apply(e, arguments).then(sa);
            } : function() {
              return sa(Gs.apply(e, arguments));
            });
            var Ar = _i;
            ht & 2048 && (Ar = ht & 256 ? function() {
              return _i.apply(e, arguments).then(na);
            } : function() {
              return na(_i.apply(e, arguments));
            }), Zr(G, Q, function() {
              return Ut(), Me && bt.callRecord.push(Q + " " + ut(arguments)), Ar.apply(e, arguments);
            });
          }
        }
        function Zr(G, Q, ht) {
          var gt = typeof ht == "function" ? function() {
            return Ut(), Me && bt.callRecord.push(Q + " " + ut(arguments)), ht.apply(e, arguments);
          } : ht;
          G === null ? bt[Q] = gt : typeof G == "string" ? bt[G][Q] = gt : G[Q] = gt;
        }
        function na(G) {
          for (var Q = 0; Q < G.length; ++Q) 0 > G[Q][0] && (G[Q] = null);
          return G;
        }
        function sa(G) {
          for (var Q = 0; Q < G.length; ++Q) 0 > G[Q] && (G[Q] = null);
          return G;
        }
        function De(G, Q) {
          return function(ht) {
            ht = new we(G, ht), Q(ht);
          };
        }
        function we(G, Q) {
          this.scFunction = G, this.data = Q;
        }
        function kr(G) {
          if ((G.length & 1) !== 0) throw new TypeError("`ids.length' must be divisible by two. (An Id is a pair of keys.)");
        }
        bt.CreateImageError = e.CreateImageError, bt.CreateMeshInstanceErrorType = e.CreateMeshInstanceErrorType, bt.CuttingSectionError = e.CuttingSectionError, bt.MeshDataGetDataError = e.MeshDataGetDataError, bt.MeshDataReplaceError = e.MeshDataReplaceError, bt.SetMatrixErrorType = e.SetMatrixErrorType, bt.SetTextureErrorType = e.SetTextureErrorType;
        var ms = k("$$es", "Camera", "reset viewMatrix projectionMatrix fullMatrix projection setProjection upVector setUpVector position setPosition target setTarget nearLimit setNearLimit fieldWidth fieldHeight setField setField setFieldByAngles setFieldByAngles dolly pan roll zoom orbit axisOrbit relativeOrbit unproject".split(" "));
        we.prototype.toString = function() {
          return this.scFunction + ": " + this.data;
        };
        var Oe = {}, Er = {}, ou = new Uint8Array(0), qa = new ms();
        N(null, "addCuttingSection", 264), N(null, "addDrawContext", function() {
          return new Promise(function(G, Q) {
            e[et].addDrawContext(G, Q);
          }).then(function(G) {
            return e.$$es.initializeDrawContext(G), G;
          });
        }), N(null, "addLight", 256), N(null, "setLightPower"), N(null, "setLightDecay"), N(null, "advanceVolumeSelection", 256), N(null, "attachModels", function(G, Q, ht, gt) {
          for (var Mt = [], Xt = [], Ye = 0; Ye < Q.length; ++Ye) {
            var Ie = Q[Ye];
            if (Ie.length !== 2) throw new TypeError("Expecting [name, matrix] pair.");
            var Ke = Ie[0];
            if (typeof Ke != "string") throw new TypeError("Name is not a string.");
            if (Ie = Ie[1], Ie.constructor !== Array && Ie.constructor !== Float64Array) throw new TypeError("Matrix is not an Array or Float64Array.");
            if (Ie.length !== 12) throw new TypeError("Inclusion matrix needs to have exactly 12 elements.");
            Ke = unescape(encodeURIComponent(Ke));
            for (var Jn = 0; Jn < Ke.length; ++Jn) Mt.push(Ke.charCodeAt(Jn));
            Mt.push(0), Array.prototype.push.apply(
              Xt,
              Ie
            );
          }
          var Un = 0, jn = 0;
          if (Un = d(Mt), !Un || (jn = a(Xt), !jn)) throw p(Un), p(jn), Error("Internal logic error.");
          return new Promise(function(rs, _s) {
            e[et].attachModels(Un, Mt.length, jn, Xt.length, G, ht, gt, rs, De("attachModels", _s));
          });
        }), N(null, "attachScsModelByKey", function(G, Q, ht, gt, Mt) {
          var Xt = [];
          if (Q.constructor !== Array && Q.constructor !== Float64Array) throw new TypeError("Matrix is not an Array or Float64Array.");
          if (Q.length !== 12) throw new TypeError("Inclusion matrix needs to have exactly 12 elements.");
          if (Array.prototype.push.apply(Xt, Q), Q = a(Xt), !Q) throw p(Q), Error("Internal logic error.");
          return e.$$es.attachScsModelByKey(Q, Xt.length, G, ht, gt, Mt);
        }), N(null, "beginConvexPolyhedronSelection", 264), N(null, "beginRayDrillSelection", 256), N(null, "beginScreenAreaSelection", 256), N(null, "beginSphereSelection", 256), N(null, "clearLights"), N(null, "createFloorplanMesh", 388), N(null, "cuttingSectionLimits"), N(null, "demandMeshInstances", 132), N(null, "detachInclusions", 258), N(null, "disableCapping"), N(
          null,
          "disconnectNetwork",
          or
        ), N(null, "enableCapping"), N(null, "endComparison"), N(null, "endVolumeSelection"), N(null, "explode"), N(null, "exportToSvg", 256), N(null, "beginExportToSvg", 256), N(null, "advanceExportToSvg", 256), N(null, "flushMetaDataCache", function() {
          et === "$$ss" && (Er = {});
        }), N(null, "getAmbientOcclusionEnabled", 256), N(null, "getAmbientOcclusionRadius", 256), N(null, "getBackFacesVisible", 256), N(null, "getBackgroundGradient", 256), N(null, "getCamera", function(G) {
          return et === "$$ss" ? ms.clone(qa) : Oe.getCamera(G);
        }), N(
          null,
          "getCameraPromise",
          768
        ), N(null, "getCappedInstances", 256), N(null, "getCuttingSections", 258), N(null, "getDefaultDepthRange", 256), N(null, "getElementCount", 256), N(null, "getEyeDomeLightingBlurEdgeDistance", 256), N(null, "getEyeDomeLightingBlurInterval", 256), N(null, "getEyeDomeLightingBlurSamples", 256), N(null, "getEyeDomeLightingEnabled", 256), N(null, "getEyeDomeLightingOpacity", 256), N(null, "getEyeDomeLightingShadingEdgeDistance", 256), N(null, "getFacesVisible", 256), N(null, "getFaceWindingFlipped", 256), N(
          null,
          "getFrontFacesVisible",
          256
        ), N(null, "getInteractiveDrawLimitIncreaseEnabled", 256), N(null, "getLightKeys", 256), N(null, "getLight", 256), N(null, "getLinesVisible", 256), N(null, "getLooseBounding", 256), N(null, "getMetaData", rn), N(null, "getMinFrameRate", 256), N(null, "getNetworkVersion"), N(null, "getPointShape", 256), N(null, "getPointSize", 256), N(null, "getPointSizeUnit", 256), N(null, "getPointsVisible", 256), N(null, "getStatistics", 256), N(null, "getStreamedBounding", 256), N(null, "getStreamVersion"), N(null, "getTriangleCount", 256), N(null, "markAllMeshInstancesInteresting"), N(null, "markCameraAsEmpty"), N(null, "meshInstanceKeyInfo", 257), N(null, "metaDataKeyInfo", 257), N(null, "modelKeysFromInclusionKeys", 258), N(null, "onResize", function(G) {
          var Q = bt.allowHighDpi && window.devicePixelRatio || 1, ht = e.$$legacyClient ? bt.container : bt.containers.get(G), gt = ht.clientWidth, Mt = ht.clientHeight;
          if (ht = gt * Q, Q *= Mt, et === "$$ss") $t.Pk(ht, Q, gt, Mt);
          else {
            var Xt = e.$$es.maxFrameBufferSize();
            0 >= Xt ? (ht = gt, Q = Mt) : ((ht > Xt || Q > Xt) && (ht = gt, Q = Mt), (ht > Xt || Q > Xt) && (ht > Q ? (Q = Q / ht * Xt, ht = Xt) : (ht = ht / Q * Xt, Q = Xt)));
          }
          e.$$cs.setScreenDimensions(
            G,
            ht,
            Q,
            gt,
            Mt
          ), et === "$$cs" && (e.$$legacyClient && (gt = e.canvas, gt.width = ht, gt.height = Q), bt.queueRedraw(G));
        }), N(null, "pauseCapping"), N(null, "primaryModelKey", 256), N(null, "queueRedraw"), N(null, "registerBimInstances", 4), N(null, "removeAllCuttingSections"), N(null, "removeCuttingSections", 258), N(null, "removeDrawContext"), N(null, "removeLight"), N(null, "replaceCuttingSection", 264), N(null, "requestGroups", 260), N(null, "requestImages", 260), N(null, "requestMeshInstances", 260), N(null, "requestMeshInstancesByGroup", 260), N(null, "resetExplode"), N(null, "resetToEmpty", function(G, Q) {
          var ht = c(Q);
          if (!ht) throw new TypeError("`meshKeys' is not an Array or Uint32Array");
          return Oe.resetToEmpty(G, ht, Q.length);
        }), N(null, "resumeCapping"), N(null, "resumeDrawing"), N(null, "screenSelectByRay", 256), N(null, "serverSideRendering", function() {
          return et === "$$ss";
        }), N(null, "setAmbientLightColor"), N(null, "setAmbientOcclusionBias"), N(null, "setAmbientOcclusionBlurInterval"), N(null, "setAmbientOcclusionBlurSamples"), N(null, "setAmbientOcclusionContrast"), N(null, "setAmbientOcclusionEdgeDistance"), N(null, "setAmbientOcclusionEnabled"), N(null, "setAmbientOcclusionIntensity"), N(null, "setAmbientOcclusionNoiseSize"), N(null, "setAmbientOcclusionOpacity"), N(null, "setAmbientOcclusionRadius"), N(null, "setAmbientOcclusionSamples"), N(null, "setAntiAliasingMode"), N(null, "setBackFacesVisible"), N(null, "setBackgroundColor"), N(null, "setBackgroundGradient"), N(null, "setBloomBlurInterval"), N(null, "setBloomBlurSamples"), N(null, "setBloomEnabled"), N(null, "setBloomIntensity"), N(null, "setBloomIntensityScale"), N(
          null,
          "setBloomLayerCount"
        ), N(null, "setBloomThreshold"), N(null, "setBloomThresholdRampWidth"), N(null, "setBoundingPreviewUnderdrawColor"), N(null, "setBoundingPreviewTestedColor"), N(null, "setBoundingPreviewEjectedColor"), N(null, "setBoundingPreviewColor"), N(null, "setBoundingPreviewUnderdraw", 16), N(null, "setBoundingPreviewTested", 16), N(null, "setBoundingPreviewEjected", 16), N(null, "setBoundingDebugLevel"), N(null, "setCamera", function(G, Q) {
          ms.assign(qa, Q), Oe.setCamera(G, Q);
        }), N(null, "setCappingIdleHookEnabled", 256), N(null, "setClumpingEnabled"), N(null, "setComparisonColors"), N(null, "setCurrentView"), N(null, "setDefaultDepthRange"), N(null, "setDefaultGloss"), N(null, "setDefaultMirror"), N(null, "setDefaultSpecularMix"), N(null, "setDefaultSphereMap"), N(null, "setDisplayIncompleteFrames"), N(null, "setDrawIdleDelay"), N(null, "setDrawMode"), N(null, "setDrawStrategy"), N(null, "setEyeDomeLightingBlurEdgeDistance"), N(null, "setEyeDomeLightingBlurInterval"), N(null, "setEyeDomeLightingBlurSamples"), N(null, "setEyeDomeLightingEnabled"), N(null, "setEyeDomeLightingOpacity"), N(null, "setEyeDomeLightingShadingEdgeDistance"), N(null, "setFacesVisible"), N(null, "setFaceWindingFlipped"), N(null, "setFixedDrawLimit"), N(null, "setFrontFacesVisible"), N(null, "setGoochBaseColorProminence"), N(null, "setGoochBlue"), N(null, "setGoochLuminanceShiftStrength"), N(null, "setGoochYellow"), N(null, "setGroundPlane"), N(null, "setGroundPlaneWithPosition"), N(null, "setHardEdgeColor"), N(null, "setHardEdgeOpacity"), N(null, "setHardEdgesEnabled"), N(null, "setHardEdgeThreshold"), N(null, "setHardEdgeThresholdRampWidth"), N(null, "setHiddenLineHiddenLineColor"), N(null, "setHiddenLineHighlightedElementFillColor"), N(null, "setHiddenLineHighlightedElementOutlineColor"), N(null, "setHiddenLineHighlightedInstanceFillColor"), N(null, "setHiddenLineHighlightedInstanceOutlineColor"), N(null, "setHiddenLineVisibleLineColor"), N(null, "setHighlightColorizeCompression"), N(null, "setHighlightedElementColor"), N(null, "setHighlightedElementFilter"), N(null, "setHighlightedElementOutlineColor"), N(null, "setHighlightedInstanceColor"), N(null, "setHighlightedInstanceFilter"), N(null, "setHighlightedInstanceOutlineColor"), N(null, "setHighlightMode"), N(null, "setImageBasedLightingEnabled"), N(null, "setImageBasedLightingEnvironment", function(G, Q) {
          var ht = d(Q);
          if (!ht) throw new TypeError("`data' is not an Array or Uint8Array");
          return e[et].setImageBasedLightingEnvironment(G, ht, Q.length);
        }), N(null, "setImageBasedLightingEnvironmentToDefault"), N(null, "setImageBasedLightingIntensity"), N(null, "setImageBasedLightingMatrix"), N(null, "setInstancingEnabled"), N(null, "setInteractiveDrawLimitIncreaseEnabled"), N(null, "setInteractiveDrawLimitIncreaseInterval"), N(null, "setLightingEnabled"), N(null, "setLineJitterEnabled"), N(null, "setLineJitterFrequency"), N(null, "setLineJitterInstanceCount"), N(null, "setLineJitterRadius"), N(null, "setLinesVisible"), N(null, "setMeshLevel"), N(null, "setMetallicRoughnessMaterialOverride"), N(null, "setMinDrawLimit"), N(null, "setMinFrameRate"), N(null, "setMinIncrementalFrameRate"), N(null, "setMinInteractiveFrameRate"), N(null, "setPointShape"), N(null, "setPointSize"), N(null, "setPointsVisible"), N(null, "setPointVisibilityTest", 16), N(null, "setPostInputDelay"), N(null, "setSilhouetteColor"), N(null, "setSilhouetteEnabled"), N(null, "setSilhouetteOpacity"), N(null, "setSilhouetteThreshold"), N(null, "setSilhouetteThresholdRampWidth"), N(null, "setSimpleReflectionAttenuation"), N(null, "setSimpleReflectionBlurInterval"), N(null, "setSimpleReflectionBlurSamples"), N(null, "setSimpleReflectionEnabled"), N(null, "setSimpleReflectionFadeAngle"), N(null, "setSimpleReflectionOpacity"), N(null, "setSimpleShadowBlurInterval"), N(null, "setSimpleShadowBlurSamples"), N(null, "setSimpleShadowColor"), N(null, "setSimpleShadowEnabled"), N(null, "setSimpleShadowInteractiveUpdateEnabled"), N(null, "setSimpleShadowOpacity"), N(null, "setSimpleShadowResolution"), N(null, "setSmaaQuality"), N(null, "setSsrQuality", function(G) {
          $t.Vk(G);
        }), N(null, "setStreamCutoffScale"), N(null, "setStreamIdleMarker", 256), N(null, "setToonBandCount"), N(null, "setToonSpecularFactor"), N(null, "setTransparencyMode"), N(null, "setUnhighlightedColor"), N(null, "setUnhighlightedFilter"), N(null, "setVisibilityByAttachment"), N(null, "setXRayMaterial"), N(null, "setXRayOpacity"), N(null, "setXRayTransparencyMode"), N(null, "startComparison", function(G, Q, ht) {
          kr(Q), kr(ht);
          var gt = c(Q);
          if (!gt) throw new TypeError("`instanceSet1' is not an Array or Uint32Array.");
          var Mt = c(ht);
          if (!Mt) throw new TypeError("`instanceSet2' is not an Array or Uint32Array.");
          return e[et].startComparison(G, gt, Q.length >> 1, Mt, ht.length >> 1);
        }), N(null, "startExplode", 4), N(null, "suspendDrawing"), N(
          null,
          "testPointVisibility",
          272
        ), N(null, "throttleLoad"), N(null, "triangulatePolygon", function(G, Q) {
          if (3 > G.length) throw new TypeError("'polygonPoints' does not describe a polygon.");
          var ht;
          if (G) if (ht = e.$$es.allocateUint8Buffer(4 * G.length)) at.set(G, ht >> 2);
          else throw Error("Out of memory.");
          else ht = 0;
          if (!ht) throw Error("Internal logic error.");
          return e.$$es.triangulatePolygon(ht, G.length, Q);
        }), N(null, "truncateMetaData", function(G) {
          if (et === "$$cs") return Oe.truncateMetaData(G);
          for (var Q = 0; Q < G.length; Q += 2) {
            var ht = G[Q + 1], gt = Er[G[Q]];
            gt && (gt[ht] = ou);
          }
        }), N(null, "unsetAllColors"), N(null, "unsetAllHighlighted"), N(null, "unsetAllOpacity"), N(null, "unsetAllXRay"), N(null, "unsetCurrentView"), N(null, "unsetXRayMaterial"), N(null, "updateLight"), N(null, "waitForImageDecoding", 256), N(null, "worldSelectByRay", 256), N(null, "_loseWebGlContext", function() {
          var G = e.Wi.getExtension("WEBGL_lose_context");
          return G !== null ? (G.loseContext(), !0) : !1;
        }), N(Oe, "getCamera", 512), N(Oe, "getMetaData", 260), N(Oe, "MeshData_getData", 256), N(Oe, "MeshInstance_setLinePattern", 132), N(
          Oe,
          "requestMetaData",
          260
        ), N(Oe, "resetToEmpty", 258), N(Oe, "setCamera", 32), N(Oe, "truncateMetaData", 260), N(null, "Debug_log", function(G) {
          G = unescape(encodeURIComponent(G));
          for (var Q = [], ht = 0; ht < G.length; ++ht) Q.push(G.charCodeAt(ht));
          Q.push(0);
          var gt = d(Q);
          if (!gt) throw Error("Internal logic error.");
          return new Promise(function(Mt, Xt) {
            e[et].debug_log(gt, Q.length, Mt, Xt);
          });
        }), N(null, "Debug_stateFailure", 256), N(null, "Debug_sync", 256), bt.Image = {}, N("Image", "create", function(G, Q, ht, gt, Mt, Xt, Ye, Ie, Ke, Jn) {
          var Un = d(Q);
          if (!Un) throw Error("Internal logic error.");
          var jn = d(Ye);
          return new Promise(function(rs, _s) {
            e[et].Image_create(Un, Q.length, jn, Ye ? Ye.length : 0, G, ht, gt || 0, Mt || 0, Xt || 0, Ie || !1, Ke || 0, Jn || 0, rs, De("Image_create", _s));
          });
        }), N("Image", "destroy", 260), bt.Matrix = {}, N("Matrix", "create", 256), N("Matrix", "destroy", 260), N("Matrix", "getElements", 260), N("Matrix", "setElements", 260), bt.MeshData = {}, N("MeshData", "create", function(G) {
          return new Promise(function(Q, ht) {
            var gt = G._marshal();
            e[et].MeshData_create(
              gt.bits,
              gt.totalFaceVertices,
              gt.totalLineVertices,
              gt.totalPointVertices,
              gt.floatDataPtr,
              gt.floatDataPtrLen,
              gt.faceElementInfosPtr,
              Ue * G._faceElements.length,
              gt.lineElementInfosPtr,
              Ue * G._lineElements.length,
              gt.pointElementInfosPtr,
              Ue * G._pointElements.length,
              Q,
              De("MeshData_create", ht)
            );
          });
        }), N("MeshData", "destroy", 260), N("MeshData", "getData", function(G) {
          return Oe.MeshData_getData(G).then(Ga);
        }), N("MeshData", "lineElementSegments", 256), N("MeshData", "linesToIncidentFaces", 258), N("MeshData", "replace", function(G, Q) {
          return new Promise(function(ht, gt) {
            var Mt = Q._marshal();
            e[et].MeshData_replace(
              G[0],
              G[1],
              Mt.bits,
              Mt.totalFaceVertices,
              Mt.totalLineVertices,
              Mt.totalPointVertices,
              Mt.floatDataPtr,
              Mt.floatDataPtrLen,
              Mt.faceElementInfosPtr,
              Ue * Q._faceElements.length,
              Mt.lineElementInfosPtr,
              Ue * Q._lineElements.length,
              Mt.pointElementInfosPtr,
              Ue * Q._pointElements.length,
              ht,
              De("MeshData_replace", gt)
            );
          });
        }), bt.MeshInstance = {}, N("MeshInstance", "clearAllElementHighlight", 132), N("MeshInstance", "clearAllElementVisible", 132), N("MeshInstance", "clearAllElementXRay", 132), N("MeshInstance", "clearElementColors", 132), N(
          "MeshInstance",
          "clearElementHighlight",
          132
        ), N("MeshInstance", "clearElementVisible", 132), N("MeshInstance", "clearElementXRay", 132), N("MeshInstance", "computeMinimalBodyBodyDistance", 256), N("MeshInstance", "computeMinimalFaceFaceDistance", 256), N("MeshInstance", "computeMinimalFaceLineDistance", 256), N("MeshInstance", "computeMinimalFaceRayDistance", 256), N("MeshInstance", "create", 256), N("MeshInstance", "destroy", 388), N("MeshInstance", "discardAnonymousMatrix", 388), N("MeshInstance", "getAlwaysDraw", 388), N(
          "MeshInstance",
          "getCappingMeshData",
          388
        ), N("MeshInstance", "getColor", 2436), N("MeshInstance", "getCullingVector", 388), N("MeshInstance", "getDoNotCut", 388), N("MeshInstance", "getDoNotExplode", 388), N("MeshInstance", "getDoNotLight", 388), N("MeshInstance", "getDoNotOutlineHighlight", 388), N("MeshInstance", "getDoNotSelect", 388), N("MeshInstance", "getDoNotUseVertexColors", 388), N("MeshInstance", "getDrawnWorldSpaceBounding", 260), N("MeshInstance", "getEffectiveColor", 388), N("MeshInstance", "getEffectiveElementColor", 388), N(
          "MeshInstance",
          "getEffectiveOpacity",
          388
        ), N("MeshInstance", "getElementColor", 2436), N("MeshInstance", "getElementHighlighted", 388), N("MeshInstance", "getElementVisible", 388), N("MeshInstance", "getElementXRay", 388), N("MeshInstance", "getExcludeBounding", 388), N("MeshInstance", "getFaceElementBounding", 258), N("MeshInstance", "getFacesVisible", 388), N("MeshInstance", "getHighlighted", 388), N("MeshInstance", "getLayerCount"), N("MeshInstance", "getLineElementBounding", 258), N("MeshInstance", "getLinesVisible", 388), N("MeshInstance", "getMatrix", 388), N(
          "MeshInstance",
          "getMeshData",
          388
        ), N("MeshInstance", "getMetallicRoughness", 388), N("MeshInstance", "getObjectSpaceBounding", 388), N("MeshInstance", "getOpacity", 1412), N("MeshInstance", "getOverrideSceneVisibility", 388), N("MeshInstance", "getPointElementBounding", 258), N("MeshInstance", "getPointsVisible", 388), N("MeshInstance", "getScreenOriented", 388), N("MeshInstance", "getSuppressCameraScale", 388), N("MeshInstance", "getWorldSpaceBounding", 260), N("MeshInstance", "hasDepthRange", 388), N("MeshInstance", "hasTransparency", 388), N(
          "MeshInstance",
          "linesToIncidentFaces",
          258
        ), N("MeshInstance", "matrixPreMultiply", 388), N("MeshInstance", "reifyAnonymousMatrix", 388), N("MeshInstance", "setAlwaysDraw", 132), N("MeshInstance", "setAmbientMix", 132), N("MeshInstance", "setAnonymousMatrix", 388), N("MeshInstance", "setAnonymousMatrices", function(G, Q) {
          var ht = 0, gt = 0;
          if (G.constructor !== Array && G.constructor !== Uint32Array) throw new TypeError("Incs Buffer is not an Array or Uint32Array.");
          if (Q.constructor !== Array && Q.constructor !== Float64Array) throw new TypeError("Matrices Buffer is not an Array or Float64Array.");
          if (ht = c(G), !ht || (gt = a(Q), !gt)) throw p(ht), p(gt), Error("Internal logic error.");
          return new Promise(function(Mt, Xt) {
            e[et].MeshInstance_setAnonymousMatrices(ht, G.length >> 1, gt, Q.length, Mt, De("MeshInstance_setAnonymousMatrices", Xt), 0);
          });
        }), N("MeshInstance", "setColor", 132), N("MeshInstance", "setCullingVector", 132), N("MeshInstance", "setDepthRange", 132), N("MeshInstance", "setDoNotCut", 132), N("MeshInstance", "setDoNotExplode", 132), N("MeshInstance", "setDoNotLight", 132), N(
          "MeshInstance",
          "setDoNotOutlineHighlight",
          132
        ), N("MeshInstance", "setDoNotSelect", 132), N("MeshInstance", "setDoNotReset", 132), N("MeshInstance", "setDoNotUseVertexColors", 132), N("MeshInstance", "setDoNotXRay", 132), N("MeshInstance", "setElementColor", 132), N("MeshInstance", "setElementHighlighted", 132), N("MeshInstance", "setElementVisible", 132), N("MeshInstance", "setElementXRay", 132), N("MeshInstance", "setExcludeBounding", 132), N("MeshInstance", "setFacesVisible", 132), N("MeshInstance", "setHighlighted", 132), N(
          "MeshInstance",
          "setLinePattern",
          function(G, Q, ht, gt) {
            var Mt = d(Q);
            if (!Mt) throw new TypeError("`pattern' is not an Array or Uint8Array");
            return Oe.MeshInstance_setLinePattern(G, Mt, Q.length, ht, gt);
          }
        ), N("MeshInstance", "setLinesVisible", 132), N("MeshInstance", "setMatrix", 388), N("MeshInstance", "setMeshLevel", 132), N("MeshInstance", "setMetallicRoughness", 132), N("MeshInstance", "unsetMetallicRoughness", 132), N("MeshInstance", "setOpacity", 132), N("MeshInstance", "setOverlayId", 132), N("MeshInstance", "setOverrideSceneVisibility", 132), N(
          "MeshInstance",
          "setPointsVisible",
          132
        ), N("MeshInstance", "setScreenOriented", 132), N("MeshInstance", "setScreenSpace", 132), N("MeshInstance", "setScreenSpaceStretched", 132), N("MeshInstance", "setStreamCutoffScale", 132), N("MeshInstance", "setSuppressCameraScale", 132), N("MeshInstance", "setTexture", 388), N("MeshInstance", "setVisible", 132), N("MeshInstance", "setXRay", 132), N("MeshInstance", "synchronizeVisibilities", 4), N("MeshInstance", "unsetColor", 132), N("MeshInstance", "unsetCullingVector", 132), N("MeshInstance", "unsetDepthRange", 132), N(
          "MeshInstance",
          "unsetElementColor",
          132
        ), N("MeshInstance", "unsetLinePattern", 132), N("MeshInstance", "unsetMatrix", 388), N("MeshInstance", "unsetOpacity", 132), N("MeshInstance", "unsetTexture", 132), N("MeshInstance", "setSpecularIntensity", 132), N("MeshInstance", "unsetSpecularIntensity", 132), bt.Overlay = {}, N("Overlay", "destroy"), N("Overlay", "maxIndex"), N("Overlay", "setCamera", 32), N("Overlay", "setViewport"), N("Overlay", "setVisible");
        var Ql = { open_model_failed: or, session_started: function() {
          et === "$$cs" && (e.canvas.addEventListener(
            "webglcontextlost",
            ct,
            !1
          ), bt.onResize(0));
        }, post_draw_json: function(G, Q) {
          try {
            var ht = JSON.parse(Q);
          } catch (gt) {
            console.assert(!1, "malformed JSON from post_draw", gt);
            return;
          }
          e.ki("post_draw", ht.draw_index, ht.stats, ia(ht.camera), ht.visiblePoints), ht.quality === "high" && (e.ki("draw_complete"), e.ki("draw_idle"));
        } }, Ii = { session_started: function() {
          et === "$$ss" && (bt.resumeDrawing(0), e[et].Debug_notifyLoggedRpcExecutionIsAllowed());
        } }, fe = {};
        e.ki = function(G) {
          if (G in Ql) {
            var Q = Ql[G];
            Q.apply(this, arguments);
          }
          var ht = fe[G];
          try {
            if (ht !== void 0) for (var gt = 0; gt < ht.length; gt++) Q = ht[gt], typeof Q == "function" && Q.apply(this, arguments);
          } catch (Mt) {
            console.log("Unhandled exception in " + G + " event handler:"), console.log(Mt);
          }
          G in Ii && (Q = Ii[G], Q.apply(this, arguments));
        }, bt.setEventHandler = function(G, Q) {
          fe.hasOwnProperty(G) || (fe[G] = []), fe[G].push(Q);
        }, bt.unsetEventHandler = function(G, Q) {
          if (G = fe[G], G !== void 0) for (var ht = 0; ht < G.length; ) G[ht] === Q ? G.splice(ht, 1) : ++ht;
        }, ke.prototype = Object.create(Error.prototype), ke.prototype.constructor = ke;
        var Kt = { Uninitialized: 0, Network: 1, Scs: 2 };
        bt.SessionType = Kt;
        var Hn = Kt.Uninitialized;
        bt.load = function(G) {
          if (Ut(), Me && bt.callRecord.push("load " + ut(G)), !G) throw new ke("InvalidConfig", "Invalid load configuration");
          var Q = G.uri;
          if (!!Q + !!G.buffer + !!G.empty != 1) throw new ke("InvalidConfig", "Must specify exactly one of 'uri', 'buffer', or 'empty'.");
          if (Q) {
            {
              if (typeof Q != "string") throw new ke("InvalidConfig", "'uri' must be a string");
              const [Ye, Ie, Ke] = Q.split("://");
              if (Ie) {
                if (Ke) throw new ke("InvalidConfig", "Invalid URI");
                var ht = Ye;
              } else ht = "http";
            }
            if (ht === "ws" || ht === "wss") {
              if (ie(), !G) throw new ke(
                "InvalidConfig",
                "Invalid load configuration"
              );
              if (G.model && typeof G.model == "string" || (G.model = ""), ht = G.sessionToken, ht === void 0 && (ht = ""), typeof ht != "string") throw new ke("InvalidConfig", "'sessionToken' must be a string");
              var gt = G.limitMiB;
              if (gt === void 0 && (gt = 0), typeof gt != "number") throw new ke("InvalidConfig", "'limitMiB' must be a number");
              var Mt = G.meshLevel;
              if (Mt === void 0 && (Mt = 0), typeof Mt != "number") throw new ke("InvalidConfig", "'meshLevel' must be a number");
              var Xt = G.streamCutoffScale;
              if (Xt === void 0 && (Xt = -1), typeof Xt != "number") throw new ke(
                "InvalidConfig",
                "'streamCutoffScale' must be a number"
              );
              if (Hn !== Kt.Uninitialized) throw new ke("AlreadyCalled", "load() already called for a non-streaming session");
              Hn = Kt.Network, G.serverSideRendering ? (et = "$$ss", e.$$legacyClient ? $t.gj(e.$$wrapper) : $t.gj(bt.wrappers.get(0)), bt.onResize(0), $t.Tk(zn), $t.Uk(Xn), $t.Sk(ps), $t.Rk(e.ki), $t.connect(G)) : (et = "$$cs", Di(e.$$es.loadNetwork(
                Q,
                unescape(encodeURIComponent(G.model)),
                unescape(encodeURIComponent(ht)),
                !!G.streamCulled,
                !!G.streamMetaDataOnIdle,
                !!G.streamNoLimit,
                !!G.streamInstancesOnDemand,
                !!G.streamAggressiveCompression,
                !!G.streamModelBoundingPreviews,
                !!G.streamInstanceBoundingPreviews,
                !!G.streamOnlyInterestingBoundingPreviews,
                !!G.streamEjectedBoundingPreviews,
                gt,
                Mt,
                Xt
              )));
            } else ht !== "http" && ht !== "https" || Bt(G, Q);
          } else G.buffer ? Dt(G, G.buffer) : (G = !!G.streamInstancesOnDemand, ie([Kt.Scs]), Hn = Kt.Scs, G = e.$$es.loadEmptyScs(G), Di(G));
          return Hn;
        }, bt.attachScsBuffer = function(G, Q, ht, gt, Mt, Xt, Ye, Ie) {
          return G = {
            attachScope: G,
            inclusionMatrix: ht,
            attachMeasurementUnit: gt,
            attachInvisibly: Mt,
            resolveOnFullyLoaded: Xt,
            cancelUnitMatrix: Ye,
            autoUnitScale: Ie
          }, Q === null || Q.length === 0 ? je(G, 0, 0) : Dt(G, Q);
        }, bt.feedScsBuffer = function(G, Q) {
          if (ie([Kt.Scs]), G === 0) throw new ke("InvalidConfig", "'attachScope' should not be 0");
          var ht = 0, gt = 0;
          if (Q !== null) {
            if (Q.constructor !== Uint8Array) throw new ke("InvalidConfig", "'buffer' must be a Uint8Array");
            if (0 >= Q.byteLength) throw new ke("EmptyBuffer", "'buffer' has a length of 0");
            ht = Q.byteLength, gt = e.$$es.allocateUint8Buffer(Q.byteLength), $.set(Q, gt);
          }
          e.$$es.feedScsBuffer(G, gt, ht);
        };
      }();
      var Ue = 3, Li = 4 * Ue;
      bt.MeshDataBuilder = function() {
        this._faceElements = [], this._lineElements = [], this._pointElements = [], this.formatBits = 0;
      }, bt.MeshDataBuilder.FormatBits = { ClockwiseWinding: 1, CounterClockwiseWinding: 2, TwoSided: 4, Manifold: 65536 }, bt.MeshDataBuilder.prototype = { constructor: bt.MeshDataBuilder, _getOptional: function(Bt, Dt) {
        return Bt === void 0 ? null : Bt[Dt] ? Bt[Dt] : null;
      }, _optionalGuard: function(Bt, Dt, je) {
        if (je) {
          if ((je = this[je][0]) && !je[Bt]) throw Error("Cannot define " + Dt + " for some but not all vertices.");
        } else this._optionalGuard(Bt, Dt, "_faceElements"), this._optionalGuard(Bt, Dt, "_lineElements"), this._optionalGuard(Bt, Dt, "_pointElements");
      }, addFace: function(Bt, Dt) {
        var je = this._faceElements, ie = this._getOptional(Dt, "normals"), Di = this._getOptional(Dt, "uvs"), ke = this._getOptional(Dt, "rgba32s");
        if (Dt = this._getOptional(Dt, "bits") || 0, Bt.length % 9 !== 0) throw Error("Illegal triangles: 'vertexData.length' must be divisible by 9 (i.e. 3 numbers per vertex and 3 vertices per triangle).");
        if (ie) {
          if (ie.length !== Bt.length) throw Error("Cannot define normals for some but not all vertices.");
          this._optionalGuard("normals", "normals", "_faceElements");
        }
        if (Di) {
          if (3 * Di.length !== 2 * Bt.length) throw Error("Cannot define UV parameters for some but not all vertices.");
          this._optionalGuard("uvs", "UV parameters", "_faceElements");
        }
        if (ke) {
          if (3 * ke.length !== 4 * Bt.length) throw Error("Cannot define RGBA32s for some but not all vertices.");
          if (this._optionalGuard("rgba32s", "RGBA32s"), (this.formatBits & 32768) == 0) {
            for (var zn = 3; zn < ke.length; zn += 4) if (ke[zn] != 255) {
              this.formatBits |= 32768;
              break;
            }
          }
        }
        je.push({
          vertexData: Bt,
          normals: ie,
          uvs: Di,
          rgba32s: ke,
          bits: Dt
        });
      }, addPolyline: function(Bt, Dt) {
        var je = this._lineElements, ie = this._getOptional(Dt, "rgba32s");
        if (Dt = this._getOptional(Dt, "bits") || 0, Bt.length % 3 !== 0) throw Error("vertexData array must be divisible by 3 (i.e. 3 numbers per vertex).");
        if (6 > Bt.length && 0 < Bt.length) throw Error("Illegal polyline: '0 < vertexData.length < 6'.");
        if (ie) {
          if (3 * ie.length !== 4 * Bt.length) throw Error("Cannot define RGBA32s for some but not all vertices.");
          this._optionalGuard("rgba32s", "RGBA32s");
        }
        je.push({
          vertexData: Bt,
          rgba32s: ie,
          bits: Dt
        });
      }, addPoints: function(Bt, Dt) {
        var je = this._pointElements, ie = this._getOptional(Dt, "rgba32s");
        if (Dt = this._getOptional(Dt, "bits") || 0, Bt.length % 3 !== 0) throw Error("vertexData array must be divisible by 3 (i.e. 3 numbers per vertex).");
        if (ie) {
          if (3 * ie.length !== 4 * Bt.length) throw Error("Cannot define RGBA32s for some but not all vertices.");
          this._optionalGuard("rgba32s", "RGBA32s");
        }
        je.push({ vertexData: Bt, rgba32s: ie, bits: Dt });
      }, _marshal: function() {
        var Bt = this._faceElements, Dt = this._lineElements, je = this._pointElements, ie = !1, Di = !1, ke = !1, zn = !1, Xn = !1, ps = !1, ia = !1, Ga = !1, $a = !1, rn = Bt[0], or = Dt[0], N = je[0];
        rn && (ie = !!rn.normals, Di = !!rn.uvs, ke = !!rn.rgba32s), or && (zn = !!or.normals, Xn = !!or.uvs, ps = !!or.rgba32s), N && (ia = !!N.normals, Ga = !!N.uvs, $a = !!N.rgba32s);
        var Zr = 3;
        rn = this.formatBits, (or = ie || zn || ia) && (Zr += 3, rn |= 4096, ie && (rn |= 8), zn && (rn |= 64), ia && (rn |= 512)), (N = Di || Xn || Ga) && (Zr += 2, rn |= 8192, Di && (rn |= 16), Xn && (rn |= 128), Ga && (rn |= 1024));
        var na = ke || ps || $a;
        na && (Zr += 1, rn |= 16384, ke && (rn |= 32), ps && (rn |= 256), $a && (rn |= 2048));
        for (var sa = 0, De = 0; De < Bt.length; ++De) {
          var we = Bt[De];
          sa += we.vertexData.length;
        }
        sa /= 3;
        var kr = 0, ms = 0;
        for (De = 0; De < Dt.length; ++De) {
          we = Dt[De];
          var Oe = we.vertexData;
          Oe.length && (kr += Oe.length, ++ms);
        }
        for (kr = 2 * (kr / 3 - ms), De = ms = 0; De < je.length; ++De) we = je[De], ms += we.vertexData.length;
        ms /= 3, Zr *= sa + kr + ms, De = e.$$es.allocateUint8Buffer;
        var Er = De(4 * Zr), ou = Bt.length ? De(Li * Bt.length) : 0, qa = Dt.length ? De(Li * Dt.length) : 0, Ql = je.length ? De(Li * je.length) : 0, Ii = $.subarray(Er), fe = at.subarray(Er >> 2), Kt = 0, Hn = 0;
        for (De = 0; De < Bt.length; ++De) {
          we = Bt[De], Oe = we.vertexData;
          var G = we.normals, Q = we.uvs, ht = we.rgba32s, gt = Oe.length / 3, Mt = it.subarray((ou >> 2) + Ue * De);
          Mt[0] = Hn, Mt[1] = gt, Mt[2] = we.bits, Hn += gt;
          var Xt = 0;
          for (gt = we = 0; gt < Oe.length; gt += 3) fe[Kt] = Oe[gt], fe[Kt + 1] = Oe[gt + 1], fe[Kt + 2] = Oe[gt + 2], Kt += 3, or && (ie ? (fe[Kt] = G[gt], fe[Kt + 1] = G[gt + 1], fe[Kt + 2] = G[gt + 2]) : (fe[Kt] = 0, fe[Kt + 1] = 0, fe[Kt + 2] = 0), Kt += 3), N && (Di ? (fe[Kt] = Q[Xt], fe[Kt + 1] = Q[Xt + 1], Xt += 2) : (fe[Kt] = 0, fe[Kt + 1] = 0), Kt += 2), na && (Mt = Kt << 2, ke ? (Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++]) : (Ii[Mt++] = 0, Ii[Mt++] = 0, Ii[Mt++] = 0, Ii[Mt++] = 0), ++Kt);
        }
        for (De = Hn = 0; De < Dt.length; ++De) for (we = Dt[De], Oe = we.vertexData, G = we.normals, Q = we.uvs, ht = we.rgba32s, gt = Oe.length / 3, 0 < gt && (gt = 2 * gt - 2), Mt = it.subarray((qa >> 2) + Ue * De), Mt[0] = Hn, Mt[1] = gt, Mt[2] = we.bits, Hn += gt, we = 4, gt = 3; gt < Oe.length; gt += 3) for (we -= 4, Bt = -3; 0 >= Bt; Bt += 3) ie = gt + Bt, fe[Kt] = Oe[ie], fe[Kt + 1] = Oe[ie + 1], fe[Kt + 2] = Oe[ie + 2], Kt += 3, or && (zn ? (fe[Kt] = G[ie], fe[Kt + 1] = G[ie + 1], fe[Kt + 2] = G[ie + 2]) : (fe[Kt] = 0, fe[Kt + 1] = 0, fe[Kt + 2] = 0), Kt += 3), N && (Xn ? (ie = ie / 3 * 2, fe[Kt] = Q[ie], fe[Kt + 1] = Q[ie + 1]) : (fe[Kt] = 0, fe[Kt + 1] = 0), Kt += 2), na && (Mt = Kt << 2, ps ? (Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++]) : (Ii[Mt++] = 0, Ii[Mt++] = 0, Ii[Mt++] = 0, Ii[Mt++] = 0), ++Kt);
        for (De = Hn = 0; De < je.length; ++De) for (we = je[De], Oe = we.vertexData, G = we.normals, Q = we.uvs, ht = we.rgba32s, gt = Oe.length / 3, Mt = it.subarray((Ql >> 2) + Ue * De), Mt[0] = Hn, Mt[1] = gt, Mt[2] = we.bits, Hn += gt, gt = we = Xt = 0; gt < Oe.length; gt += 3) fe[Kt] = Oe[gt], fe[Kt + 1] = Oe[gt + 1], fe[Kt + 2] = Oe[gt + 2], Kt += 3, or && (ia ? (fe[Kt] = G[gt], fe[Kt + 1] = G[gt + 1], fe[Kt + 2] = G[gt + 2]) : (fe[Kt] = 0, fe[Kt + 1] = 0, fe[Kt + 2] = 0), Kt += 3), N && (Ga ? (fe[Kt] = Q[Xt], fe[Kt + 1] = Q[Xt + 1], Xt += 2) : (fe[Kt] = 0, fe[Kt + 1] = 0), Kt += 2), na && (Mt = Kt << 2, $a ? (Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++], Ii[Mt++] = ht[we++]) : (Ii[Mt++] = 0, Ii[Mt++] = 0, Ii[Mt++] = 0, Ii[Mt++] = 0), ++Kt);
        return {
          totalFaceVertices: sa,
          totalLineVertices: kr,
          totalPointVertices: ms,
          faceElementInfosPtr: ou,
          lineElementInfosPtr: qa,
          pointElementInfosPtr: Ql,
          floatDataPtr: Er,
          floatDataPtrLen: Zr,
          bits: rn
        };
      } };
    }, e.Oj = function() {
      var a = { Tj: null, aj: null, connection: null, jj: null, mj: null, fj: null, ej: null, dj: 1280, cj: 800, lj: 1280, kj: 800, Vi: 1, hk: { command: "SERVER_SETTINGS" }, gj: function(d) {
        this.Tj = d, c.gj();
      }, Xk: function() {
        this.ak = !0, delete this.jj, delete this.mj, delete this.fj, delete this.ej, this.connection && this.connection.close();
      }, pk: function(d) {
        a.aj !== d && (a.aj && (a.aj.style.display = "none"), a.aj = d, a.aj.style.display = "");
      }, connected: function() {
        return a.connection && a.connection.readyState === WebSocket.OPEN;
      }, Ij: function() {
        a.connected() && a.connection.send(JSON.stringify({ command: "SERVER_SIDE_CLIENT_INFO", width: a.dj * a.Vi, height: a.cj * a.Vi, layoutWidth: a.lj, layoutHeight: a.kj, encoding: "jpeg" }));
      }, Pk: function(d, p, w, k) {
        0 >= d || 0 >= p || 0 >= w || 0 >= k || a.dj === d && a.cj === p && a.lj === w && a.kj === k || (a.dj = d, a.cj = p, a.lj = w, a.kj = k, a.connected() && (a.Hj !== void 0 && window.clearTimeout(a.Hj), a.Hj = setTimeout(function() {
          a.ak || (a.Hj = void 0, a.Ij());
        }, 500)));
      }, Ok: function(d) {
        a.connected() && a.connection.send(d);
      }, Tk: function(d) {
        a.jj = d;
      }, Uk: function(d) {
        a.mj = d;
      }, Sk: function(d) {
        a.fj = d;
      }, Rk: function(d) {
        a.ej = d;
      }, Jk: function(d) {
        a.fj && a.fj(d);
      }, Vk: function(d) {
        var p = { command: "SERVER_SETTINGS" }, w;
        for (w in d) if (d.hasOwnProperty(w)) {
          if (w === "scaleHigh") {
            var k = d[w];
            if (typeof k != "number") continue;
            k = Math.min(1, k), 0 >= k && (k = 1), a.Vi !== k && (a.Vi = k, a.Ij());
          }
          w !== "jpegQualityHigh" && w !== "jpegQualityLow" && w !== "jpegChromaSamplesHigh" && w !== "jpegChromaSamplesLow" && w !== "scaleLow" || typeof d[w] != "number" || (p[w] = a.hk[w] = d[w]);
        }
        a.connected() && a.connection.send(JSON.stringify(p));
      }, connect: function(d) {
        var p = e.$$es.getNetworkVersion();
        a.connection = new WebSocket(d.uri, ["binary"]), a.connection.binaryType = "arraybuffer";
        var w = !1;
        a.connection.onclose = function() {
          e.ki("websocket_connection_closed");
        }, a.connection.onopen = function() {
          w = !0, a.connection.send(JSON.stringify({
            command: "SERVER_SIDE_RENDER",
            width: a.dj * a.Vi,
            height: a.cj * a.Vi,
            layoutWidth: a.lj,
            layoutHeight: a.kj,
            model: d.model,
            networkVersion: p,
            streamCulled: !!d.streamCulled,
            streamKeyedDataOnIdle: !!d.streamMetaDataOnIdle,
            streamNoLimit: !!d.streamNoLimit,
            streamInstancesOnDemand: !!d.streamInstancesOnDemand,
            streamBoundingPreviews: !!d.streamBoundingPreviews,
            streamModelBoundingPreviews: !!d.streamModelBoundingPreviews,
            streamInstanceBoundingPreviews: !!d.streamInstanceBoundingPreviews,
            streamOnlyInterestingBoundingPreviews: !!d.streamOnlyInterestingBoundingPreviews,
            streamEjectedBoundingPreviews: !!d.streamEjectedBoundingPreviews,
            limitMiB: d.limitMiB,
            meshLevel: d.meshLevel,
            streamCutoffScale: d.streamCutoffScale,
            sessionToken: d.sessionToken
          })), a.Ij(), a.connection.send(JSON.stringify(a.hk));
        }, a.connection.onerror = function() {
          a.ej && a.ej(w ? "socket_error" : "socket_open_failed");
        }, a.connection.onmessage = function(k) {
          if (!a.ak && k.data instanceof ArrayBuffer) {
            var L = new Uint8Array(k.data);
            if (k = L[0], k === 123) a.jj && a.jj(L);
            else if (k === 68) a.mj && a.mj(L.subarray(1));
            else {
              a.connection.send('{"command":"ACK"}');
              var z = [L[1], L[2]], Z = L[4] << 24 | L[5] << 16 | L[6] << 8 | L[7], ct = new Uint8Array(L.subarray(8, 8 + Z));
              L = L.subarray(8 + Z), k === 0 && c.zk(L, z, ct);
            }
          }
        };
      } }, c = { canvas: null, Rj: null, gj: function() {
      }, createElement: function() {
        this.canvas || (this.canvas = document.createElement("canvas"), this.canvas.setAttribute("style", "display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;"), this.Rj = this.canvas.getContext("2d"), a.Tj.appendChild(this.canvas));
      }, drawImage: function(d, p) {
        var w = d.width - p[0];
        p = d.height - p[1], this.canvas.width !== w && (this.canvas.width = w), this.canvas.height !== p && (this.canvas.height = p), this.Rj.drawImage(d, 0, 0);
      }, sk: function(d, p, w) {
        var k = document.createElement("img");
        return this.Hk = k, k.onload = function() {
          k === c.Hk && (c.drawImage(k, p), a.pk(c.canvas), a.Jk(w)), URL.revokeObjectURL(d);
        }, k.onerror = function() {
          URL.revokeObjectURL(d);
        }, k.src = d, k;
      }, zk: function(d, p, w) {
        12 >= d.byteLength || (this.createElement(), this.sk(URL.createObjectURL(new Blob([d], { type: "image/jpeg" })), p, w));
      } };
      return a;
    };
    var r = Object.assign({}, e), o = "./this.program", l = (a, c) => {
      throw c;
    }, h = typeof window == "object", u = typeof importScripts == "function", f = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", g = "", y, _, x;
    if (f) {
      g = u ? {}.dirname(g) + "/" : __dirname + "/";
      var b, I;
      typeof require == "function" && (b = {}, I = {}), y = (a, c) => (a = I.normalize(a), b.readFileSync(a, c ? void 0 : "utf8")), x = (a) => (a = y(a, !0), a.buffer || (a = new Uint8Array(a)), a), _ = (a, c, d) => {
        a = I.normalize(a), b.readFile(a, function(p, w) {
          p ? d(p) : c(w.buffer);
        });
      }, 1 < process.argv.length && (o = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(a) {
        if (!(a instanceof xt)) throw a;
      }), process.on("unhandledRejection", function(a) {
        throw a;
      }), l = (a, c) => {
        throw process.exitCode = a, c;
      }, e.inspect = function() {
        return "[Emscripten Module object]";
      };
    } else (h || u) && (u ? g = self.location.href : typeof document < "u" && document.currentScript && (g = document.currentScript.src), s && (g = s), g.indexOf("blob:") !== 0 ? g = g.substr(0, g.replace(/[?#].*/, "").lastIndexOf("/") + 1) : g = "", y = (a) => {
      var c = new XMLHttpRequest();
      return c.open("GET", a, !1), c.send(null), c.responseText;
    }, u && (x = (a) => {
      var c = new XMLHttpRequest();
      return c.open("GET", a, !1), c.responseType = "arraybuffer", c.send(null), new Uint8Array(c.response);
    }), _ = (a, c, d) => {
      var p = new XMLHttpRequest();
      p.open("GET", a, !0), p.responseType = "arraybuffer", p.onload = () => {
        p.status == 200 || p.status == 0 && p.response ? c(p.response) : d();
      }, p.onerror = d, p.send(null);
    });
    var C = e.print || console.log.bind(console), M = e.printErr || console.warn.bind(console);
    Object.assign(e, r), r = null, e.thisProgram && (o = e.thisProgram), e.quit && (l = e.quit);
    var P;
    e.wasmBinary && (P = e.wasmBinary), e.noExitRuntime, typeof WebAssembly != "object" && pe("no native wasm support detected");
    var O, B = !1, j = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
    function F(a, c, d) {
      var p = c + d;
      for (d = c; a[d] && !(d >= p); ) ++d;
      if (16 < d - c && a.buffer && j) return j.decode(a.subarray(c, d));
      for (p = ""; c < d; ) {
        var w = a[c++];
        if (w & 128) {
          var k = a[c++] & 63;
          if ((w & 224) == 192) p += String.fromCharCode((w & 31) << 6 | k);
          else {
            var L = a[c++] & 63;
            w = (w & 240) == 224 ? (w & 15) << 12 | k << 6 | L : (w & 7) << 18 | k << 12 | L << 6 | a[c++] & 63, 65536 > w ? p += String.fromCharCode(w) : (w -= 65536, p += String.fromCharCode(55296 | w >> 10, 56320 | w & 1023));
          }
        } else p += String.fromCharCode(w);
      }
      return p;
    }
    function K(a, c) {
      return a ? F($, a, c) : "";
    }
    function J(a, c, d, p) {
      if (!(0 < p)) return 0;
      var w = d;
      p = d + p - 1;
      for (var k = 0; k < a.length; ++k) {
        var L = a.charCodeAt(k);
        if (55296 <= L && 57343 >= L) {
          var z = a.charCodeAt(++k);
          L = 65536 + ((L & 1023) << 10) | z & 1023;
        }
        if (127 >= L) {
          if (d >= p) break;
          c[d++] = L;
        } else {
          if (2047 >= L) {
            if (d + 1 >= p) break;
            c[d++] = 192 | L >> 6;
          } else {
            if (65535 >= L) {
              if (d + 2 >= p) break;
              c[d++] = 224 | L >> 12;
            } else {
              if (d + 3 >= p) break;
              c[d++] = 240 | L >> 18, c[d++] = 128 | L >> 12 & 63;
            }
            c[d++] = 128 | L >> 6 & 63;
          }
          c[d++] = 128 | L & 63;
        }
      }
      return c[d] = 0, d - w;
    }
    function rt(a) {
      for (var c = 0, d = 0; d < a.length; ++d) {
        var p = a.charCodeAt(d);
        127 >= p ? c++ : 2047 >= p ? c += 2 : 55296 <= p && 57343 >= p ? (c += 4, ++d) : c += 3;
      }
      return c;
    }
    var ft, H, $, D, R, U, it, at, mt;
    function Nt() {
      var a = O.buffer;
      ft = a, e.HEAP8 = H = new Int8Array(a), e.HEAP16 = D = new Int16Array(a), e.HEAP32 = U = new Int32Array(a), e.HEAPU8 = $ = new Uint8Array(a), e.HEAPU16 = R = new Uint16Array(a), e.HEAPU32 = it = new Uint32Array(a), e.HEAPF32 = at = new Float32Array(a), e.HEAPF64 = mt = new Float64Array(a);
    }
    var lt, ot = [], Ht = [], St = [], Rt = [];
    function ei() {
      var a = e.preRun.shift();
      ot.unshift(a);
    }
    var ai = 0, re = null;
    function Se() {
      ai++, e.monitorRunDependencies && e.monitorRunDependencies(ai);
    }
    function Be() {
      if (ai--, e.monitorRunDependencies && e.monitorRunDependencies(ai), ai == 0 && re) {
        var a = re;
        re = null, a();
      }
    }
    function pe(a) {
      throw e.onAbort && e.onAbort(a), a = "Aborted(" + a + ")", M(a), B = !0, a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info."), n(a), a;
    }
    function ki() {
      return ii.startsWith("data:application/octet-stream;base64,");
    }
    var ii;
    if (e.locateFile) {
      if (ii = "engine.esm.wasm", !ki()) {
        var T = ii;
        ii = e.locateFile ? e.locateFile(T, g) : g + T;
      }
    } else ii = void 0;
    function vt() {
      var a = ii;
      try {
        if (a == ii && P) return new Uint8Array(P);
        if (x) return x(a);
        throw "both async and sync fetching of the wasm failed";
      } catch (c) {
        pe(c);
      }
    }
    function pt() {
      if (!P && (h || u)) {
        if (typeof fetch == "function" && !ii.startsWith("file://")) return fetch(ii, { credentials: "same-origin" }).then(function(a) {
          if (!a.ok) throw "failed to load wasm binary file at '" + ii + "'";
          return a.arrayBuffer();
        }).catch(function() {
          return vt();
        });
        if (_) return new Promise(function(a, c) {
          _(ii, function(d) {
            a(new Uint8Array(d));
          }, c);
        });
      }
      return Promise.resolve().then(function() {
        return vt();
      });
    }
    var q, W, st = { 731344: () => {
      console.log("RPC parsing failed");
    }, 731383: (a, c, d) => {
      e.$$facade && (e.$$legacyClient ? (mt[a >> 3] = e.$$facade.container.clientWidth, mt[c >> 3] = e.$$facade.container.clientHeight) : (mt[a >> 3] = e.$$facade.containers.get(d).clientWidth, mt[c >> 3] = e.$$facade.containers.get(d).clientHeight));
    }, 731734: () => {
      try {
        var a = window.bowser;
        return a && a.windows && (a.webkit || a.blink || a.gecko) ? 1 : 0;
      } catch {
        return 1;
      }
    }, 731907: () => {
      try {
        var a = window.bowser;
        if (!(a && a.windows && (a.chrome && 0 <= a.compareVersions([
          a.version,
          "55"
        ]) && 0 > a.compareVersions([a.version, "57"]) || a.firefox && 0 <= a.compareVersions([a.version, "51"]) && 0 > a.compareVersions([a.version, "58"])))) return 0;
      } catch {
        return 0;
      }
      try {
        var c = e.Wi, d = c.getExtension("WEBGL_debug_renderer_info");
        if (d) {
          var p = c.getParameter(d.UNMASKED_RENDERER_WEBGL);
          if (!(p && 0 <= p.indexOf("ANGLE") && (0 <= p.indexOf("AMD") || 0 <= p.indexOf("Radeon")) && 0 <= p.indexOf("Direct3D11"))) return 0;
        }
      } catch {
      }
      return 1;
    } };
    function xt(a) {
      this.name = "ExitStatus", this.message = "Program terminated with exit(" + a + ")", this.status = a;
    }
    function It(a) {
      for (; 0 < a.length; ) a.shift()(e);
    }
    var nt = [], kt = [], Lt = (a, c) => {
      for (var d = 0, p = a.length - 1; 0 <= p; p--) {
        var w = a[p];
        w === "." ? a.splice(p, 1) : w === ".." ? (a.splice(p, 1), d++) : d && (a.splice(p, 1), d--);
      }
      if (c) for (; d; d--) a.unshift("..");
      return a;
    }, Tt = (a) => {
      var c = a.charAt(0) === "/", d = a.substr(-1) === "/";
      return (a = Lt(a.split("/").filter((p) => !!p), !c).join("/")) || c || (a = "."), a && d && (a += "/"), (c ? "/" : "") + a;
    }, Yt = (a) => {
      var c = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a).slice(1);
      return a = c[0], c = c[1], !a && !c ? "." : (c && (c = c.substr(0, c.length - 1)), a + c);
    }, Ve = (a) => {
      if (a === "/") return "/";
      a = Tt(a), a = a.replace(/\/$/, "");
      var c = a.lastIndexOf("/");
      return c === -1 ? a : a.substr(c + 1);
    };
    function xe() {
      if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") {
        var a = new Uint8Array(1);
        return () => (crypto.getRandomValues(a), a[0]);
      }
      if (f) try {
        var c = require("crypto");
        return () => c.randomBytes(1)[0];
      } catch {
      }
      return () => pe("randomDevice");
    }
    function Ri() {
      for (var a = "", c = !1, d = arguments.length - 1; -1 <= d && !c; d--) {
        if (c = 0 <= d ? arguments[d] : "/", typeof c != "string") throw new TypeError("Arguments to path.resolve must be strings");
        if (!c) return "";
        a = c + "/" + a, c = c.charAt(0) === "/";
      }
      return a = Lt(a.split("/").filter((p) => !!p), !c).join("/"), (c ? "/" : "") + a || ".";
    }
    function Fn(a, c) {
      var d = Array(rt(a) + 1);
      return a = J(a, d, 0, d.length), c && (d.length = a), d;
    }
    var cn = [];
    function ns(a, c) {
      cn[a] = { input: [], output: [], Ui: c }, Ol(a, di);
    }
    var di = { open: function(a) {
      var c = cn[a.node.rdev];
      if (!c) throw new Ft(43);
      a.tty = c, a.seekable = !1;
    }, close: function(a) {
      a.tty.Ui.fsync(a.tty);
    }, fsync: function(a) {
      a.tty.Ui.fsync(a.tty);
    }, read: function(a, c, d, p) {
      if (!a.tty || !a.tty.Ui.$j) throw new Ft(60);
      for (var w = 0, k = 0; k < p; k++) {
        try {
          var L = a.tty.Ui.$j(a.tty);
        } catch {
          throw new Ft(29);
        }
        if (L === void 0 && w === 0) throw new Ft(6);
        if (L == null) break;
        w++, c[d + k] = L;
      }
      return w && (a.node.timestamp = Date.now()), w;
    }, write: function(a, c, d, p) {
      if (!a.tty || !a.tty.Ui.Ej) throw new Ft(60);
      try {
        for (var w = 0; w < p; w++) a.tty.Ui.Ej(a.tty, c[d + w]);
      } catch {
        throw new Ft(29);
      }
      return p && (a.node.timestamp = Date.now()), w;
    } }, Vs = { $j: function(a) {
      if (!a.input.length) {
        var c = null;
        if (f) {
          var d = Buffer.alloc(256), p = 0;
          try {
            p = b.readSync(process.stdin.fd, d, 0, 256, -1);
          } catch (w) {
            if (w.toString().includes("EOF")) p = 0;
            else throw w;
          }
          0 < p ? c = d.slice(0, p).toString("utf-8") : c = null;
        } else typeof window < "u" && typeof window.prompt == "function" ? (c = window.prompt("Input: "), c !== null && (c += `
`)) : typeof readline == "function" && (c = readline(), c !== null && (c += `
`));
        if (!c) return null;
        a.input = Fn(c, !0);
      }
      return a.input.shift();
    }, Ej: function(a, c) {
      c === null || c === 10 ? (C(F(a.output, 0)), a.output = []) : c != 0 && a.output.push(c);
    }, fsync: function(a) {
      a.output && 0 < a.output.length && (C(F(a.output, 0)), a.output = []);
    } }, zs = { Ej: function(a, c) {
      c === null || c === 10 ? (M(F(a.output, 0)), a.output = []) : c != 0 && a.output.push(c);
    }, fsync: function(a) {
      a.output && 0 < a.output.length && (M(F(a.output, 0)), a.output = []);
    } }, te = { yi: null, Di: function() {
      return te.createNode(
        null,
        "/",
        16895,
        0
      );
    }, createNode: function(a, c, d, p) {
      if ((d & 61440) === 24576 || (d & 61440) === 4096) throw new Ft(63);
      return te.yi || (te.yi = { dir: { node: { Hi: te.hi.Hi, ui: te.hi.ui, lookup: te.hi.lookup, nj: te.hi.nj, rename: te.hi.rename, unlink: te.hi.unlink, rmdir: te.hi.rmdir, readdir: te.hi.readdir, symlink: te.hi.symlink }, stream: { Li: te.ii.Li } }, file: { node: { Hi: te.hi.Hi, ui: te.hi.ui }, stream: { Li: te.ii.Li, read: te.ii.read, write: te.ii.write, Pj: te.ii.Pj, Dj: te.ii.Dj, ek: te.ii.ek } }, link: { node: { Hi: te.hi.Hi, ui: te.hi.ui, readlink: te.hi.readlink }, stream: {} }, Sj: {
        node: { Hi: te.hi.Hi, ui: te.hi.ui },
        stream: Hh
      } }), d = Fh(a, c, d, p), (d.mode & 61440) === 16384 ? (d.hi = te.yi.dir.node, d.ii = te.yi.dir.stream, d.gi = {}) : (d.mode & 61440) === 32768 ? (d.hi = te.yi.file.node, d.ii = te.yi.file.stream, d.mi = 0, d.gi = null) : (d.mode & 61440) === 40960 ? (d.hi = te.yi.link.node, d.ii = te.yi.link.stream) : (d.mode & 61440) === 8192 && (d.hi = te.yi.Sj.node, d.ii = te.yi.Sj.stream), d.timestamp = Date.now(), a && (a.gi[c] = d, a.timestamp = d.timestamp), d;
    }, ll: function(a) {
      return a.gi ? a.gi.subarray ? a.gi.subarray(0, a.mi) : new Uint8Array(a.gi) : new Uint8Array(0);
    }, Xj: function(a, c) {
      var d = a.gi ? a.gi.length : 0;
      d >= c || (c = Math.max(c, d * (1048576 > d ? 2 : 1.125) >>> 0), d != 0 && (c = Math.max(c, 256)), d = a.gi, a.gi = new Uint8Array(c), 0 < a.mi && a.gi.set(d.subarray(0, a.mi), 0));
    }, Nk: function(a, c) {
      if (a.mi != c) if (c == 0) a.gi = null, a.mi = 0;
      else {
        var d = a.gi;
        a.gi = new Uint8Array(c), d && a.gi.set(d.subarray(0, Math.min(c, a.mi))), a.mi = c;
      }
    }, hi: { Hi: function(a) {
      var c = {};
      return c.dev = (a.mode & 61440) === 8192 ? a.id : 1, c.ino = a.id, c.mode = a.mode, c.nlink = 1, c.uid = 0, c.gid = 0, c.rdev = a.rdev, (a.mode & 61440) === 16384 ? c.size = 4096 : (a.mode & 61440) === 32768 ? c.size = a.mi : (a.mode & 61440) === 40960 ? c.size = a.link.length : c.size = 0, c.atime = new Date(a.timestamp), c.mtime = new Date(a.timestamp), c.ctime = new Date(a.timestamp), c.qk = 4096, c.blocks = Math.ceil(c.size / c.qk), c;
    }, ui: function(a, c) {
      c.mode !== void 0 && (a.mode = c.mode), c.timestamp !== void 0 && (a.timestamp = c.timestamp), c.size !== void 0 && te.Nk(a, c.size);
    }, lookup: function() {
      throw Nl[44];
    }, nj: function(a, c, d, p) {
      return te.createNode(a, c, d, p);
    }, rename: function(a, c, d) {
      if ((a.mode & 61440) === 16384) {
        try {
          var p = mo(c, d);
        } catch {
        }
        if (p) for (var w in p.gi) throw new Ft(55);
      }
      delete a.parent.gi[a.name], a.parent.timestamp = Date.now(), a.name = d, c.gi[d] = a, c.timestamp = a.parent.timestamp, a.parent = c;
    }, unlink: function(a, c) {
      delete a.gi[c], a.timestamp = Date.now();
    }, rmdir: function(a, c) {
      var d = mo(a, c), p;
      for (p in d.gi) throw new Ft(55);
      delete a.gi[c], a.timestamp = Date.now();
    }, readdir: function(a) {
      var c = [".", ".."], d;
      for (d in a.gi) a.gi.hasOwnProperty(d) && c.push(d);
      return c;
    }, symlink: function(a, c, d) {
      return a = te.createNode(a, c, 41471, 0), a.link = d, a;
    }, readlink: function(a) {
      if ((a.mode & 61440) !== 40960) throw new Ft(28);
      return a.link;
    } }, ii: { read: function(a, c, d, p, w) {
      var k = a.node.gi;
      if (w >= a.node.mi) return 0;
      if (a = Math.min(a.node.mi - w, p), 8 < a && k.subarray) c.set(k.subarray(w, w + a), d);
      else for (p = 0; p < a; p++) c[d + p] = k[w + p];
      return a;
    }, write: function(a, c, d, p, w, k) {
      if (c.buffer === H.buffer && (k = !1), !p) return 0;
      if (a = a.node, a.timestamp = Date.now(), c.subarray && (!a.gi || a.gi.subarray)) {
        if (k) return a.gi = c.subarray(d, d + p), a.mi = p;
        if (a.mi === 0 && w === 0) return a.gi = c.slice(d, d + p), a.mi = p;
        if (w + p <= a.mi) return a.gi.set(c.subarray(d, d + p), w), p;
      }
      if (te.Xj(a, w + p), a.gi.subarray && c.subarray) a.gi.set(c.subarray(d, d + p), w);
      else for (k = 0; k < p; k++) a.gi[w + k] = c[d + k];
      return a.mi = Math.max(a.mi, w + p), p;
    }, Li: function(a, c, d) {
      if (d === 1 ? c += a.position : d === 2 && (a.node.mode & 61440) === 32768 && (c += a.node.mi), 0 > c) throw new Ft(28);
      return c;
    }, Pj: function(a, c, d) {
      te.Xj(a.node, c + d), a.node.mi = Math.max(a.node.mi, c + d);
    }, Dj: function(a, c, d, p, w) {
      if ((a.node.mode & 61440) !== 32768) throw new Ft(43);
      if (a = a.node.gi, w & 2 || a.buffer !== ft) {
        if ((0 < d || d + c < a.length) && (a.subarray ? a = a.subarray(d, d + c) : a = Array.prototype.slice.call(
          a,
          d,
          d + c
        )), d = !0, pe(), c = void 0, !c) throw new Ft(48);
        H.set(a, c);
      } else d = !1, c = a.byteOffset;
      return { li: c, dl: d };
    }, ek: function(a, c, d, p) {
      return te.ii.write(a, c, 0, p, d, !1), 0;
    } } };
    function Ki(a, c, d) {
      var p = "al " + a;
      _(a, (w) => {
        w || pe('Loading data file "' + a + '" failed (no arrayBuffer).'), c(new Uint8Array(w)), p && Be();
      }, () => {
        if (d) d();
        else throw 'Loading data file "' + a + '" failed.';
      }), p && Se();
    }
    var vn = null, qn = {}, Bn = [], kn = 1, Je = null, xr = !0, Ft = null, Nl = {}, Hs = (a, c = {}) => {
      if (a = Ri("/", a), !a) return { path: "", node: null };
      if (c = Object.assign({ Zj: !0, Fj: 0 }, c), 8 < c.Fj) throw new Ft(32);
      a = Lt(a.split("/").filter((L) => !!L), !1);
      for (var d = vn, p = "/", w = 0; w < a.length; w++) {
        var k = w === a.length - 1;
        if (k && c.parent) break;
        if (d = mo(d, a[w]), p = Tt(p + "/" + a[w]), d.Xi && (!k || k && c.Zj) && (d = d.Xi.root), !k || c.wj) {
          for (k = 0; (d.mode & 61440) === 40960; ) if (d = V(p), p = Ri(Yt(p), d), d = Hs(p, { Fj: c.Fj + 1 }).node, 40 < k++) throw new Ft(32);
        }
      }
      return { path: p, node: d };
    }, Xr = (a) => {
      for (var c; ; ) {
        if (a === a.parent) return a = a.Di.dk, c ? a[a.length - 1] !== "/" ? a + "/" + c : a + c : a;
        c = c ? a.name + "/" + c : a.name, a = a.parent;
      }
    }, Ei = (a, c) => {
      for (var d = 0, p = 0; p < c.length; p++) d = (d << 5) - d + c.charCodeAt(p) | 0;
      return (a + d >>> 0) % Je.length;
    }, mo = (a, c) => {
      var d;
      if (d = (d = Xo(a, "x")) ? d : a.hi.lookup ? 0 : 2) throw new Ft(d, a);
      for (d = Je[Ei(a.id, c)]; d; d = d.Ti) {
        var p = d.name;
        if (d.parent.id === a.id && p === c) return d;
      }
      return a.hi.lookup(a, c);
    }, Fh = (a, c, d, p) => (a = new wp(a, c, d, p), c = Ei(a.parent.id, a.name), a.Ti = Je[c], Je[c] = a), Sd = {
      r: 0,
      "r+": 2,
      w: 577,
      "w+": 578,
      a: 1089,
      "a+": 1090
    }, Bh = (a) => {
      var c = ["r", "w", "rw"][a & 3];
      return a & 512 && (c += "w"), c;
    }, Xo = (a, c) => {
      if (xr) return 0;
      if (!c.includes("r") || a.mode & 292) {
        if (c.includes("w") && !(a.mode & 146) || c.includes("x") && !(a.mode & 73)) return 2;
      } else return 2;
      return 0;
    }, Vh = (a, c) => {
      try {
        return mo(a, c), 20;
      } catch {
      }
      return Xo(a, "wx");
    }, Md = (a = 0) => {
      for (; 4096 >= a; a++) if (!Bn[a]) return a;
      throw new Ft(33);
    }, zh = (a, c) => (un || (un = function() {
      this.ti = {};
    }, un.prototype = {}, Object.defineProperties(un.prototype, { object: {
      get: function() {
        return this.node;
      },
      set: function(d) {
        this.node = d;
      }
    }, flags: { get: function() {
      return this.ti.flags;
    }, set: function(d) {
      this.ti.flags = d;
    } }, position: { get: function() {
      return this.ti.position;
    }, set: function(d) {
      this.ti.position = d;
    } } })), a = Object.assign(new un(), a), c = Md(c), a.fd = c, Bn[c] = a), Hh = { open: (a) => {
      a.ii = qn[a.node.rdev].ii, a.ii.open && a.ii.open(a);
    }, Li: () => {
      throw new Ft(70);
    } }, Ol = (a, c) => {
      qn[a] = { ii: c };
    }, Rl = (a, c) => {
      var d = c === "/", p = !c;
      if (d && vn) throw new Ft(10);
      if (!d && !p) {
        var w = Hs(c, { Zj: !1 });
        if (c = w.path, w = w.node, w.Xi) throw new Ft(10);
        if ((w.mode & 61440) !== 16384) throw new Ft(54);
      }
      c = { type: a, rl: {}, dk: c, Ik: [] }, a = a.Di(c), a.Di = c, c.root = a, d ? vn = a : w && (w.Xi = c, w.Di && w.Di.Ik.push(c));
    }, Vn = (a, c, d) => {
      var p = Hs(a, { parent: !0 }).node;
      if (a = Ve(a), !a || a === "." || a === "..") throw new Ft(28);
      var w = Vh(p, a);
      if (w) throw new Ft(w);
      if (!p.hi.nj) throw new Ft(63);
      return p.hi.nj(p, a, c, d);
    }, v = (a, c, d) => (typeof d > "u" && (d = c, c = 438), Vn(a, c | 8192, d)), S = (a, c) => {
      if (!Ri(a)) throw new Ft(44);
      var d = Hs(c, { parent: !0 }).node;
      if (!d) throw new Ft(44);
      c = Ve(c);
      var p = Vh(d, c);
      if (p) throw new Ft(p);
      if (!d.hi.symlink) throw new Ft(63);
      d.hi.symlink(d, c, a);
    }, E = (a) => {
      var c = Hs(a, { parent: !0 }).node;
      if (!c) throw new Ft(44);
      var d = Ve(a);
      a = mo(c, d);
      t: {
        try {
          var p = mo(c, d);
        } catch (k) {
          p = k.Gi;
          break t;
        }
        var w = Xo(c, "wx");
        p = w || ((p.mode & 61440) === 16384 ? 31 : 0);
      }
      if (p) throw new Ft(p);
      if (!c.hi.unlink) throw new Ft(63);
      if (a.Xi) throw new Ft(10);
      if (c.hi.unlink(c, d), c = Ei(a.parent.id, a.name), Je[c] === a) Je[c] = a.Ti;
      else for (c = Je[c]; c; ) {
        if (c.Ti === a) {
          c.Ti = a.Ti;
          break;
        }
        c = c.Ti;
      }
    }, V = (a) => {
      if (a = Hs(a).node, !a) throw new Ft(44);
      if (!a.hi.readlink) throw new Ft(28);
      return Ri(Xr(a.parent), a.hi.readlink(a));
    }, Y = (a, c) => {
      if (a = typeof a == "string" ? Hs(a, { wj: !0 }).node : a, !a.hi.ui) throw new Ft(63);
      a.hi.ui(a, { mode: c & 4095 | a.mode & -4096, timestamp: Date.now() });
    }, tt = (a, c, d) => {
      if (a === "") throw new Ft(44);
      if (typeof c == "string") {
        var p = Sd[c];
        if (typeof p > "u") throw Error("Unknown file open mode: " + c);
        c = p;
      }
      if (d = c & 64 ? (typeof d > "u" ? 438 : d) & 4095 | 32768 : 0, typeof a == "object") var w = a;
      else {
        a = Tt(a);
        try {
          w = Hs(a, { wj: !(c & 131072) }).node;
        } catch {
        }
      }
      if (p = !1, c & 64) if (w) {
        if (c & 128) throw new Ft(20);
      } else w = Vn(a, d, 0), p = !0;
      if (!w) throw new Ft(44);
      if ((w.mode & 61440) === 8192 && (c &= -513), c & 65536 && (w.mode & 61440) !== 16384) throw new Ft(54);
      if (!p && (d = w ? (w.mode & 61440) === 40960 ? 32 : (w.mode & 61440) === 16384 && (Bh(c) !== "r" || c & 512) ? 31 : Xo(w, Bh(c)) : 44)) throw new Ft(d);
      if (c & 512 && !p) {
        if (d = w, d = typeof d == "string" ? Hs(d, { wj: !0 }).node : d, !d.hi.ui) throw new Ft(63);
        if ((d.mode & 61440) === 16384) throw new Ft(31);
        if ((d.mode & 61440) !== 32768) throw new Ft(28);
        if (p = Xo(d, "w")) throw new Ft(p);
        d.hi.ui(d, { size: 0, timestamp: Date.now() });
      }
      return c &= -131713, w = zh({ node: w, path: Xr(w), flags: c, seekable: !0, position: 0, ii: w.ii, bl: [], error: !1 }), w.ii.open && w.ii.open(w), !e.logReadFiles || c & 1 || (Qt || (Qt = {}), a in Qt || (Qt[a] = 1)), w;
    }, _t = (a) => {
      if (a.fd === null) throw new Ft(8);
      a.xj && (a.xj = null);
      try {
        a.ii.close && a.ii.close(a);
      } catch (c) {
        throw c;
      } finally {
        Bn[a.fd] = null;
      }
      a.fd = null;
    }, Pt = (a, c, d) => {
      if (a.fd === null) throw new Ft(8);
      if (!a.seekable || !a.ii.Li) throw new Ft(70);
      if (d != 0 && d != 1 && d != 2) throw new Ft(28);
      a.position = a.ii.Li(a, c, d), a.bl = [];
    }, zt = (a, c, d, p, w, k) => {
      if (0 > p || 0 > w) throw new Ft(28);
      if (a.fd === null) throw new Ft(8);
      if ((a.flags & 2097155) === 0) throw new Ft(8);
      if ((a.node.mode & 61440) === 16384) throw new Ft(31);
      if (!a.ii.write) throw new Ft(28);
      a.seekable && a.flags & 1024 && Pt(a, 0, 2);
      var L = typeof w < "u";
      if (!L) w = a.position;
      else if (!a.seekable) throw new Ft(70);
      return c = a.ii.write(a, c, d, p, w, k), L || (a.position += c), c;
    }, me = () => {
      Ft || (Ft = function(a, c) {
        this.node = c, this.Qk = function(d) {
          this.Gi = d;
        }, this.Qk(a), this.message = "FS error";
      }, Ft.prototype = Error(), Ft.prototype.constructor = Ft, [44].forEach((a) => {
        Nl[a] = new Ft(a), Nl[a].stack = "<generic error, no stack>";
      }));
    }, ni, Wi = (a, c) => {
      var d = 0;
      return a && (d |= 365), c && (d |= 146), d;
    }, bi = (a, c) => {
      for (a = typeof a == "string" ? a : Xr(a), c = c.split("/").reverse(); c.length; ) {
        var d = c.pop();
        if (d) {
          var p = Tt(a + "/" + d);
          try {
            Vn(p, 16895, 0);
          } catch {
          }
          a = p;
        }
      }
      return p;
    }, Gi = (a, c, d, p) => (a = Tt((typeof a == "string" ? a : Xr(a)) + "/" + c), d = Wi(d, p), Vn(a, (d !== void 0 ? d : 438) & 4095 | 32768, 0)), Ai = (a, c, d, p, w, k) => {
      var L = c;
      if (a && (a = typeof a == "string" ? a : Xr(a), L = c ? Tt(a + "/" + c) : a), a = Wi(p, w), L = Vn(L, (a !== void 0 ? a : 438) & 4095 | 32768, 0), d) {
        if (typeof d == "string") {
          for (c = Array(d.length), p = 0, w = d.length; p < w; ++p) c[p] = d.charCodeAt(p);
          d = c;
        }
        Y(L, a | 146), c = tt(L, 577), zt(c, d, 0, d.length, 0, k), _t(c), Y(L, a);
      }
      return L;
    }, hn = (a, c, d, p) => {
      a = Tt((typeof a == "string" ? a : Xr(a)) + "/" + c), c = Wi(!!d, !!p), hn.ck || (hn.ck = 64);
      var w = hn.ck++ << 8 | 0;
      return Ol(w, { open: (k) => {
        k.seekable = !1;
      }, close: () => {
        p && p.buffer && p.buffer.length && p(10);
      }, read: (k, L, z, Z) => {
        for (var ct = 0, ut = 0; ut < Z; ut++) {
          try {
            var At = d();
          } catch {
            throw new Ft(29);
          }
          if (At === void 0 && ct === 0) throw new Ft(6);
          if (At == null) break;
          ct++, L[z + ut] = At;
        }
        return ct && (k.node.timestamp = Date.now()), ct;
      }, write: (k, L, z, Z) => {
        for (var ct = 0; ct < Z; ct++) try {
          p(L[z + ct]);
        } catch {
          throw new Ft(29);
        }
        return Z && (k.node.timestamp = Date.now()), ct;
      } }), v(a, c, w);
    }, Us = (a) => {
      if (!(a.Ek || a.Fk || a.link || a.gi)) {
        if (typeof XMLHttpRequest < "u") throw Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        if (y) try {
          a.gi = Fn(
            y(a.url),
            !0
          ), a.mi = a.gi.length;
        } catch {
          throw new Ft(29);
        }
        else throw Error("Cannot load without read() or XMLHttpRequest.");
      }
    }, Jo = (a, c, d, p, w) => {
      function k() {
        this.Bj = !1, this.ti = [];
      }
      if (k.prototype.get = function(ut) {
        if (!(ut > this.length - 1 || 0 > ut)) {
          var At = ut % this.chunkSize;
          return this.Si(ut / this.chunkSize | 0)[At];
        }
      }, k.prototype.yk = function(ut) {
        this.Si = ut;
      }, k.prototype.Qj = function() {
        var ut = new XMLHttpRequest();
        if (ut.open("HEAD", d, !1), ut.send(null), !(200 <= ut.status && 300 > ut.status || ut.status === 304)) throw Error("Couldn't load " + d + ". Status: " + ut.status);
        var At = Number(ut.getResponseHeader("Content-length")), Ut, et = (Ut = ut.getResponseHeader("Accept-Ranges")) && Ut === "bytes";
        ut = (Ut = ut.getResponseHeader("Content-Encoding")) && Ut === "gzip";
        var bt = 1048576;
        et || (bt = At);
        var $t = this;
        $t.yk((Me) => {
          var Ue = Me * bt, Li = (Me + 1) * bt - 1;
          if (Li = Math.min(Li, At - 1), typeof $t.ti[Me] > "u") {
            var Bt = $t.ti;
            if (Ue > Li) throw Error("invalid range (" + Ue + ", " + Li + ") or no bytes requested!");
            if (Li > At - 1) throw Error("only " + At + " bytes available! programmer error!");
            var Dt = new XMLHttpRequest();
            if (Dt.open("GET", d, !1), At !== bt && Dt.setRequestHeader("Range", "bytes=" + Ue + "-" + Li), Dt.responseType = "arraybuffer", Dt.overrideMimeType && Dt.overrideMimeType("text/plain; charset=x-user-defined"), Dt.send(null), !(200 <= Dt.status && 300 > Dt.status || Dt.status === 304)) throw Error("Couldn't load " + d + ". Status: " + Dt.status);
            Ue = Dt.response !== void 0 ? new Uint8Array(Dt.response || []) : Fn(Dt.responseText || "", !0), Bt[Me] = Ue;
          }
          if (typeof $t.ti[Me] > "u") throw Error("doXHR failed!");
          return $t.ti[Me];
        }), (ut || !At) && (bt = At = 1, bt = At = this.Si(0).length, C("LazyFiles on gzip forces download of the whole file when length is accessed")), this.nk = At, this.mk = bt, this.Bj = !0;
      }, typeof XMLHttpRequest < "u") {
        if (!u) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var L = new k();
        Object.defineProperties(L, { length: { get: function() {
          return this.Bj || this.Qj(), this.nk;
        } }, chunkSize: { get: function() {
          return this.Bj || this.Qj(), this.mk;
        } } });
        var z = void 0;
      } else z = d, L = void 0;
      var Z = Gi(a, c, p, w);
      L ? Z.gi = L : z && (Z.gi = null, Z.url = z), Object.defineProperties(Z, { mi: { get: function() {
        return this.gi.length;
      } } });
      var ct = {};
      return Object.keys(Z.ii).forEach((ut) => {
        var At = Z.ii[ut];
        ct[ut] = function() {
          return Us(Z), At.apply(null, arguments);
        };
      }), ct.read = (ut, At, Ut, et, bt) => {
        if (Us(Z), ut = ut.node.gi, bt >= ut.length) At = 0;
        else {
          if (et = Math.min(ut.length - bt, et), ut.slice) for (var $t = 0; $t < et; $t++) At[Ut + $t] = ut[bt + $t];
          else for ($t = 0; $t < et; $t++) At[Ut + $t] = ut.get(bt + $t);
          At = et;
        }
        return At;
      }, ct.Dj = () => {
        throw Us(Z), pe(), new Ft(48);
      }, Z.ii = ct, Z;
    }, Kn = (a, c, d, p, w, k, L, z, Z, ct) => {
      function ut(Ut) {
        function et(bt) {
          ct && ct(), z || Ai(a, c, bt, p, w, Z), k && k(), Be();
        }
        Tw(Ut, At, et, () => {
          L && L(), Be();
        }) || et(Ut);
      }
      var At = c ? Ri(Tt(a + "/" + c)) : a;
      Se(), typeof d == "string" ? Ki(d, (Ut) => ut(Ut), L) : ut(d);
    }, ss = {}, un, Qt, ae = void 0;
    function ce() {
      return ae += 4, U[ae - 4 >> 2];
    }
    function Ee(a) {
      if (a = Bn[a], !a) throw new Ft(8);
      return a;
    }
    var mi = {};
    function Ti(a) {
      for (; a.length; ) {
        var c = a.pop();
        a.pop()(c);
      }
    }
    function xi(a) {
      return this.fromWireType(U[a >> 2]);
    }
    var Ge = {}, fi = {}, li = {};
    function dt(a) {
      if (a === void 0) return "_unknown";
      a = a.replace(/[^a-zA-Z0-9_]/g, "$");
      var c = a.charCodeAt(0);
      return 48 <= c && 57 >= c ? "_" + a : a;
    }
    function Ot(a, c) {
      return a = dt(a), new Function("body", "return function " + a + `() {
    "use strict";    return body.apply(this, arguments);
};
`)(c);
    }
    function Gt(a) {
      var c = Error, d = Ot(a, function(p) {
        this.name = a, this.message = p, p = Error(p).stack, p !== void 0 && (this.stack = this.toString() + `
` + p.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return d.prototype = Object.create(c.prototype), d.prototype.constructor = d, d.prototype.toString = function() {
        return this.message === void 0 ? this.name : this.name + ": " + this.message;
      }, d;
    }
    var de = void 0;
    function $e(a) {
      throw new de(a);
    }
    function ze(a, c, d) {
      function p(z) {
        z = d(z), z.length !== a.length && $e("Mismatched type converter count");
        for (var Z = 0; Z < a.length; ++Z) Ir(a[Z], z[Z]);
      }
      a.forEach(function(z) {
        li[z] = c;
      });
      var w = Array(c.length), k = [], L = 0;
      c.forEach((z, Z) => {
        fi.hasOwnProperty(z) ? w[Z] = fi[z] : (k.push(z), Ge.hasOwnProperty(z) || (Ge[z] = []), Ge[z].push(() => {
          w[Z] = fi[z], ++L, L === k.length && p(w);
        }));
      }), k.length === 0 && p(w);
    }
    var Xi = {};
    function js(a) {
      switch (a) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a);
      }
    }
    var Ll = void 0;
    function Ji(a) {
      for (var c = ""; $[a]; ) c += Ll[$[a++]];
      return c;
    }
    var Ba = void 0;
    function He(a) {
      throw new Ba(a);
    }
    function Ir(a, c, d = {}) {
      if (!("argPackAdvance" in c)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var p = c.name;
      if (a || He('type "' + p + '" must have a positive integer typeid pointer'), fi.hasOwnProperty(a)) {
        if (d.Bk) return;
        He("Cannot register type '" + p + "' twice");
      }
      fi[a] = c, delete li[a], Ge.hasOwnProperty(a) && (c = Ge[a], delete Ge[a], c.forEach((w) => w()));
    }
    function Pd(a) {
      He(a.fi.ni.ji.name + " instance already deleted");
    }
    var kd = !1;
    function Bg() {
    }
    function Vg(a) {
      --a.count.value, a.count.value === 0 && (a.ri ? a.wi.vi(a.ri) : a.ni.ji.vi(a.li));
    }
    function zg(a, c, d) {
      return c === d ? a : d.xi === void 0 ? null : (a = zg(a, c, d.xi), a === null ? null : d.tk(a));
    }
    var Hg = {}, Fl = [];
    function Ed() {
      for (; Fl.length; ) {
        var a = Fl.pop();
        a.fi.Ri = !1, a.delete();
      }
    }
    var Bl = void 0, Vl = {};
    function ow(a, c) {
      for (c === void 0 && He("ptr should not be undefined"); a.xi; ) c = a.$i(c), a = a.xi;
      return Vl[c];
    }
    function Uh(a, c) {
      return c.ni && c.li || $e("makeClassHandle requires ptr and ptrType"), !!c.wi != !!c.ri && $e("Both smartPtrType and smartPtr must be specified"), c.count = { value: 1 }, zl(Object.create(a, { fi: { value: c } }));
    }
    function zl(a) {
      return typeof FinalizationRegistry > "u" ? (zl = (c) => c, a) : (kd = new FinalizationRegistry((c) => {
        Vg(c.fi);
      }), zl = (c) => {
        var d = c.fi;
        return d.ri && kd.register(c, { fi: d }, c), c;
      }, Bg = (c) => {
        kd.unregister(c);
      }, zl(a));
    }
    function _o() {
    }
    function Ug(a, c, d) {
      if (a[c].Ei === void 0) {
        var p = a[c];
        a[c] = function() {
          return a[c].Ei.hasOwnProperty(arguments.length) || He("Function '" + d + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[c].Ei + ")!"), a[c].Ei[arguments.length].apply(this, arguments);
        }, a[c].Ei = [], a[c].Ei[p.uj] = p;
      }
    }
    function jg(a, c) {
      e.hasOwnProperty(a) ? (He("Cannot register public name '" + a + "' twice"), Ug(e, a, a), e.hasOwnProperty(void 0) && He("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), e[a].Ei[void 0] = c) : e[a] = c;
    }
    function aw(a, c, d, p, w, k, L, z) {
      this.name = a, this.constructor = c, this.Ki = d, this.vi = p, this.xi = w, this.wk = k, this.$i = L, this.tk = z;
    }
    function jh(a, c, d) {
      for (; c !== d; ) c.$i || He("Expected null or instance of " + d.name + ", got an instance of " + c.name), a = c.$i(a), c = c.xi;
      return a;
    }
    function lw(a, c) {
      return c === null ? (this.Aj && He("null is not a valid " + this.name), 0) : (c.fi || He('Cannot pass "' + Dd(c) + '" as a ' + this.name), c.fi.li || He("Cannot pass deleted object as a pointer of type " + this.name), jh(c.fi.li, c.fi.ni.ji, this.ji));
    }
    function cw(a, c) {
      if (c === null) {
        if (this.Aj && He("null is not a valid " + this.name), this.ij) {
          var d = this.Zi();
          return a !== null && a.push(this.vi, d), d;
        }
        return 0;
      }
      if (c.fi || He('Cannot pass "' + Dd(c) + '" as a ' + this.name), c.fi.li || He("Cannot pass deleted object as a pointer of type " + this.name), !this.hj && c.fi.ni.hj && He("Cannot convert argument of type " + (c.fi.wi ? c.fi.wi.name : c.fi.ni.name) + " to parameter type " + this.name), d = jh(c.fi.li, c.fi.ni.ji, this.ji), this.ij) switch (c.fi.ri === void 0 && He("Passing raw pointer to smart pointer is illegal"), this.Wk) {
        case 0:
          c.fi.wi === this ? d = c.fi.ri : He("Cannot convert argument of type " + (c.fi.wi ? c.fi.wi.name : c.fi.ni.name) + " to parameter type " + this.name);
          break;
        case 1:
          d = c.fi.ri;
          break;
        case 2:
          if (c.fi.wi === this) d = c.fi.ri;
          else {
            var p = c.clone();
            d = this.Mk(d, ds(function() {
              p.delete();
            })), a !== null && a.push(this.vi, d);
          }
          break;
        default:
          He("Unsupporting sharing policy");
      }
      return d;
    }
    function hw(a, c) {
      return c === null ? (this.Aj && He("null is not a valid " + this.name), 0) : (c.fi || He('Cannot pass "' + Dd(c) + '" as a ' + this.name), c.fi.li || He("Cannot pass deleted object as a pointer of type " + this.name), c.fi.ni.hj && He("Cannot convert argument of type " + c.fi.ni.name + " to parameter type " + this.name), jh(c.fi.li, c.fi.ni.ji, this.ji));
    }
    function Cr(a, c, d, p, w, k, L, z, Z, ct, ut) {
      this.name = a, this.ji = c, this.Aj = d, this.hj = p, this.ij = w, this.Kk = k, this.Wk = L, this.gk = z, this.Zi = Z, this.Mk = ct, this.vi = ut, w || c.xi !== void 0 ? this.toWireType = cw : (this.toWireType = p ? lw : hw, this.si = null);
    }
    function uw(a, c) {
      e.hasOwnProperty(a) || $e("Replacing nonexistant public symbol"), e[a] = c, e[a].uj = void 0;
    }
    function dw(a, c) {
      var d = [];
      return function() {
        if (d.length = 0, Object.assign(d, arguments), a.includes("j")) {
          var p = e["dynCall_" + a];
          p = d && d.length ? p.apply(null, [c].concat(d)) : p.call(null, c);
        } else p = lt.get(c).apply(null, d);
        return p;
      };
    }
    function dn(a, c) {
      a = Ji(a);
      var d = a.includes("j") ? dw(a, c) : lt.get(c);
      return typeof d != "function" && He("unknown function pointer with signature " + a + ": " + c), d;
    }
    var Wg = void 0;
    function Gg(a) {
      a = xp(a);
      var c = Ji(a);
      return Pr(a), c;
    }
    function Hl(a, c) {
      function d(k) {
        w[k] || fi[k] || (li[k] ? li[k].forEach(d) : (p.push(k), w[k] = !0));
      }
      var p = [], w = {};
      throw c.forEach(d), new Wg(a + ": " + p.map(Gg).join([", "]));
    }
    function $g(a) {
      var c = Function;
      if (!(c instanceof Function)) throw new TypeError("new_ called with constructor type " + typeof c + " which is not a function");
      var d = Ot(c.name || "unknownFunctionName", function() {
      });
      return d.prototype = c.prototype, d = new d(), a = c.apply(d, a), a instanceof Object ? a : d;
    }
    function qg(a, c, d, p) {
      var w = c.length;
      2 > w && He("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var k = c[1] !== null && !1, L = !1, z = 1; z < c.length; ++z) if (c[z] !== null && c[z].si === void 0) {
        L = !0;
        break;
      }
      var Z = c[0].name !== "void", ct = "", ut = "";
      for (z = 0; z < w - 2; ++z) ct += (z !== 0 ? ", " : "") + "arg" + z, ut += (z !== 0 ? ", " : "") + "arg" + z + "Wired";
      a = "return function " + dt(a) + "(" + ct + `) {
if (arguments.length !== ` + (w - 2) + `) {
throwBindingError('function ` + a + " called with ' + arguments.length + ' arguments, expected " + (w - 2) + ` args!');
}
`, L && (a += `var destructors = [];
`);
      var At = L ? "destructors" : "null";
      for (ct = "throwBindingError invoker fn runDestructors retType classParam".split(" "), d = [He, d, p, Ti, c[0], c[1]], k && (a += "var thisWired = classParam.toWireType(" + At + `, this);
`), z = 0; z < w - 2; ++z) a += "var arg" + z + "Wired = argType" + z + ".toWireType(" + At + ", arg" + z + "); // " + c[z + 2].name + `
`, ct.push("argType" + z), d.push(c[z + 2]);
      if (k && (ut = "thisWired" + (0 < ut.length ? ", " : "") + ut), a += (Z ? "var rv = " : "") + "invoker(fn" + (0 < ut.length ? ", " : "") + ut + `);
`, L) a += `runDestructors(destructors);
`;
      else for (z = k ? 1 : 2; z < c.length; ++z) w = z === 1 ? "thisWired" : "arg" + (z - 2) + "Wired", c[z].si !== null && (a += w + "_dtor(" + w + "); // " + c[z].name + `
`, ct.push(w + "_dtor"), d.push(c[z].si));
      return Z && (a += `var ret = retType.fromWireType(rv);
return ret;
`), ct.push(a + `}
`), $g(ct).apply(null, d);
    }
    function Kg(a, c) {
      for (var d = [], p = 0; p < a; p++) d.push(it[c + 4 * p >> 2]);
      return d;
    }
    function Xg(a, c, d) {
      return a instanceof Object || He(d + ' with invalid "this": ' + a), a instanceof c.ji.constructor || He(d + ' incompatible with "this" of type ' + a.constructor.name), a.fi.li || He("cannot call emscripten binding method " + d + " on deleted object"), jh(a.fi.li, a.fi.ni.ji, c.ji);
    }
    var Ad = [], er = [{}, { value: void 0 }, { value: null }, { value: !0 }, { value: !1 }];
    function Td(a) {
      4 < a && --er[a].Gj === 0 && (er[a] = void 0, Ad.push(a));
    }
    var ir = (a) => (a || He("Cannot use deleted val. handle = " + a), er[a].value), ds = (a) => {
      switch (a) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          var c = Ad.length ? Ad.pop() : er.length;
          return er[c] = { Gj: 1, value: a }, c;
      }
    };
    function fw(a, c, d) {
      switch (c) {
        case 0:
          return function(p) {
            return this.fromWireType((d ? H : $)[p]);
          };
        case 1:
          return function(p) {
            return this.fromWireType((d ? D : R)[p >> 1]);
          };
        case 2:
          return function(p) {
            return this.fromWireType((d ? U : it)[p >> 2]);
          };
        default:
          throw new TypeError("Unknown integer type: " + a);
      }
    }
    function Ul(a, c) {
      var d = fi[a];
      return d === void 0 && He(c + " has unknown type " + Gg(a)), d;
    }
    function Dd(a) {
      if (a === null) return "null";
      var c = typeof a;
      return c === "object" || c === "array" || c === "function" ? a.toString() : "" + a;
    }
    function gw(a, c) {
      switch (c) {
        case 2:
          return function(d) {
            return this.fromWireType(at[d >> 2]);
          };
        case 3:
          return function(d) {
            return this.fromWireType(mt[d >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a);
      }
    }
    function pw(a, c, d) {
      switch (c) {
        case 0:
          return d ? function(p) {
            return H[p];
          } : function(p) {
            return $[p];
          };
        case 1:
          return d ? function(p) {
            return D[p >> 1];
          } : function(p) {
            return R[p >> 1];
          };
        case 2:
          return d ? function(p) {
            return U[p >> 2];
          } : function(p) {
            return it[p >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a);
      }
    }
    var Jg = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
    function mw(a, c) {
      for (var d = a >> 1, p = d + c / 2; !(d >= p) && R[d]; ) ++d;
      if (d <<= 1, 32 < d - a && Jg) return Jg.decode($.subarray(a, d));
      for (d = "", p = 0; !(p >= c / 2); ++p) {
        var w = D[a + 2 * p >> 1];
        if (w == 0) break;
        d += String.fromCharCode(w);
      }
      return d;
    }
    function _w(a, c, d) {
      if (d === void 0 && (d = 2147483647), 2 > d) return 0;
      d -= 2;
      var p = c;
      d = d < 2 * a.length ? d / 2 : a.length;
      for (var w = 0; w < d; ++w) D[c >> 1] = a.charCodeAt(w), c += 2;
      return D[c >> 1] = 0, c - p;
    }
    function yw(a) {
      return 2 * a.length;
    }
    function ww(a, c) {
      for (var d = 0, p = ""; !(d >= c / 4); ) {
        var w = U[a + 4 * d >> 2];
        if (w == 0) break;
        ++d, 65536 <= w ? (w -= 65536, p += String.fromCharCode(55296 | w >> 10, 56320 | w & 1023)) : p += String.fromCharCode(w);
      }
      return p;
    }
    function vw(a, c, d) {
      if (d === void 0 && (d = 2147483647), 4 > d) return 0;
      var p = c;
      d = p + d - 4;
      for (var w = 0; w < a.length; ++w) {
        var k = a.charCodeAt(w);
        if (55296 <= k && 57343 >= k) {
          var L = a.charCodeAt(++w);
          k = 65536 + ((k & 1023) << 10) | L & 1023;
        }
        if (U[c >> 2] = k, c += 4, c + 4 > d) break;
      }
      return U[c >> 2] = 0, c - p;
    }
    function bw(a) {
      for (var c = 0, d = 0; d < a.length; ++d) {
        var p = a.charCodeAt(d);
        55296 <= p && 57343 >= p && ++d, c += 4;
      }
      return c;
    }
    function Yg(a, c) {
      for (var d = Array(a), p = 0; p < a; ++p) d[p] = Ul(it[c + 4 * p >> 2], "parameter " + p);
      return d;
    }
    var xw = {};
    function Wh(a) {
      var c = xw[a];
      return c === void 0 ? Ji(a) : c;
    }
    var Nd = [];
    function Zg() {
      return typeof globalThis == "object" ? globalThis : Function("return this")();
    }
    function Iw(a) {
      var c = Nd.length;
      return Nd.push(a), c;
    }
    var Qg = [];
    function Cw(a) {
      for (var c = "", d = 0; d < a; ++d) c += (d !== 0 ? ", " : "") + "arg" + d;
      var p = "return function emval_allocator_" + a + `(constructor, argTypes, args) {
  var HEAPU32 = getMemory();
`;
      for (d = 0; d < a; ++d) p += "var argType" + d + " = requireRegisteredType(HEAPU32[((argTypes)>>2)], 'parameter " + d + `');
var arg` + d + " = argType" + d + `.readValueFromPointer(args);
args += argType` + d + `['argPackAdvance'];
argTypes += 4;
`;
      return new Function("requireRegisteredType", "Module", "valueToHandle", "getMemory", p + ("var obj = new constructor(" + c + `);
return valueToHandle(obj);
}
`))(Ul, e, ds, () => it);
    }
    var tp = {}, Od = [];
    function Sw(a, c) {
      if (qh = a, Kh = c, jl) {
        if (a == 0) Yo = function() {
          var p = Math.max(0, rp + c - Gh()) | 0;
          setTimeout(Wl, p);
        };
        else if (a == 1) Yo = function() {
          Bd(Wl);
        };
        else if (a == 2) {
          if (typeof setImmediate > "u") {
            var d = [];
            addEventListener("message", (p) => {
              (p.data === "setimmediate" || p.data.target === "setimmediate") && (p.stopPropagation(), d.shift()());
            }, !0), setImmediate = function(p) {
              d.push(p), u ? (e.setImmediates === void 0 && (e.setImmediates = []), e.setImmediates.push(p), postMessage({ target: "setimmediate" })) : postMessage(
                "setimmediate",
                "*"
              );
            };
          }
          Yo = function() {
            setImmediate(Wl);
          };
        }
      }
    }
    var Gh;
    Gh = f ? () => {
      var a = process.hrtime();
      return 1e3 * a[0] + a[1] / 1e6;
    } : () => performance.now();
    function ep(a) {
      l(a, new xt(a));
    }
    function ip(a) {
      a instanceof xt || a == "unwind" || l(1, a);
    }
    function Mw(a) {
      !jl || pe("emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."), jl = a;
      var c = Va;
      Wl = function() {
        if (!B) if (0 < sp.length) {
          var d = Date.now(), p = sp.shift();
          p.kl(p.el);
          var w;
          C('main loop blocker "' + p.name + '" took ' + (Date.now() - d) + " ms"), e.setStatus && (d = e.statusMessage || "Please wait...", p = Ew, w = kw.jl, p ? p < w ? e.setStatus(d + " (" + (w - p) + "/" + w + ")") : e.setStatus(d) : e.setStatus("")), c < Va || setTimeout(Wl, 0);
        } else c < Va || (Ld = Ld + 1 | 0, qh == 1 && 1 < Kh && Ld % Kh != 0 ? Yo() : (qh == 0 && (rp = Gh()), B || e.preMainLoop && e.preMainLoop() === !1 || (Rd(a), e.postMainLoop && e.postMainLoop()), c < Va || (typeof SDL == "object" && SDL.audio && SDL.audio.Lk && SDL.audio.Lk(), Yo())));
      };
    }
    function Rd(a) {
      if (!B) try {
        a();
      } catch (c) {
        ip(c);
      }
    }
    function np(a, c) {
      setTimeout(function() {
        Rd(a);
      }, c);
    }
    function Pw(a) {
      $h || ($h = {}), $h[a] || ($h[a] = 1, f && (a = "warning: " + a), M(a));
    }
    var $h, Yo = null, Va = 0, jl = null, qh = 0, Kh = 0, Ld = 0, sp = [], kw = {}, rp, Wl, Ew, za = !1, op = !1, Aw = [];
    function Fd() {
      function a() {
        op = document.pointerLockElement === e.canvas || document.mozPointerLockElement === e.canvas || document.webkitPointerLockElement === e.canvas || document.msPointerLockElement === e.canvas;
      }
      if (e.preloadPlugins || (e.preloadPlugins = []), !lp) {
        lp = !0;
        try {
          Ua = !0;
        } catch {
          Ua = !1, M("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Hd = typeof MozBlobBuilder < "u" ? MozBlobBuilder : typeof WebKitBlobBuilder < "u" ? WebKitBlobBuilder : Ua ? null : M("warning: no BlobBuilder"), yo = typeof window < "u" ? window.URL ? window.URL : window.webkitURL : void 0, e.fk || typeof yo < "u" || (M("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available."), e.fk = !0), e.preloadPlugins.push({ canHandle: function(d) {
          return !e.fk && /\.(jpg|jpeg|png|bmp)$/i.test(d);
        }, handle: function(d, p, w, k) {
          var L = null;
          if (Ua) try {
            L = new Blob([d], { type: Vd(p) }), L.size !== d.length && (L = new Blob([new Uint8Array(d).buffer], { type: Vd(p) }));
          } catch (ct) {
            Pw("Blob constructor present but fails: " + ct + "; falling back to blob builder");
          }
          L || (L = new Hd(), L.append(new Uint8Array(d).buffer), L = L.getBlob());
          var z = yo.createObjectURL(L), Z = new Image();
          Z.onload = () => {
            Z.complete || pe("Image " + p + " could not be decoded");
            var ct = document.createElement("canvas");
            ct.width = Z.width, ct.height = Z.height, ct.getContext("2d").drawImage(Z, 0, 0), yo.revokeObjectURL(z), w && w(d);
          }, Z.onerror = () => {
            C("Image " + z + " could not be decoded"), k && k();
          }, Z.src = z;
        } }), e.preloadPlugins.push({ canHandle: function(d) {
          return !e.ql && d.substr(-4) in {
            ".ogg": 1,
            ".wav": 1,
            ".mp3": 1
          };
        }, handle: function(d, p, w, k) {
          function L() {
            Z || (Z = !0, w && w(d));
          }
          function z() {
            Z || (Z = !0, new Audio(), k && k());
          }
          var Z = !1;
          if (Ua) {
            try {
              var ct = new Blob([d], { type: Vd(p) });
            } catch {
              return z();
            }
            ct = yo.createObjectURL(ct);
            var ut = new Audio();
            ut.addEventListener("canplaythrough", () => L(), !1), ut.onerror = function() {
              if (!Z) {
                M("warning: browser could not fully decode audio " + p + ", trying slower base64 approach");
                for (var At = "", Ut = 0, et = 0, bt = 0; bt < d.length; bt++) for (Ut = Ut << 8 | d[bt], et += 8; 6 <= et; ) {
                  var $t = Ut >> et - 6 & 63;
                  et -= 6, At += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[$t];
                }
                et == 2 ? (At += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(Ut & 3) << 4], At += "==") : et == 4 && (At += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(Ut & 15) << 2], At += "="), ut.src = "data:audio/x-" + p.substr(-3) + ";base64," + At, L();
              }
            }, ut.src = ct, np(function() {
              L();
            }, 1e4);
          } else return z();
        } });
        var c = e.canvas;
        c && (c.requestPointerLock = c.requestPointerLock || c.mozRequestPointerLock || c.webkitRequestPointerLock || c.msRequestPointerLock || (() => {
        }), c.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock || document.msExitPointerLock || (() => {
        }), c.exitPointerLock = c.exitPointerLock.bind(document), document.addEventListener("pointerlockchange", a, !1), document.addEventListener("mozpointerlockchange", a, !1), document.addEventListener("webkitpointerlockchange", a, !1), document.addEventListener("mspointerlockchange", a, !1), e.elementPointerLock && c.addEventListener("click", (d) => {
          !op && e.canvas.requestPointerLock && (e.canvas.requestPointerLock(), d.preventDefault());
        }, !1));
      }
    }
    function Tw(a, c, d, p) {
      Fd();
      var w = !1;
      return e.preloadPlugins.forEach(function(k) {
        !w && k.canHandle(c) && (k.handle(a, c, d, p), w = !0);
      }), w;
    }
    function Dw(a, c, d, p) {
      if (c && e.Wi && a == e.canvas) return e.Wi;
      var w;
      if (c) {
        var k = { antialias: !1, alpha: !1, Cj: typeof WebGL2RenderingContext < "u" ? 2 : 1 };
        if (p) for (var L in p) k[L] = p[L];
        if (typeof Wd < "u" && (w = up(a, k))) var z = Mr[w].Qi;
      } else z = a.getContext("2d");
      return z ? (d && (c || typeof A > "u" || pe("cannot set in module if GLctx is used, but we are a non-GL context that would replace it"), e.Wi = z, c && dp(w), e.wl = c, Aw.forEach(function(Z) {
        Z();
      }), Fd()), z) : null;
    }
    var ap = !1, Xh = void 0, Ha = void 0;
    function Nw(a, c) {
      function d() {
        za = !1;
        var k = p.parentNode;
        (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === k ? (p.exitFullscreen = Ow, Xh && p.requestPointerLock(), za = !0, Ha ? (typeof SDL < "u" && (U[SDL.screen >> 2] = it[SDL.screen >> 2] | 8388608), $l(e.canvas), zd()) : $l(p)) : (k.parentNode.insertBefore(p, k), k.parentNode.removeChild(k), Ha ? (typeof SDL < "u" && (U[SDL.screen >> 2] = it[SDL.screen >> 2] & -8388609), $l(e.canvas), zd()) : $l(p)), e.onFullScreen && e.onFullScreen(za), e.onFullscreen && e.onFullscreen(za);
      }
      Xh = a, Ha = c, typeof Xh > "u" && (Xh = !0), typeof Ha > "u" && (Ha = !1);
      var p = e.canvas;
      ap || (ap = !0, document.addEventListener("fullscreenchange", d, !1), document.addEventListener("mozfullscreenchange", d, !1), document.addEventListener("webkitfullscreenchange", d, !1), document.addEventListener("MSFullscreenChange", d, !1));
      var w = document.createElement("div");
      p.parentNode.insertBefore(w, p), w.appendChild(p), w.requestFullscreen = w.requestFullscreen || w.mozRequestFullScreen || w.msRequestFullscreen || (w.webkitRequestFullscreen ? () => w.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : null) || (w.webkitRequestFullScreen ? () => w.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT) : null), w.requestFullscreen();
    }
    function Ow() {
      return za ? ((document.exitFullscreen || document.cancelFullScreen || document.mozCancelFullScreen || document.msExitFullscreen || document.webkitCancelFullScreen || function() {
      }).apply(document, []), !0) : !1;
    }
    var Gl = 0;
    function Bd(a) {
      if (typeof requestAnimationFrame == "function") requestAnimationFrame(a);
      else {
        var c = Date.now();
        if (Gl === 0) Gl = c + 1e3 / 60;
        else for (; c + 2 >= Gl; ) Gl += 1e3 / 60;
        setTimeout(a, Math.max(Gl - c, 0));
      }
    }
    function Rw(a) {
      Bd(function() {
        Rd(a);
      });
    }
    function Vd(a) {
      return { jpg: "image/jpeg", jpeg: "image/jpeg", png: "image/png", bmp: "image/bmp", ogg: "audio/ogg", wav: "audio/wav", mp3: "audio/mpeg" }[a.substr(a.lastIndexOf(".") + 1)];
    }
    var Lw = [];
    function zd() {
      var a = e.canvas;
      Lw.forEach(function(c) {
        c(a.width, a.height);
      });
    }
    function $l(a, c, d) {
      c && d ? (a.cl = c, a.Ak = d) : (c = a.cl, d = a.Ak);
      var p = c, w = d;
      if (e.forcedAspectRatio && 0 < e.forcedAspectRatio && (p / w < e.forcedAspectRatio ? p = Math.round(w * e.forcedAspectRatio) : w = Math.round(p / e.forcedAspectRatio)), (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === a.parentNode && typeof screen < "u") {
        var k = Math.min(screen.width / p, screen.height / w);
        p = Math.round(p * k), w = Math.round(w * k);
      }
      Ha ? (a.width != p && (a.width = p), a.height != w && (a.height = w), typeof a.style < "u" && (a.style.removeProperty("width"), a.style.removeProperty("height"))) : (a.width != c && (a.width = c), a.height != d && (a.height = d), typeof a.style < "u" && (p != c || w != d ? (a.style.setProperty("width", p + "px", "important"), a.style.setProperty("height", w + "px", "important")) : (a.style.removeProperty("width"), a.style.removeProperty("height"))));
    }
    var lp, Ua, Hd, yo;
    function Fw(a) {
      var c = a.getExtension("ANGLE_instanced_arrays");
      c && (a.vertexAttribDivisor = function(d, p) {
        c.vertexAttribDivisorANGLE(d, p);
      }, a.drawArraysInstanced = function(d, p, w, k) {
        c.drawArraysInstancedANGLE(d, p, w, k);
      }, a.drawElementsInstanced = function(d, p, w, k, L) {
        c.drawElementsInstancedANGLE(d, p, w, k, L);
      });
    }
    function Bw(a) {
      var c = a.getExtension("OES_vertex_array_object");
      c && (a.createVertexArray = function() {
        return c.createVertexArrayOES();
      }, a.deleteVertexArray = function(d) {
        c.deleteVertexArrayOES(d);
      }, a.bindVertexArray = function(d) {
        c.bindVertexArrayOES(d);
      }, a.isVertexArray = function(d) {
        return c.isVertexArrayOES(d);
      });
    }
    function Vw(a) {
      var c = a.getExtension("WEBGL_draw_buffers");
      c && (a.drawBuffers = function(d, p) {
        c.drawBuffersWEBGL(d, p);
      });
    }
    var Ud = 1, nr = [], Ne = [], Jr = [], sr = [], Ws = [], Yi = [], Sr = [], Mr = [], Jh = {}, Zi = [], rr = [], ql = [], wo = [], Yh = {}, cp = {}, jd = 4;
    function qt(a) {
      ja || (ja = a);
    }
    function vo(a) {
      for (var c = Ud++, d = a.length; d < c; d++) a[d] = null;
      return c;
    }
    function hp(a, c, d) {
      for (var p = "", w = 0; w < a; ++w) {
        var k = d ? U[d + 4 * w >> 2] : -1;
        p += K(U[c + 4 * w >> 2], 0 > k ? void 0 : k);
      }
      return p;
    }
    function up(a, c) {
      a.ti || (a.ti = a.getContext, a.getContext = function(p, w) {
        return w = a.ti(p, w), p == "webgl" == w instanceof WebGLRenderingContext ? w : null;
      });
      var d = 1 < c.Cj ? a.getContext("webgl2", c) : a.getContext("webgl", c);
      return d ? zw(d, c) : 0;
    }
    function zw(a, c) {
      var d = vo(Mr), p = { ml: d, attributes: c, version: c.Cj, Qi: a };
      return a.canvas && (a.canvas.lk = p), Mr[d] = p, (typeof c.Wj > "u" || c.Wj) && Hw(p), d;
    }
    function dp(a) {
      return ye = Mr[a], e.Wi = A = ye && ye.Qi, !(a && !A);
    }
    function Hw(a) {
      if (a || (a = ye), !a.Ck) {
        a.Ck = !0;
        var c = a.Qi;
        Fw(c), Bw(c), Vw(c), c.gl = c.getExtension("WEBGL_draw_instanced_base_vertex_base_instance"), c.nl = c.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance"), 2 <= a.version && (c.pi = c.getExtension("EXT_disjoint_timer_query_webgl2")), (2 > a.version || !c.pi) && (c.pi = c.getExtension("EXT_disjoint_timer_query")), c.pl = c.getExtension("WEBGL_multi_draw"), (c.getSupportedExtensions() || []).forEach(function(d) {
          d.includes("lose_context") || d.includes("debug") || c.getExtension(d);
        });
      }
    }
    var Wd = {}, ja, ye, Zo = [];
    function fp(a, c, d, p) {
      A.drawElements(a, c, d, p);
    }
    function fs(a, c, d, p) {
      for (var w = 0; w < a; w++) {
        var k = A[d](), L = k && vo(p);
        k ? (k.name = L, p[L] = k) : qt(1282), U[c + 4 * w >> 2] = L;
      }
    }
    function Zh(a, c, d, p, w, k, L, z) {
      c = Ne[c], (a = A[a](c, d)) && (p = z && J(a.name, $, z, p), w && (U[w >> 2] = p), k && (U[k >> 2] = a.size), L && (U[L >> 2] = a.type));
    }
    function Kl(a, c) {
      it[a >> 2] = c, it[a + 4 >> 2] = (c - it[a >> 2]) / 4294967296;
    }
    function Qo(a, c, d) {
      if (c) {
        var p = void 0;
        switch (a) {
          case 36346:
            p = 1;
            break;
          case 36344:
            d != 0 && d != 1 && qt(1280);
            return;
          case 34814:
          case 36345:
            p = 0;
            break;
          case 34466:
            var w = A.getParameter(34467);
            p = w ? w.length : 0;
            break;
          case 33309:
            if (2 > ye.version) {
              qt(1282);
              return;
            }
            p = 2 * (A.getSupportedExtensions() || []).length;
            break;
          case 33307:
          case 33308:
            if (2 > ye.version) {
              qt(1280);
              return;
            }
            p = a == 33307 ? 3 : 0;
        }
        if (p === void 0) switch (w = A.getParameter(a), typeof w) {
          case "number":
            p = w;
            break;
          case "boolean":
            p = w ? 1 : 0;
            break;
          case "string":
            qt(1280);
            return;
          case "object":
            if (w === null) switch (a) {
              case 34964:
              case 35725:
              case 34965:
              case 36006:
              case 36007:
              case 32873:
              case 34229:
              case 36662:
              case 36663:
              case 35053:
              case 35055:
              case 36010:
              case 35097:
              case 35869:
              case 32874:
              case 36389:
              case 35983:
              case 35368:
              case 34068:
                p = 0;
                break;
              default:
                qt(1280);
                return;
            }
            else {
              if (w instanceof Float32Array || w instanceof Uint32Array || w instanceof Int32Array || w instanceof Array) {
                for (a = 0; a < w.length; ++a) switch (d) {
                  case 0:
                    U[c + 4 * a >> 2] = w[a];
                    break;
                  case 2:
                    at[c + 4 * a >> 2] = w[a];
                    break;
                  case 4:
                    H[c + a >> 0] = w[a] ? 1 : 0;
                }
                return;
              }
              try {
                p = w.name | 0;
              } catch (k) {
                qt(1280), M("GL_INVALID_ENUM in glGet" + d + "v: Unknown object returned from WebGL getParameter(" + a + ")! (error: " + k + ")");
                return;
              }
            }
            break;
          default:
            qt(1280), M("GL_INVALID_ENUM in glGet" + d + "v: Native code calling glGet" + d + "v(" + a + ") and it returns " + w + " of type " + typeof w + "!");
            return;
        }
        switch (d) {
          case 1:
            Kl(c, p);
            break;
          case 0:
            U[c >> 2] = p;
            break;
          case 2:
            at[c >> 2] = p;
            break;
          case 4:
            H[c >> 0] = p ? 1 : 0;
        }
      } else qt(1281);
    }
    function gp(a, c, d, p) {
      if (d) {
        switch (c = A.getIndexedParameter(a, c), typeof c) {
          case "boolean":
            a = c ? 1 : 0;
            break;
          case "number":
            a = c;
            break;
          case "object":
            if (c === null) switch (a) {
              case 35983:
              case 35368:
                a = 0;
                break;
              default:
                qt(1280);
                return;
            }
            else if (c instanceof WebGLBuffer) a = c.name | 0;
            else {
              qt(1280);
              return;
            }
            break;
          default:
            qt(1280);
            return;
        }
        switch (p) {
          case 1:
            Kl(d, a);
            break;
          case 0:
            U[d >> 2] = a;
            break;
          case 2:
            at[d >> 2] = a;
            break;
          case 4:
            H[d >> 0] = a ? 1 : 0;
            break;
          default:
            throw "internal emscriptenWebGLGetIndexed() error, bad type: " + p;
        }
      } else qt(1281);
    }
    function Yr(a) {
      var c = rt(a) + 1, d = Yl(c);
      return J(a, $, d, c), d;
    }
    function Gd(a) {
      return a.slice(-1) == "]" && a.lastIndexOf("[");
    }
    function $d(a) {
      var c = a.Pi, d = a.sj, p;
      if (!c) for (a.Pi = c = {}, a.jk = {}, p = 0; p < A.getProgramParameter(a, 35718); ++p) {
        var w = A.getActiveUniform(a, p), k = w.name;
        w = w.size;
        var L = Gd(k);
        L = 0 < L ? k.slice(0, L) : k;
        var z = a.rj;
        for (a.rj += w, d[L] = [w, z], k = 0; k < w; ++k) c[z] = k, a.jk[z++] = L;
      }
    }
    function Zt(a) {
      var c = A.Uj;
      if (c) {
        var d = c.Pi[a];
        return typeof d == "number" && (c.Pi[a] = d = A.getUniformLocation(c, c.jk[a] + (0 < d ? "[" + d + "]" : ""))), d;
      }
      qt(1282);
    }
    function qd(a, c, d, p) {
      if (d) if (a = Ne[a], $d(a), a = A.getUniform(a, Zt(c)), typeof a == "number" || typeof a == "boolean") switch (p) {
        case 0:
          U[d >> 2] = a;
          break;
        case 2:
          at[d >> 2] = a;
      }
      else for (c = 0; c < a.length; c++) switch (p) {
        case 0:
          U[d + 4 * c >> 2] = a[c];
          break;
        case 2:
          at[d + 4 * c >> 2] = a[c];
      }
      else qt(1281);
    }
    function Qh(a, c, d, p) {
      if (d) if (a = A.getVertexAttrib(a, c), c == 34975) U[d >> 2] = a && a.name;
      else if (typeof a == "number" || typeof a == "boolean") switch (p) {
        case 0:
          U[d >> 2] = a;
          break;
        case 2:
          at[d >> 2] = a;
          break;
        case 5:
          U[d >> 2] = Math.fround(a);
      }
      else for (c = 0; c < a.length; c++) switch (p) {
        case 0:
          U[d + 4 * c >> 2] = a[c];
          break;
        case 2:
          at[d + 4 * c >> 2] = a[c];
          break;
        case 5:
          U[d + 4 * c >> 2] = Math.fround(a[c]);
      }
      else qt(1281);
    }
    function bo(a) {
      return a -= 5120, a == 0 ? H : a == 1 ? $ : a == 2 ? D : a == 4 ? U : a == 6 ? at : a == 5 || a == 28922 || a == 28520 || a == 30779 || a == 30782 ? it : R;
    }
    function xo(a) {
      return 31 - Math.clz32(a.BYTES_PER_ELEMENT);
    }
    function Xl(a, c, d, p, w) {
      a = bo(a);
      var k = xo(a), L = jd;
      return a.subarray(w >> k, w + p * (d * ({ 5: 3, 6: 4, 8: 2, 29502: 3, 29504: 4, 26917: 2, 26918: 2, 29846: 3, 29847: 4 }[c - 6402] || 1) * (1 << k) + L - 1 & -L) >> k);
    }
    var gs = [], Jl = [], tu = [], Uw = {}, jw = ["default", "low-power", "high-performance"], Ww = [0, typeof document < "u" ? document : 0, typeof window < "u" ? window : 0];
    function Gw(a) {
      try {
        return a ? (typeof a == "number" && (a = Ww[a] || K(a)), a === "#window" ? window : a === "#document" ? document : a === "#screen" ? screen : a === "#canvas" ? e.canvas : typeof a == "string" ? document.getElementById(a) : a) : window;
      } catch {
        return null;
      }
    }
    var Kd = {};
    function pp() {
      if (!Xd) {
        var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: o || "./this.program" }, c;
        for (c in Kd) Kd[c] === void 0 ? delete a[c] : a[c] = Kd[c];
        var d = [];
        for (c in a) d.push(c + "=" + a[c]);
        Xd = d;
      }
      return Xd;
    }
    var Xd;
    function mp(a, c) {
      a = new Uint8Array(a);
      var d = a.byteLength;
      if (e.bk += d + 24, 327680 >= d) {
        var p = nu();
        try {
          var w = Zl(d);
          $.subarray(w, w + d).set(a), c(w, d);
        } finally {
          su(p);
        }
      } else {
        w = Yl(d);
        try {
          $.subarray(w, w + d).set(a), c(w, d);
        } finally {
          Pr(w);
        }
      }
    }
    var ta = { connect: function(a, c, d) {
      if (e.vj = c, e.oj = Wa("webSocketHandlerOnMessage", null, ["number", "number", "number", "number"]), e.Mi ? e.Mi++ : e.Mi = 1, e.ik = !1, !e.worker) {
        a = new Worker(URL.createObjectURL(new Blob(['var socket;self.onmessage = function (event) {	if (event.data.constructor === ArrayBuffer) {		socket.send (event.data);	} else if (event.data[0] === "connect") {		socket = new WebSocket (event.data[1]);		socket.binaryType = "arraybuffer";		var token = event.data[2];		socket.onclose = function (event) {			self.postMessage (["close", token]);		};		socket.onerror = function (event) {			self.postMessage (["error", token]);		};		socket.onopen = function (event) {			self.postMessage (["open", token]);		};		socket.onmessage = function (event) {			self.postMessage (["data", event.data, token], [event.data]);		};	} else if (event.data[0] === "close") {		socket.close ();	}}'], { type: "application/javascript" }))), e.worker = a;
        var p = function(w, k) {
          e.oj(w, k, e.vj, 2);
        };
        a.onmessage = function(w) {
          e.$$facade && (w.data[0] === "data" ? w.data[2] === e.Mi && mp(w.data[1], p) : w.data[0] === "open" ? w.data[1] === e.Mi && (e.ik = !0, e.oj(0, 0, e.vj, 0)) : w.data[0] === "close" ? w.data[1] === e.Mi && (e.oj(0, 0, e.vj, 3), e.ki("websocket_connection_closed")) : w.data[0] === "error" && w.data[1] === e.Mi && e.ki(e.ik ? "socket_error" : "socket_open_failed"));
        };
      }
      e.worker.postMessage(["connect", K(d), e.Mi]);
    }, Jj: function(a, c) {
      e.worker && (a = new Uint8Array($.subarray(a, a + c)).buffer, e.worker.postMessage(a, [a]));
    }, close: function() {
      e.worker && e.worker.postMessage(["close"]), e.oj = function() {
      };
    } }, ea = { connect: function(a, c, d) {
      function p(z, Z) {
        k(z, Z, c, 2);
      }
      a = K(d);
      var w = new WebSocket(a);
      e.Fi = w, w.binaryType = "arraybuffer";
      var k = Wa("webSocketHandlerOnMessage", null, ["number", "number", "number", "number"]), L = !1;
      w.onclose = function() {
        e.Fi === w && (k(0, 0, c, 3), e.ki("websocket_connection_closed"));
      }, w.onerror = function() {
        e.Fi === w && e.ki(L ? "socket_error" : "socket_open_failed");
      }, w.onopen = function() {
        e.Fi === w && (L = !0, k(0, 0, c, 0));
      }, w.onmessage = function(z) {
        e.Fi === w && mp(z.data, p);
      };
    }, Jj: function(a, c) {
      e.Fi && e.Fi.send($.subarray(a, a + c));
    }, close: function() {
      e.Fi && e.Fi.close(), delete e.Fi;
    } };
    function eu(a) {
      return a % 4 === 0 && (a % 100 !== 0 || a % 400 === 0);
    }
    var _p = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], yp = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function $w(a, c, d, p) {
      function w(et, bt, $t) {
        for (et = typeof et == "number" ? et.toString() : et || ""; et.length < bt; ) et = $t[0] + et;
        return et;
      }
      function k(et, bt) {
        return w(et, bt, "0");
      }
      function L(et, bt) {
        function $t(Ue) {
          return 0 > Ue ? -1 : 0 < Ue ? 1 : 0;
        }
        var Me;
        return (Me = $t(et.getFullYear() - bt.getFullYear())) === 0 && (Me = $t(et.getMonth() - bt.getMonth())) === 0 && (Me = $t(et.getDate() - bt.getDate())), Me;
      }
      function z(et) {
        switch (et.getDay()) {
          case 0:
            return new Date(et.getFullYear() - 1, 11, 29);
          case 1:
            return et;
          case 2:
            return new Date(et.getFullYear(), 0, 3);
          case 3:
            return new Date(
              et.getFullYear(),
              0,
              2
            );
          case 4:
            return new Date(et.getFullYear(), 0, 1);
          case 5:
            return new Date(et.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(et.getFullYear() - 1, 11, 30);
        }
      }
      function Z(et) {
        var bt = et.Ni;
        for (et = new Date(new Date(et.Oi + 1900, 0, 1).getTime()); 0 < bt; ) {
          var $t = et.getMonth(), Me = (eu(et.getFullYear()) ? _p : yp)[$t];
          if (bt > Me - et.getDate()) bt -= Me - et.getDate() + 1, et.setDate(1), 11 > $t ? et.setMonth($t + 1) : (et.setMonth(0), et.setFullYear(et.getFullYear() + 1));
          else {
            et.setDate(et.getDate() + bt);
            break;
          }
        }
        return $t = new Date(et.getFullYear() + 1, 0, 4), bt = z(new Date(
          et.getFullYear(),
          0,
          4
        )), $t = z($t), 0 >= L(bt, et) ? 0 >= L($t, et) ? et.getFullYear() + 1 : et.getFullYear() : et.getFullYear() - 1;
      }
      var ct = U[p + 40 >> 2];
      p = { $k: U[p >> 2], Zk: U[p + 4 >> 2], pj: U[p + 8 >> 2], Nj: U[p + 12 >> 2], qj: U[p + 16 >> 2], Oi: U[p + 20 >> 2], zi: U[p + 24 >> 2], Ni: U[p + 28 >> 2], ul: U[p + 32 >> 2], Yk: U[p + 36 >> 2], al: ct ? K(ct) : "" }, d = K(d), ct = {
        "%c": "%a %b %d %H:%M:%S %Y",
        "%D": "%m/%d/%y",
        "%F": "%Y-%m-%d",
        "%h": "%b",
        "%r": "%I:%M:%S %p",
        "%R": "%H:%M",
        "%T": "%H:%M:%S",
        "%x": "%m/%d/%y",
        "%X": "%H:%M:%S",
        "%Ec": "%c",
        "%EC": "%C",
        "%Ex": "%m/%d/%y",
        "%EX": "%H:%M:%S",
        "%Ey": "%y",
        "%EY": "%Y",
        "%Od": "%d",
        "%Oe": "%e",
        "%OH": "%H",
        "%OI": "%I",
        "%Om": "%m",
        "%OM": "%M",
        "%OS": "%S",
        "%Ou": "%u",
        "%OU": "%U",
        "%OV": "%V",
        "%Ow": "%w",
        "%OW": "%W",
        "%Oy": "%y"
      };
      for (var ut in ct) d = d.replace(new RegExp(ut, "g"), ct[ut]);
      var At = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), Ut = "January February March April May June July August September October November December".split(" ");
      ct = {
        "%a": function(et) {
          return At[et.zi].substring(0, 3);
        },
        "%A": function(et) {
          return At[et.zi];
        },
        "%b": function(et) {
          return Ut[et.qj].substring(0, 3);
        },
        "%B": function(et) {
          return Ut[et.qj];
        },
        "%C": function(et) {
          return k((et.Oi + 1900) / 100 | 0, 2);
        },
        "%d": function(et) {
          return k(et.Nj, 2);
        },
        "%e": function(et) {
          return w(et.Nj, 2, " ");
        },
        "%g": function(et) {
          return Z(et).toString().substring(2);
        },
        "%G": function(et) {
          return Z(et);
        },
        "%H": function(et) {
          return k(et.pj, 2);
        },
        "%I": function(et) {
          return et = et.pj, et == 0 ? et = 12 : 12 < et && (et -= 12), k(et, 2);
        },
        "%j": function(et) {
          for (var bt = 0, $t = 0; $t <= et.qj - 1; bt += (eu(et.Oi + 1900) ? _p : yp)[$t++]) ;
          return k(et.Nj + bt, 3);
        },
        "%m": function(et) {
          return k(et.qj + 1, 2);
        },
        "%M": function(et) {
          return k(et.Zk, 2);
        },
        "%n": function() {
          return `
`;
        },
        "%p": function(et) {
          return 0 <= et.pj && 12 > et.pj ? "AM" : "PM";
        },
        "%S": function(et) {
          return k(et.$k, 2);
        },
        "%t": function() {
          return "	";
        },
        "%u": function(et) {
          return et.zi || 7;
        },
        "%U": function(et) {
          return k(Math.floor((et.Ni + 7 - et.zi) / 7), 2);
        },
        "%V": function(et) {
          var bt = Math.floor((et.Ni + 7 - (et.zi + 6) % 7) / 7);
          if (2 >= (et.zi + 371 - et.Ni - 2) % 7 && bt++, bt) bt == 53 && ($t = (et.zi + 371 - et.Ni) % 7, $t == 4 || $t == 3 && eu(et.Oi) || (bt = 1));
          else {
            bt = 52;
            var $t = (et.zi + 7 - et.Ni - 1) % 7;
            ($t == 4 || $t == 5 && eu(et.Oi % 400 - 1)) && bt++;
          }
          return k(bt, 2);
        },
        "%w": function(et) {
          return et.zi;
        },
        "%W": function(et) {
          return k(Math.floor((et.Ni + 7 - (et.zi + 6) % 7) / 7), 2);
        },
        "%y": function(et) {
          return (et.Oi + 1900).toString().substring(2);
        },
        "%Y": function(et) {
          return et.Oi + 1900;
        },
        "%z": function(et) {
          et = et.Yk;
          var bt = 0 <= et;
          return et = Math.abs(et) / 60, (bt ? "+" : "-") + ("0000" + (et / 60 * 100 + et % 60)).slice(-4);
        },
        "%Z": function(et) {
          return et.al;
        },
        "%%": function() {
          return "%";
        }
      }, d = d.replace(/%%/g, "\0\0");
      for (ut in ct) d.includes(ut) && (d = d.replace(new RegExp(ut, "g"), ct[ut](p)));
      return d = d.replace(/\0\0/g, "%"), ut = Fn(d, !1), ut.length > c ? 0 : (H.set(ut, a), ut.length - 1);
    }
    function Jd(a, c, d, p) {
      var w = { string: (ct) => {
        var ut = 0;
        if (ct != null && ct !== 0) {
          var At = (ct.length << 2) + 1;
          ut = Zl(At), J(ct, $, ut, At);
        }
        return ut;
      }, array: (ct) => {
        var ut = Zl(ct.length);
        return H.set(ct, ut), ut;
      } };
      a = e["_" + a];
      var k = [], L = 0;
      if (p) for (var z = 0; z < p.length; z++) {
        var Z = w[d[z]];
        Z ? (L === 0 && (L = nu()), k[z] = Z(p[z])) : k[z] = p[z];
      }
      return d = a.apply(null, k), d = function(ct) {
        return L !== 0 && su(L), c === "string" ? K(ct) : c === "boolean" ? !!ct : ct;
      }(d);
    }
    function Wa(a, c, d, p) {
      d = d || [];
      var w = d.every((k) => k === "number" || k === "boolean");
      return c !== "string" && w && !p ? e["_" + a] : function() {
        return Jd(a, c, d, arguments);
      };
    }
    function wp(a, c, d, p) {
      a || (a = this), this.parent = a, this.Di = a.Di, this.Xi = null, this.id = kn++, this.name = c, this.mode = d, this.hi = {}, this.ii = {}, this.rdev = p;
    }
    Object.defineProperties(wp.prototype, { read: { get: function() {
      return (this.mode & 365) === 365;
    }, set: function(a) {
      a ? this.mode |= 365 : this.mode &= -366;
    } }, write: { get: function() {
      return (this.mode & 146) === 146;
    }, set: function(a) {
      a ? this.mode |= 146 : this.mode &= -147;
    } }, Fk: { get: function() {
      return (this.mode & 61440) === 16384;
    } }, Ek: { get: function() {
      return (this.mode & 61440) === 8192;
    } } }), me(), Je = Array(4096), Rl(te, "/"), Vn("/tmp", 16895, 0), Vn("/home", 16895, 0), Vn("/home/web_user", 16895, 0), (() => {
      Vn("/dev", 16895, 0), Ol(259, { read: () => 0, write: (c, d, p, w) => w }), v("/dev/null", 259), ns(1280, Vs), ns(1536, zs), v("/dev/tty", 1280), v("/dev/tty1", 1536);
      var a = xe();
      hn("/dev", "random", a), hn("/dev", "urandom", a), Vn("/dev/shm", 16895, 0), Vn("/dev/shm/tmp", 16895, 0);
    })(), (() => {
      Vn("/proc", 16895, 0);
      var a = Vn("/proc/self", 16895, 0);
      Vn("/proc/self/fd", 16895, 0), Rl({ Di: () => {
        var c = Fh(a, "fd", 16895, 73);
        return c.hi = { lookup: (d, p) => {
          var w = Bn[+p];
          if (!w) throw new Ft(8);
          return d = { parent: null, Di: { dk: "fake" }, hi: { readlink: () => w.path } }, d.parent = d;
        } }, c;
      } }, "/proc/self/fd");
    })(), e.FS_createPath = bi, e.FS_createDataFile = Ai, e.FS_createPreloadedFile = Kn, e.FS_unlink = E, e.FS_createLazyFile = Jo, e.FS_createDevice = hn, de = e.InternalError = Gt("InternalError");
    for (var vp = Array(256), iu = 0; 256 > iu; ++iu) vp[iu] = String.fromCharCode(iu);
    Ll = vp, Ba = e.BindingError = Gt("BindingError"), _o.prototype.isAliasOf = function(a) {
      if (!(this instanceof _o && a instanceof _o)) return !1;
      var c = this.fi.ni.ji, d = this.fi.li, p = a.fi.ni.ji;
      for (a = a.fi.li; c.xi; ) d = c.$i(d), c = c.xi;
      for (; p.xi; ) a = p.$i(a), p = p.xi;
      return c === p && d === a;
    }, _o.prototype.clone = function() {
      if (this.fi.li || Pd(this), this.fi.Yi) return this.fi.count.value += 1, this;
      var a = zl, c = Object, d = c.create, p = Object.getPrototypeOf(this), w = this.fi;
      return a = a(d.call(c, p, { fi: { value: { count: w.count, Ri: w.Ri, Yi: w.Yi, li: w.li, ni: w.ni, ri: w.ri, wi: w.wi } } })), a.fi.count.value += 1, a.fi.Ri = !1, a;
    }, _o.prototype.delete = function() {
      this.fi.li || Pd(this), this.fi.Ri && !this.fi.Yi && He("Object already scheduled for deletion"), Bg(this), Vg(this.fi), this.fi.Yi || (this.fi.ri = void 0, this.fi.li = void 0);
    }, _o.prototype.isDeleted = function() {
      return !this.fi.li;
    }, _o.prototype.deleteLater = function() {
      return this.fi.li || Pd(this), this.fi.Ri && !this.fi.Yi && He("Object already scheduled for deletion"), Fl.push(this), Fl.length === 1 && Bl && Bl(Ed), this.fi.Ri = !0, this;
    }, e.getInheritedInstanceCount = function() {
      return Object.keys(Vl).length;
    }, e.getLiveInheritedInstances = function() {
      var a = [], c;
      for (c in Vl) Vl.hasOwnProperty(c) && a.push(Vl[c]);
      return a;
    }, e.flushPendingDeletes = Ed, e.setDelayFunction = function(a) {
      Bl = a, Fl.length && Bl && Bl(Ed);
    }, Cr.prototype.xk = function(a) {
      return this.gk && (a = this.gk(a)), a;
    }, Cr.prototype.Vj = function(a) {
      this.vi && this.vi(a);
    }, Cr.prototype.argPackAdvance = 8, Cr.prototype.readValueFromPointer = xi, Cr.prototype.deleteObject = function(a) {
      a !== null && a.delete();
    }, Cr.prototype.fromWireType = function(a) {
      function c() {
        return this.ij ? Uh(this.ji.Ki, { ni: this.Kk, li: d, wi: this, ri: a }) : Uh(this.ji.Ki, { ni: this, li: a });
      }
      var d = this.xk(a);
      if (!d) return this.Vj(a), null;
      var p = ow(this.ji, d);
      if (p !== void 0)
        return p.fi.count.value === 0 ? (p.fi.li = d, p.fi.ri = a, p.clone()) : (p = p.clone(), this.Vj(a), p);
      if (p = this.ji.wk(d), p = Hg[p], !p) return c.call(this);
      p = this.hj ? p.rk : p.pointerType;
      var w = zg(d, this.ji, p.ji);
      return w === null ? c.call(this) : this.ij ? Uh(p.ji.Ki, { ni: p, li: w, wi: this, ri: a }) : Uh(
        p.ji.Ki,
        { ni: p, li: w }
      );
    }, Wg = e.UnboundTypeError = Gt("UnboundTypeError"), e.count_emval_handles = function() {
      for (var a = 0, c = 5; c < er.length; ++c) er[c] !== void 0 && ++a;
      return a;
    }, e.get_first_emval = function() {
      for (var a = 5; a < er.length; ++a) if (er[a] !== void 0) return er[a];
      return null;
    }, e.requestFullscreen = function(a, c) {
      Nw(a, c);
    }, e.requestAnimationFrame = function(a) {
      Bd(a);
    }, e.setCanvasSize = function(a, c, d) {
      $l(e.canvas, a, c), d || zd();
    }, e.pauseMainLoop = function() {
      Yo = null, Va++;
    }, e.resumeMainLoop = function() {
      Va++;
      var a = qh, c = Kh, d = jl;
      jl = null, Mw(d), Sw(a, c), Yo();
    }, e.getUserMedia = function() {
      window.getUserMedia || (window.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia), window.getUserMedia(void 0);
    }, e.createContext = function(a, c, d, p) {
      return Dw(a, c, d, p);
    };
    for (var A, Ps = 0; 32 > Ps; ++Ps) Zo.push(Array(Ps));
    var qw = new Float32Array(288);
    for (Ps = 0; 288 > Ps; ++Ps) gs[Ps] = qw.subarray(0, Ps + 1);
    var Kw = new Int32Array(288);
    for (Ps = 0; 288 > Ps; ++Ps) Jl[Ps] = Kw.subarray(0, Ps + 1);
    var Xw = {
      Ka: function(a, c, d) {
        nt[a] = void 0;
        try {
          var p = [new Float32Array(c), new Uint16Array(d)];
        } catch {
          return 0;
        }
        return nt[a] = p, 1;
      },
      Ja: function(a, c, d, p, w) {
        nt[a] = void 0, d >>= 2, w >>= 1;
        try {
          var k = [new Float32Array(at.subarray(d, d + c)), new Uint16Array(R.subarray(w, w + p))];
        } catch {
          return 0;
        }
        return nt[a] = k, 1;
      },
      La: function(a) {
        nt[a] = void 0;
      },
      Na: function() {
        if (kt.length) return kt.pop();
        var a = nt.length;
        return nt[a] = void 0, a;
      },
      Ma: function(a) {
        nt[a] = void 0, kt.push(a);
      },
      Dh: function(a, c) {
        return !c || (a = nt[a], !a) ? 0 : (a = a[1], a.length ? (R.set(a, c >> 1), 1) : 0);
      },
      Eh: function(a, c) {
        return !c || (a = nt[a], !a) ? 0 : (a = a[0], a.length ? (at.set(a, c >> 2), 1) : 0);
      },
      Gh: function(a) {
        return (a = nt[a]) ? a[1].length : 0;
      },
      Bh: function(a, c) {
        return a = nt[a], a ? (a = a[1], a.length ? (A.bufferSubData(A.ELEMENT_ARRAY_BUFFER, c, a), 1) : 0) : 0;
      },
      zh: function(a, c, d, p) {
        if (a = nt[a], !a) return 0;
        a = a[1];
        try {
          var w = new Uint8Array(a.buffer, c, d);
        } catch {
          return 0;
        }
        return w.length ? (A.bufferSubData(A.ELEMENT_ARRAY_BUFFER, p, w), 1) : 0;
      },
      Ch: function(a, c) {
        return a = nt[a], a ? (a = a[0], a.length ? (A.bufferSubData(A.ARRAY_BUFFER, c, a), 1) : 0) : 0;
      },
      Ah: function(a, c, d, p) {
        if (a = nt[a], !a) return 0;
        a = a[0];
        try {
          var w = new Uint8Array(a.buffer, c, d);
        } catch {
          return 0;
        }
        return w.length ? (A.bufferSubData(A.ARRAY_BUFFER, p, w), 1) : 0;
      },
      Fh: function(a, c, d, p) {
        return a = nt[a], a ? (a = a[0], a.length && c < a.length && a.length - c >= d ? (p >>= 2, a.set(at.subarray(p, p + d), c), 1) : 0) : 0;
      },
      Hh: function(a) {
        return (a = nt[a]) ? a[0].length : 0;
      },
      wb: function(a, c) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), e.ki(
          "announce_model",
          a,
          c
        );
      },
      Y: function(a, c, d) {
        var p = e.$$facade;
        if (p) {
          var w = e.callAfterMap, k = ++w.index, L = function(z) {
            p === e.$$facade && Jd("callFuncWrapper", null, ["number", "number", "number"], [a, !z, c]), delete w.indexedWrappers[k];
          };
          w.indexedWrappers[k] = L, 0 <= d ? np(L, d) : Rw(L);
        }
      },
      Td: function() {
        for (var a = e.callAfterMap, c = a.indexedWrappers, d = Object.keys(c), p = 0; p < d.length; ++p) c[d[p]](!0);
        a.indexedWrappers = {}, a.index = 0;
      },
      vb: function(a, c) {
        e.ki("capping_idle", !!a, c);
      },
      pb: function(a) {
        0 > a && (a += 4294967296), e.ki("data_access_attached", a);
      },
      ob: function() {
        e.ki("first_instance");
      },
      X: function(a) {
        e.ki(K(a));
      },
      ha: function(a, c) {
        c = K(c);
        try {
          var d = JSON.parse(c);
        } catch {
          d = c;
        }
        e.ki(K(a), d);
      },
      ub: function(a, c, d) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), 0 > d && (d += 4294967296), e.ki("inclusion", a, c, d);
      },
      nc: function(a, c, d, p) {
        e.ki("meta_data", a, c, e.HEAPU8.subarray(d, d + p));
      },
      tb: function(a, c) {
        0 > a && (a += 4294967296), c = K(c), e.ki("missing_model", a, c);
      },
      Cb: function(a) {
        e.ki("network_receive_data", a);
      },
      nb: function(a) {
        e.ki("post_draw_json", "{" + K(a) + "}");
      },
      qb: function(a, c) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), e.ki("priority_meta_data_sent", a, c);
      },
      rb: function(a, c, d, p) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), 0 > d && (d += 4294967296), 0 > p && (p += 4294967296), e.ki("remap_inclusion", a, c, d, p);
      },
      sb: function(a, c, d) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), 0 > d && (d += 4294967296), e.ki("remap_model", a, c, d);
      },
      h: function(a, c) {
        e.tj && (a = e.HEAP8.buffer.slice(a, c), e.tj.Ok(a));
      },
      cc: function() {
        e.ki("session_started");
      },
      xd: function() {
        e.$$setReady();
      },
      l: function(a, c, d, p) {
        pe("Assertion failed: " + K(a) + ", at: " + [
          c ? K(c) : "unknown filename",
          d,
          p ? K(p) : "unknown function"
        ]);
      },
      ua: function(a, c, d) {
        ae = d;
        try {
          var p = Ee(a);
          switch (c) {
            case 0:
              var w = ce();
              return 0 > w ? -28 : zh(p, w).fd;
            case 1:
            case 2:
              return 0;
            case 3:
              return p.flags;
            case 4:
              return w = ce(), p.flags |= w, 0;
            case 5:
              return w = ce(), D[w + 0 >> 1] = 2, 0;
            case 6:
            case 7:
              return 0;
            case 16:
            case 8:
              return -28;
            case 9:
              return U[bp() >> 2] = 28, -1;
            default:
              return -28;
          }
        } catch (k) {
          if (typeof ss > "u" || !(k instanceof Ft)) throw k;
          return -k.Gi;
        }
      },
      Gb: function(a, c, d) {
        ae = d;
        try {
          var p = Ee(a);
          switch (c) {
            case 21509:
            case 21505:
              return p.tty ? 0 : -59;
            case 21510:
            case 21511:
            case 21512:
            case 21506:
            case 21507:
            case 21508:
              return p.tty ? 0 : -59;
            case 21519:
              if (!p.tty) return -59;
              var w = ce();
              return U[w >> 2] = 0;
            case 21520:
              return p.tty ? -28 : -59;
            case 21531:
              if (a = w = ce(), !p.ii.Dk) throw new Ft(59);
              return p.ii.Dk(p, c, a);
            case 21523:
              return p.tty ? 0 : -59;
            case 21524:
              return p.tty ? 0 : -59;
            default:
              return -28;
          }
        } catch (k) {
          if (typeof ss > "u" || !(k instanceof Ft)) throw k;
          return -k.Gi;
        }
      },
      Hb: function(a, c, d, p) {
        ae = p;
        try {
          c = K(c);
          var w = c;
          if (w.charAt(0) === "/") c = w;
          else {
            var k = a === -100 ? "/" : Ee(a).path;
            if (w.length == 0) throw new Ft(44);
            c = Tt(k + "/" + w);
          }
          var L = p ? ce() : 0;
          return tt(c, d, L).fd;
        } catch (z) {
          if (typeof ss > "u" || !(z instanceof Ft)) throw z;
          return -z.Gi;
        }
      },
      w: function(a) {
        var c = mi[a];
        delete mi[a];
        var d = c.elements, p = d.length, w = d.map(function(z) {
          return z.zj;
        }).concat(d.map(function(z) {
          return z.Lj;
        })), k = c.Zi, L = c.vi;
        ze([a], w, function(z) {
          return d.forEach((Z, ct) => {
            var ut = z[ct], At = Z.Si, Ut = Z.yj, et = z[ct + p], bt = Z.Kj, $t = Z.Mj;
            Z.read = (Me) => ut.fromWireType(At(Ut, Me)), Z.write = (Me, Ue) => {
              var Li = [];
              bt($t, Me, et.toWireType(Li, Ue)), Ti(Li);
            };
          }), [{
            name: c.name,
            fromWireType: function(Z) {
              for (var ct = Array(p), ut = 0; ut < p; ++ut) ct[ut] = d[ut].read(Z);
              return L(Z), ct;
            },
            toWireType: function(Z, ct) {
              if (p !== ct.length) throw new TypeError("Incorrect number of tuple elements for " + c.name + ": expected=" + p + ", actual=" + ct.length);
              for (var ut = k(), At = 0; At < p; ++At) d[At].write(ut, ct[At]);
              return Z !== null && Z.push(L, ut), ut;
            },
            argPackAdvance: 8,
            readValueFromPointer: xi,
            si: L
          }];
        });
      },
      L: function(a) {
        var c = Xi[a];
        delete Xi[a];
        var d = c.Zi, p = c.vi, w = c.Yj, k = w.map((L) => L.zj).concat(w.map((L) => L.Lj));
        ze([a], k, (L) => {
          var z = {};
          return w.forEach((Z, ct) => {
            var ut = L[ct], At = Z.Si, Ut = Z.yj, et = L[ct + w.length], bt = Z.Kj, $t = Z.Mj;
            z[Z.vk] = { read: (Me) => ut.fromWireType(At(Ut, Me)), write: (Me, Ue) => {
              var Li = [];
              bt($t, Me, et.toWireType(Li, Ue)), Ti(Li);
            } };
          }), [{ name: c.name, fromWireType: function(Z) {
            var ct = {}, ut;
            for (ut in z) ct[ut] = z[ut].read(Z);
            return p(Z), ct;
          }, toWireType: function(Z, ct) {
            for (var ut in z) if (!(ut in ct)) throw new TypeError('Missing field:  "' + ut + '"');
            var At = d();
            for (ut in z) z[ut].write(At, ct[ut]);
            return Z !== null && Z.push(p, At), At;
          }, argPackAdvance: 8, readValueFromPointer: xi, si: p }];
        });
      },
      yb: function() {
      },
      Tg: function(a, c, d, p, w) {
        var k = js(d);
        c = Ji(c), Ir(a, { name: c, fromWireType: function(L) {
          return !!L;
        }, toWireType: function(L, z) {
          return z ? p : w;
        }, argPackAdvance: 8, readValueFromPointer: function(L) {
          if (d === 1) var z = H;
          else if (d === 2) z = D;
          else if (d === 4) z = U;
          else throw new TypeError("Unknown boolean type size: " + c);
          return this.fromWireType(z[L >> k]);
        }, si: null });
      },
      _: function(a, c, d, p, w, k, L, z, Z, ct, ut, At, Ut) {
        ut = Ji(ut), k = dn(w, k), z && (z = dn(L, z)), ct && (ct = dn(Z, ct)), Ut = dn(At, Ut);
        var et = dt(ut);
        jg(et, function() {
          Hl(
            "Cannot construct " + ut + " due to unbound types",
            [p]
          );
        }), ze([a, c, d], p ? [p] : [], function(bt) {
          if (bt = bt[0], p)
            var $t = bt.ji, Me = $t.Ki;
          else Me = _o.prototype;
          bt = Ot(et, function() {
            if (Object.getPrototypeOf(this) !== Ue) throw new Ba("Use 'new' to construct " + ut);
            if (Li.Ii === void 0) throw new Ba(ut + " has no accessible constructor");
            var Dt = Li.Ii[arguments.length];
            if (Dt === void 0) throw new Ba("Tried to invoke ctor of " + ut + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(Li.Ii).toString() + ") parameters instead!");
            return Dt.apply(this, arguments);
          });
          var Ue = Object.create(Me, { constructor: { value: bt } });
          bt.prototype = Ue;
          var Li = new aw(ut, bt, Ue, Ut, $t, k, z, ct);
          $t = new Cr(ut, Li, !0, !1, !1), Me = new Cr(ut + "*", Li, !1, !1, !1);
          var Bt = new Cr(ut + " const*", Li, !1, !0, !1);
          return Hg[a] = { pointerType: Me, rk: Bt }, uw(et, bt), [$t, Me, Bt];
        });
      },
      b: function(a, c, d, p, w, k, L) {
        var z = Kg(d, p);
        c = Ji(c), k = dn(w, k), ze([], [a], function(Z) {
          function ct() {
            Hl("Cannot call " + ut + " due to unbound types", z);
          }
          Z = Z[0];
          var ut = Z.name + "." + c;
          c.startsWith("@@") && (c = Symbol[c.substring(2)]);
          var At = Z.ji.constructor;
          return At[c] === void 0 ? (ct.uj = d - 1, At[c] = ct) : (Ug(At, c, ut), At[c].Ei[d - 1] = ct), ze([], z, function(Ut) {
            return Ut = [Ut[0], null].concat(Ut.slice(1)), Ut = qg(ut, Ut, k, L), At[c].Ei === void 0 ? (Ut.uj = d - 1, At[c] = Ut) : At[c].Ei[d - 1] = Ut, [];
          }), [];
        });
      },
      ja: function(a, c, d, p, w, k) {
        0 < c || pe();
        var L = Kg(c, d);
        w = dn(p, w), ze([], [a], function(z) {
          z = z[0];
          var Z = "constructor " + z.name;
          if (z.ji.Ii === void 0 && (z.ji.Ii = []), z.ji.Ii[c - 1] !== void 0) throw new Ba("Cannot register multiple constructors with identical number of parameters (" + (c - 1) + ") for class '" + z.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          return z.ji.Ii[c - 1] = () => {
            Hl("Cannot construct " + z.name + " due to unbound types", L);
          }, ze([], L, function(ct) {
            return ct.splice(1, 0, null), z.ji.Ii[c - 1] = qg(Z, ct, w, k), [];
          }), [];
        });
      },
      Z: function(a, c, d, p, w, k, L, z, Z, ct) {
        c = Ji(c), w = dn(p, w), ze([], [a], function(ut) {
          ut = ut[0];
          var At = ut.name + "." + c, Ut = { get: function() {
            Hl("Cannot access " + At + " due to unbound types", [d, L]);
          }, enumerable: !0, configurable: !0 };
          return Ut.set = Z ? () => {
            Hl("Cannot access " + At + " due to unbound types", [d, L]);
          } : () => {
            He(At + " is a read-only property");
          }, Object.defineProperty(
            ut.ji.Ki,
            c,
            Ut
          ), ze([], Z ? [d, L] : [d], function(et) {
            var bt = et[0], $t = { get: function() {
              var Ue = Xg(this, ut, At + " getter");
              return bt.fromWireType(w(k, Ue));
            }, enumerable: !0 };
            if (Z) {
              Z = dn(z, Z);
              var Me = et[1];
              $t.set = function(Ue) {
                var Li = Xg(this, ut, At + " setter"), Bt = [];
                Z(ct, Li, Me.toWireType(Bt, Ue)), Ti(Bt);
              };
            }
            return Object.defineProperty(ut.ji.Ki, c, $t), [];
          }), [];
        });
      },
      Sg: function(a, c) {
        c = Ji(c), Ir(a, { name: c, fromWireType: function(d) {
          var p = ir(d);
          return Td(d), p;
        }, toWireType: function(d, p) {
          return ds(p);
        }, argPackAdvance: 8, readValueFromPointer: xi, si: null });
      },
      K: function(a, c, d, p) {
        function w() {
        }
        d = js(d), c = Ji(c), w.values = {}, Ir(a, { name: c, constructor: w, fromWireType: function(k) {
          return this.constructor.values[k];
        }, toWireType: function(k, L) {
          return L.value;
        }, argPackAdvance: 8, readValueFromPointer: fw(c, d, p), si: null }), jg(c, w);
      },
      v: function(a, c, d) {
        var p = Ul(a, "enum");
        c = Ji(c), a = p.constructor, p = Object.create(p.constructor.prototype, { value: { value: d }, constructor: { value: Ot(p.name + "_" + c, function() {
        }) } }), a.values[d] = p, a[c] = p;
      },
      xa: function(a, c, d) {
        d = js(d), c = Ji(c), Ir(a, {
          name: c,
          fromWireType: function(p) {
            return p;
          },
          toWireType: function(p, w) {
            return w;
          },
          argPackAdvance: 8,
          readValueFromPointer: gw(c, d),
          si: null
        });
      },
      P: function(a, c, d, p, w) {
        c = Ji(c), w === -1 && (w = 4294967295), w = js(d);
        var k = (z) => z;
        if (p === 0) {
          var L = 32 - 8 * d;
          k = (z) => z << L >>> L;
        }
        d = c.includes("unsigned") ? function(z, Z) {
          return Z >>> 0;
        } : function(z, Z) {
          return Z;
        }, Ir(a, { name: c, fromWireType: k, toWireType: d, argPackAdvance: 8, readValueFromPointer: pw(c, w, p !== 0), si: null });
      },
      D: function(a, c, d) {
        function p(k) {
          k >>= 2;
          var L = it;
          return new w(ft, L[k + 1], L[k]);
        }
        var w = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array
        ][c];
        d = Ji(d), Ir(a, { name: d, fromWireType: p, argPackAdvance: 8, readValueFromPointer: p }, { Bk: !0 });
      },
      ia: function(a, c, d, p, w, k, L, z, Z, ct, ut, At) {
        d = Ji(d), k = dn(w, k), z = dn(L, z), ct = dn(Z, ct), At = dn(ut, At), ze([a], [c], function(Ut) {
          return Ut = Ut[0], [new Cr(d, Ut.ji, !1, !1, !0, Ut, p, k, z, ct, At)];
        });
      },
      wa: function(a, c) {
        c = Ji(c);
        var d = c === "std::string";
        Ir(a, { name: c, fromWireType: function(p) {
          var w = it[p >> 2], k = p + 4;
          if (d) for (var L = k, z = 0; z <= w; ++z) {
            var Z = k + z;
            if (z == w || $[Z] == 0) {
              if (L = K(L, Z - L), ct === void 0) var ct = L;
              else ct += "\0", ct += L;
              L = Z + 1;
            }
          }
          else {
            for (ct = Array(w), z = 0; z < w; ++z) ct[z] = String.fromCharCode($[k + z]);
            ct = ct.join("");
          }
          return Pr(p), ct;
        }, toWireType: function(p, w) {
          w instanceof ArrayBuffer && (w = new Uint8Array(w));
          var k = typeof w == "string";
          k || w instanceof Uint8Array || w instanceof Uint8ClampedArray || w instanceof Int8Array || He("Cannot pass non-string to std::string");
          var L = d && k ? rt(w) : w.length, z = Yl(4 + L + 1), Z = z + 4;
          if (it[z >> 2] = L, d && k) J(w, $, Z, L + 1);
          else if (k) for (k = 0; k < L; ++k) {
            var ct = w.charCodeAt(k);
            255 < ct && (Pr(Z), He("String has UTF-16 code units that do not fit in 8 bits")), $[Z + k] = ct;
          }
          else for (k = 0; k < L; ++k) $[Z + k] = w[k];
          return p !== null && p.push(Pr, z), z;
        }, argPackAdvance: 8, readValueFromPointer: xi, si: function(p) {
          Pr(p);
        } });
      },
      ka: function(a, c, d) {
        if (d = Ji(d), c === 2)
          var p = mw, w = _w, k = yw, L = () => R, z = 1;
        else c === 4 && (p = ww, w = vw, k = bw, L = () => it, z = 2);
        Ir(a, { name: d, fromWireType: function(Z) {
          for (var ct = it[Z >> 2], ut = L(), At, Ut = Z + 4, et = 0; et <= ct; ++et) {
            var bt = Z + 4 + et * c;
            (et == ct || ut[bt >> z] == 0) && (Ut = p(Ut, bt - Ut), At === void 0 ? At = Ut : (At += "\0", At += Ut), Ut = bt + c);
          }
          return Pr(Z), At;
        }, toWireType: function(Z, ct) {
          typeof ct != "string" && He("Cannot pass non-string to C++ string type " + d);
          var ut = k(ct), At = Yl(4 + ut + c);
          return it[At >> 2] = ut >> z, w(ct, At + 4, ut + c), Z !== null && Z.push(Pr, At), At;
        }, argPackAdvance: 8, readValueFromPointer: xi, si: function(Z) {
          Pr(Z);
        } });
      },
      x: function(a, c, d, p, w, k) {
        mi[a] = { name: Ji(c), Zi: dn(d, p), vi: dn(w, k), elements: [] };
      },
      i: function(a, c, d, p, w, k, L, z, Z) {
        mi[a].elements.push({ zj: c, Si: dn(d, p), yj: w, Lj: k, Kj: dn(L, z), Mj: Z });
      },
      M: function(a, c, d, p, w, k) {
        Xi[a] = { name: Ji(c), Zi: dn(d, p), vi: dn(
          w,
          k
        ), Yj: [] };
      },
      z: function(a, c, d, p, w, k, L, z, Z, ct) {
        Xi[a].Yj.push({ vk: Ji(c), zj: d, Si: dn(p, w), yj: k, Lj: L, Kj: dn(z, Z), Mj: ct });
      },
      Ug: function(a, c) {
        c = Ji(c), Ir(a, { Gk: !0, name: c, argPackAdvance: 0, fromWireType: function() {
        }, toWireType: function() {
        } });
      },
      Vg: function(a) {
        do {
          var c = it[a >> 2];
          a += 4;
          var d = it[a >> 2];
          a += 4;
          var p = it[a >> 2];
          a += 4, c = K(c), bi("/", Yt(c)), Ai(c, null, H.subarray(p, p + d), !0, !0, !0);
        } while (it[a >> 2]);
      },
      Db: function() {
        return !0;
      },
      p: function(a, c, d) {
        a = ir(a), c = Ul(c, "emval::as");
        var p = [], w = ds(p);
        return it[d >> 2] = w, c.toWireType(
          p,
          a
        );
      },
      j: function(a, c, d, p) {
        a = ir(a), d = Yg(c, d);
        for (var w = Array(c), k = 0; k < c; ++k) {
          var L = d[k];
          w[k] = L.readValueFromPointer(p), p += L.argPackAdvance;
        }
        return a = a.apply(void 0, w), ds(a);
      },
      Q: function(a, c, d, p, w) {
        a = Nd[a], c = ir(c), d = Wh(d);
        var k = [];
        return it[p >> 2] = ds(k), a(c, d, k, w);
      },
      a: Td,
      J: function(a) {
        return a === 0 ? ds(Zg()) : (a = Wh(a), ds(Zg()[a]));
      },
      R: function(a, c) {
        var d = Yg(a, c), p = d[0];
        c = p.name + "_$" + d.slice(1).map(function(ut) {
          return ut.name;
        }).join("_") + "$";
        var w = Qg[c];
        if (w !== void 0) return w;
        w = ["retType"];
        for (var k = [p], L = "", z = 0; z < a - 1; ++z) L += (z !== 0 ? ", " : "") + "arg" + z, w.push("argType" + z), k.push(d[1 + z]);
        var Z = "return function " + dt("methodCaller_" + c) + `(handle, name, destructors, args) {
`, ct = 0;
        for (z = 0; z < a - 1; ++z) Z += "    var arg" + z + " = argType" + z + ".readValueFromPointer(args" + (ct ? "+" + ct : "") + `);
`, ct += d[z + 1].argPackAdvance;
        for (Z += "    var rv = handle[name](" + L + `);
`, z = 0; z < a - 1; ++z) d[z + 1].deleteObject && (Z += "    argType" + z + ".deleteObject(arg" + z + `);
`);
        return p.Gk || (Z += `    return retType.toWireType(destructors, rv);
`), w.push(Z + `};
`), a = $g(w).apply(null, k), w = Iw(a), Qg[c] = w;
      },
      aa: function(a) {
        return a = Wh(a), ds(e[a]);
      },
      o: function(a, c) {
        return a = ir(a), c = ir(c), ds(a[c]);
      },
      d: function(a) {
        4 < a && (er[a].Gj += 1);
      },
      S: function(a, c, d, p) {
        a = ir(a);
        var w = tp[c];
        return w || (w = Cw(c), tp[c] = w), w(a, d, p);
      },
      u: function() {
        return ds([]);
      },
      f: function(a) {
        return ds(Wh(a));
      },
      B: function() {
        return ds({});
      },
      m: function(a) {
        var c = ir(a);
        Ti(c), Td(a);
      },
      g: function(a, c, d) {
        a = ir(a), c = ir(c), d = ir(d), a[c] = d;
      },
      e: function(a, c) {
        return a = Ul(a, "_emval_take_value"), a = a.readValueFromPointer(c), ds(a);
      },
      c: function() {
        pe("");
      },
      da: function(a, c, d) {
        Od.length = 0;
        var p;
        for (d >>= 2; p = $[c++]; ) d += p != 105 & d, Od.push(p == 105 ? U[d] : mt[d++ >> 1]), ++d;
        return st[a].apply(null, Od);
      },
      Id: function(a, c, d) {
        var p = e.canvas;
        U[a >> 2] = p.width, U[c >> 2] = p.height, U[d >> 2] = za ? 1 : 0;
      },
      A: Gh,
      yg: function(a) {
        A.activeTexture(a);
      },
      xg: function(a, c) {
        A.attachShader(Ne[a], Yi[c]);
      },
      Bd: function(a, c) {
        A.beginQuery(a, Zi[c]);
      },
      Og: function(a, c) {
        A.pi.beginQueryEXT(a, Zi[c]);
      },
      hd: function(a) {
        A.beginTransformFeedback(a);
      },
      wg: function(a, c, d) {
        A.bindAttribLocation(Ne[a], c, K(d));
      },
      vg: function(a, c) {
        a == 35051 ? A.Ji = c : a == 35052 && (A.oi = c), A.bindBuffer(a, nr[c]);
      },
      ed: function(a, c, d) {
        A.bindBufferBase(a, c, nr[d]);
      },
      fd: function(a, c, d, p, w) {
        A.bindBufferRange(a, c, nr[d], p, w);
      },
      ug: function(a, c) {
        A.bindFramebuffer(a, Jr[c]);
      },
      tg: function(a, c) {
        A.bindRenderbuffer(a, sr[c]);
      },
      ic: function(a, c) {
        A.bindSampler(a, rr[c]);
      },
      sg: function(a, c) {
        A.bindTexture(a, Ws[c]);
      },
      $b: function(a, c) {
        A.bindTransformFeedback(a, ql[c]);
      },
      md: function(a) {
        A.bindVertexArray(Sr[a]);
      },
      Gg: function(a) {
        A.bindVertexArray(Sr[a]);
      },
      rg: function(a, c, d, p) {
        A.blendColor(a, c, d, p);
      },
      qg: function(a) {
        A.blendEquation(a);
      },
      pg: function(a, c) {
        A.blendEquationSeparate(a, c);
      },
      og: function(a, c) {
        A.blendFunc(a, c);
      },
      ng: function(a, c, d, p) {
        A.blendFuncSeparate(a, c, d, p);
      },
      pd: function(a, c, d, p, w, k, L, z, Z, ct) {
        A.blitFramebuffer(a, c, d, p, w, k, L, z, Z, ct);
      },
      mg: function(a, c, d, p) {
        2 <= ye.version ? d && c ? A.bufferData(a, $, p, d, c) : A.bufferData(a, c, p) : A.bufferData(a, d ? $.subarray(d, d + c) : c, p);
      },
      lg: function(a, c, d, p) {
        2 <= ye.version ? d && A.bufferSubData(a, c, $, p, d) : A.bufferSubData(a, c, $.subarray(p, p + d));
      },
      kg: function(a) {
        return A.checkFramebufferStatus(a);
      },
      jg: function(a) {
        A.clear(a);
      },
      Hc: function(a, c, d, p) {
        A.clearBufferfi(a, c, d, p);
      },
      Ic: function(a, c, d) {
        A.clearBufferfv(a, c, at, d >> 2);
      },
      Lc: function(a, c, d) {
        A.clearBufferiv(a, c, U, d >> 2);
      },
      Kc: function(a, c, d) {
        A.clearBufferuiv(a, c, it, d >> 2);
      },
      ig: function(a, c, d, p) {
        A.clearColor(a, c, d, p);
      },
      hg: function(a) {
        A.clearDepth(a);
      },
      gg: function(a) {
        A.clearStencil(a);
      },
      sc: function(a, c, d, p) {
        return A.clientWaitSync(wo[a], c, (d >>> 0) + 4294967296 * p);
      },
      fg: function(a, c, d, p) {
        A.colorMask(!!a, !!c, !!d, !!p);
      },
      eg: function(a) {
        A.compileShader(Yi[a]);
      },
      dg: function(a, c, d, p, w, k, L, z) {
        2 <= ye.version ? A.oi || !L ? A.compressedTexImage2D(a, c, d, p, w, k, L, z) : A.compressedTexImage2D(a, c, d, p, w, k, $, z, L) : A.compressedTexImage2D(a, c, d, p, w, k, z ? $.subarray(z, z + L) : null);
      },
      Gd: function(a, c, d, p, w, k, L, z, Z) {
        A.oi ? A.compressedTexImage3D(a, c, d, p, w, k, L, z, Z) : A.compressedTexImage3D(a, c, d, p, w, k, L, $, Z, z);
      },
      cg: function(a, c, d, p, w, k, L, z, Z) {
        2 <= ye.version ? A.oi || !z ? A.compressedTexSubImage2D(a, c, d, p, w, k, L, z, Z) : A.compressedTexSubImage2D(a, c, d, p, w, k, L, $, Z, z) : A.compressedTexSubImage2D(a, c, d, p, w, k, L, Z ? $.subarray(
          Z,
          Z + z
        ) : null);
      },
      Fd: function(a, c, d, p, w, k, L, z, Z, ct, ut) {
        A.oi ? A.compressedTexSubImage3D(a, c, d, p, w, k, L, z, Z, ct, ut) : A.compressedTexSubImage3D(a, c, d, p, w, k, L, z, Z, $, ut, ct);
      },
      Fc: function(a, c, d, p, w) {
        A.copyBufferSubData(a, c, d, p, w);
      },
      bg: function(a, c, d, p, w, k, L, z) {
        A.copyTexImage2D(a, c, d, p, w, k, L, z);
      },
      ag: function(a, c, d, p, w, k, L, z) {
        A.copyTexSubImage2D(a, c, d, p, w, k, L, z);
      },
      Hd: function(a, c, d, p, w, k, L, z, Z) {
        A.copyTexSubImage3D(a, c, d, p, w, k, L, z, Z);
      },
      $f: function() {
        var a = vo(Ne), c = A.createProgram();
        return c.name = a, c.Ci = c.Ai = c.Bi = 0, c.rj = 1, Ne[a] = c, a;
      },
      _f: function(a) {
        var c = vo(Yi);
        return Yi[c] = A.createShader(a), c;
      },
      Zf: function(a) {
        A.cullFace(a);
      },
      Yf: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = nr[p];
          w && (A.deleteBuffer(w), w.name = 0, nr[p] = null, p == A.Ji && (A.Ji = 0), p == A.oi && (A.oi = 0));
        }
      },
      Xf: function(a, c) {
        for (var d = 0; d < a; ++d) {
          var p = U[c + 4 * d >> 2], w = Jr[p];
          w && (A.deleteFramebuffer(w), w.name = 0, Jr[p] = null);
        }
      },
      Wf: function(a) {
        if (a) {
          var c = Ne[a];
          c ? (A.deleteProgram(c), c.name = 0, Ne[a] = null) : qt(1281);
        }
      },
      Dd: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = Zi[p];
          w && (A.deleteQuery(w), Zi[p] = null);
        }
      },
      Qg: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = Zi[p];
          w && (A.pi.deleteQueryEXT(w), Zi[p] = null);
        }
      },
      Vf: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = sr[p];
          w && (A.deleteRenderbuffer(w), w.name = 0, sr[p] = null);
        }
      },
      kc: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = rr[p];
          w && (A.deleteSampler(w), w.name = 0, rr[p] = null);
        }
      },
      Uf: function(a) {
        if (a) {
          var c = Yi[a];
          c ? (A.deleteShader(c), Yi[a] = null) : qt(1281);
        }
      },
      tc: function(a) {
        if (a) {
          var c = wo[a];
          c ? (A.deleteSync(c), c.name = 0, wo[a] = null) : qt(1281);
        }
      },
      Tf: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = Ws[p];
          w && (A.deleteTexture(w), w.name = 0, Ws[p] = null);
        }
      },
      _b: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = ql[p];
          w && (A.deleteTransformFeedback(w), w.name = 0, ql[p] = null);
        }
      },
      ld: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2];
          A.deleteVertexArray(Sr[p]), Sr[p] = null;
        }
      },
      Fg: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2];
          A.deleteVertexArray(Sr[p]), Sr[p] = null;
        }
      },
      Sf: function(a) {
        A.depthFunc(a);
      },
      Rf: function(a) {
        A.depthMask(!!a);
      },
      Qf: function(a, c) {
        A.depthRange(a, c);
      },
      Pf: function(a, c) {
        A.detachShader(Ne[a], Yi[c]);
      },
      Of: function(a) {
        A.disable(a);
      },
      Nf: function(a) {
        A.disableVertexAttribArray(a);
      },
      Mf: function(a, c, d) {
        A.drawArrays(a, c, d);
      },
      xc: function(a, c, d, p) {
        A.drawArraysInstanced(a, c, d, p);
      },
      Bg: function(a, c, d, p) {
        A.drawArraysInstanced(a, c, d, p);
      },
      Kb: function(a, c, d, p) {
        A.drawArraysInstanced(a, c, d, p);
      },
      Pd: function(a, c, d, p) {
        A.drawArraysInstanced(a, c, d, p);
      },
      Lb: function(a, c, d, p) {
        A.drawArraysInstanced(a, c, d, p);
      },
      wd: function(a, c) {
        for (var d = Zo[a], p = 0; p < a; p++) d[p] = U[c + 4 * p >> 2];
        A.drawBuffers(d);
      },
      Nd: function(a, c) {
        for (var d = Zo[a], p = 0; p < a; p++) d[p] = U[c + 4 * p >> 2];
        A.drawBuffers(d);
      },
      Cg: function(a, c) {
        for (var d = Zo[a], p = 0; p < a; p++) d[p] = U[c + 4 * p >> 2];
        A.drawBuffers(d);
      },
      Lf: function(a, c, d, p) {
        A.drawElements(a, c, d, p);
      },
      wc: function(a, c, d, p, w) {
        A.drawElementsInstanced(a, c, d, p, w);
      },
      Ag: function(a, c, d, p, w) {
        A.drawElementsInstanced(a, c, d, p, w);
      },
      Ib: function(a, c, d, p, w) {
        A.drawElementsInstanced(a, c, d, p, w);
      },
      Jb: function(a, c, d, p, w) {
        A.drawElementsInstanced(a, c, d, p, w);
      },
      Od: function(a, c, d, p, w) {
        A.drawElementsInstanced(
          a,
          c,
          d,
          p,
          w
        );
      },
      Ld: function(a, c, d, p, w, k) {
        fp(a, p, w, k);
      },
      Kf: function(a) {
        A.enable(a);
      },
      Jf: function(a) {
        A.enableVertexAttribArray(a);
      },
      Ad: function(a) {
        A.endQuery(a);
      },
      Ng: function(a) {
        A.pi.endQueryEXT(a);
      },
      gd: function() {
        A.endTransformFeedback();
      },
      vc: function(a, c) {
        return (a = A.fenceSync(a, c)) ? (c = vo(wo), a.name = c, wo[c] = a, c) : 0;
      },
      If: function() {
        A.finish();
      },
      Hf: function() {
        A.flush();
      },
      Gf: function(a, c, d, p) {
        A.framebufferRenderbuffer(a, c, d, sr[p]);
      },
      Ff: function(a, c, d, p, w) {
        A.framebufferTexture2D(a, c, d, Ws[p], w);
      },
      nd: function(a, c, d, p, w) {
        A.framebufferTextureLayer(
          a,
          c,
          Ws[d],
          p,
          w
        );
      },
      Ef: function(a) {
        A.frontFace(a);
      },
      Df: function(a, c) {
        fs(a, c, "createBuffer", nr);
      },
      Bf: function(a, c) {
        fs(a, c, "createFramebuffer", Jr);
      },
      Ed: function(a, c) {
        fs(a, c, "createQuery", Zi);
      },
      Rg: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = A.pi.createQueryEXT();
          if (!p) {
            for (qt(1282); d < a; ) U[c + 4 * d++ >> 2] = 0;
            break;
          }
          var w = vo(Zi);
          p.name = w, Zi[w] = p, U[c + 4 * d >> 2] = w;
        }
      },
      Af: function(a, c) {
        fs(a, c, "createRenderbuffer", sr);
      },
      lc: function(a, c) {
        fs(a, c, "createSampler", rr);
      },
      zf: function(a, c) {
        fs(a, c, "createTexture", Ws);
      },
      Zb: function(a, c) {
        fs(
          a,
          c,
          "createTransformFeedback",
          ql
        );
      },
      kd: function(a, c) {
        fs(a, c, "createVertexArray", Sr);
      },
      Eg: function(a, c) {
        fs(a, c, "createVertexArray", Sr);
      },
      Cf: function(a) {
        A.generateMipmap(a);
      },
      yf: function(a, c, d, p, w, k, L) {
        Zh("getActiveAttrib", a, c, d, p, w, k, L);
      },
      xf: function(a, c, d, p, w, k, L) {
        Zh("getActiveUniform", a, c, d, p, w, k, L);
      },
      Ac: function(a, c, d, p, w) {
        a = Ne[a], (a = A.getActiveUniformBlockName(a, c)) && (w && 0 < d ? (d = J(a, $, w, d), p && (U[p >> 2] = d)) : p && (U[p >> 2] = 0));
      },
      Bc: function(a, c, d, p) {
        if (p) {
          if (a = Ne[a], d == 35393) d = A.getActiveUniformBlockName(a, c), U[p >> 2] = d.length + 1;
          else if (a = A.getActiveUniformBlockParameter(a, c, d), a !== null) if (d == 35395) for (d = 0; d < a.length; d++) U[p + 4 * d >> 2] = a[d];
          else U[p >> 2] = a;
        } else qt(1281);
      },
      Dc: function(a, c, d, p, w) {
        if (w) if (0 < c && d == 0) qt(1281);
        else {
          a = Ne[a];
          for (var k = [], L = 0; L < c; L++) k.push(U[d + 4 * L >> 2]);
          if (a = A.getActiveUniforms(a, k, p)) for (c = a.length, L = 0; L < c; L++) U[w + 4 * L >> 2] = a[L];
        }
        else qt(1281);
      },
      wf: function(a, c, d, p) {
        a = A.getAttachedShaders(Ne[a]);
        var w = a.length;
        for (w > c && (w = c), U[d >> 2] = w, c = 0; c < w; ++c) U[p + 4 * c >> 2] = Yi.indexOf(a[c]);
      },
      vf: function(a, c) {
        return A.getAttribLocation(
          Ne[a],
          K(c)
        );
      },
      uf: function(a, c) {
        Qo(a, c, 4);
      },
      mc: function(a, c, d) {
        d ? Kl(d, A.getBufferParameter(a, c)) : qt(1281);
      },
      tf: function(a, c, d) {
        d ? U[d >> 2] = A.getBufferParameter(a, c) : qt(1281);
      },
      sf: function() {
        var a = A.getError() || ja;
        return ja = 0, a;
      },
      rf: function(a, c) {
        Qo(a, c, 2);
      },
      Uc: function(a, c) {
        return A.getFragDataLocation(Ne[a], K(c));
      },
      qf: function(a, c, d, p) {
        a = A.getFramebufferAttachmentParameter(a, c, d), (a instanceof WebGLRenderbuffer || a instanceof WebGLTexture) && (a = a.name | 0), U[p >> 2] = a;
      },
      oc: function(a, c, d) {
        gp(a, c, d, 1);
      },
      qc: function(a, c) {
        Qo(
          a,
          c,
          1
        );
      },
      id: function(a, c, d) {
        gp(a, c, d, 0);
      },
      pf: function(a, c) {
        Qo(a, c, 0);
      },
      Ob: function(a, c, d, p, w) {
        if (0 > p) qt(1281);
        else if (w) {
          if (a = A.getInternalformatParameter(a, c, d), a !== null) for (c = 0; c < a.length && c < p; ++c) U[w + 4 * c >> 2] = a[c];
        } else qt(1281);
      },
      Vb: function() {
        qt(1282);
      },
      nf: function(a, c, d, p) {
        a = A.getProgramInfoLog(Ne[a]), a === null && (a = "(unknown error)"), c = 0 < c && p ? J(a, $, p, c) : 0, d && (U[d >> 2] = c);
      },
      of: function(a, c, d) {
        if (d) if (a >= Ud) qt(1281);
        else if (a = Ne[a], c == 35716) a = A.getProgramInfoLog(a), a === null && (a = "(unknown error)"), U[d >> 2] = a.length + 1;
        else if (c == 35719) {
          if (!a.Ci) for (c = 0; c < A.getProgramParameter(a, 35718); ++c) a.Ci = Math.max(a.Ci, A.getActiveUniform(a, c).name.length + 1);
          U[d >> 2] = a.Ci;
        } else if (c == 35722) {
          if (!a.Ai) for (c = 0; c < A.getProgramParameter(a, 35721); ++c) a.Ai = Math.max(a.Ai, A.getActiveAttrib(a, c).name.length + 1);
          U[d >> 2] = a.Ai;
        } else if (c == 35381) {
          if (!a.Bi) for (c = 0; c < A.getProgramParameter(a, 35382); ++c) a.Bi = Math.max(a.Bi, A.getActiveUniformBlockName(a, c).length + 1);
          U[d >> 2] = a.Bi;
        } else U[d >> 2] = A.getProgramParameter(a, c);
        else qt(1281);
      },
      Ig: function(a, c, d) {
        if (d) {
          a = Zi[a], c = 2 > ye.version ? A.pi.getQueryObjectEXT(a, c) : A.getQueryParameter(a, c);
          var p;
          typeof c == "boolean" ? p = c ? 1 : 0 : p = c, Kl(d, p);
        } else qt(1281);
      },
      Kg: function(a, c, d) {
        if (d) {
          a = A.pi.getQueryObjectEXT(Zi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, U[d >> 2] = p;
        } else qt(1281);
      },
      Hg: function(a, c, d) {
        if (d) {
          a = Zi[a], c = 2 > ye.version ? A.pi.getQueryObjectEXT(a, c) : A.getQueryParameter(a, c);
          var p;
          typeof c == "boolean" ? p = c ? 1 : 0 : p = c, Kl(d, p);
        } else qt(1281);
      },
      yd: function(a, c, d) {
        if (d) {
          a = A.getQueryParameter(Zi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, U[d >> 2] = p;
        } else qt(1281);
      },
      Jg: function(a, c, d) {
        if (d) {
          a = A.pi.getQueryObjectEXT(Zi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, U[d >> 2] = p;
        } else qt(1281);
      },
      zd: function(a, c, d) {
        d ? U[d >> 2] = A.getQuery(a, c) : qt(1281);
      },
      Lg: function(a, c, d) {
        d ? U[d >> 2] = A.pi.getQueryEXT(a, c) : qt(1281);
      },
      mf: function(a, c, d) {
        d ? U[d >> 2] = A.getRenderbufferParameter(a, c) : qt(1281);
      },
      bc: function(a, c, d) {
        d ? at[d >> 2] = A.getSamplerParameter(rr[a], c) : qt(1281);
      },
      dc: function(a, c, d) {
        d ? U[d >> 2] = A.getSamplerParameter(rr[a], c) : qt(1281);
      },
      kf: function(a, c, d, p) {
        a = A.getShaderInfoLog(Yi[a]), a === null && (a = "(unknown error)"), c = 0 < c && p ? J(a, $, p, c) : 0, d && (U[d >> 2] = c);
      },
      jf: function(a, c, d, p) {
        a = A.getShaderPrecisionFormat(a, c), U[d >> 2] = a.rangeMin, U[d + 4 >> 2] = a.rangeMax, U[p >> 2] = a.precision;
      },
      hf: function(a, c, d, p) {
        (a = A.getShaderSource(Yi[a])) && (c = 0 < c && p ? J(a, $, p, c) : 0, d && (U[d >> 2] = c));
      },
      lf: function(a, c, d) {
        d ? c == 35716 ? (a = A.getShaderInfoLog(Yi[a]), a === null && (a = "(unknown error)"), U[d >> 2] = a ? a.length + 1 : 0) : c == 35720 ? (a = A.getShaderSource(Yi[a]), U[d >> 2] = a ? a.length + 1 : 0) : U[d >> 2] = A.getShaderParameter(
          Yi[a],
          c
        ) : qt(1281);
      },
      gf: function(a) {
        var c = Yh[a];
        if (!c) {
          switch (a) {
            case 7939:
              c = A.getSupportedExtensions() || [], c = c.concat(c.map(function(p) {
                return "GL_" + p;
              })), c = Yr(c.join(" "));
              break;
            case 7936:
            case 7937:
            case 37445:
            case 37446:
              (c = A.getParameter(a)) || qt(1280), c = c && Yr(c);
              break;
            case 7938:
              c = A.getParameter(7938), c = 2 <= ye.version ? "OpenGL ES 3.0 (" + c + ")" : "OpenGL ES 2.0 (" + c + ")", c = Yr(c);
              break;
            case 35724:
              c = A.getParameter(35724);
              var d = c.match(/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/);
              d !== null && (d[1].length == 3 && (d[1] += "0"), c = "OpenGL ES GLSL ES " + d[1] + " (" + c + ")"), c = Yr(c);
              break;
            default:
              qt(1280);
          }
          Yh[a] = c;
        }
        return c;
      },
      Gc: function(a, c) {
        if (2 > ye.version) return qt(1282), 0;
        var d = cp[a];
        if (d) return 0 > c || c >= d.length ? (qt(1281), 0) : d[c];
        switch (a) {
          case 7939:
            return d = A.getSupportedExtensions() || [], d = d.concat(d.map(function(p) {
              return "GL_" + p;
            })), d = d.map(function(p) {
              return Yr(p);
            }), d = cp[a] = d, 0 > c || c >= d.length ? (qt(1281), 0) : d[c];
          default:
            return qt(1280), 0;
        }
      },
      pc: function(a, c, d, p, w) {
        0 > d ? qt(1281) : w ? (a = A.getSyncParameter(wo[a], c), a !== null && (U[w >> 2] = a, p && (U[p >> 2] = 1))) : qt(1281);
      },
      ff: function(a, c, d) {
        d ? at[d >> 2] = A.getTexParameter(a, c) : qt(1281);
      },
      ef: function(a, c, d) {
        d ? U[d >> 2] = A.getTexParameter(a, c) : qt(1281);
      },
      bd: function(a, c, d, p, w, k, L) {
        a = Ne[a], (a = A.getTransformFeedbackVarying(a, c)) && (L && 0 < d ? (d = J(a.name, $, L, d), p && (U[p >> 2] = d)) : p && (U[p >> 2] = 0), w && (U[w >> 2] = a.size), k && (U[k >> 2] = a.type));
      },
      Cc: function(a, c) {
        return A.getUniformBlockIndex(Ne[a], K(c));
      },
      Ec: function(a, c, d, p) {
        if (p) if (0 < c && (d == 0 || p == 0)) qt(1281);
        else {
          a = Ne[a];
          for (var w = [], k = 0; k < c; k++) w.push(K(U[d + 4 * k >> 2]));
          if (a = A.getUniformIndices(
            a,
            w
          )) for (c = a.length, k = 0; k < c; k++) U[p + 4 * k >> 2] = a[k];
        }
        else qt(1281);
      },
      bf: function(a, c) {
        if (c = K(c), a = Ne[a]) {
          $d(a);
          var d = a.Pi, p = 0, w = c, k = Gd(c);
          if (0 < k && (p = parseInt(c.slice(k + 1)) >>> 0, w = c.slice(0, k)), (w = a.sj[w]) && p < w[0] && (p += w[1], d[p] = d[p] || A.getUniformLocation(a, c))) return p;
        } else qt(1281);
        return -1;
      },
      df: function(a, c, d) {
        qd(a, c, d, 2);
      },
      cf: function(a, c, d) {
        qd(a, c, d, 0);
      },
      Vc: function(a, c, d) {
        qd(a, c, d, 0);
      },
      $c: function(a, c, d) {
        Qh(a, c, d, 0);
      },
      _c: function(a, c, d) {
        Qh(a, c, d, 0);
      },
      _e: function(a, c, d) {
        d ? U[d >> 2] = A.getVertexAttribOffset(a, c) : qt(1281);
      },
      af: function(a, c, d) {
        Qh(a, c, d, 2);
      },
      $e: function(a, c, d) {
        Qh(a, c, d, 5);
      },
      Ze: function(a, c) {
        A.hint(a, c);
      },
      Sb: function(a, c, d) {
        for (var p = Zo[c], w = 0; w < c; w++) p[w] = U[d + 4 * w >> 2];
        A.invalidateFramebuffer(a, p);
      },
      Rb: function(a, c, d, p, w, k, L) {
        for (var z = Zo[c], Z = 0; Z < c; Z++) z[Z] = U[d + 4 * Z >> 2];
        A.invalidateSubFramebuffer(a, z, p, w, k, L);
      },
      Ye: function(a) {
        return (a = nr[a]) ? A.isBuffer(a) : 0;
      },
      Xe: function(a) {
        return A.isEnabled(a);
      },
      We: function(a) {
        return (a = Jr[a]) ? A.isFramebuffer(a) : 0;
      },
      Ve: function(a) {
        return (a = Ne[a]) ? A.isProgram(a) : 0;
      },
      Cd: function(a) {
        return (a = Zi[a]) ? A.isQuery(a) : 0;
      },
      Pg: function(a) {
        return (a = Zi[a]) ? A.pi.isQueryEXT(a) : 0;
      },
      Ue: function(a) {
        return (a = sr[a]) ? A.isRenderbuffer(a) : 0;
      },
      jc: function(a) {
        return (a = rr[a]) ? A.isSampler(a) : 0;
      },
      Te: function(a) {
        return (a = Yi[a]) ? A.isShader(a) : 0;
      },
      uc: function(a) {
        return A.isSync(wo[a]);
      },
      Se: function(a) {
        return (a = Ws[a]) ? A.isTexture(a) : 0;
      },
      Yb: function(a) {
        return A.isTransformFeedback(ql[a]);
      },
      jd: function(a) {
        return (a = Sr[a]) ? A.isVertexArray(a) : 0;
      },
      Dg: function(a) {
        return (a = Sr[a]) ? A.isVertexArray(a) : 0;
      },
      Re: function(a) {
        A.lineWidth(a);
      },
      Qe: function(a) {
        a = Ne[a], A.linkProgram(a), a.Pi = 0, a.sj = {};
      },
      Xb: function() {
        A.pauseTransformFeedback();
      },
      Pe: function(a, c) {
        a == 3317 && (jd = c), A.pixelStorei(a, c);
      },
      Oe: function(a, c) {
        A.polygonOffset(a, c);
      },
      Ub: function() {
        qt(1280);
      },
      Tb: function() {
        qt(1280);
      },
      Mg: function(a, c) {
        A.pi.queryCounterEXT(Zi[a], c);
      },
      Md: function(a) {
        A.readBuffer(a);
      },
      Ne: function(a, c, d, p, w, k, L) {
        if (2 <= ye.version) if (A.Ji) A.readPixels(a, c, d, p, w, k, L);
        else {
          var z = bo(k);
          A.readPixels(a, c, d, p, w, k, z, L >> xo(z));
        }
        else (L = Xl(k, w, d, p, L)) ? A.readPixels(a, c, d, p, w, k, L) : qt(1280);
      },
      Me: function() {
      },
      Le: function(a, c, d, p) {
        A.renderbufferStorage(a, c, d, p);
      },
      od: function(a, c, d, p, w) {
        A.renderbufferStorageMultisample(a, c, d, p, w);
      },
      Wb: function() {
        A.resumeTransformFeedback();
      },
      Ke: function(a, c) {
        A.sampleCoverage(a, !!c);
      },
      fc: function(a, c, d) {
        A.samplerParameterf(rr[a], c, d);
      },
      ec: function(a, c, d) {
        A.samplerParameterf(rr[a], c, at[d >> 2]);
      },
      hc: function(a, c, d) {
        A.samplerParameteri(rr[a], c, d);
      },
      gc: function(a, c, d) {
        A.samplerParameteri(rr[a], c, U[d >> 2]);
      },
      Je: function(a, c, d, p) {
        A.scissor(a, c, d, p);
      },
      Ie: function() {
        qt(1280);
      },
      He: function(a, c, d, p) {
        c = hp(c, d, p), A.shaderSource(Yi[a], c);
      },
      Ge: function(a, c, d) {
        A.stencilFunc(a, c, d);
      },
      Fe: function(a, c, d, p) {
        A.stencilFuncSeparate(a, c, d, p);
      },
      Ee: function(a) {
        A.stencilMask(a);
      },
      De: function(a, c) {
        A.stencilMaskSeparate(a, c);
      },
      Ce: function(a, c, d) {
        A.stencilOp(a, c, d);
      },
      Be: function(a, c, d, p) {
        A.stencilOpSeparate(a, c, d, p);
      },
      Ae: function(a, c, d, p, w, k, L, z, Z) {
        if (2 <= ye.version) if (A.oi) A.texImage2D(a, c, d, p, w, k, L, z, Z);
        else if (Z) {
          var ct = bo(z);
          A.texImage2D(a, c, d, p, w, k, L, z, ct, Z >> xo(ct));
        } else A.texImage2D(
          a,
          c,
          d,
          p,
          w,
          k,
          L,
          z,
          null
        );
        else A.texImage2D(a, c, d, p, w, k, L, z, Z ? Xl(z, L, p, w, Z) : null);
      },
      Kd: function(a, c, d, p, w, k, L, z, Z, ct) {
        if (A.oi) A.texImage3D(a, c, d, p, w, k, L, z, Z, ct);
        else if (ct) {
          var ut = bo(Z);
          A.texImage3D(a, c, d, p, w, k, L, z, Z, ut, ct >> xo(ut));
        } else A.texImage3D(a, c, d, p, w, k, L, z, Z, null);
      },
      ze: function(a, c, d) {
        A.texParameterf(a, c, d);
      },
      ye: function(a, c, d) {
        A.texParameterf(a, c, at[d >> 2]);
      },
      xe: function(a, c, d) {
        A.texParameteri(a, c, d);
      },
      we: function(a, c, d) {
        A.texParameteri(a, c, U[d >> 2]);
      },
      Qb: function(a, c, d, p, w) {
        A.texStorage2D(a, c, d, p, w);
      },
      Pb: function(a, c, d, p, w, k) {
        A.texStorage3D(a, c, d, p, w, k);
      },
      ve: function(a, c, d, p, w, k, L, z, Z) {
        if (2 <= ye.version) if (A.oi) A.texSubImage2D(a, c, d, p, w, k, L, z, Z);
        else if (Z) {
          var ct = bo(z);
          A.texSubImage2D(a, c, d, p, w, k, L, z, ct, Z >> xo(ct));
        } else A.texSubImage2D(a, c, d, p, w, k, L, z, null);
        else ct = null, Z && (ct = Xl(z, L, w, k, Z)), A.texSubImage2D(a, c, d, p, w, k, L, z, ct);
      },
      Jd: function(a, c, d, p, w, k, L, z, Z, ct, ut) {
        if (A.oi) A.texSubImage3D(a, c, d, p, w, k, L, z, Z, ct, ut);
        else if (ut) {
          var At = bo(ct);
          A.texSubImage3D(a, c, d, p, w, k, L, z, Z, ct, At, ut >> xo(At));
        } else A.texSubImage3D(
          a,
          c,
          d,
          p,
          w,
          k,
          L,
          z,
          Z,
          ct,
          null
        );
      },
      dd: function(a, c, d, p) {
        a = Ne[a];
        for (var w = [], k = 0; k < c; k++) w.push(K(U[d + 4 * k >> 2]));
        A.transformFeedbackVaryings(a, w, p);
      },
      ue: function(a, c) {
        A.uniform1f(Zt(a), c);
      },
      te: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform1fv(Zt(a), at, d >> 2, c);
        else {
          if (288 >= c) for (var p = gs[c - 1], w = 0; w < c; ++w) p[w] = at[d + 4 * w >> 2];
          else p = at.subarray(d >> 2, d + 4 * c >> 2);
          A.uniform1fv(Zt(a), p);
        }
      },
      se: function(a, c) {
        A.uniform1i(Zt(a), c);
      },
      re: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform1iv(Zt(a), U, d >> 2, c);
        else {
          if (288 >= c) for (var p = Jl[c - 1], w = 0; w < c; ++w) p[w] = U[d + 4 * w >> 2];
          else p = U.subarray(d >> 2, d + 4 * c >> 2);
          A.uniform1iv(Zt(a), p);
        }
      },
      Tc: function(a, c) {
        A.uniform1ui(Zt(a), c);
      },
      Pc: function(a, c, d) {
        c && A.uniform1uiv(Zt(a), it, d >> 2, c);
      },
      qe: function(a, c, d) {
        A.uniform2f(Zt(a), c, d);
      },
      pe: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform2fv(Zt(a), at, d >> 2, 2 * c);
        else {
          if (144 >= c) for (var p = gs[2 * c - 1], w = 0; w < 2 * c; w += 2) p[w] = at[d + 4 * w >> 2], p[w + 1] = at[d + (4 * w + 4) >> 2];
          else p = at.subarray(d >> 2, d + 8 * c >> 2);
          A.uniform2fv(Zt(a), p);
        }
      },
      oe: function(a, c, d) {
        A.uniform2i(Zt(a), c, d);
      },
      ne: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform2iv(
          Zt(a),
          U,
          d >> 2,
          2 * c
        );
        else {
          if (144 >= c) for (var p = Jl[2 * c - 1], w = 0; w < 2 * c; w += 2) p[w] = U[d + 4 * w >> 2], p[w + 1] = U[d + (4 * w + 4) >> 2];
          else p = U.subarray(d >> 2, d + 8 * c >> 2);
          A.uniform2iv(Zt(a), p);
        }
      },
      Sc: function(a, c, d) {
        A.uniform2ui(Zt(a), c, d);
      },
      Oc: function(a, c, d) {
        c && A.uniform2uiv(Zt(a), it, d >> 2, 2 * c);
      },
      me: function(a, c, d, p) {
        A.uniform3f(Zt(a), c, d, p);
      },
      le: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform3fv(Zt(a), at, d >> 2, 3 * c);
        else {
          if (96 >= c) for (var p = gs[3 * c - 1], w = 0; w < 3 * c; w += 3) p[w] = at[d + 4 * w >> 2], p[w + 1] = at[d + (4 * w + 4) >> 2], p[w + 2] = at[d + (4 * w + 8) >> 2];
          else p = at.subarray(d >> 2, d + 12 * c >> 2);
          A.uniform3fv(Zt(a), p);
        }
      },
      ke: function(a, c, d, p) {
        A.uniform3i(Zt(a), c, d, p);
      },
      je: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform3iv(Zt(a), U, d >> 2, 3 * c);
        else {
          if (96 >= c) for (var p = Jl[3 * c - 1], w = 0; w < 3 * c; w += 3) p[w] = U[d + 4 * w >> 2], p[w + 1] = U[d + (4 * w + 4) >> 2], p[w + 2] = U[d + (4 * w + 8) >> 2];
          else p = U.subarray(d >> 2, d + 12 * c >> 2);
          A.uniform3iv(Zt(a), p);
        }
      },
      Rc: function(a, c, d, p) {
        A.uniform3ui(Zt(a), c, d, p);
      },
      Nc: function(a, c, d) {
        c && A.uniform3uiv(Zt(a), it, d >> 2, 3 * c);
      },
      ie: function(a, c, d, p, w) {
        A.uniform4f(Zt(a), c, d, p, w);
      },
      he: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform4fv(Zt(a), at, d >> 2, 4 * c);
        else {
          if (72 >= c) {
            var p = gs[4 * c - 1], w = at;
            d >>= 2;
            for (var k = 0; k < 4 * c; k += 4) {
              var L = d + k;
              p[k] = w[L], p[k + 1] = w[L + 1], p[k + 2] = w[L + 2], p[k + 3] = w[L + 3];
            }
          } else p = at.subarray(d >> 2, d + 16 * c >> 2);
          A.uniform4fv(Zt(a), p);
        }
      },
      ge: function(a, c, d, p, w) {
        A.uniform4i(Zt(a), c, d, p, w);
      },
      fe: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform4iv(Zt(a), U, d >> 2, 4 * c);
        else {
          if (72 >= c) for (var p = Jl[4 * c - 1], w = 0; w < 4 * c; w += 4) p[w] = U[d + 4 * w >> 2], p[w + 1] = U[d + (4 * w + 4) >> 2], p[w + 2] = U[d + (4 * w + 8) >> 2], p[w + 3] = U[d + (4 * w + 12) >> 2];
          else p = U.subarray(d >> 2, d + 16 * c >> 2);
          A.uniform4iv(Zt(a), p);
        }
      },
      Qc: function(a, c, d, p, w) {
        A.uniform4ui(Zt(a), c, d, p, w);
      },
      Mc: function(a, c, d) {
        c && A.uniform4uiv(Zt(a), it, d >> 2, 4 * c);
      },
      zc: function(a, c, d) {
        a = Ne[a], A.uniformBlockBinding(a, c, d);
      },
      ee: function(a, c, d, p) {
        if (2 <= ye.version) c && A.uniformMatrix2fv(Zt(a), !!d, at, p >> 2, 4 * c);
        else {
          if (72 >= c) for (var w = gs[4 * c - 1], k = 0; k < 4 * c; k += 4) w[k] = at[p + 4 * k >> 2], w[k + 1] = at[p + (4 * k + 4) >> 2], w[k + 2] = at[p + (4 * k + 8) >> 2], w[k + 3] = at[p + (4 * k + 12) >> 2];
          else w = at.subarray(p >> 2, p + 16 * c >> 2);
          A.uniformMatrix2fv(Zt(a), !!d, w);
        }
      },
      vd: function(a, c, d, p) {
        c && A.uniformMatrix2x3fv(
          Zt(a),
          !!d,
          at,
          p >> 2,
          6 * c
        );
      },
      td: function(a, c, d, p) {
        c && A.uniformMatrix2x4fv(Zt(a), !!d, at, p >> 2, 8 * c);
      },
      de: function(a, c, d, p) {
        if (2 <= ye.version) c && A.uniformMatrix3fv(Zt(a), !!d, at, p >> 2, 9 * c);
        else {
          if (32 >= c) for (var w = gs[9 * c - 1], k = 0; k < 9 * c; k += 9) w[k] = at[p + 4 * k >> 2], w[k + 1] = at[p + (4 * k + 4) >> 2], w[k + 2] = at[p + (4 * k + 8) >> 2], w[k + 3] = at[p + (4 * k + 12) >> 2], w[k + 4] = at[p + (4 * k + 16) >> 2], w[k + 5] = at[p + (4 * k + 20) >> 2], w[k + 6] = at[p + (4 * k + 24) >> 2], w[k + 7] = at[p + (4 * k + 28) >> 2], w[k + 8] = at[p + (4 * k + 32) >> 2];
          else w = at.subarray(p >> 2, p + 36 * c >> 2);
          A.uniformMatrix3fv(Zt(a), !!d, w);
        }
      },
      ud: function(a, c, d, p) {
        c && A.uniformMatrix3x2fv(Zt(a), !!d, at, p >> 2, 6 * c);
      },
      rd: function(a, c, d, p) {
        c && A.uniformMatrix3x4fv(Zt(a), !!d, at, p >> 2, 12 * c);
      },
      ce: function(a, c, d, p) {
        if (2 <= ye.version) c && A.uniformMatrix4fv(Zt(a), !!d, at, p >> 2, 16 * c);
        else {
          if (18 >= c) {
            var w = gs[16 * c - 1], k = at;
            p >>= 2;
            for (var L = 0; L < 16 * c; L += 16) {
              var z = p + L;
              w[L] = k[z], w[L + 1] = k[z + 1], w[L + 2] = k[z + 2], w[L + 3] = k[z + 3], w[L + 4] = k[z + 4], w[L + 5] = k[z + 5], w[L + 6] = k[z + 6], w[L + 7] = k[z + 7], w[L + 8] = k[z + 8], w[L + 9] = k[z + 9], w[L + 10] = k[z + 10], w[L + 11] = k[z + 11], w[L + 12] = k[z + 12], w[L + 13] = k[z + 13], w[L + 14] = k[z + 14], w[L + 15] = k[z + 15];
            }
          } else w = at.subarray(p >> 2, p + 64 * c >> 2);
          A.uniformMatrix4fv(Zt(a), !!d, w);
        }
      },
      sd: function(a, c, d, p) {
        c && A.uniformMatrix4x2fv(Zt(a), !!d, at, p >> 2, 8 * c);
      },
      qd: function(a, c, d, p) {
        c && A.uniformMatrix4x3fv(Zt(a), !!d, at, p >> 2, 12 * c);
      },
      be: function(a) {
        a = Ne[a], A.useProgram(a), A.Uj = a;
      },
      ae: function(a) {
        A.validateProgram(Ne[a]);
      },
      $d: function(a, c) {
        A.vertexAttrib1f(a, c);
      },
      _d: function(a, c) {
        A.vertexAttrib1f(a, at[c >> 2]);
      },
      Zd: function(a, c, d) {
        A.vertexAttrib2f(a, c, d);
      },
      Yd: function(a, c) {
        A.vertexAttrib2f(a, at[c >> 2], at[c + 4 >> 2]);
      },
      Xd: function(a, c, d, p) {
        A.vertexAttrib3f(a, c, d, p);
      },
      Wd: function(a, c) {
        A.vertexAttrib3f(a, at[c >> 2], at[c + 4 >> 2], at[c + 8 >> 2]);
      },
      Vd: function(a, c, d, p, w) {
        A.vertexAttrib4f(a, c, d, p, w);
      },
      Ud: function(a, c) {
        A.vertexAttrib4f(a, at[c >> 2], at[c + 4 >> 2], at[c + 8 >> 2], at[c + 12 >> 2]);
      },
      ac: function(a, c) {
        A.vertexAttribDivisor(a, c);
      },
      zg: function(a, c) {
        A.vertexAttribDivisor(a, c);
      },
      Mb: function(a, c) {
        A.vertexAttribDivisor(a, c);
      },
      Qd: function(a, c) {
        A.vertexAttribDivisor(a, c);
      },
      Nb: function(a, c) {
        A.vertexAttribDivisor(a, c);
      },
      Zc: function(a, c, d, p, w) {
        A.vertexAttribI4i(a, c, d, p, w);
      },
      Xc: function(a, c) {
        A.vertexAttribI4i(a, U[c >> 2], U[c + 4 >> 2], U[c + 8 >> 2], U[c + 12 >> 2]);
      },
      Yc: function(a, c, d, p, w) {
        A.vertexAttribI4ui(a, c, d, p, w);
      },
      Wc: function(a, c) {
        A.vertexAttribI4ui(a, it[c >> 2], it[c + 4 >> 2], it[c + 8 >> 2], it[c + 12 >> 2]);
      },
      ad: function(a, c, d, p, w) {
        A.vertexAttribIPointer(a, c, d, p, w);
      },
      Sd: function(a, c, d, p, w, k) {
        A.vertexAttribPointer(a, c, d, !!p, w, k);
      },
      Rd: function(a, c, d, p) {
        A.viewport(a, c, d, p);
      },
      rc: function(a, c, d, p) {
        A.waitSync(wo[a], c, (d >>> 0) + 4294967296 * p);
      },
      Eb: function(a) {
        var c = $.length;
        if (a >>>= 0, 2147483648 < a) return !1;
        for (var d = 1; 4 >= d; d *= 2) {
          var p = c * (1 + 0.2 / d);
          p = Math.min(p, a + 100663296);
          var w = Math;
          p = Math.max(a, p), w = w.min.call(w, 2147483648, p + (65536 - p % 65536) % 65536);
          t: {
            try {
              O.grow(w - ft.byteLength + 65535 >>> 16), Nt();
              var k = 1;
              break t;
            } catch {
            }
            k = void 0;
          }
          if (k) return !0;
        }
        return !1;
      },
      va: function(a, c) {
        return c >>= 2, c = { alpha: !!U[c], depth: !!U[c + 1], stencil: !!U[c + 2], antialias: !!U[c + 3], premultipliedAlpha: !!U[c + 4], preserveDrawingBuffer: !!U[c + 5], powerPreference: jw[U[c + 6]], failIfMajorPerformanceCaveat: !!U[c + 7], Cj: U[c + 8], ol: U[c + 9], Wj: U[c + 10], uk: U[c + 11], sl: U[c + 12], tl: U[c + 13] }, typeof a == "number" && (a = K(a)), a = a && a !== "#canvas" ? typeof Wd < "u" && Jh[a] ? Jh[a] : Gw(a) : typeof Wd < "u" && Jh.canvas ? Jh.canvas : e.canvas, !a || c.uk ? 0 : up(a, c);
      },
      yc: function(a) {
        if (ye == a && (ye = 0), ye === Mr[a] && (ye = null), typeof Uw == "object") {
          for (var c = Mr[a].Qi.canvas, d = 0; d < tu.length; ++d) if (tu[d].target == c) {
            var p = d--, w = tu[p];
            w.target.removeEventListener(w.il, w.hl, w.vl), tu.splice(p, 1);
          }
        }
        Mr[a] && Mr[a].Qi.canvas && (Mr[a].Qi.canvas.lk = void 0), Mr[a] = null;
      },
      cd: function(a) {
        a >>= 2;
        for (var c = 0; 14 > c; ++c) U[a + c] = 0;
        U[a] = U[a + 1] = U[a + 3] = U[a + 4] = U[a + 8] = U[a + 10] = 1;
      },
      Jc: function(a) {
        return dp(a) ? 0 : -5;
      },
      Ab: function(a, c) {
        var d = 0;
        return pp().forEach(function(p, w) {
          var k = c + d;
          for (w = it[a + 4 * w >> 2] = k, k = 0; k < p.length; ++k) H[w++ >> 0] = p.charCodeAt(k);
          H[w >> 0] = 0, d += p.length + 1;
        }), 0;
      },
      Bb: function(a, c) {
        var d = pp();
        it[a >> 2] = d.length;
        var p = 0;
        return d.forEach(function(w) {
          p += w.length + 1;
        }), it[c >> 2] = p, 0;
      },
      la: ep,
      sa: function(a) {
        try {
          var c = Ee(a);
          return _t(c), 0;
        } catch (d) {
          if (typeof ss > "u" || !(d instanceof Ft)) throw d;
          return d.Gi;
        }
      },
      Fb: function(a, c, d, p) {
        try {
          t: {
            var w = Ee(a);
            a = c;
            for (var k = c = 0; k < d; k++) {
              var L = it[a >> 2], z = it[a + 4 >> 2];
              a += 8;
              var Z = w, ct = L, ut = z, At = void 0, Ut = H;
              if (0 > ut || 0 > At) throw new Ft(28);
              if (Z.fd === null) throw new Ft(8);
              if ((Z.flags & 2097155) === 1) throw new Ft(8);
              if ((Z.node.mode & 61440) === 16384) throw new Ft(31);
              if (!Z.ii.read) throw new Ft(28);
              var et = typeof At < "u";
              if (!et) At = Z.position;
              else if (!Z.seekable) throw new Ft(70);
              var bt = Z.ii.read(Z, Ut, ct, ut, At);
              et || (Z.position += bt);
              var $t = bt;
              if (0 > $t) {
                var Me = -1;
                break t;
              }
              if (c += $t, $t < z) break;
            }
            Me = c;
          }
          return it[p >> 2] = Me, 0;
        } catch (Ue) {
          if (typeof ss > "u" || !(Ue instanceof Ft)) throw Ue;
          return Ue.Gi;
        }
      },
      xb: function(a, c, d, p, w) {
        try {
          if (c = d + 2097152 >>> 0 < 4194305 - !!c ? (c >>> 0) + 4294967296 * d : NaN, isNaN(c)) return 61;
          var k = Ee(a);
          return Pt(k, c, p), W = [k.position >>> 0, (q = k.position, 1 <= +Math.abs(q) ? 0 < q ? (Math.min(+Math.floor(q / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((q - +(~~q >>> 0)) / 4294967296) >>> 0 : 0)], U[w >> 2] = W[0], U[w + 4 >> 2] = W[1], k.xj && c === 0 && p === 0 && (k.xj = null), 0;
        } catch (L) {
          if (typeof ss > "u" || !(L instanceof Ft)) throw L;
          return L.Gi;
        }
      },
      ta: function(a, c, d, p) {
        try {
          t: {
            var w = Ee(a);
            a = c;
            for (var k = c = 0; k < d; k++) {
              var L = it[a >> 2], z = it[a + 4 >> 2];
              a += 8;
              var Z = zt(w, H, L, z);
              if (0 > Z) {
                var ct = -1;
                break t;
              }
              c += Z;
            }
            ct = c;
          }
          return it[p >> 2] = ct, 0;
        } catch (ut) {
          if (typeof ss > "u" || !(ut instanceof Ft)) throw ut;
          return ut.Gi;
        }
      },
      ga: function(a) {
        A.activeTexture(a);
      },
      oa: function(a, c) {
        A.attachShader(Ne[a], Yi[c]);
      },
      _g: function(a, c) {
        A.beginQuery(a, Zi[c]);
      },
      ca: function(a, c) {
        a == 35051 ? A.Ji = c : a == 35052 && (A.oi = c), A.bindBuffer(a, nr[c]);
      },
      fa: function(a, c) {
        A.bindFramebuffer(a, Jr[c]);
      },
      eb: function(a, c) {
        A.bindRenderbuffer(
          a,
          sr[c]
        );
      },
      ib: function(a, c) {
        A.bindTexture(a, Ws[c]);
      },
      Wa: function(a, c) {
        A.blendFunc(a, c);
      },
      Xa: function(a, c, d, p) {
        A.blendFuncSeparate(a, c, d, p);
      },
      xh: function(a, c, d, p) {
        2 <= ye.version ? d && c ? A.bufferData(a, $, p, d, c) : A.bufferData(a, c, p) : A.bufferData(a, d ? $.subarray(d, d + c) : c, p);
      },
      wh: function(a, c, d, p) {
        2 <= ye.version ? d && A.bufferSubData(a, c, $, p, d) : A.bufferSubData(a, c, $.subarray(p, p + d));
      },
      s: function(a) {
        A.clear(a);
      },
      Za: function(a, c, d, p) {
        A.clearColor(a, c, d, p);
      },
      Ya: function(a) {
        A.clearStencil(a);
      },
      ab: function(a, c, d, p) {
        A.colorMask(
          !!a,
          !!c,
          !!d,
          !!p
        );
      },
      oh: function(a) {
        A.compileShader(Yi[a]);
      },
      Ia: function() {
        var a = vo(Ne), c = A.createProgram();
        return c.name = a, c.Ci = c.Ai = c.Bi = 0, c.rj = 1, Ne[a] = c, a;
      },
      qh: function(a) {
        var c = vo(Yi);
        return Yi[c] = A.createShader(a), c;
      },
      gb: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = nr[p];
          w && (A.deleteBuffer(w), w.name = 0, nr[p] = null, p == A.Ji && (A.Ji = 0), p == A.oi && (A.oi = 0));
        }
      },
      cb: function(a, c) {
        for (var d = 0; d < a; ++d) {
          var p = U[c + 4 * d >> 2], w = Jr[p];
          w && (A.deleteFramebuffer(w), w.name = 0, Jr[p] = null);
        }
      },
      nh: function(a) {
        if (a) {
          var c = Ne[a];
          c ? (A.deleteProgram(c), c.name = 0, Ne[a] = null) : qt(1281);
        }
      },
      $g: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = Zi[p];
          w && (A.deleteQuery(w), Zi[p] = null);
        }
      },
      db: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = sr[p];
          w && (A.deleteRenderbuffer(w), w.name = 0, sr[p] = null);
        }
      },
      rh: function(a) {
        if (a) {
          var c = Yi[a];
          c ? (A.deleteShader(c), Yi[a] = null) : qt(1281);
        }
      },
      hb: function(a, c) {
        for (var d = 0; d < a; d++) {
          var p = U[c + 4 * d >> 2], w = Ws[p];
          w && (A.deleteTexture(w), w.name = 0, Ws[p] = null);
        }
      },
      Va: function(a) {
        A.depthFunc(a);
      },
      $a: function(a) {
        A.depthMask(!!a);
      },
      Ua: function(a, c) {
        A.depthRange(a, c);
      },
      Oa: function(a) {
        A.disable(a);
      },
      I: function(a) {
        A.disableVertexAttribArray(a);
      },
      U: function(a, c, d) {
        A.drawArrays(a, c, d);
      },
      Ba: function(a, c, d, p) {
        A.drawArraysInstanced(a, c, d, p);
      },
      fh: function(a, c) {
        for (var d = Zo[a], p = 0; p < a; p++) d[p] = U[c + 4 * p >> 2];
        A.drawBuffers(d);
      },
      Ga: fp,
      Ca: function(a, c, d, p, w) {
        A.drawElementsInstanced(a, c, d, p, w);
      },
      Pa: function(a) {
        A.enable(a);
      },
      E: function(a) {
        A.enableVertexAttribArray(a);
      },
      Zg: function(a) {
        A.endQuery(a);
      },
      ih: function() {
        A.finish();
      },
      Ea: function(a, c, d, p) {
        A.framebufferRenderbuffer(
          a,
          c,
          d,
          sr[p]
        );
      },
      eh: function(a, c, d, p, w) {
        A.framebufferTexture2D(a, c, d, Ws[p], w);
      },
      _a: function(a) {
        A.frontFace(a);
      },
      yh: function(a, c) {
        fs(a, c, "createBuffer", nr);
      },
      Fa: function(a, c) {
        fs(a, c, "createFramebuffer", Jr);
      },
      ah: function(a, c) {
        fs(a, c, "createQuery", Zi);
      },
      hh: function(a, c) {
        fs(a, c, "createRenderbuffer", sr);
      },
      th: function(a, c) {
        fs(a, c, "createTexture", Ws);
      },
      vh: function(a) {
        A.generateMipmap(a);
      },
      kh: function(a, c, d, p, w, k, L) {
        Zh("getActiveAttrib", a, c, d, p, w, k, L);
      },
      jh: function(a, c, d, p, w, k, L) {
        Zh("getActiveUniform", a, c, d, p, w, k, L);
      },
      mh: function(a, c) {
        return A.getAttribLocation(Ne[a], K(c));
      },
      kb: function(a, c) {
        Qo(a, c, 4);
      },
      mb: function() {
        var a = A.getError() || ja;
        return ja = 0, a;
      },
      W: function(a, c) {
        Qo(a, c, 2);
      },
      n: function(a, c) {
        Qo(a, c, 0);
      },
      ba: function(a, c, d) {
        if (d) if (a >= Ud) qt(1281);
        else if (a = Ne[a], c == 35716) a = A.getProgramInfoLog(a), a === null && (a = "(unknown error)"), U[d >> 2] = a.length + 1;
        else if (c == 35719) {
          if (!a.Ci) for (c = 0; c < A.getProgramParameter(a, 35718); ++c) a.Ci = Math.max(a.Ci, A.getActiveUniform(a, c).name.length + 1);
          U[d >> 2] = a.Ci;
        } else if (c == 35722) {
          if (!a.Ai) for (c = 0; c < A.getProgramParameter(a, 35721); ++c) a.Ai = Math.max(a.Ai, A.getActiveAttrib(a, c).name.length + 1);
          U[d >> 2] = a.Ai;
        } else if (c == 35381) {
          if (!a.Bi) for (c = 0; c < A.getProgramParameter(a, 35382); ++c) a.Bi = Math.max(a.Bi, A.getActiveUniformBlockName(a, c).length + 1);
          U[d >> 2] = a.Bi;
        } else U[d >> 2] = A.getProgramParameter(a, c);
        else qt(1281);
      },
      za: function(a, c, d) {
        if (d) {
          a = A.getQueryParameter(Zi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, U[d >> 2] = p;
        } else qt(1281);
      },
      lb: function(a, c, d, p) {
        a = A.getShaderPrecisionFormat(a, c), U[d >> 2] = a.rangeMin, U[d + 4 >> 2] = a.rangeMax, U[p >> 2] = a.precision;
      },
      ra: function(a) {
        var c = Yh[a];
        if (!c) {
          switch (a) {
            case 7939:
              c = A.getSupportedExtensions() || [], c = c.concat(c.map(function(p) {
                return "GL_" + p;
              })), c = Yr(c.join(" "));
              break;
            case 7936:
            case 7937:
            case 37445:
            case 37446:
              (c = A.getParameter(a)) || qt(1280), c = c && Yr(c);
              break;
            case 7938:
              c = A.getParameter(7938), c = 2 <= ye.version ? "OpenGL ES 3.0 (" + c + ")" : "OpenGL ES 2.0 (" + c + ")", c = Yr(c);
              break;
            case 35724:
              c = A.getParameter(35724);
              var d = c.match(/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/);
              d !== null && (d[1].length == 3 && (d[1] += "0"), c = "OpenGL ES GLSL ES " + d[1] + " (" + c + ")"), c = Yr(c);
              break;
            default:
              qt(1280);
          }
          Yh[a] = c;
        }
        return c;
      },
      lh: function(a, c) {
        if (c = K(c), a = Ne[a]) {
          $d(a);
          var d = a.Pi, p = 0, w = c, k = Gd(c);
          if (0 < k && (p = parseInt(c.slice(k + 1)) >>> 0, w = c.slice(0, k)), (w = a.sj[w]) && p < w[0] && (p += w[1], d[p] = d[p] || A.getUniformLocation(a, c))) return p;
        } else qt(1281);
        return -1;
      },
      O: function(a) {
        return A.isEnabled(a);
      },
      Ha: function(a) {
        a = Ne[a], A.linkProgram(a), a.Pi = 0, a.sj = {};
      },
      bb: function(a, c) {
        a == 3317 && (jd = c), A.pixelStorei(a, c);
      },
      Ta: function(a, c) {
        A.polygonOffset(a, c);
      },
      dh: function(a, c, d, p, w, k, L) {
        if (2 <= ye.version) if (A.Ji) A.readPixels(a, c, d, p, w, k, L);
        else {
          var z = bo(k);
          A.readPixels(a, c, d, p, w, k, z, L >> xo(z));
        }
        else (L = Xl(k, w, d, p, L)) ? A.readPixels(a, c, d, p, w, k, L) : qt(1280);
      },
      gh: function(a, c, d, p) {
        A.renderbufferStorage(a, c, d, p);
      },
      Sa: function(a, c, d, p) {
        A.scissor(a, c, d, p);
      },
      ph: function(a, c, d, p) {
        c = hp(c, d, p), A.shaderSource(Yi[a], c);
      },
      ea: function(a, c, d) {
        A.stencilFunc(a, c, d);
      },
      V: function(a, c, d, p) {
        A.stencilFuncSeparate(a, c, d, p);
      },
      Ra: function(a) {
        A.stencilMask(a);
      },
      qa: function(a, c) {
        A.stencilMaskSeparate(a, c);
      },
      Qa: function(a, c, d) {
        A.stencilOp(a, c, d);
      },
      pa: function(a, c, d, p) {
        A.stencilOpSeparate(a, c, d, p);
      },
      $: function(a, c, d, p, w, k, L, z, Z) {
        if (2 <= ye.version) if (A.oi) A.texImage2D(a, c, d, p, w, k, L, z, Z);
        else if (Z) {
          var ct = bo(z);
          A.texImage2D(a, c, d, p, w, k, L, z, ct, Z >> xo(ct));
        } else A.texImage2D(a, c, d, p, w, k, L, z, null);
        else A.texImage2D(a, c, d, p, w, k, L, z, Z ? Xl(z, L, p, w, Z) : null);
      },
      uh: function(a, c, d) {
        A.texParameterf(a, c, d);
      },
      G: function(a, c, d) {
        A.texParameteri(a, c, d);
      },
      q: function(a, c) {
        A.uniform1f(Zt(a), c);
      },
      N: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform1fv(Zt(a), at, d >> 2, c);
        else {
          if (288 >= c) for (var p = gs[c - 1], w = 0; w < c; ++w) p[w] = at[d + 4 * w >> 2];
          else p = at.subarray(d >> 2, d + 4 * c >> 2);
          A.uniform1fv(Zt(a), p);
        }
      },
      k: function(a, c) {
        A.uniform1i(Zt(a), c);
      },
      y: function(a, c, d) {
        A.uniform2f(Zt(a), c, d);
      },
      Da: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform2fv(Zt(a), at, d >> 2, 2 * c);
        else {
          if (144 >= c) for (var p = gs[2 * c - 1], w = 0; w < 2 * c; w += 2) p[w] = at[d + 4 * w >> 2], p[w + 1] = at[d + (4 * w + 4) >> 2];
          else p = at.subarray(d >> 2, d + 8 * c >> 2);
          A.uniform2fv(Zt(a), p);
        }
      },
      ch: function(a, c, d) {
        A.uniform2i(Zt(a), c, d);
      },
      ma: function(a, c, d, p) {
        A.uniform3f(Zt(a), c, d, p);
      },
      F: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform3fv(Zt(a), at, d >> 2, 3 * c);
        else {
          if (96 >= c) for (var p = gs[3 * c - 1], w = 0; w < 3 * c; w += 3) p[w] = at[d + 4 * w >> 2], p[w + 1] = at[d + (4 * w + 4) >> 2], p[w + 2] = at[d + (4 * w + 8) >> 2];
          else p = at.subarray(d >> 2, d + 12 * c >> 2);
          A.uniform3fv(Zt(a), p);
        }
      },
      T: function(a, c, d, p, w) {
        A.uniform4f(Zt(a), c, d, p, w);
      },
      r: function(a, c, d) {
        if (2 <= ye.version) c && A.uniform4fv(Zt(a), at, d >> 2, 4 * c);
        else {
          if (72 >= c) {
            var p = gs[4 * c - 1], w = at;
            d >>= 2;
            for (var k = 0; k < 4 * c; k += 4) {
              var L = d + k;
              p[k] = w[L], p[k + 1] = w[L + 1], p[k + 2] = w[L + 2], p[k + 3] = w[L + 3];
            }
          } else p = at.subarray(d >> 2, d + 16 * c >> 2);
          A.uniform4fv(Zt(a), p);
        }
      },
      na: function(a, c, d, p) {
        if (2 <= ye.version) c && A.uniformMatrix3fv(Zt(a), !!d, at, p >> 2, 9 * c);
        else {
          if (32 >= c) for (var w = gs[9 * c - 1], k = 0; k < 9 * c; k += 9) w[k] = at[p + 4 * k >> 2], w[k + 1] = at[p + (4 * k + 4) >> 2], w[k + 2] = at[p + (4 * k + 8) >> 2], w[k + 3] = at[p + (4 * k + 12) >> 2], w[k + 4] = at[p + (4 * k + 16) >> 2], w[k + 5] = at[p + (4 * k + 20) >> 2], w[k + 6] = at[p + (4 * k + 24) >> 2], w[k + 7] = at[p + (4 * k + 28) >> 2], w[k + 8] = at[p + (4 * k + 32) >> 2];
          else w = at.subarray(p >> 2, p + 36 * c >> 2);
          A.uniformMatrix3fv(Zt(a), !!d, w);
        }
      },
      t: function(a, c, d, p) {
        if (2 <= ye.version) c && A.uniformMatrix4fv(Zt(a), !!d, at, p >> 2, 16 * c);
        else {
          if (18 >= c) {
            var w = gs[16 * c - 1], k = at;
            p >>= 2;
            for (var L = 0; L < 16 * c; L += 16) {
              var z = p + L;
              w[L] = k[z], w[L + 1] = k[z + 1], w[L + 2] = k[z + 2], w[L + 3] = k[z + 3], w[L + 4] = k[z + 4], w[L + 5] = k[z + 5], w[L + 6] = k[z + 6], w[L + 7] = k[z + 7], w[L + 8] = k[z + 8], w[L + 9] = k[z + 9], w[L + 10] = k[z + 10], w[L + 11] = k[z + 11], w[L + 12] = k[z + 12], w[L + 13] = k[z + 13], w[L + 14] = k[z + 14], w[L + 15] = k[z + 15];
            }
          } else w = at.subarray(p >> 2, p + 64 * c >> 2);
          A.uniformMatrix4fv(Zt(a), !!d, w);
        }
      },
      fb: function(a) {
        a = Ne[a], A.useProgram(a), A.Uj = a;
      },
      Aa: function(a, c) {
        A.vertexAttrib1f(a, c);
      },
      bh: function(a, c, d, p, w) {
        A.vertexAttrib4f(a, c, d, p, w);
      },
      H: function(a, c) {
        A.vertexAttribDivisor(a, c);
      },
      C: function(a, c, d, p, w, k) {
        A.vertexAttribPointer(a, c, d, !!p, w, k);
      },
      jb: function(a, c, d, p) {
        A.viewport(a, c, d, p);
      },
      sh: function(a, c, d, p, w) {
        Fd(), a = $.subarray(a, a + c), c = null, d = ["image/jpeg", "image/png", "image/gif", "image/bmp", "image/svg+xml"][d];
        var k = [A.LUMINANCE, A.LUMINANCE_ALPHA, A.RGB, A.RGBA][p - 1];
        if (k === void 0 && (k = A.RGBA), Ua) try {
          c = new Blob([a], { type: d }), c.size !== a.length && (c = new Blob(
            [new Uint8Array(a).buffer],
            { type: d }
          ));
        } catch {
        }
        c || (d = new Hd(), d.append(new Uint8Array(a).buffer), c = d.getBlob());
        var L = Wa("wrapperTexturePreLoad", "number", ["number", "number", "number", "number"]), z = Wa("wrapperTexturePostLoad", null, ["number", "number", "number"]), Z = Wa("wrapperTextureOnError", null, ["number", "number"]), ct = yo.createObjectURL(c), ut = document.createElement("img"), At = e.$$facade;
        ut.onload = function() {
          if (At === e.$$facade) {
            var Ut = 1;
            L && (Ut = L(w, ut.width, ut.height, p));
            var et = 0;
            if (Ut) try {
              A.texImage2D(A.TEXTURE_2D, 0, k, k, A.UNSIGNED_BYTE, ut), et = 1;
            } catch {
            }
            z && z(0, w, et);
          } else z && z(1, w, 0);
          yo.revokeObjectURL(ct);
        }, ut.onerror = function() {
          At === e.$$facade ? Z && Z(0, w) : Z && Z(1, w), yo.revokeObjectURL(ct);
        }, ut.src = ct;
      },
      ya: function() {
        return e.bj ? ta.close.apply(ta, arguments) : ea.close.apply(ea, arguments);
      },
      Yg: function() {
        window.addEventListener("beforeunload", function() {
          e.bj ? ta.close() : ea.close();
        });
      },
      Xg: function(a, c, d) {
        return e.bk = 0, self.bowser.chrome && 0 > self.bowser.compareVersions([self.bowser.version, "68"]) && (e.bj = !0), e.bj ? ta.connect.apply(ta, arguments) : ea.connect.apply(
          ea,
          arguments
        );
      },
      Wg: function(a, c) {
        return e.bj ? ta.Jj.apply(ta, arguments) : ea.Jj.apply(ea, arguments);
      },
      zb: function(a, c, d, p) {
        return $w(a, c, d, p);
      }
    };
    (function() {
      function a(w) {
        e.asm = w.exports, O = e.asm.Ih, Nt(), lt = e.asm.Kh, Ht.unshift(e.asm.Jh), Be();
      }
      function c(w) {
        a(w.instance);
      }
      function d(w) {
        return pt().then(function(k) {
          return WebAssembly.instantiate(k, p);
        }).then(function(k) {
          return k;
        }).then(w, function(k) {
          M("failed to asynchronously prepare wasm: " + k), pe(k);
        });
      }
      var p = { a: Xw };
      if (Se(), e.instantiateWasm) try {
        return e.instantiateWasm(p, a);
      } catch (w) {
        M("Module.instantiateWasm callback failed with error: " + w), n(w);
      }
      return function() {
        return P || typeof WebAssembly.instantiateStreaming != "function" || ki() || ii.startsWith("file://") || f || typeof fetch != "function" ? d(c) : fetch(ii, { credentials: "same-origin" }).then(function(w) {
          return WebAssembly.instantiateStreaming(w, p).then(c, function(k) {
            return M("wasm streaming compile failed: " + k), M("falling back to ArrayBuffer instantiation"), d(c);
          });
        });
      }().catch(n), {};
    })(), e.___wasm_call_ctors = function() {
      return (e.___wasm_call_ctors = e.asm.Jh).apply(null, arguments);
    }, e._callFuncWrapper = function() {
      return (e._callFuncWrapper = e.asm.Lh).apply(null, arguments);
    }, e._main = function() {
      return (e._main = e.asm.Mh).apply(null, arguments);
    }, e._wrapperTexturePreLoad = function() {
      return (e._wrapperTexturePreLoad = e.asm.Nh).apply(null, arguments);
    }, e._wrapperTexturePostLoad = function() {
      return (e._wrapperTexturePostLoad = e.asm.Oh).apply(null, arguments);
    }, e._wrapperTextureOnError = function() {
      return (e._wrapperTextureOnError = e.asm.Ph).apply(null, arguments);
    };
    var Pr = e._free = function() {
      return (Pr = e._free = e.asm.Qh).apply(null, arguments);
    }, bp = e.___errno_location = function() {
      return (bp = e.___errno_location = e.asm.Rh).apply(null, arguments);
    }, Yl = e._malloc = function() {
      return (Yl = e._malloc = e.asm.Sh).apply(null, arguments);
    };
    e._webSocketHandlerOnMessage = function() {
      return (e._webSocketHandlerOnMessage = e.asm.Th).apply(null, arguments);
    };
    var xp = e.___getTypeName = function() {
      return (xp = e.___getTypeName = e.asm.Uh).apply(null, arguments);
    };
    e.__embind_initialize_bindings = function() {
      return (e.__embind_initialize_bindings = e.asm.Vh).apply(null, arguments);
    };
    var nu = e.stackSave = function() {
      return (nu = e.stackSave = e.asm.Wh).apply(null, arguments);
    }, su = e.stackRestore = function() {
      return (su = e.stackRestore = e.asm.Xh).apply(null, arguments);
    }, Zl = e.stackAlloc = function() {
      return (Zl = e.stackAlloc = e.asm.Yh).apply(null, arguments);
    };
    e.dynCall_viiijiiiiiiiiiii = function() {
      return (e.dynCall_viiijiiiiiiiiiii = e.asm.Zh).apply(null, arguments);
    }, e.dynCall_iij = function() {
      return (e.dynCall_iij = e.asm._h).apply(null, arguments);
    }, e.dynCall_iiiiiijii = function() {
      return (e.dynCall_iiiiiijii = e.asm.$h).apply(null, arguments);
    }, e.dynCall_jiji = function() {
      return (e.dynCall_jiji = e.asm.ai).apply(null, arguments);
    }, e.dynCall_viijii = function() {
      return (e.dynCall_viijii = e.asm.bi).apply(null, arguments);
    }, e.dynCall_iiiiij = function() {
      return (e.dynCall_iiiiij = e.asm.ci).apply(null, arguments);
    }, e.dynCall_iiiiijj = function() {
      return (e.dynCall_iiiiijj = e.asm.di).apply(null, arguments);
    }, e.dynCall_iiiiiijj = function() {
      return (e.dynCall_iiiiiijj = e.asm.ei).apply(null, arguments);
    }, e.___emscripten_embedded_file_data = 662548, e.addRunDependency = Se, e.removeRunDependency = Be, e.FS_createPath = bi, e.FS_createDataFile = Ai, e.FS_createPreloadedFile = Kn, e.FS_createLazyFile = Jo, e.FS_createDevice = hn, e.FS_unlink = E, e.ccall = Jd, e.cwrap = Wa;
    var ru;
    re = function a() {
      ru || Ip(), ru || (re = a);
    };
    function Ip() {
      function a() {
        if (!ru && (ru = !0, e.calledRun = !0, !B)) {
          if (e.noFSInit || ni || (ni = !0, me(), e.stdin = e.stdin, e.stdout = e.stdout, e.stderr = e.stderr, e.stdin ? hn("/dev", "stdin", e.stdin) : S("/dev/tty", "/dev/stdin"), e.stdout ? hn("/dev", "stdout", null, e.stdout) : S("/dev/tty", "/dev/stdout"), e.stderr ? hn("/dev", "stderr", null, e.stderr) : S("/dev/tty1", "/dev/stderr"), tt("/dev/stdin", 0), tt("/dev/stdout", 1), tt("/dev/stderr", 1)), xr = !1, It(Ht), It(St), i(e), e.onRuntimeInitialized && e.onRuntimeInitialized(), Cp) {
            var c = e._main;
            try {
              var d = c(0, 0);
              ep(d, !0);
            } catch (p) {
              ip(p);
            }
          }
          if (e.postRun) for (typeof e.postRun == "function" && (e.postRun = [e.postRun]); e.postRun.length; ) c = e.postRun.shift(), Rt.unshift(c);
          It(Rt);
        }
      }
      if (!(0 < ai)) {
        if (e.preRun) for (typeof e.preRun == "function" && (e.preRun = [e.preRun]); e.preRun.length; ) ei();
        It(ot), 0 < ai || (e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            e.setStatus("");
          }, 1), a();
        }, 1)) : a());
      }
    }
    if (e.preInit) for (typeof e.preInit == "function" && (e.preInit = [e.preInit]); 0 < e.preInit.length; ) e.preInit.pop()();
    var Cp = !0;
    return e.noInitialRun && (Cp = !1), Ip(), t.ready;
  };
})();
window.bowser = _v;
const pn = class pn {
  // store instance arguments and return empty base object that will
  // be populated asynchronously
  static async createInstance(t) {
    const e = {
      isWrapper: !0,
      base: {},
      args: t,
      enginePath: t.enginePath ?? pn.defaultEnginePath
    };
    return await pn.createScInstance(e), e.base;
  }
  static catchExceptions(t, e) {
    return function(...i) {
      try {
        e.apply(this, i);
      } catch (n) {
        console.log("Unhandled exception in " + t + "():"), console.log(n);
      }
    };
  }
  static getElement(t) {
    return typeof t != "string" ? t : document.getElementById(t);
  }
  static getAvailableCore() {
    for (const t of pn.core_pool)
      if (t.$$available)
        return t;
    return null;
  }
  static async getWasmBinary(t) {
    if (pn.defaultBinary)
      return pn.defaultBinary;
    const e = new URL((t || "") + "/engine.esm.wasm", window.location.toString()), i = await fetch(e);
    if (!i.ok)
      return;
    const n = await i.arrayBuffer();
    return new Uint8Array(n);
  }
  static createRenderCanvas(t) {
    const e = t.containers.get(Ae.Default);
    let i = new OffscreenCanvas(
      e.clientWidth,
      e.clientHeight
    );
    return i.getContext("webgl2") || (console.debug(
      "WebGL2 context not supported with OffscreenCanvas, fallback with HTMLCanvasElement"
    ), i = document.createElement("canvas"), i.width = e.clientWidth, i.height = e.clientHeight), i;
  }
  static createCore(t, e) {
    console.assert(t.canvas !== void 0);
    const i = {
      $$available: !1,
      $$facade: t,
      callAfterMap: { index: 0, indexedWrappers: {} },
      canvas: t.canvas,
      wasmBinary: e
    };
    return pn.core_pool.push(i), i;
  }
  static async getCore(t, e) {
    let i = pn.getAvailableCore();
    const n = !i;
    if (n ? t.canvas = pn.createRenderCanvas(t) : t.canvas = i == null ? void 0 : i.canvas, i === null) {
      const r = await pn.getWasmBinary(e.enginePath);
      if (r === void 0)
        throw typeof e.onError == "function" && e.onError("Unable to load engine binary"), "Unable to load engine binary";
      i = pn.createCore(t, r);
    }
    return i.$$available = !1, i.$$facade = t, i.$$onReady = pn.catchExceptions("onReady", function() {
      const r = e.onReady;
      typeof r == "function" && r(t);
    }), typeof e.onError == "function" && (i.onAbort = pn.catchExceptions("onError", function(r) {
      e.onError("fatal error: see console " + r);
    })), typeof e.enginePath == "string" && (i.locateFile = (r) => `${e.enginePath}/${r}`), { core: i, isNew: n };
  }
  static getFacade(t) {
    let e, i;
    e = t.base, i = t.args;
    const n = pn.getElement(i.container);
    if (!n) throw new TypeError("'container' argument is missing or invalid");
    e.containers = /* @__PURE__ */ new Map(), e.containers.set(Ae.Default, n);
    const r = this.createWrapper();
    return e.wrappers = /* @__PURE__ */ new Map(), e.wrappers.set(Ae.Default, r), { facade: e, args: i };
  }
  static setupNewView(t, e, i) {
    const n = pn.getElement(i), r = this.createWrapper();
    if (t.wrappers.set(e, r), !n)
      throw new TypeError("'container' argument is missing or invalid");
    t.containers.set(e, n), this.createSubContainer(t, e);
  }
  static createWrapper() {
    const t = document.createElement("div");
    return t.setAttribute(
      "style",
      "position: absolute; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), t;
  }
  static createSubContainer(t, e) {
    const i = document.createElement("div");
    i.setAttribute(
      "style",
      "position: relative; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    );
    const n = document.createElement("div");
    n.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), n.onmousedown = function(l) {
      l.preventDefault();
    }, n.oncontextmenu = function(l) {
      l.preventDefault();
    };
    const r = t.wrappers.get(e);
    i.appendChild(r), i.appendChild(n);
    const o = t.containers.get(e);
    return o.innerHTML = "", o.appendChild(i), i;
  }
  static async createScInstance(t) {
    const { facade: e, args: i } = pn.getFacade(t), { core: n, isNew: r } = await pn.getCore(e, i);
    return pn.createSubContainer(e, Ae.Default), r ? yv(n) : setTimeout(function() {
      n.$$setReady && n.$$setReady();
    }), e;
  }
};
pn.core_pool = [];
let oo = pn;
const $C = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AntiAliasingMode: il,
  AttachScope: ba,
  BimMask: _n,
  BimType: bc,
  BlurIntervalUnit: xc,
  ColorType: An,
  CullingVectorSpace: Rm,
  CuttingSectionKey: el,
  DataKey: Lu,
  DrawMode: fr,
  DrawStrategy: Lm,
  ElementMask: Fm,
  ElementType: an,
  GroupKey: Am,
  HighlightFilter: Rr,
  HighlightMode: Bu,
  ImageFormat: Mo,
  ImageKey: Tm,
  InclusionKey: Ni,
  InstanceKey: eg,
  Key: tg,
  LightKey: Dm,
  LightSpace: Om,
  LightType: Fu,
  LinePatternLengthUnit: Bm,
  MasterModelKey: jr,
  MatrixKey: Nm,
  MeshKey: vc,
  ModelKey: Is,
  OverlayAnchor: dr,
  OverlayUnit: nl,
  PointShape: Vm,
  PointSizeUnit: zm,
  Projection: Gc,
  SessionType: nn,
  SetVisibility: ao,
  SimpleReflectionAttenuationUnit: ig,
  SmaaQuality: Hm,
  StateFailure: ng,
  StreamcacheModule: oo,
  TextureInterpolation: Vu,
  TextureMipMapping: zu,
  TextureModifier: Ic,
  TextureParameterization: Hu,
  TextureTiling: Uu,
  TransparencyMode: Um,
  UnspecifiedMeasurementUnit: Ds,
  ViewKey: Ae,
  XRayGroup: ju,
  getStateFailure: jm,
  isError: ca
}, Symbol.toStringTag, { value: "Module" }));
function cd(s) {
  const t = /* @__PURE__ */ new Map();
  return s.forEach((e, i) => {
    t.set(i, e);
  }), t;
}
function wv(s) {
  const t = /* @__PURE__ */ new Set();
  return s.forEach((e) => {
    t.add(e);
  }), t;
}
function Cc(s) {
  const t = /* @__PURE__ */ new Set();
  for (const e of s)
    t.add(e);
  return t;
}
function lo(s) {
  const t = [];
  return s.forEach((e) => {
    t.push(e);
  }), t;
}
function wf(s, t) {
  const e = lo(s).filter((i) => !t.has(i));
  return Cc(e);
}
function Wu(s) {
  const t = {
    origin: [],
    direction: []
  };
  return s.origin.toArray(t.origin), s.direction.toArray(t.direction), t;
}
function hu(s) {
  const t = new kb();
  return t.pos1.fromArray(s.point1), t.pos2.fromArray(s.point2), t.distance = s.distance, t;
}
function ne(s, t) {
  return (s & t) === t;
}
function fa(s, t, e) {
  return e ? s | t : s & ~t;
}
function vv(s) {
  let t = "";
  const e = s.byteLength;
  for (let i = 0; i < e; i++)
    t += String.fromCharCode(s[i]);
  return window.btoa(t);
}
function kp(s) {
  let t = Math.abs(s.x), e = Math.abs(s.y), i = Math.abs(s.z);
  return t = +t.toFixed(6), e = +e.toFixed(6), i = +i.toFixed(6), t > e && t > i ? new m(1, 0, 0) : e > t && e > i ? new m(0, 1, 0) : i > t && i > e ? new m(0, 0, 1) : null;
}
function $c(s) {
  return JSON.parse(JSON.stringify(s));
}
function bv(s, t) {
  for (const e in s)
    Object.prototype.hasOwnProperty.call(s, e) && (t[e] = s[e]);
}
function sl(s, t) {
  return s === void 0 ? t : s;
}
function qc(s, t) {
  const e = s.length > t.length ? s.length : t.length;
  for (let i = 0; i < e; ++i) {
    const n = s[i] || 0, r = t[i] || 0;
    if (n > r)
      return !0;
    if (n < r)
      return !1;
  }
  return !0;
}
function Gm(s) {
  if (s.length === 0)
    return "";
  let t = `${s[0]}`;
  for (let e = 1; e < s.length; ++e)
    t += `.${s[e]}`;
  return t;
}
function xv() {
  return window.crypto || window.msCrypto;
}
const Iv = "²", Cv = "³";
function Ep(s) {
  if (s instanceof Map)
    return s;
  const t = /* @__PURE__ */ new Map(), e = Object.keys(s);
  for (const i of e) {
    const n = s[i];
    t.set(parseInt(i, 10), n);
  }
  return t;
}
const $m = /* @__PURE__ */ new Map();
function us(s, t) {
  $m.set(s, t);
}
function sg(s) {
  return $m.get(s);
}
const Ts = -1;
function Pl(s) {
  return console.assert(s !== Ts), s > Ts;
}
function Sv(s) {
  return console.assert(Pl(s)), s;
}
function qo(s, t) {
  return Pl(s) ? qi(t).toRuntimeId(s) : s;
}
class rg {
  static parseXml(t) {
    console.assert(t.localName === "Material");
    let e = null, i = null;
    const n = t.getAttribute("Color");
    if (n !== null) {
      const r = n.split(" ");
      if (r.length !== 4)
        throw new si('Expected "Color" attribute to have four channel components.');
      const o = parseFloat(r[0]), l = parseFloat(r[1]), h = parseFloat(r[2]), u = parseFloat(r[3]);
      e = new yt(o, l, h), i = u;
    }
    return new rg(e, i);
  }
  constructor(t, e) {
    t !== null && (this._color = t), e !== null && (this._alpha = e);
  }
  getColor() {
    return this._color !== void 0 ? this._color : null;
  }
  getAlpha() {
    return this._alpha !== void 0 ? this._alpha : null;
  }
}
var ti = /* @__PURE__ */ ((s) => (s[s.Id = 1] = "Id", s[s.Name = 2] = "Name", s[s.Visiblity = 4] = "Visiblity", s[s.Transform = 8] = "Transform", s[s.SubNodes = 16] = "SubNodes", s[s.Instance = 32] = "Instance", s[s.InstanceQuickAccess = 64] = "InstanceQuickAccess", s[s.BodyInstances = 128] = "BodyInstances", s[s.Attributes = 256] = "Attributes", s[s.PartDataLink = 512] = "PartDataLink", s[s.Bodies = 1024] = "Bodies", s[s.FaceMeasurement = 2048] = "FaceMeasurement", s[s.EdgeMeasurement = 4096] = "EdgeMeasurement", s[s.MeshKey = 8192] = "MeshKey", s[s.Unit = 16384] = "Unit", s[s.Views = 32768] = "Views", s[s.Pmis = 65536] = "Pmis", s[s.ScInclusionKey = 131072] = "ScInclusionKey", s[s.ScInstanceKey = 262144] = "ScInstanceKey", s[s.ExternalModel = 524288] = "ExternalModel", s[s.PhysicalProperties = 1048576] = "PhysicalProperties", s[s.VersionNumber = 2097152] = "VersionNumber", s[s.ProductBits = 4194304] = "ProductBits", s[s.Header = 8388608] = "Header", s[s.FrontUpVector = 16777216] = "FrontUpVector", s[s.ExchangeId = 33554432] = "ExchangeId", s[s.LayerId = 67108864] = "LayerId", s[s.LayerList = 134217728] = "LayerList", s[s.Filters = 268435456] = "Filters", s[s.UserData = 536870912] = "UserData", s[s.UseNodeParseBits2 = 1073741824] = "UseNodeParseBits2", s))(ti || {}), yr = /* @__PURE__ */ ((s) => (s[s.FaceAttributes = 1] = "FaceAttributes", s[s.EdgeAttributes = 2] = "EdgeAttributes", s[s.OriginalName = 4] = "OriginalName", s[s.GenericTypes = 8] = "GenericTypes", s[s.GenericTypeId = 16] = "GenericTypeId", s[s.GenericId = 32] = "GenericId", s[s.DoublePrecisionMatrices = 64] = "DoublePrecisionMatrices", s[s.PointAttributes = 128] = "PointAttributes", s[s.Relationships = 256] = "Relationships", s[s.Modifiers = 512] = "Modifiers", s))(yr || {}), bn = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s[s.Camera = 2] = "Camera", s[s.Pmi = 4] = "Pmi", s[s.Frame = 8] = "Frame", s[s.ShowNodes = 16] = "ShowNodes", s[s.HideNodes = 32] = "HideNodes", s[s.MoveNodes = 64] = "MoveNodes", s[s.CuttingPlanes = 128] = "CuttingPlanes", s[s.IsAnnotationView = 256] = "IsAnnotationView", s[s.IsNotCameraSet = 512] = "IsNotCameraSet", s[s.IsNotPmiFilteringSet = 1024] = "IsNotPmiFilteringSet", s[s.IsNotGeomFilteringSet = 2048] = "IsNotGeomFilteringSet", s[s.IsNotCrosssectionSet = 4096] = "IsNotCrosssectionSet", s[s.IsNotExplosionSet = 8192] = "IsNotExplosionSet", s[s.IsCombineState = 16384] = "IsCombineState", s[s.IsPerspective = 32768] = "IsPerspective", s[s.IsDefaultView = 65536] = "IsDefaultView", s[s.ViewFilters = 131072] = "ViewFilters", s))(bn || {}), oa = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s[s.TopoRef = 2] = "TopoRef", s[s.Attributes = 4] = "Attributes", s[s.InitiallyHidden = 8] = "InitiallyHidden", s[s.HasMultipleBodies = 16] = "HasMultipleBodies", s[s.ExchangeId = 32] = "ExchangeId", s))(oa || {}), lc = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s[s.LayerItem = 2] = "LayerItem", s[s.EntityItem = 4] = "EntityItem", s[s.ScId = 8] = "ScId", s))(lc || {}), qm = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s))(qm || {}), vf = /* @__PURE__ */ ((s) => (s[s.ValueName = 1] = "ValueName", s[s.Units = 2] = "Units", s))(vf || {}), vu = /* @__PURE__ */ ((s) => (s[s.Type = 1] = "Type", s[s.Related = 2] = "Related", s[s.Relating = 4] = "Relating", s))(vu || {}), Nn = /* @__PURE__ */ ((s) => (s[s.BeforeAction = 0] = "BeforeAction", s[s.AfterAction = 1] = "AfterAction", s))(Nn || {});
function Mv(s, t) {
  let e = 0;
  for (let i = 0; i < s.length; ++i) {
    const n = s[i];
    t(n) && (s[e++] = n);
  }
  s.length = e;
}
class Cs {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced.
   */
  static create(t) {
    return new Cs(t);
  }
  constructor(t) {
    this._deferredValue = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return this._deferredValue !== null && (this._resolvedValue = this._deferredValue(), this._deferredValue = null), this._resolvedValue;
  }
}
const Pv = 1024;
class Ap {
  constructor() {
    this.items = [], this.next = null;
  }
}
class Km {
  constructor() {
    this.clear();
  }
  clear() {
    this._head = new Ap(), this._tail = this._head, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(t) {
    if (++this._size, this._tail.items.length === Pv) {
      const e = new Ap();
      this._tail.next = e, this._tail = e;
    }
    this._tail.items.push(t);
  }
  pop() {
    console.assert(this._size > 0), console.assert(this._head.items.length > 0), --this._size;
    const t = this._head.items.shift();
    if (this._head.items.length === 0) {
      const e = this._head.next;
      e === null ? console.assert(this._head === this._tail) : this._head = e;
    }
    return t;
  }
}
function vi() {
  let s, t;
  const e = new Promise((i, n) => {
    s = i, t = n;
  });
  return e.resolve = s, e.reject = t, e;
}
class Sc {
  /**
   * Creates a new [ActionQueue]
   * @param maxActivePromises Max number of promises to leave open before they begin getting deferred
   * @param suppressFailures Whether or not rejected promises and actions that throw cause the queue to fail
   */
  constructor(t, e) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._suppressFailures = e, this._deferredActions = new Km();
  }
  /**
   * Returns `true` if there are no actions waiting to be evaluated
   * @returns Boolean indicating idle status
   */
  isIdle() {
    return this._activePromiseCount === 0;
  }
  /**
   * Returns a `Promise<void>` that resolves when all actions have been completed or rejects if there
   * was a failure
   *
   * It should be noted that if the queue is configured not to suppress failures and an action throws an error,
   * any deferred actions (actions that were queued but not active at the time of the failure) will be
   * cleared from the queue and will not be evaluated
   * @returns A promise that resolves/rejects when all actions have been completed
   */
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = vi()), this._idlePromise;
  }
  /**
   * Pushes a new [ActionLike] to be evaluated onto the queue
   * @param action
   */
  push(t) {
    typeof t == "function" && (t = Cs.create(t)), this._activePromiseCount < this._maxActivePromises ? (console.assert(this._deferredActions.length === 0), this._immediateAction(t)) : this._deferredActions.push(t);
  }
  _immediateAction(t) {
    if (this._failed)
      return console.assert(this._deferredActions.length === 0), !0;
    let e;
    try {
      e = t.get();
    } catch (i) {
      this._suppressFailures || (this._failed = !0, this._failureError = i, this._deferredActions.clear());
    }
    return e === void 0 ? !0 : (++this._activePromiseCount, e.then((i) => (this._finalizePromise(), i)).catch((i) => {
      throw this._finalizePromise(), i;
    }), !1);
  }
  _finalizePromise() {
    if (--this._activePromiseCount, this._failed && console.assert(this._deferredActions.length === 0), this._deferredActions.length > 0)
      do {
        const t = this._deferredActions.pop();
        if (!this._immediateAction(t))
          break;
      } while (this._deferredActions.length > 0);
    this._tryActivateIdlePromise();
  }
  _tryActivateIdlePromise() {
    this._activePromiseCount === 0 && (console.assert(this._deferredActions.length === 0), this._idlePromise !== null && (this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null));
  }
}
class fo {
  /**
   * Creates a new `CurrentAction`.
   * @param suppressFailures Controls whether or not thrown action errors cause `waitForIdle` to throw.
   */
  constructor(t) {
    this._active = null, this._pending = null, this._idlePromise = null, this._suppressFailures = t;
  }
  /**
   * Queries the idle state of this object.
   * @return `true` if there are no executing actions and `false` otherwise.
   */
  isIdle() {
    return this._active === null;
  }
  /**
   * Creates `Promise` that can be used to wait for this object to become idle.
   *
   * If this object was created with `suppressFailures`, then the returned `Promise`
   * never throws. Otherwise action failures (from `this.set`) propagate to the returned `Promise`.
   *
   * @return The idle `Promise`.
   */
  waitForIdle() {
    return this.isIdle() ? Promise.resolve() : (this._idlePromise === null && (this._idlePromise = vi()), this._idlePromise);
  }
  /**
   * Sets the action to execute to the one supplied.
   *
   * If this object is idle, then the action is immediately executed,
   * and this object is no longer as long as the action is running.
   *
   * Otherwise if the object is not idle, then action becomes pended
   * and will execute after the current one finishes. If an action is
   * already pended, then the prior pending action is replaced by the
   * newly supplied action and is discarded.
   *
   * @param action
   */
  set(t) {
    if (typeof t == "function" && (t = Cs.create(t)), this._active === null) {
      let e;
      try {
        e = t.get();
      } catch (i) {
        return this._advance(!this._suppressFailures, i);
      }
      if (e === void 0)
        return this._advance(!1, null);
      this._active = e.then(() => {
        this._advance(!1, null);
      }).catch((i) => {
        this._advance(!this._suppressFailures, i);
      });
    } else
      this._pending = t;
  }
  _advance(t, e) {
    if (this._active = null, t && (this._pending = null), this._pending === null)
      this._idlePromise !== null && (t ? this._idlePromise.reject(e) : this._idlePromise.resolve(), this._idlePromise = null);
    else {
      const i = this._pending;
      this._pending = null, this.set(i);
    }
  }
  /**
   * Clears and discards any pending actions. If an action is
   * currently being executed, it remains unaffected by this.
   */
  clear() {
    this._pending = null;
  }
}
function We(s) {
  return Promise.all(s);
}
class kv {
  constructor(t) {
    this.promise = vi(), this.ids = t;
  }
}
class Ev {
  constructor() {
    this._aliasMap = /* @__PURE__ */ new Map(), this._callbackMap = /* @__PURE__ */ new Map(), this._activeTriggerDepth = 0, this._pendingClearUnboundFilteredNames = /* @__PURE__ */ new Set(), this._aliasMap.set("sceneRendered", "frameDrawn");
  }
  _filterName(t) {
    const e = this._aliasMap.get(t);
    return e === void 0 ? t : e;
  }
  bind(t, e) {
    const i = Object.keys(t);
    for (const n of i) {
      const r = t[n];
      if (typeof r == "function") {
        const o = this._filterName(n), l = this._callbackMap.get(o);
        l === void 0 ? this._callbackMap.set(o, [r]) : e ? l.unshift(r) : l.push(r);
      }
    }
  }
  unbind(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const n = this._filterName(i), r = this._callbackMap.get(n);
      if (r !== void 0) {
        const o = t[i];
        for (let l = 0; l < r.length; l++)
          r[l] === o && (r[l] = null, this._pendingClearUnboundFilteredNames.add(n));
      }
    }
    this._clearUnboundCallbacks();
  }
  _clearUnboundCallbacks() {
    this._pendingClearUnboundFilteredNames.size !== 0 && this._activeTriggerDepth === 0 && (this._pendingClearUnboundFilteredNames.forEach((t) => {
      let e = this._callbackMap.get(t);
      e !== void 0 && (e = e.filter((i) => i !== null), e.length === 0 ? this._callbackMap.delete(t) : this._callbackMap.set(t, e));
    }), this._pendingClearUnboundFilteredNames.clear());
  }
  async promiseTrigger(t, e, ...i) {
    console.assert(t !== e);
    try {
      await this._unsafePromiseTrigger(t, i);
    } catch (n) {
      console.error(`Rejected promise in '${t}' callback:`, n);
    } finally {
      e !== null && this.unsafeTrigger(e, i);
    }
  }
  // Unsafe from a type safety point of view.
  _unsafePromiseTrigger(t, e) {
    const i = this._filterName(t), n = this._callbackMap.get(i), r = [];
    if (n !== void 0) {
      ++this._activeTriggerDepth;
      for (const o of n)
        if (o !== null)
          try {
            r.push(o(...e ?? []));
          } catch (l) {
            console.error(`Unhandled exception in '${t}' callback:`, l);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
    return We(r);
  }
  trigger(t, ...e) {
    this.unsafeTrigger(t, e);
  }
  // Unsafe from a type safety point of view.
  unsafeTrigger(t, e) {
    const i = this._filterName(t), n = this._callbackMap.get(i);
    if (n !== void 0) {
      ++this._activeTriggerDepth;
      for (const r of n)
        if (r !== null)
          try {
            r(...e ?? []);
          } catch (o) {
            console.error(`Unhandled exception in '${t}' callback:`, o);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
  }
}
var Xm = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Line = 1] = "Line", s[s.Circle = 2] = "Circle", s[s.Other = 6] = "Other", s))(Xm || {}), Jm = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Cylinder = 3] = "Cylinder", s[s.Plane = 4] = "Plane", s[s.Cone = 5] = "Cone", s[s.Other = 6] = "Other", s[s.Sphere = 7] = "Sphere", s[s.Torus = 8] = "Torus", s[s.Blend01 = 9] = "Blend01", s[s.Blend02 = 10] = "Blend02", s[s.Blend03 = 11] = "Blend03", s[s.Nurbs = 12] = "Nurbs", s[s.Cylindrical = 13] = "Cylindrical", s[s.Offset = 14] = "Offset", s[s.Pipe = 15] = "Pipe", s[s.Ruled = 16] = "Ruled", s[s.Revolution = 17] = "Revolution", s[s.Extrusion = 18] = "Extrusion", s[s.FromCurves = 19] = "FromCurves", s[s.Transform = 20] = "Transform", s))(Jm || {});
let fh = class bf {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new bf(t.length);
  }
  copy() {
    return new bf(this.length);
  }
  type() {
    return 1;
  }
}, kl = class xf {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new m(t.origin.x, t.origin.y, t.origin.z), n = new m(t.normal.x, t.normal.y, t.normal.z);
    return new xf(e, i, n);
  }
  copy() {
    return new xf(this.radius, this.origin, this.normal);
  }
  type() {
    return 2;
  }
};
class zo {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new zo(t.length);
  }
  copy() {
    return new zo(this.length);
  }
  type() {
    return 6;
  }
}
class gh {
  copy() {
    return new gh();
  }
  type() {
    return 6;
  }
}
class Bi {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new m(t.origin.x, t.origin.y, t.origin.z), n = new m(t.normal.x, t.normal.y, t.normal.z);
    return new Bi(e, i, n);
  }
  copy() {
    return new Bi(this.radius, this.origin, this.normal);
  }
  type() {
    return 3;
  }
}
class $i {
  constructor(t, e) {
    this.origin = t.copy(), this.normal = e.copy();
  }
  static fromJson(t) {
    const e = new m(t.origin.x, t.origin.y, t.origin.z), i = new m(t.normal.x, t.normal.y, t.normal.z);
    return new $i(e, i);
  }
  copy() {
    return new $i(this.origin, this.normal);
  }
  type() {
    return 4;
  }
}
class xa {
  constructor(t, e, i, n) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy(), this.halfAngle = n;
  }
  static fromJson(t) {
    const e = t.radius, i = t.halfAngle, n = new m(t.origin.x, t.origin.y, t.origin.z), r = new m(t.normal.x, t.normal.y, t.normal.z);
    return new xa(e, n, r, i);
  }
  copy() {
    return new xa(this.radius, this.origin, this.normal, this.halfAngle);
  }
  type() {
    return 5;
  }
}
class Ia {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new m(t.origin.x, t.origin.y, t.origin.z), n = new m(t.normal.x, t.normal.y, t.normal.z);
    return new Ia(e, i, n);
  }
  copy() {
    return new Ia(this.radius, this.origin, this.normal);
  }
  type() {
    return 7;
  }
}
class Ca {
  constructor(t, e, i, n) {
    this.majorRadius = t, this.minorRadius = e, this.origin = i.copy(), this.normal = n.copy();
  }
  static fromJson(t) {
    const e = new m(t.origin.x, t.origin.y, t.origin.z), i = new m(t.normal.x, t.normal.y, t.normal.z), n = t.majRadius, r = t.minRadius;
    return new Ca(n, r, e, i);
  }
  copy() {
    return new Ca(this.majorRadius, this.minorRadius, this.origin, this.normal);
  }
  type() {
    return 8;
  }
}
class ph {
  copy() {
    return new ph();
  }
  type() {
    return 9;
  }
}
class mh {
  copy() {
    return new mh();
  }
  type() {
    return 10;
  }
}
class _h {
  copy() {
    return new _h();
  }
  type() {
    return 11;
  }
}
class yh {
  copy() {
    return new yh();
  }
  type() {
    return 12;
  }
}
class wh {
  copy() {
    return new wh();
  }
  type() {
    return 13;
  }
}
class vh {
  copy() {
    return new vh();
  }
  type() {
    return 14;
  }
}
class bh {
  copy() {
    return new bh();
  }
  type() {
    return 15;
  }
}
class xh {
  copy() {
    return new xh();
  }
  type() {
    return 16;
  }
}
class Ih {
  copy() {
    return new Ih();
  }
  type() {
    return 17;
  }
}
class Ch {
  copy() {
    return new Ch();
  }
  type() {
    return 18;
  }
}
class Sh {
  copy() {
    return new Sh();
  }
  type() {
    return 19;
  }
}
class Mh {
  copy() {
    return new Mh();
  }
  type() {
    return 20;
  }
}
function hd() {
  let s, t;
  const e = new Promise((i, n) => {
    s = (r) => {
      e.state = Wr.Resolved, i(r);
    }, t = (r) => {
      e.state = Wr.Rejected, n(r);
    };
  });
  return e.state = Wr.Pending, e.resolve = s, e.reject = t, e;
}
function To(s, t) {
  const e = new Promise((i, n) => {
    t.then(() => {
      e.isReady = !0, i(s);
    }, n);
  });
  return e.unsafeValue = s, e.readyPromise = t, e.isReady = !1, e;
}
class Ss {
  constructor() {
    this._faceMeshData = [], this._pointMeshData = [], this._polylineMeshData = [], this._faceWinding = Qs.CounterClockwise, this._backfacesEnabled = !1, this._isManifold = !1;
  }
  /**
   * Adds face data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * When adding vertex data into the mesh using this method, it is important to note that the data is interpreted as triangles in which each vertex must be explicitly enumerated.
   * @param vertexData floating point data describing the points in space for the faces to be added to the mesh
   * @param normalData normals for the corresponding vertex data points.
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param uvs texture parameters for the corresponding vertex data points.
   * @param bits bitmask associated with the face.
   */
  addFaces(t, e, i, n, r = 0) {
    this._faceMeshData.push(new Av(t, e, i, n, r));
  }
  /**
   * Adds point data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param pointData floating point data describing the points to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the point.
   */
  addPoints(t, e, i = 0) {
    this._pointMeshData.push(new Dv(t, e, i));
  }
  /**
   * Adds polyline data to the mesh.Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param polylineData floating point data describing the polyline to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the line.
   */
  addPolyline(t, e, i = 0) {
    this._polylineMeshData.push(new Tv(t, e, i));
  }
  /**
   * Removes all data from the object.
   */
  clear() {
    this._faceMeshData.length = 0, this._pointMeshData.length = 0, this._polylineMeshData.length = 0;
  }
  /**
   * Sets the face winding to be used for this mesh. The default value is CounterClockwise.
   * @param faceWinding the face winding to use for mesh geometry.
   */
  setFaceWinding(t) {
    this._faceWinding = t;
  }
  /**
   * Gets the face winding used for this mesh.
   */
  getFaceWinding() {
    return this._faceWinding;
  }
  /**
   * Sets whether backfaces should be enabled for this geometry. The default value is false.
   * Setting this to true for geometry with a large amount of faces may affect performance.
   * @param backfacesEnabled indicated whether backfaces should be enabled for this geometry.
   */
  setBackfacesEnabled(t) {
    this._backfacesEnabled = t;
  }
  /**
   * Gets whether backfaces are enabled for this geometry
   * @returns value indicting whether backfaces are enabled for this geometry.
   */
  getBackfacesEnabled() {
    return this._backfacesEnabled;
  }
  /**
   * Sets whether the mesh is a manifold one or not (if the mesh is not set as manifold, then capping won't happen while cutting).
   * @param isManifold indicated whether or not it's a manifold mesh.
   */
  setManifold(t) {
    this._isManifold = t;
  }
  /**
   * Gets if the mesh is set as manifold.
   * @returns value indicating whether or not it's a manifold mesh.
   */
  isManifold() {
    return this._isManifold;
  }
  /** @hidden */
  _getFaceData() {
    return this._faceMeshData;
  }
  /** @hidden */
  _getPointData() {
    return this._pointMeshData;
  }
  /** @hidden */
  _getPolylineData() {
    return this._polylineMeshData;
  }
}
class tr {
  /**
   * Creates a new MeshInstanceData object.
   * @param meshId the [[MeshId]] of the mesh to instantiate
   * @param matrix a matrix that will be applied to this instance
   * @param instanceName a name that will be visible when querying the model hierarchy
   * @param faceColor the color for faces of this instance
   * @param lineColor the color for lines of this instance
   * @param pointColor the color for points of this instance
   * @param creationFlags additional options that can be used to alter the behavior of this instance
   */
  constructor(t, e, i, n, r, o, l) {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = ee.None, this.overlayId = { viewKey: Ae.Default, overayIndex: 0 }, t && (this._meshId = t.slice()), e && (this._matrix = e.copy()), i && (this._instanceName = i), n && (this._faceColor = n.copy()), r && (this._lineColor = r.copy()), o && (this._pointColor = o.copy()), l && (this._creationFlags = l);
  }
  /**
   * Creates a copy of this MeshInstanceData.
   * @returns Copy of this MeshInstanceData object.
   */
  copy() {
    const t = new tr(
      this.getMeshId(),
      this.getMatrix(),
      this.getInstanceName(),
      this.getFaceColor(),
      this.getLineColor(),
      this.getPointColor(),
      this.getCreationFlags()
    );
    return t.setPointOpacity(this.getOpacity()), t.setLineOpacity(this.getLineOpacity()), t.setOpacity(this.getOpacity()), t.overlayId = Object.assign({}, this.overlayId), t;
  }
  /**
   * Resets all fields of this object.
   */
  clear() {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = ee.None, this.overlayId = { viewKey: Ae.Default, overayIndex: 0 };
  }
  /**
   * Gets the [[MeshId]] of the mesh to use for this instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @returns the mesh ID to use for this instance.
   */
  getMeshId() {
    return this._meshId !== null ? this._meshId.slice() : null;
  }
  /**
   * Sets the [[MeshId]] of the mesh to use for the instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @param meshId the [[MeshId]] to use.
   */
  setMeshId(t) {
    this._meshId = t.slice();
  }
  /**
   * Gets the matrix to apply to this instance.
   * @returns the current matrix that will be applied to this instance upon creation.
   */
  getMatrix() {
    return this._matrix !== null ? this._matrix.copy() : null;
  }
  /**
   * Gets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @returns the mesh instance creation flags (null if none set)
   */
  getCreationFlags() {
    return this._creationFlags;
  }
  /**
   * Sets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @param flags creation flags
   */
  setCreationFlags(t) {
    this._creationFlags = t;
  }
  /**
   * Sets the matrix that will be applied to this instance.
   * @param matrix the matrix to apply.
   */
  setMatrix(t) {
    this._matrix = t.copy();
  }
  /**
   * Gets the name that will be applied to the instance.
   * @returns the instance name.
   */
  getInstanceName() {
    return this._instanceName;
  }
  /**
   * Sets the name that will be assigned to this instance. This name will be visible when querying the model hierarchy.
   * @param instanceName the name to assign to this instance.
   */
  setInstanceName(t) {
    this._instanceName = t;
  }
  /**
   * Sets the color for face elements in this instance.
   * @param faceColor the color to apply to face elements.
   */
  setFaceColor(t) {
    this._faceColor = t.copy();
  }
  /**
   * Gets the color for face elements in this instance.
   * @returns the color for face elements.
   */
  getFaceColor() {
    return this._faceColor !== null ? this._faceColor.copy() : null;
  }
  /**
   * Sets the color for line elements in this instance.
   * @param lineColor the color to apply to line elements.
   */
  setLineColor(t) {
    this._lineColor = t.copy();
  }
  /**
   * Gets the color for line elements in this instance.
   * @returns the color for line elements.
   */
  getLineColor() {
    return this._lineColor !== null ? this._lineColor.copy() : null;
  }
  /**
   * Sets the color for point elements in this instance.
   * @param pointColor the color to apply to point elements.
   */
  setPointColor(t) {
    this._pointColor = t.copy();
  }
  /**
   * Gets the color for point elements in this instance.
   * @returns the color for point elements.
   */
  getPointColor() {
    return this._pointColor !== null ? this._pointColor.copy() : null;
  }
  /**
   * Sets the point opacity for this instance.
   * @param pointOpacity opacity value to set.
   */
  setPointOpacity(t) {
    this._pointOpacity = t;
  }
  /**
   * Gets the point opacity value for this instance.
   * @returns the point opacity value for this instance.
   */
  getPointOpacity() {
    return this._pointOpacity;
  }
  /**
   * Sets the line opacity for this instance.
   * @param lineOpacity opacity value to set.
   */
  setLineOpacity(t) {
    this._lineOpacity = t;
  }
  /**
   * Gets the line opacity value for this instance.
   * @returns the line opacity value for this instance.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the face opacity for this instance.
   * @param faceOpacity opacity value to set.
   */
  setOpacity(t) {
    this._faceOpacity = t;
  }
  /**
   * Gets the face opacity value for this instance.
   * @returns the face opacity value for this instance.
   */
  getOpacity() {
    return this._faceOpacity;
  }
  /**
   * Sets the overlay index for this instance but doesn't change the associated view.
   * @param overlayIndex overlay index to set.
   * @deprecated use [[overlayId]] instead.
   */
  setOverlayIndex(t) {
    this.overlayId.overayIndex = t;
  }
  /**
   * Gets the overlay index for this instance.
   * @returns the overlay index for this instance, but not the associated view.
   * @deprecated use [[overlayId]] instead.
   */
  getOverlayIndex() {
    return this.overlayId.overayIndex;
  }
}
class Av {
  constructor(t, e, i, n, r = 0) {
    this.vertexData = t, this.normalData = e, this.rgba32data = i, this.uvData = n, this.bits = r;
  }
}
class Tv {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
class Dv {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
function Ym() {
  const s = (1 + Math.sqrt(5)) / 2, t = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * s), e = t / 2, i = t / (2 * s), n = [];
  n[0] = new m(-i, e, 0), n[1] = new m(i, e, 0), n[2] = new m(-i, -e, 0), n[3] = new m(i, -e, 0), n[4] = new m(0, -i, e), n[5] = new m(0, i, e), n[6] = new m(0, -i, -e), n[7] = new m(0, i, -e), n[8] = new m(e, 0, -i), n[9] = new m(e, 0, i), n[10] = new m(-e, 0, -i), n[11] = new m(-e, 0, i);
  for (const g of n)
    g.normalize();
  let r = [
    [0, 11, 5],
    [0, 5, 1],
    [0, 1, 7],
    [0, 7, 10],
    [0, 10, 11],
    [1, 5, 9],
    [5, 11, 4],
    [11, 10, 2],
    [10, 7, 6],
    [7, 1, 8],
    [3, 9, 4],
    [3, 4, 2],
    [3, 2, 6],
    [3, 6, 8],
    [3, 8, 9],
    [4, 9, 5],
    [2, 4, 11],
    [6, 2, 10],
    [8, 6, 7],
    [9, 8, 1]
  ], o = 12;
  const l = 2;
  for (let g = 0; g < l; g++) {
    const y = [];
    r.map((_) => {
      const x = n[_[0]], b = n[_[1]], I = n[_[2]];
      n[o++] = new m(x.x + b.x, x.y + b.y, x.z + b.z).scale(0.5).normalize(), n[o++] = new m(b.x + I.x, b.y + I.y, b.z + I.z).scale(0.5).normalize(), n[o++] = new m(I.x + x.x, I.y + x.y, I.z + x.z).scale(0.5).normalize(), y.push([_[0], o - 3, o - 1]), y.push([o - 3, o - 2, o - 1]), y.push([o - 3, _[1], o - 2]), y.push([o - 2, _[2], o - 1]);
    }), r = y;
  }
  const h = [], u = [];
  for (const g of r)
    for (let y = 0; y < 3; y++) {
      const _ = g[y];
      h.push(n[_].x), h.push(n[_].y), h.push(n[_].z);
      const x = n[_].normalize();
      u.push(x.x), u.push(x.y), u.push(x.z);
    }
  const f = new Ss();
  return f.addFaces(h, u), f.setFaceWinding(Qs.CounterClockwise), f;
}
function og(s, t, e, i, n, r) {
  const o = new wt(), l = Ov(
    i,
    t,
    e + r,
    n,
    o
  ), h = Nv(s, t, e, o), u = Rv(
    s,
    i,
    t,
    e,
    r
  ), f = l[0].concat(h[0]).concat(u[0]), g = l[1].concat(h[1]).concat(u[1]), y = new Ss();
  return y.setFaceWinding(Qs.Clockwise), y.addFaces(f, g), y;
}
function Zm(s) {
  const t = Math.PI * 2 / s, e = [];
  for (let i = 0; i < s; i++) {
    const n = i * t, r = Math.cos(n), o = Math.sin(n);
    e.push(r), e.push(o);
  }
  return e;
}
function Po(s, t, e, i = 1) {
  let n = m.cross(e, new m(0, 1, 0));
  n.length() < 1e-3 && (n = m.cross(e, new m(0, 0, 1)));
  const r = m.cross(n, e), o = Math.PI * 2 / s, l = [];
  for (let h = 0; h < s; h++) {
    const u = h * o, f = Math.sin(u), g = Math.cos(u), y = n.copy().scale(f).add(r.copy().scale(g)).scale(i).add(t);
    l.push(y);
  }
  return l;
}
function Qm(s, t, e, i) {
  const o = [], l = [];
  let h;
  for (let P = 0; P < s.length - 3; P += 3) {
    const O = new m(s[P], s[P + 1], s[P + 2]), B = new m(s[P + 3], s[P + 4], s[P + 5]), j = Po(e, O, t, i), F = Po(e, B, t, i);
    h = bu(O, B, j, F, !1), Array.prototype.push.apply(o, h[0]), Array.prototype.push.apply(l, h[1]);
  }
  const u = s.length;
  let f = new m(s[u - 3], s[u - 2], s[u - 1]), g = f.copy().subtract(new m(s[u - 6], s[u - 5], s[u - 4])).normalize(), y = Po(
    e * 2,
    f,
    t,
    i
  ), _ = f.copy().add(g.copy().scale(2 / 3)), x = Po(
    e * 2,
    _,
    t,
    i * 2
  ), b = _.copy().add(g.copy().scale(2));
  h = bu(
    f,
    _,
    y,
    x,
    !1
  ), Array.prototype.push.apply(o, h[0]), Array.prototype.push.apply(l, h[1]);
  for (let P = 0; P < y.length; P++) {
    const O = (P + 1) % y.length;
    o.push(b), o.push(x[P]), o.push(x[O]);
    const B = x[P].copy().subtract(_).normalize().add(b.copy().normalize()).normalize();
    l.push(B), l.push(B), l.push(B);
  }
  f = new m(s[0], s[1], s[2]), g = f.copy().subtract(new m(s[3], s[4], s[5])).normalize(), y = Po(
    e * 2,
    f,
    t,
    i
  ), _ = f.copy().add(g.copy().scale(2 / 3)), x = Po(
    e * 2,
    _,
    t,
    i * 2
  ), b = _.copy().add(g.copy().scale(2)), h = bu(
    _,
    f,
    x,
    y,
    !1
  ), Array.prototype.push.apply(o, h[0]), Array.prototype.push.apply(l, h[1]);
  for (let P = 0; P < y.length; P++) {
    const O = (P + 1) % y.length;
    o.push(b), o.push(x[O]), o.push(x[P]);
    const B = x[P].copy().subtract(_).normalize().add(b.copy().normalize()).normalize();
    l.push(B), l.push(B), l.push(B);
  }
  const I = [], C = [];
  for (let P = 0; P < o.length; P++) {
    const O = o[P];
    I.push(O.x), I.push(O.y), I.push(O.z);
    const B = l[P];
    C.push(B.x), C.push(B.y), C.push(B.z);
  }
  const M = new Ss();
  return M.setFaceWinding(Qs.CounterClockwise), M.addFaces(I, C), M;
}
function bu(s, t, e, i, n) {
  const r = [], o = [];
  for (let l = 0; l < e.length; l++) {
    const h = (l + 1) % e.length;
    r.push(e[l]), r.push(e[h]), r.push(i[l]), r.push(e[h]), r.push(i[h]), r.push(i[l]), o.push(m.subtract(e[l], s)), o.push(m.subtract(e[h], s)), o.push(m.subtract(i[l], t)), o.push(m.subtract(e[h], s)), o.push(m.subtract(i[h], t)), o.push(m.subtract(i[l], t));
  }
  if (n) {
    const l = m.subtract(s, t);
    for (const h of o)
      h.add(l).normalize();
  }
  return [r, o];
}
function Nv(s, t, e, i) {
  const n = [], r = [], o = Zm(t), l = o;
  for (let y = 0; y < l.length; y++)
    l[y] *= s;
  const h = [], u = [];
  for (let y = 0; y < l.length; y += 2) {
    const _ = l[y], x = l[y + 1], b = (y + 2) % l.length, I = l[b], C = l[b + 1], M = o[y], P = o[y + 1], O = o[b], B = o[b + 1];
    h[0] = new m(_, e, x), h[1] = new m(_, 0, x), h[2] = new m(I, 0, C), h[3] = new m(I, 0, C), h[4] = new m(I, e, C), h[5] = new m(_, e, x), u[0] = new m(M, 0, P), u[1] = new m(M, 0, P), u[2] = new m(O, 0, B), u[3] = new m(O, 0, B), u[4] = new m(O, 0, B), u[5] = new m(M, 0, P);
    for (let j = 0; j < h.length; j++) {
      const F = i.transform(h[j]);
      n.push(F);
      const K = i.transform(u[j]);
      r.push(K);
    }
    h[0] = new m(I, 0, C), h[1] = new m(_, 0, x), h[2] = m.zero(), u[0] = new m(0, -1, 0), u[1] = new m(0, -1, 0), u[2] = new m(0, -1, 0);
    for (let j = 0; j < 3; j++) {
      const F = i.transform(h[j]);
      n.push(F);
      const K = i.transform(u[j]);
      r.push(K);
    }
  }
  const f = [], g = [];
  for (let y = 0; y < n.length; y++) {
    const _ = n[y];
    f.push(_.x), f.push(_.y), f.push(_.z);
    const x = r[y];
    g.push(x.x), g.push(x.y), g.push(x.z);
  }
  return [f, g];
}
function Ov(s, t, e, i, n) {
  const r = Zm(t), o = r;
  for (let b = 0; b < o.length; b++)
    o[b] *= s;
  const l = new m(0, e + i, 0), h = new m(0, e, 0), u = n.transform(l), f = n.transform(h), g = [], y = [];
  for (let b = 0; b < o.length; b += 2) {
    const I = o[b], C = o[b + 1], M = (b + 2) % o.length, P = o[M], O = o[M + 1], B = r[b], j = r[b + 1], F = r[M], K = r[M + 1], J = new m(I, e, C), rt = new m(P, e, O), ft = n.transform(J), H = n.transform(rt);
    g.push(u), g.push(ft), g.push(H);
    const $ = new m(0, 1, 0), D = new m(B, 0, j), R = new m(F, 0, K), U = n.transform($), it = n.transform(D), at = n.transform(R);
    y.push(U), y.push(it), y.push(at);
    const mt = new m(I, e, C), Nt = new m(P, e, O), lt = n.transform(mt), ot = n.transform(Nt);
    g.push(f), g.push(ot), g.push(lt);
    const Ht = new m(0, -1, 0), St = n.transform(Ht);
    y.push(St), y.push(St), y.push(St);
  }
  const _ = [], x = [];
  for (let b = 0; b < g.length; b++) {
    const I = g[b];
    _.push(I.x), _.push(I.y), _.push(I.z);
    const C = y[b];
    x.push(C.x), x.push(C.y), x.push(C.z);
  }
  return [_, x];
}
function Rv(s, t, e, i, n) {
  const r = new m(0, 0, i), o = new m(0, 0, i + n), l = new m(0, 0, 1), h = Po(e, r, l, s), u = Po(e, o, l, t), f = bu(r, o, h, u, !0), g = [], y = [];
  for (let _ = 0; _ < f[0].length; _++)
    g.push(f[0][_].x), g.push(f[0][_].z), g.push(f[0][_].y), y.push(f[1][_].x), y.push(f[1][_].z), y.push(f[1][_].y);
  return [g, y];
}
function Lv(s) {
}
function qr(s) {
  throw new oi();
}
class Fv {
  constructor(t, e) {
    this._state = t, this._reducer = e;
  }
  /**
   * Handle an action and update the state
   *
   * @param evt The action to handle
   * @param payload The payload if any
   */
  handle(t, e) {
    this._state = this._reducer(this._state, { name: t, payload: e });
  }
}
function ud(s) {
  return new Promise((t) => {
    setTimeout(t, s);
  });
}
function Bv(s, ...t) {
  return setTimeout(s, 0, ...t);
}
function Vv(s, t) {
  return s === t;
}
function zv(s) {
  return s instanceof fh;
}
function Hv(s) {
  return s instanceof kl;
}
function Uv(s) {
  return s instanceof zo;
}
function jv(s) {
  return s instanceof $i;
}
function Wv(s) {
  return s instanceof Bi || s instanceof $i || s instanceof xa || s instanceof Ia || s instanceof Ca || s instanceof ph || s instanceof mh || s instanceof _h || s instanceof yh || s instanceof wh || s instanceof vh || s instanceof bh || s instanceof xh || s instanceof Ih || s instanceof Ch || s instanceof Sh || s instanceof Mh || s instanceof gh;
}
class Ko {
  constructor() {
    this._timerId = null, this._action = null, this._beforeActionIdlePromise = null, this._afterActionIdlePromise = null;
  }
  /**
   * Returns true if no pending action exists and false otherwise.
   */
  isIdle(t) {
    return t === Nn.BeforeAction ? this._timerId === null : this._action === null;
  }
  /**
   * Returns a promise that resolves when the timer becomes (or already is) idle.
   */
  waitForIdle(t) {
    return t === Nn.BeforeAction ? this._timerId === null ? Promise.resolve() : (this._beforeActionIdlePromise === null && (this._beforeActionIdlePromise = vi()), this._beforeActionIdlePromise) : this._action === null ? Promise.resolve() : (this._afterActionIdlePromise === null && (this._afterActionIdlePromise = vi()), this._afterActionIdlePromise);
  }
  _triggerIdlePromise(t) {
    t === Nn.BeforeAction ? this._beforeActionIdlePromise !== null && (this._beforeActionIdlePromise.resolve(), this._beforeActionIdlePromise = null) : this._afterActionIdlePromise !== null && (this._afterActionIdlePromise.resolve(), this._afterActionIdlePromise = null);
  }
  _clearTimeout() {
    this._timerId !== null && (clearTimeout(this._timerId), this._timerId = null);
  }
  /**
   * Clears the pending action if it exists.
   */
  clear() {
    this._clearTimeout(), this._triggerIdlePromise(Nn.BeforeAction), this._action = null, this._triggerIdlePromise(Nn.AfterAction);
  }
  /**
   * Sets a new delayed action. If one is already pending before this call is made, it gets cleared.
   * @param delay The delay in milliseconds to pend the action.
   * @param action The action to pend.
   */
  set(t, e) {
    this._clearTimeout(), this._action = e, this._timerId = setTimeout(() => {
      this._timerId = null, this._triggerIdlePromise(Nn.BeforeAction);
      const i = this._afterActionIdlePromise;
      this._afterActionIdlePromise = null, this._action(), this._timerId === null && (this._action = null), i !== null && i.resolve();
    }, t);
  }
}
function Gv() {
  const s = new Ko();
  s.set(0, () => {
    s.set(0, () => {
    }), s.waitForIdle(Nn.AfterAction).then(() => {
      console.log("inner-1");
    }), s.clear(), s.waitForIdle(Nn.AfterAction).then(() => {
      console.log("inner-2");
    }), s.set(0, () => {
    }), s.waitForIdle(Nn.AfterAction).then(() => {
      console.log("inner-3");
    });
  }), s.waitForIdle(Nn.AfterAction).then(() => {
    console.log("outer");
  });
}
const qC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionQueue: Sc,
  CurrentAction: fo,
  Lazy: Cs,
  StateMachine: Fv,
  Timer: Ko,
  TimerIdleType: Nn,
  TypeAssert: Lv,
  TypeAssertNever: qr,
  _timerStressTest: Gv,
  copyMap: cd,
  copySet: wv,
  createCylinderMeshDataFromArc: Qm,
  createOpenPromise: vi,
  createTrackedOpenPromise: hd,
  createUnsafePromise: To,
  delayCall: Bv,
  exchangeIdEqual: Vv,
  filterInPlace: Mv,
  generateConeCylinderMeshData: og,
  generateSphereMeshData: Ym,
  isCircleElement: Hv,
  isFace: Wv,
  isLineElement: zv,
  isOtherEdgeElement: Uv,
  isPlaneElement: jv,
  setSubtraction: wf,
  setToArray: lo,
  sleep: ud,
  toSet: Cc,
  waitForAll: We
}, Symbol.toStringTag, { value: "Module" }));
var Wr = /* @__PURE__ */ ((s) => (s[s.Pending = 0] = "Pending", s[s.Resolved = 1] = "Resolved", s[s.Rejected = 2] = "Rejected", s))(Wr || {}), vs = /* @__PURE__ */ ((s) => (s[s.Direct = 0] = "Direct", s[s.Indirect = 1] = "Indirect", s))(vs || {}), xu = /* @__PURE__ */ ((s) => (s[s.X = 2] = "X", s[s.Y = 4] = "Y", s[s.Z = 8] = "Z", s))(xu || {}), Iu = /* @__PURE__ */ ((s) => (s[s.X = 16] = "X", s[s.Y = 32] = "Y", s[s.Z = 64] = "Z", s))(Iu || {}), cc = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.EyeX_UpY = 34] = "EyeX_UpY", s[s.EyeX_UpZ = 66] = "EyeX_UpZ", s[s.EyeY_UpX = 20] = "EyeY_UpX", s[s.EyeY_UpZ = 68] = "EyeY_UpZ", s[s.EyeZ_UpX = 24] = "EyeZ_UpX", s[s.EyeZ_UpY = 40] = "EyeZ_UpY", s))(cc || {}), qs = /* @__PURE__ */ ((s) => (s[s.StemHeight = 2] = "StemHeight", s[s.CapHeight = 0.5] = "CapHeight", s[s.TaperHeight = 0.1] = "TaperHeight", s[s.SegmentCount = 20] = "SegmentCount", s[s.CylinderRadius = 0.2] = "CylinderRadius", s[s.ConeBaseRadius = 0.4] = "ConeBaseRadius", s[s.LetterOffsetPos = 0.6] = "LetterOffsetPos", s[s.LetterWidth = 0.3] = "LetterWidth", s[s.LetterHeight = 0.5] = "LetterHeight", s))(qs || {}), Zn = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Position = 1] = "Position", s[s.Target = 2] = "Target", s[s.Up = 4] = "Up", s[s.Width = 8] = "Width", s[s.Height = 16] = "Height", s[s.Projection = 32] = "Projection", s[s.NearLimit = 64] = "NearLimit", s))(Zn || {}), Gu = /* @__PURE__ */ ((s) => (s[s.Attachment = 0] = "Attachment", s[s.Model = 1] = "Model", s))(Gu || {}), $u = /* @__PURE__ */ ((s) => (s[s.AllKeys = 0] = "AllKeys", s[s.KeyCountOnly = 1] = "KeyCountOnly", s))($u || {}), hc = /* @__PURE__ */ ((s) => (s[s.Add = 0] = "Add", s[s.Update = 1] = "Update", s))(hc || {}), uc = /* @__PURE__ */ ((s) => (s[s.MetaData = 0] = "MetaData", s[s.Count = 1] = "Count", s))(uc || {}), t_ = /* @__PURE__ */ ((s) => (s[s.SelectionBitsFaceHasMeasurementData = 1] = "SelectionBitsFaceHasMeasurementData", s[s.SelectionBitsFacePlanar = 2] = "SelectionBitsFacePlanar", s[s.SelectionBitsEdgeHasMeasurementData = 4] = "SelectionBitsEdgeHasMeasurementData", s))(t_ || {}), Cu = /* @__PURE__ */ ((s) => (s[s.Outside = 0] = "Outside", s[s.PartiallyInside = 1] = "PartiallyInside", s[s.FullyInside = 2] = "FullyInside", s))(Cu || {}), e_ = /* @__PURE__ */ ((s) => (s[s.Unsent = 0] = "Unsent", s[s.Opened = 1] = "Opened", s[s.HeadersRecieved = 2] = "HeadersRecieved", s[s.Loading = 3] = "Loading", s[s.Done = 4] = "Done", s))(e_ || {}), i_ = /* @__PURE__ */ ((s) => (s[s.Ok = 200] = "Ok", s))(i_ || {});
class Sn {
  constructor() {
    this._position = new m(0, 0, 1), this._target = m.zero(), this._up = new m(0, 1, 0), this._width = 0, this._height = 0, this._projection = ri.Orthographic, this._nearLimit = 0.01, this._cameraFlags = Zn.None;
  }
  /** @hidden */
  _clearFlags() {
    this._cameraFlags = Zn.None;
  }
  /** @hidden */
  _getFlags() {
    return this._cameraFlags;
  }
  /**
   * Creates a copy of the camera.
   * @returns new object initialized with the current values of this camera
   */
  copy() {
    return Sn.create(
      this._position,
      this._target,
      this._up,
      this._projection,
      this._width,
      this._height,
      this._nearLimit
    );
  }
  /**
   * Sets the camera position
   * @param position the new camera position
   */
  setPosition(t) {
    this._position.assign(t), this._cameraFlags |= Zn.Position;
  }
  /**
   * gets the camera position
   * @returns the camera position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the camera target
   * @param target the new camera target
   */
  setTarget(t) {
    this._target.assign(t), this._cameraFlags |= Zn.Target;
  }
  /**
   * gets the camera target
   * @returns the camera target
   */
  getTarget() {
    return this._target.copy();
  }
  /**
   * Sets the camera up vector
   * @param up the new camera up vector
   */
  setUp(t) {
    this._up.assign(t), this._cameraFlags |= Zn.Up;
  }
  /**
   * gets the camera up vector
   * @returns the camera up vector
   */
  getUp() {
    return this._up.copy();
  }
  /**
   * Sets the camera width
   * @param width the new camera width
   */
  setWidth(t) {
    this._width = t, this._cameraFlags |= Zn.Width;
  }
  /**
   * gets the camera width
   * @returns the camera width
   */
  getWidth() {
    return this._width;
  }
  /**
   * Sets the camera height
   * @param height the new camera height
   */
  setHeight(t) {
    this._height = t, this._cameraFlags |= Zn.Height;
  }
  /**
   * gets the camera height
   * @returns the camera width
   */
  getHeight() {
    return this._height;
  }
  /**
   * Sets the camera projection
   * @param projection the new camera Projection
   */
  setProjection(t) {
    this._projection = t, this._cameraFlags |= Zn.Projection;
  }
  /**
   * gets the camera projection
   * @returns the camera projection
   */
  getProjection() {
    return this._projection;
  }
  /**
   * Sets the camera near clipping limit
   * @param nearLimit the new camera near clipping limit
   */
  setNearLimit(t) {
    this._nearLimit = t, this._cameraFlags |= Zn.NearLimit;
  }
  /**
   * gets the camera near clipping limit
   * @returns the camera near clipping limit
   */
  getNearLimit() {
    return this._nearLimit;
  }
  /**
   * Returns checks for equality with another camera
   * @param cam the camera to compare against
   */
  equals(t) {
    return this._position.equals(t._position) && this._target.equals(t._target) && this._up.equals(t._up) && this._width === t._width && this._height === t._height && this._projection === t._projection && this._nearLimit === t._nearLimit;
  }
  /**
   * Returns checks for equality with another camera with tolerance
   * @param cam the camera to compare against
   * @param tolerance floating point tolerance
   */
  equalsWithTolerance(t, e) {
    const i = (n, r) => Math.abs(n - r) < e;
    return this._position.equalsWithTolerance(t._position, e) && this._target.equalsWithTolerance(t._target, e) && this._up.equalsWithTolerance(t._up, e) && i(this._width, t._width) && i(this._height, t._height) && i(this._projection, t._projection) && i(this._nearLimit, t._nearLimit);
  }
  /**
   * Move the camera along a delta
   * @param delta
   */
  dolly(t) {
    this._position.subtract(t), this._target.subtract(t);
  }
  /**
   * Finds the intersection point with the camera plane
   * @param point
   * @param view
   */
  getCameraPlaneIntersectionPoint(t, e) {
    const i = m.subtract(this._position, this._target).normalize(), n = ln.createFromPointAndNormal(this._target, i), r = e.raycastFromPoint(t);
    if (r === null)
      return null;
    const o = m.zero();
    return n.intersectsRay(r, o) ? o : null;
  }
  /**
   * Returns the camera's view matrix. This matrix places the camera at
   * `<0,0,0>`, with the negative z-axis pointing toward the camera's
   * target and the y-axis in the direction of the camera's up-vector.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getViewMatrix(t) {
    return t._getScEngine().getViewMatrix(this);
  }
  /**
   * Returns the camera's projection matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   * @param view the [[View]] to use when calculating projection effects. Uses default view if undefined
   */
  getProjectionMatrix(t, e) {
    return e = e ?? t.view, t._getScEngine().getProjectionMatrix(this, e.id);
  }
  /**
   * Returns the camera's projection matrix multiplied by its view matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   * @param view the [[View]] to use when calculating projection effects. Uses default view if undefined
   */
  getFullMatrix(t, e) {
    return e = e ?? t.view, t._getScEngine().getFullCameraMatrix(this, e.id);
  }
  /**
   * Creates a new camera object with the given parameters.
   * @param pos the camera position.
   * @param tar the camera target.
   * @param up the camera up vector.
   * @param projection the camera projection mode.
   * @param width camera view width.
   * @param height camera view height.
   * @param nearLimit the camera near limit.
   * @returns a new camera object.
   */
  static create(t, e, i, n, r, o, l) {
    const h = new Sn();
    return h._position.assign(t), h._target.assign(e), h._up.assign(i), h._projection = n, h._width = r, h._height = o, l !== void 0 && (h._nearLimit = l), h;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      target: this._target.toJson(),
      up: this._up.toJson(),
      width: this._width,
      height: this._height,
      projection: this._projection,
      nearLimit: this._nearLimit,
      className: "Communicator.Camera"
    };
  }
  /**
   * Creates a new [[Camera]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = m.fromJson(e.position), n = m.fromJson(e.target), r = m.fromJson(e.up);
    return Sn.create(
      i,
      n,
      r,
      e.projection,
      e.width,
      e.height,
      e.nearLimit
    );
  }
  transform(t) {
    if (t.isIdentity())
      return this.copy();
    const e = Math.abs(this._width), i = Math.abs(this._height), n = this.getUp().normalize().scale(i), r = m.subtract(this._position, this._target), o = m.cross(n, r).normalize().scale(e), l = this.getTarget(), h = m.add(l, o), u = m.add(l, n), f = m.add(l, r);
    t.transform(l, l), t.transform(h, h), t.transform(u, u), t.transform(f, f);
    const g = m.subtract(h, l), y = m.subtract(u, l), _ = m.subtract(f, l), x = m.add(l, _), b = l, I = y.copy().normalize();
    let C = g.length(), M = y.length();
    return this._width < 0 && (C = -C), this._height < 0 && (M = -M), Sn.create(
      x,
      b,
      I,
      this._projection,
      C,
      M,
      this._nearLimit
    );
  }
}
function $v(s) {
  if (typeof window < "u" && s.length < 8192 && "escape" in window) {
    let l;
    try {
      const h = String.fromCharCode.apply(null, s), u = window.escape(h);
      l = decodeURIComponent(u);
    } catch {
      l = "";
    }
    return l;
  }
  let t, e, i, n, r;
  t = "";
  const o = s.length;
  for (e = 0; e < o; )
    switch (i = s[e++], i >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        t += String.fromCharCode(i);
        break;
      case 12:
      case 13:
        n = s[e++], t += String.fromCharCode((i & 31) << 6 | n & 63);
        break;
      case 14:
        n = s[e++], r = s[e++], t += String.fromCharCode(
          (i & 15) << 12 | (n & 63) << 6 | (r & 63) << 0
        );
        break;
    }
  return t;
}
const qv = /^\d+$/;
function n_(s) {
  return qv.test(s);
}
const uu = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`~!@#$%^&*()_+-=[]{};:'\",.<>\\|/?".split(
  ""
);
function Qd(s) {
  if (console.assert(s >= 0), s === 0)
    return uu[0];
  const t = [];
  for (; s !== 0; ) {
    const e = Math.floor(s / uu.length), i = s % uu.length, n = uu[i];
    t.push(n), s = e;
  }
  return t.join("");
}
const Kv = ["0000000", "000000", "00000", "0000", "000", "00", "0", ""];
function Xv(s) {
  const t = s.toString(16);
  return Kv[t.length - 1] + t;
}
class ui {
  static _parseUint_32(t) {
    if (!n_(t))
      return null;
    const e = parseInt(t, 10);
    return e <= 4294967295 ? e : null;
  }
  static _parseFloat(t) {
    const e = parseFloat(t);
    return isNaN(e) ? null : e;
  }
  static parseFloat(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseFloat(i);
  }
  static _parseScKey(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseDataKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseMeshKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseInstanceKeyFromInc(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = i.split(" ");
    return n.length !== 2 || this._parseUint_32(n[0]) === null ? null : this._parseUint_32(n[1]);
  }
  static parseNodeId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseLayerId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUint(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUints(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = [], r = i.match(/[0-9]+/g) || [];
    for (const o of r) {
      const l = this._parseUint_32(o);
      if (l === null)
        return null;
      n.push(l);
    }
    return n;
  }
  static parseFloats(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = [], r = i.match(/\S+/g) || [];
    for (const o of r) {
      const l = this._parseFloat(o);
      if (l === null)
        return null;
      n.push(l);
    }
    return n;
  }
  static parseNodeIds(t, e) {
    return this.parseUints(t, e);
  }
  static _parsePoint3(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = i.split(" ");
    if (n.length !== 3)
      return null;
    const r = [];
    for (const o of n) {
      const l = Number(o);
      if (isNaN(l))
        return null;
      r.push(l);
    }
    return new m(r[0], r[1], r[2]);
  }
  static parseBounding(t, e) {
    const i = t.getElementsByTagName(e);
    if (i.length !== 1)
      return null;
    const n = i[0], r = this._parsePoint3(n, "Min");
    if (r === null)
      return null;
    const o = this._parsePoint3(n, "Max");
    return o === null ? null : new wn(r, o);
  }
  static parseCamera(t) {
    const e = ui.parseUint(t, "Projection");
    if (e === null)
      return null;
    const i = t.getAttribute("field");
    if (i === null)
      return null;
    const n = i.split(" ");
    if (n.length !== 2)
      return null;
    const r = parseFloat(n[0]), o = parseFloat(n[1]), l = t.getAttribute("definition");
    if (l === null)
      return null;
    const h = l.split(" ");
    if (h.length !== 9)
      return null;
    const u = (_, x) => new m(
      parseFloat(_[x]),
      parseFloat(_[x + 1]),
      parseFloat(_[x + 2])
    ), f = u(h, 0), g = u(h, 3), y = u(h, 6);
    return Sn.create(f, g, y, e, r, o);
  }
}
class Kc {
  constructor() {
    this.isInclusive = !1, this.ids = [];
  }
  static parseBinary(t) {
    const e = new Kc();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let n = 0; n < i; n++)
      e.ids.push(t.parseNodeId());
    return e;
  }
  static parseXml(t) {
    const e = new Kc();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = ui.parseNodeIds(t, "Ids");
    if (i !== null) {
      e.ids = i;
      const n = t.getAttribute("Count");
      if (n !== null) {
        const r = parseInt(n, 10);
        console.assert(r === e.ids.length);
      }
    } else
      console.error("'Entities' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class Xc {
  constructor() {
    this.isInclusive = !1, this.authoredIds = [];
  }
  static parseBinary(t) {
    const e = new Xc();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let n = 0; n < i; n++)
      e.authoredIds.push(t.parseLayerId());
    return e;
  }
  static parseXml(t) {
    const e = new Xc();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = ui.parseUints(t, "Ids");
    if (i !== null) {
      e.authoredIds = i;
      const n = t.getAttribute("Count");
      if (n !== null) {
        const r = parseInt(n, 10);
        console.assert(r === e.authoredIds.length);
      }
    } else
      console.error("'Layers' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class Jc {
  constructor() {
    this.isDisplayfilter = !1, this.name = null, this.isActive = !1, this.layers = null, this.entities = null, this.scId = null;
  }
  static parseBinary(t) {
    const e = new Jc();
    let i = null, n = null;
    const r = t.parseLayerParseBits();
    return e.isDisplayfilter = t.parseBoolean(), ne(r, lc.ScId) && (e.scId = t.parseUInt32()), ne(r, lc.Name) && (e.name = t.parseCString()), e.isActive = t.parseBoolean(), ne(r, lc.LayerItem) && (i = Xc.parseBinary(t)), ne(r, lc.EntityItem) && (n = Kc.parseBinary(t)), e.layers = i, e.entities = n, e;
  }
  static parseXml(t) {
    const e = new Jc(), i = t.getAttribute("Name");
    i !== null && (e.name = i), e.isDisplayfilter = t.getAttribute("Display") === "1", e.isActive = t.getAttribute("Active") === "1";
    for (let n = t.firstElementChild; n !== null; n = n.nextElementSibling)
      n.localName === "Layers" ? (console.assert(e.layers === null), e.layers = Xc.parseXml(n)) : n.localName === "Entities" ? (console.assert(e.entities === null), e.entities = Kc.parseXml(n)) : console.error(`Unknown tag: ${t.localName}`);
    return e;
  }
}
var Fo = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Unconnected = 1] = "Unconnected", s[s.Connected = 2] = "Connected", s))(Fo || {});
class ag {
  constructor() {
    this.relationships = [];
  }
  static parseBinary(t, e) {
    const i = new ag(), n = e.parseCount_32();
    for (let r = 0; r < n; r++) {
      let o = Fo.Undefined;
      const l = e.parseCString(), h = e.parseCString();
      e.parseBoolean() ? (o = Fo.Connected, Sa.registerBimId(l, t)) : o = Fo.Unconnected, i.relationships.push({
        category: o,
        id: l,
        name: h
      });
    }
    return i;
  }
}
class qu {
  constructor() {
    this.relationElt = {
      id: "",
      name: "",
      category: Fo.Undefined
    };
  }
  static parseBinary(t, e) {
    const i = new qu();
    return i.relationElt.id = e.parseCString(), i.relationElt.name = e.parseCString(), e.parseBoolean() ? (i.relationElt.category = Fo.Connected, Sa.registerBimId(i.relationElt.id, t)) : i.relationElt.category = Fo.Unconnected, i;
  }
  //TODO with the writer
  static parseXml(t) {
    return new qu();
  }
}
class Sa {
  constructor() {
    this.type = I_.Undefined, this.related = null, this.relating = null;
  }
  static registerBimId(t, e) {
    const i = e.toRuntimeId(parseInt(t, 10));
    i !== null && e.addBimIdToMap(t, i);
  }
  static parseBinary(t, e) {
    const i = new Sa(), n = e.parseRelationshipParseBits();
    return ne(n, vu.Type) && (i.type = e.parseCount_32()), ne(n, vu.Relating) && (i.relating = qu.parseBinary(t, e)), ne(n, vu.Related) && (i.related = ag.parseBinary(t, e)), i;
  }
  //TODO with the writer
  static parseXml(t) {
    const e = new Sa(), i = t.getAttribute("Type");
    return i !== null && (e.type = Number(i)), e;
  }
}
class pr {
  static parseBinary(t) {
    let e = null;
    const i = t.getHeader();
    let n = 0;
    i !== null && i.supportsAttributeBits() && (n = t.parseAttributeParseBits());
    const r = t.parseCString();
    ne(n, vf.ValueName) && (e = t.parseCString());
    const o = t.parseAttributeType(), l = t.parseCString();
    let h = [];
    return ne(n, vf.Units) && (h = t.parseUnits()), new pr(o, r, e, l, h);
  }
  static parseXml(t) {
    console.assert(t.localName === "Attr");
    let e = Hr.Undefined, i = "", n = "";
    const r = [], o = t.getAttribute("ValueName"), l = t.getAttribute("Name");
    if (l !== null && (i = l, i === "__PRC_RESERVED_ATTRIBUTE_A3DF_ProductInformation"))
      return new pr(e, i, o, n, r);
    const h = t.getAttribute("Type");
    if (h !== null)
      switch (h) {
        case "i":
          e = Hr.Int;
          break;
        case "f":
          e = Hr.Float;
          break;
        case "t":
          e = Hr.Time;
          break;
        case "s":
          e = Hr.String;
          break;
      }
    const u = t.getAttribute("Value");
    return u !== null && (n = u), new pr(e, i, o, n, r);
  }
  constructor(t, e, i, n, r) {
    this._type = t, this._valueName = i, this._title = e, this._value = n, this._unit = r;
  }
  getType() {
    return this._type;
  }
  getValueName() {
    return this._valueName;
  }
  getTitle() {
    return this._title;
  }
  getValue() {
    return this._value;
  }
  getUnit() {
    return lv(this._unit);
  }
  copy() {
    let t = null;
    return this._valueName !== null && (t = this._valueName.slice()), new pr(
      this._type,
      this._title.slice(),
      t,
      this._value.slice(),
      this._unit.slice()
    );
  }
}
let Gn = class s_ {
  static parseBinary(t) {
    return t.parseMatrix();
  }
  static parseXml(t) {
    console.assert(t.localName === "Transformation");
    const e = [], i = t.getAttribute("RelativeTransfo");
    if (i !== null) {
      const n = i.split(" ");
      console.assert(n.length === 16);
      for (let r = 0; r < 16; ++r) {
        const o = parseFloat(n[r]);
        console.assert(!isNaN(o)), e.push(o);
      }
    }
    return e;
  }
  static getIdentity() {
    return [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  static copy(t) {
    return t.slice();
  }
  static isIdentity(t) {
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  static multiply(t, e) {
    const i = s_.getIdentity();
    return i[0] = t[0] * e[0] + t[1] * e[4] + t[2] * e[8] + t[3] * e[12], i[1] = t[0] * e[1] + t[1] * e[5] + t[2] * e[9] + t[3] * e[13], i[2] = t[0] * e[2] + t[1] * e[6] + t[2] * e[10] + t[3] * e[14], i[3] = t[0] * e[3] + t[1] * e[7] + t[2] * e[11] + t[3] * e[15], i[4] = t[4] * e[0] + t[5] * e[4] + t[6] * e[8] + t[7] * e[12], i[5] = t[4] * e[1] + t[5] * e[5] + t[6] * e[9] + t[7] * e[13], i[6] = t[4] * e[2] + t[5] * e[6] + t[6] * e[10] + t[7] * e[14], i[7] = t[4] * e[3] + t[5] * e[7] + t[6] * e[11] + t[7] * e[15], i[8] = t[8] * e[0] + t[9] * e[4] + t[10] * e[8] + t[11] * e[12], i[9] = t[8] * e[1] + t[9] * e[5] + t[10] * e[9] + t[11] * e[13], i[10] = t[8] * e[2] + t[9] * e[6] + t[10] * e[10] + t[11] * e[14], i[11] = t[8] * e[3] + t[9] * e[7] + t[10] * e[11] + t[11] * e[15], i[12] = t[12] * e[0] + t[13] * e[4] + t[14] * e[8] + t[15] * e[12], i[13] = t[12] * e[1] + t[13] * e[5] + t[14] * e[9] + t[15] * e[13], i[14] = t[12] * e[2] + t[13] * e[6] + t[14] * e[10] + t[15] * e[14], i[15] = t[12] * e[3] + t[13] * e[7] + t[14] * e[11] + t[15] * e[15], i;
  }
  constructor() {
  }
};
const Tp = Hi.InitiallyShown;
let Ho = class {
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseXml(t, e, i) {
    let n = ui.parseNodeId(e, "Id");
    n === null && (console.assert(!1), n = t.generateDynamicNodeId());
    const r = e.getAttribute("Name");
    let o = null;
    const l = [];
    let h = e.firstElementChild;
    for (; h !== null; ) {
      if (h.localName === "Transformation")
        console.assert(o === null), o = Gn.parseXml(h), Gn.isIdentity(o) && (o = null);
      else if (h.localName === "Attributes") {
        let g = h.firstElementChild;
        for (; g !== null; ) {
          console.assert(g.localName === "Attr");
          const y = pr.parseXml(g);
          l.push(y), g = g.nextElementSibling;
        }
      }
      h = h.nextElementSibling;
    }
    const u = e.getAttribute("ExchangeId"), f = i.ignoreLayers ? null : ui.parseLayerId(e, "LayerId");
    return {
      nodeId: n,
      bits: Tp,
      name: r,
      localTransform: o,
      attributes: l,
      header: Zs.dynamic,
      exchangeId: u,
      layerId: f,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
  }
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseBinary(t, e, i, n) {
    let r;
    i.hasBits1(ti.Id) ? r = e.parseNodeId() : (console.assert(!1), r = t.generateDynamicNodeId());
    const o = i.hasBits1(ti.Name) ? e.parseCString() : null;
    let l = Tp;
    if (i.hasBits1(ti.Visiblity)) {
      const b = e.parseVisibility();
      b.shown || (l &= ~Hi.InitiallyShown), b.removed && (l |= Hi.InitiallyRemoved);
    }
    let h = null;
    i.hasBits1(ti.Transform) && (h = Gn.parseBinary(e), Gn.isIdentity(h) && (h = null));
    let u = null;
    i.hasBits1(ti.Attributes) && (u = e.parseDataKey());
    const f = i.hasBits1(ti.ExchangeId) ? e.parseCString() : null;
    let g = null;
    if (i.hasBits1(ti.LayerId)) {
      const b = e.parseLayerId();
      n.ignoreLayers || (g = b);
    }
    let y = null;
    if (i.hasBits2(yr.GenericTypeId)) {
      const b = e.parseGenericTypeId();
      n.ignoreGenericTypes || (y = b);
    }
    let _ = null;
    i.hasBits2(yr.GenericId) && (_ = e.parseGenericId());
    let x = null;
    if (i.hasBits1(ti.UserData)) {
      x = /* @__PURE__ */ new Map();
      const b = e.parseCount_32();
      for (let I = 0; I < b; ++I) {
        const C = e.parseUserDataIndex(), M = e.parseCount_32(), P = e.parseBytes(M);
        x.set(C, P);
      }
    }
    return {
      nodeId: r,
      bits: l,
      name: o,
      localTransform: h,
      attributes: u !== null ? u : [],
      header: e.getHeader(),
      exchangeId: f,
      layerId: g,
      genericTypeId: y,
      genericId: _,
      userDatas: x
    };
  }
  constructor() {
    console.assert(!1);
  }
};
function Jv(s, t) {
  const e = typeof s == "number";
  return e === (typeof t == "number") ? s < t ? -1 : s > t ? 1 : 0 : e ? -1 : 1;
}
class Oo {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new Oo(t);
  }
  constructor(t) {
    this._value = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return typeof this._value == "function" && (this._value = this._value()), this._value;
  }
}
class Wn {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new Wn(t);
  }
  constructor(t) {
    typeof t == "function" && (t = Oo.create(t)), t instanceof Promise && (t = this._rectifyResult(t)), this._value = t;
  }
  /**
   * Returns whether or not this has been both forced (lazy).
   * This says nothing about resolution (promise).
   */
  isUnforced() {
    return this._value instanceof Oo;
  }
  /**
   * Returns whether or not this has been both forced (lazy) and resolved (promise).
   */
  isResolved() {
    return !(this._value instanceof Oo) && !(this._value instanceof Promise);
  }
  /**
   * Returns the final promised value synchronously.
   *
   * This is only legal to call if `isResolved()` returns `true`.
   *
   */
  getResolved() {
    return console.assert(this.isResolved()), this._value;
  }
  /**
   * Forces the lazy promise and then delegates to the forced promise's `then()` method.
   *
   * Note: This intentionally returns a normal `Promise`, not a `LazyPromise`.
   */
  then(t, e) {
    return this._value instanceof Oo && (this._value = this._rectifyResult(this._value.get())), this._value instanceof Promise ? this._value.then(t, e) : (this._value, Promise.resolve(this._value).then(t, e));
  }
  _rectifyResult(t) {
    return t instanceof Promise ? t.then((e) => (this._value = e, e)) : t;
  }
}
function Yv(s) {
  return s == null;
}
function hi(s) {
  return Array.isArray(s) ? s.slice() : s == null ? [] : [s];
}
function bs(s) {
  return s.length === 0 ? null : s.length === 1 ? s[0] : s;
}
function Qn(s, t) {
  return s ? Array.isArray(s) ? (s.push(t), s) : [s, t] : t;
}
class is {
  constructor(t, e, i) {
    if (this._bits = 0, this._nodeId = i.nodeId, this._bits = i.bits, i.name !== null && (this._name = i.name), i.localTransform !== null && (this._localTransform = Gn.copy(i.localTransform)), typeof i.attributes == "number") {
      const n = i.attributes;
      this._lazyAttributes = is._lazyLoadAttributes(
        t,
        e,
        n,
        i.header
      );
    } else i.attributes.length > 0 && (this._lazyAttributes = Wn.create(i.attributes));
    i.exchangeId !== null && (this._exchangeId = i.exchangeId), i.layerId !== null && (this._layerId = i.layerId), i.genericTypeId !== null && (this._genericTypeId = i.genericTypeId), i.genericId !== null && (this._genericId = i.genericId), i.userDatas !== null && (this._userDatas = cd(i.userDatas));
  }
  static _lazyLoadAttributes(t, e, i, n) {
    return Wn.create(async () => {
      const r = t.getAbstractScEngine(), o = await t.enqueue(() => r.safeGetMetaData(e, i)), l = [];
      if (o !== null) {
        const h = new ya(n, o), u = new th(h);
        for (; u.hasNext(); ) {
          const f = pr.parseBinary(u);
          l.push(f);
        }
      }
      return l;
    });
  }
  hasAuthoredId() {
    return Pl(this._nodeId);
  }
  getAuthoredId() {
    return Sv(this._nodeId);
  }
  getName() {
    return this._name !== void 0 ? this._name : null;
  }
  getExchangeId() {
    return this._exchangeId ?? null;
  }
  getAuthoredLayerId() {
    return this._layerId !== void 0 ? this._layerId : null;
  }
  getGenericTypeId() {
    return this._genericTypeId !== void 0 ? this._genericTypeId : null;
  }
  getGenericId() {
    return this._genericId !== void 0 ? this._genericId : null;
  }
  _hasBits(t) {
    return ne(this._bits, t);
  }
  isLoaded() {
    return this._hasBits(Hi.IsLoaded);
  }
  markLoaded() {
    this._bits |= Hi.IsLoaded;
  }
  _setVisibility(t) {
    this._bits |= Hi.IsShownSpecified, t ? this._bits |= Hi.IsShown : this._bits &= ~Hi.IsShown;
  }
  isVisible() {
    return this._hasBits(Hi.IsShownSpecified) ? this._hasBits(Hi.IsShown) : this.isInitiallyShown();
  }
  isInitiallyShown() {
    return this._hasBits(Hi.InitiallyRemoved) ? !1 : this._hasBits(Hi.InitiallyShown);
  }
  _toAffineTransformation(t) {
    const e = t.slice();
    return e[3] = 0, e[7] = 0, e[11] = 0, e[15] = 1, e;
  }
  setLocalTransformAsInitial(t) {
    this._localTransform = this._toAffineTransformation(t);
  }
  overrideLocalTransform(t) {
    this._localTransformOverride = this._toAffineTransformation(t);
  }
  hasLocalTransformOverride() {
    return this._localTransformOverride !== void 0;
  }
  removeLocalTransformOverride() {
    console.assert(this._localTransformOverride !== void 0), delete this._localTransformOverride;
  }
  getLocalTransform() {
    return this._localTransformOverride !== void 0 ? this._localTransformOverride : this._localTransform !== void 0 ? this._localTransform : null;
  }
  async getAttributes() {
    return this._lazyAttributes !== void 0 ? this._lazyAttributes.then((t) => {
      if (this._lazyAttributes !== void 0) {
        for (const e of t)
          this.addAttribute(e);
        delete this._lazyAttributes;
      }
      return this.getAttributes();
    }) : hi(this._attributes);
  }
  addAttribute(t) {
    this._attributes = Qn(this._attributes, t);
  }
  getUserDataIndices() {
    const t = [];
    return this._userDatas !== void 0 && this._userDatas.forEach((e, i) => {
      t.push(i);
    }), t.sort(Jv);
  }
  getUserData(t) {
    if (this._userDatas !== void 0) {
      const e = this._userDatas.get(t);
      if (e !== void 0)
        return e;
    }
    throw new mg(t);
  }
}
class gl {
  static parseBinary(t) {
    const e = t.parseInstanceKey(), i = t.parsePmiTopoRef(), n = t.parseIndex_32();
    return {
      bodyInstanceKey: e,
      topoItemType: i,
      itemIndex: n
    };
  }
  static reify(t, e) {
    const i = t.getInclusionKey();
    return new gl(
      i,
      e.bodyInstanceKey,
      e.topoItemType,
      e.itemIndex
    );
  }
  static fromBodyInstance(t, e, i) {
    const n = t.getInstanceInc();
    return new gl(n[0], n[1], e, i);
  }
  constructor(t, e, i, n) {
    this._inclusionKey = t, this._bodyInstanceKey = e, this._topoItemType = i, this._itemIndex = n;
  }
  getBodyInstanceInc() {
    return [this._inclusionKey, this._bodyInstanceKey];
  }
  getTopoItemType() {
    return this._topoItemType;
  }
  getItemIndex() {
    return this._itemIndex;
  }
}
const Lg = class Lg {
  // UINT16_MAX, "No layer" ID defined by Exchange
  static parseBinary(t) {
    const e = t.parseLayerParseBits(), i = t.parseLayerId();
    let n = null;
    return ne(e, qm.Name) && (n = t.parseCString()), {
      id: i,
      name: n
    };
  }
  static parseXml(t) {
    const e = t.getAttribute("Name"), i = ui.parseUint(t, "Id");
    return i === null ? (console.error("'Layer' tag missing 'Id' attribute"), null) : {
      id: i,
      name: e
    };
  }
  constructor(t, e, i, n) {
    this.id = t, this.name = e, this.nodes = i, this.treeNodes = n;
  }
};
Lg.NoLayerId = 65535;
let co = Lg;
class El extends is {
  constructor(t, e, i, n) {
    super(t, e, n.nodeInfo), this._bits |= n.bits, this._modifiers = n.modifierbits, this._parent = i, this._instanceKey = n.instanceKey;
    const r = this.getAuthoredLayerId();
    r !== null && t.registerNodeInLayer(this, r), r !== null && !this.isOutOfHierarchy() && t.registerTreeNodeInLayer(this, r), r === null && !this.isOutOfHierarchy() && Pl(n.nodeInfo.nodeId) && (t.registerNodeInLayer(this, co.NoLayerId), t.registerTreeNodeInLayer(this, co.NoLayerId));
  }
  setRequested() {
    this._bits |= Vr.Requested;
  }
  isRequested() {
    return this._hasBits(Vr.Requested);
  }
  isOutOfHierarchy() {
    return this._hasBits(Vr.OutOfHierarchy);
  }
  preventFromResetting() {
    return this._hasBits(Vr.PreventFromResetting);
  }
  isImplicitBody() {
    return this._hasBits(Vr.ImplicitBody);
  }
  getParent() {
    return this._parent;
  }
  getInstanceKey() {
    return this._instanceKey;
  }
  hasModifiers() {
    return this._modifiers != 0;
  }
  ignoreParentScale() {
    return ne(this._modifiers, _f.IgnoreParentScale);
  }
  ignoreParentRotation() {
    return ne(this._modifiers, _f.IgnoreParentRotation);
  }
}
class ji extends El {
  static parseXml(t, e, i, n) {
    const r = Ho.parseXml(t, e, n), o = ui.parseInstanceKeyFromInc(e, "MeshInstanceKey");
    if (o === null)
      throw new si('Expected "MeshInstanceKey" attribute.');
    return {
      nodeInfo: r,
      inclusionKey: i,
      instanceKey: o,
      bits: 0,
      modifierbits: 0
    };
  }
  static parseBinary(t, e, i, n) {
    const r = Vi(e), o = r.getRemapper(), l = r.getMasterModelKey(), h = i.parseNodeParseBits(), u = Ho.parseBinary(t, i, h, n);
    let f;
    if (h.hasBits1(ti.ScInclusionKey) ? f = i.parseInclusionKey(o, l) : f = e.getInclusionKey(), !h.hasBits1(ti.ScInstanceKey))
      throw new Pa('Expected "ScInstanceKey" in binary data.');
    const g = i.parseInstanceKey();
    let y = 0;
    return h.hasBits2(yr.Modifiers) && (y = i.parseModifiers()), {
      nodeInfo: u,
      inclusionKey: f,
      instanceKey: g,
      bits: 0,
      modifierbits: y
    };
  }
  static reify(t, e, i, n) {
    const r = Vi(i), o = new ji(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, n, r, o, l, h) {
    const u = qi(o), g = Vi(u).getMasterModelKey(), x = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(u, n),
        bits: l,
        name: r,
        localTransform: null,
        attributes: [],
        header: Zs.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: e,
      instanceKey: i,
      bits: h,
      modifierbits: 0
    };
    return new ji(t, g, o, x);
  }
  constructor(t, e, i, n) {
    super(t, e, i, n), t.registerBodyInstance(this, n.inclusionKey);
  }
  getName() {
    const t = super.getName();
    if (t !== null)
      return t;
    const i = this.getParent().getBodyInstances();
    if (i.length > 1) {
      for (let n = 0; n < i.length; ++n) {
        const r = i[n];
        if (this === r)
          return `body ${n + 1}`;
      }
      console.assert(!1);
    }
    return "body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = Ni.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = qi(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return qo(this._nodeId, this);
  }
}
class Bs extends El {
  static parseBinary(t, e, i, n, r) {
    let o = ji.parseBinary(t, e, i, r);
    if (n) {
      let l = o.nodeInfo, h = l.bits;
      h &= ~Hi.InitiallyShown, l = { ...l, bits: h }, o = { ...o, nodeInfo: l };
    }
    return o;
  }
  static reify(t, e, i, n) {
    const r = Vi(i), o = new Bs(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  constructor(t, e, i, n) {
    super(t, e, i, n), this._modifiers = n.modifierbits, t.registerPmiBody(this, n.inclusionKey);
  }
  getName() {
    const t = super.getName();
    return t !== null ? t : "PMI body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = Ni.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = qi(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return qo(this._nodeId, this);
  }
}
class Zv {
  constructor(t) {
    this.faceIds = [], this.edgeIds = [], this.body = t;
  }
}
class Mn extends is {
  static parseBinary(t, e, i, n) {
    const r = i.parsePmiParseBits(), o = i.parseNodeId();
    let l = null;
    ne(r, oa.Name) && (l = i.parseCString());
    let h = null;
    ne(r, oa.ExchangeId) && (h = i.parseCString());
    let u = null;
    ne(r, oa.Attributes) && (u = i.parseDataKey());
    let f = 1;
    ne(r, oa.HasMultipleBodies) && (f = i.parseCount_32());
    const g = [], y = ne(r, oa.InitiallyHidden);
    for (let C = 0; C < f; ++C) {
      const M = Bs.parseBinary(
        t,
        e,
        i,
        y,
        n
      );
      g.push(M);
    }
    const _ = g.length > 0 ? ne(g[0].nodeInfo.bits, Hi.InitiallyShown) : !1, x = i.parsePmiType(), b = i.parsePmiSubType(), I = [];
    if (ne(r, oa.TopoRef)) {
      const C = i.parseCount_32();
      for (let M = 0; M < C; ++M) {
        const P = gl.parseBinary(i);
        I.push(P);
      }
    }
    return {
      nodeId: o,
      name: l,
      attributesDataKey: u,
      pmiBodyInfos: g,
      initiallyShown: _,
      pmiType: x,
      pmiSubType: b,
      topoRefInfos: I,
      topoRefs: [],
      exchangeId: h
    };
  }
  static reify(t, e, i, n) {
    const r = Vi(e), o = new Mn(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, n, r, o, l, h) {
    const f = {
      nodeId: t.generateDynamicNodeId(),
      name: n,
      attributesDataKey: null,
      pmiBodyInfos: l,
      initiallyShown: !0,
      pmiType: r,
      pmiSubType: o,
      topoRefInfos: [],
      topoRefs: h,
      exchangeId: null
    };
    return new Mn(t, e, f, i);
  }
  constructor(t, e, i, n) {
    const o = Vi(e).getMasterModelKey();
    let l = 0;
    i.initiallyShown && (l |= Hi.InitiallyShown);
    const h = {
      nodeId: i.nodeId,
      bits: l,
      name: i.name,
      localTransform: null,
      attributes: i.attributesDataKey ? i.attributesDataKey : [],
      header: Zs.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    super(t, o, h), this._bits |= Vr.PreventFromResetting, this._parent = n, this._packed = Mn._pack(i.pmiType, i.pmiSubType);
    for (const u of i.pmiBodyInfos) {
      const f = this._loadPmiBody(t, o, u);
      this._pmiBodies = Qn(this._pmiBodies, f), f.markLoaded();
    }
    if (i.topoRefInfos.length > 0 && (this._topoRefs = Mn._loadTopoRefs(e, i.topoRefInfos)), i.topoRefs.length > 0)
      if (this._topoRefs === void 0)
        this._topoRefs = i.topoRefs.slice();
      else
        for (const u of i.topoRefs)
          this._topoRefs.push(u);
    t.registerPmi(this);
  }
  static _loadTopoRefs(t, e) {
    const i = [];
    for (const n of e) {
      const r = gl.reify(t, n);
      i.push(r);
    }
    return i;
  }
  _loadPmiBody(t, e, i) {
    return Bs.reify(t, e, this, i);
  }
  getPmiBodies() {
    return hi(this._pmiBodies);
  }
  static _pack(t, e) {
    return t + 100 * e;
  }
  getPmiType() {
    return this._packed % 100;
  }
  getPmiSubType() {
    return Math.floor(this._packed / 100) % 100;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return qo(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? ue.Shown : ue.Hidden;
    for (const e of hi(this._pmiBodies))
      e.isOutOfHierarchy() || (t |= e.isVisible() ? ue.Shown : ue.Hidden);
    return t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  getPmiTopologyReferences(t) {
    if (this._topoRefs === void 0)
      return [];
    const e = /* @__PURE__ */ new Map();
    for (const n of this._topoRefs) {
      const r = n.getBodyInstanceInc(), o = t.lookupAnyBodyByInstanceInc(r[0], r[1]);
      if (o === null)
        continue;
      let l = e.get(o);
      switch (l === void 0 && (l = new Zv(o), e.set(o, l)), n.getTopoItemType()) {
        case sh.Face:
          l.faceIds.push(n.getItemIndex());
          break;
        case sh.Edge:
          l.edgeIds.push(n.getItemIndex());
          break;
      }
    }
    const i = [];
    return e.forEach((n) => {
      i.push(n);
    }), i;
  }
}
class _a {
  static parseBinary(t) {
    const e = t.parseFloat_64(), i = t.parseFloat_64(), n = t.parsePoint3_64();
    return new _a(e, i, n);
  }
  constructor(t, e, i) {
    this.surfaceArea = t, this.volume = e, this.centerOfGravity = i;
  }
}
function Qv(s) {
  const t = Jm;
  switch (s.parseFaceType()) {
    case t.Cylinder:
      return t0.parseBinary(s);
    case t.Plane:
      return e0.parseBinary(s);
    case t.Cone:
      return i0.parseBinary(s);
    case t.Other:
      return r0.parseBinary(s);
    case t.Sphere:
      return n0.parseBinary(s);
    case t.Torus:
      return s0.parseBinary(s);
    case t.Blend01:
      return o0.parseBinary(s);
    case t.Blend02:
      return a0.parseBinary(s);
    case t.Blend03:
      return l0.parseBinary(s);
    case t.Nurbs:
      return c0.parseBinary(s);
    case t.Cylindrical:
      return h0.parseBinary(s);
    case t.Offset:
      return u0.parseBinary(s);
    case t.Pipe:
      return d0.parseBinary(s);
    case t.Ruled:
      return f0.parseBinary(s);
    case t.Revolution:
      return g0.parseBinary(s);
    case t.Extrusion:
      return p0.parseBinary(s);
    case t.FromCurves:
      return m0.parseBinary(s);
    case t.Transform:
      return _0.parseBinary(s);
    default:
      throw new Pa("Unexpected measurement face type.");
  }
}
class t0 {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32();
    return new Bi(e, i, n);
  }
}
class e0 {
  static parseBinary(t) {
    const e = t.parsePoint3_32(), i = t.parsePoint3_32();
    return new $i(e, i);
  }
}
class i0 {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32(), r = t.parseFloat_32();
    return new xa(e, i, n, r);
  }
}
class n0 {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32();
    return new Ia(e, i, n);
  }
}
class s0 {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parseFloat_32(), n = t.parsePoint3_32(), r = t.parsePoint3_32();
    return new Ca(e, i, n, r);
  }
}
let r0 = class {
  static parseBinary(t) {
    return new gh();
  }
};
class o0 {
  static parseBinary(t) {
    return new ph();
  }
}
class a0 {
  static parseBinary(t) {
    return new mh();
  }
}
class l0 {
  static parseBinary(t) {
    return new _h();
  }
}
class c0 {
  static parseBinary(t) {
    return new yh();
  }
}
class h0 {
  static parseBinary(t) {
    return new wh();
  }
}
let u0 = class {
  static parseBinary(t) {
    return new vh();
  }
};
class d0 {
  static parseBinary(t) {
    return new bh();
  }
}
class f0 {
  static parseBinary(t) {
    return new xh();
  }
}
class g0 {
  static parseBinary(t) {
    return new Ih();
  }
}
class p0 {
  static parseBinary(t) {
    return new Ch();
  }
}
class m0 {
  static parseBinary(t) {
    return new Sh();
  }
}
let _0 = class {
  static parseBinary(t) {
    return new Mh();
  }
};
function y0(s) {
  const t = Xm;
  switch (s.parseEdgeType()) {
    case t.Line:
      return w0.parseBinary(s);
    case t.Circle:
      return v0.parseBinary(s);
    case t.Other:
      return b0.parseBinary(s);
    default:
      throw new Pa("Unexpected measurement edge type.");
  }
}
let w0 = class {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new fh(e);
  }
}, v0 = class {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32();
    return new kl(e, i, n);
  }
};
class b0 {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new zo(e);
  }
}
class Mc {
  constructor(t) {
    this.attributes = t;
  }
  copy() {
    return new Mc(this.attributes.map((t) => t.copy()));
  }
}
function tc(s, t) {
  return s !== void 0 && t < s.length ? s[t] : null;
}
function Dp(s, t, e) {
  return s === void 0 && (s = []), s.length = Math.max(s.length, t + 1), s[t] = e, s;
}
var Ya = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.BRep = 1] = "BRep", s[s.Tessellation = 2] = "Tessellation", s[s.Wireframe = 3] = "Wireframe", s[s.PointCloud = 4] = "PointCloud", s))(Ya || {});
class en extends is {
  static parseXml(t, e, i) {
    const n = Ho.parseXml(t, e, i), r = ui.parseMeshKey(e, "TCKey_Mesh");
    return {
      nodeInfo: n,
      meshKey: r,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
  }
  static parseBinary(t, e, i) {
    const n = e.parseNodeParseBits(), r = Ho.parseBinary(t, e, n, i), o = e.parseBodyType();
    let l = null;
    n.hasBits1(ti.MeshKey) && (l = e.parseMeshKey());
    const h = [];
    if (n.hasBits1(ti.FaceMeasurement)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; ++b) {
        const I = Qv(e);
        h.push(I);
      }
    }
    const u = [];
    if (n.hasBits1(ti.EdgeMeasurement)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; ++b) {
        const I = y0(e);
        u.push(I);
      }
    }
    let f = null;
    n.hasBits1(ti.PhysicalProperties) && (f = _a.parseBinary(e));
    const g = [];
    if (n.hasBits2(yr.FaceAttributes)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; b++) {
        const I = [], C = e.parseCount_32();
        for (let M = 0; M < C; M++) {
          const P = pr.parseBinary(e);
          P.getType() !== Hr.Ignored && I.push(P);
        }
        g.push(I.length > 0 ? new Mc(I) : null);
      }
    }
    const y = [];
    if (n.hasBits2(yr.EdgeAttributes)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; b++) {
        const I = [], C = e.parseCount_32();
        for (let M = 0; M < C; M++) {
          const P = pr.parseBinary(e);
          P.getType() !== Hr.Ignored && I.push(P);
        }
        y.push(I.length > 0 ? new Mc(I) : null);
      }
    }
    const _ = [];
    if (n.hasBits2(yr.PointAttributes)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; b++) {
        const I = [], C = e.parseCount_32();
        for (let M = 0; M < C; M++) {
          const P = pr.parseBinary(e);
          P.getType() !== Hr.Ignored && I.push(P);
        }
        _.push(I.length > 0 ? new Mc(I) : null);
      }
    }
    return {
      nodeInfo: r,
      meshKey: l,
      bodyType: o,
      faceMeasurementProps: h,
      edgeMeasurementProps: u,
      physicalProps: f,
      faceAttributes: g,
      edgeAttributes: y,
      pointAttributes: _
    };
  }
  static reify(t, e, i, n) {
    return new en(t, e, i, n);
  }
  static createDynamic(t, e, i, n, r) {
    const o = r.getInclusionContextForNodeId(), u = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(o, e),
        bits: Hi.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: Zs.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      meshKey: null,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
    return new en(t, n, u, r);
  }
  constructor(t, e, i, n) {
    if (super(t, e, i.nodeInfo), this._parent = n, this._bodyType = i.bodyType, i.faceMeasurementProps.length > 0 && (this._faceMeasurementProps = i.faceMeasurementProps.slice()), i.edgeMeasurementProps.length > 0 && (this._edgeMeasurementProps = i.edgeMeasurementProps.slice()), i.physicalProps !== null && (this._physicalProps = i.physicalProps), i.faceAttributes.length > 0) {
      this._faceAttributes = [];
      for (const r of i.faceAttributes)
        this._faceAttributes.push(r === null ? null : r.copy());
    }
    if (i.edgeAttributes.length > 0) {
      this._edgeAttributes = [];
      for (const r of i.edgeAttributes)
        this._edgeAttributes.push(r === null ? null : r.copy());
    }
    if (i.pointAttributes.length > 0) {
      this._pointAttributes = [];
      for (const r of i.pointAttributes)
        this._pointAttributes.push(r === null ? null : r.copy());
    }
    t.registerRepresentationItem(this);
  }
  setPhysicalProperties(t) {
    this._physicalProps = t;
  }
  getPhysicalProperties() {
    return this._physicalProps !== void 0 ? this._physicalProps : null;
  }
  getParent() {
    return this._parent;
  }
  getFaceCount() {
    return this._faceMeasurementProps !== void 0 ? this._faceMeasurementProps.length : 0;
  }
  getEdgeCount() {
    return this._edgeMeasurementProps !== void 0 ? this._edgeMeasurementProps.length : 0;
  }
  getFaceAttributes(t) {
    return tc(this._faceAttributes, t);
  }
  getEdgeAttributes(t) {
    return tc(this._edgeAttributes, t);
  }
  getPointAttributes(t) {
    return tc(this._pointAttributes, t);
  }
  getFaceMeasurementProperty(t) {
    return tc(this._faceMeasurementProps, t);
  }
  getEdgeMeasurementProperty(t) {
    return tc(this._edgeMeasurementProps, t);
  }
  setFaceMeasurementProperty(t, e) {
    this._faceMeasurementProps = Dp(this._faceMeasurementProps, t, e.copy());
  }
  setEdgeMeasurementProperty(t, e) {
    this._edgeMeasurementProps = Dp(this._edgeMeasurementProps, t, e.copy());
  }
  getBodyType() {
    return this._bodyType;
  }
  getRuntimeId() {
    return qo(this._nodeId, this._parent.getInclusionContextForNodeId());
  }
}
class as extends is {
  static parseXml(t, e, i) {
    let n = Ho.parseXml(t, e, i);
    if (n.name === null) {
      const l = e.getAttribute("FilePath");
      l !== null && (n = { ...n, name: l });
    }
    const r = [];
    let o = e.firstElementChild;
    for (; o !== null; ) {
      if (o.localName === "Body") {
        const l = en.parseXml(t, o, i);
        r.push(l);
      }
      o = o.nextElementSibling;
    }
    return {
      nodeInfo: n,
      repItemInfos: r
    };
  }
  static parseBinary(t, e, i) {
    const n = e.parseNodeParseBits(), r = Ho.parseBinary(t, e, n, i), o = [];
    if (n.hasBits1(ti.Bodies)) {
      const l = e.parseCount_32();
      for (let h = 0; h < l; ++h) {
        const u = en.parseBinary(t, e, i);
        o.push(u);
      }
    }
    return {
      nodeInfo: r,
      repItemInfos: o
    };
  }
  static reify(t, e, i, n) {
    return new as(t, e, i, n);
  }
  static createDynamic(t, e, i) {
    const n = t.getRootNode(), r = qi(n), h = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(r, e),
        bits: Hi.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: Zs.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      repItemInfos: []
    };
    return new as(t, r, Is.Local, h);
  }
  static createMissing(t) {
    const e = this.createDynamic(t, null, null);
    return e._bits |= yf.IsMissing, e;
  }
  isMissing() {
    return this._hasBits(yf.IsMissing);
  }
  constructor(t, e, i, n) {
    const r = i;
    if (super(t, r, n.nodeInfo), this._inclusionContextForNodeId = e, this._modelKey = i, n.repItemInfos.length > 0) {
      const o = this._loadRepresentationItems(
        t,
        r,
        n.repItemInfos
      );
      this._repItems = bs(o);
    }
    t.registerPartDefinition(this);
  }
  _loadRepresentationItems(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = en.reify(t, e, r, this);
      this._addRepresentationItem(o), n.push(o);
    }
    return n;
  }
  getRuntimeId() {
    return qo(this._nodeId, this._inclusionContextForNodeId);
  }
  getInclusionContextForNodeId() {
    return this._inclusionContextForNodeId;
  }
  addReferrer(t) {
    const e = Ys(t), i = Ys(this._inclusionContextForNodeId);
    console.assert(e === i), this._referrers = Qn(this._referrers, t);
  }
  createRepItem(t, e) {
    const i = this._modelKey, n = en.createDynamic(
      t,
      e,
      null,
      i,
      this
    );
    return this._addRepresentationItem(n), n;
  }
  _addRepresentationItem(t) {
    this._repItems = Qn(this._repItems, t);
  }
  getRepresentationItems() {
    return hi(this._repItems);
  }
  getReferrers() {
    return hi(this._referrers);
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t) {
      const i = e.removePartDefinition();
      console.assert(this === i);
    }
    delete this._referrers;
  }
  getModelKey() {
    return this._modelKey;
  }
}
class ga {
  static pushRelatedItemFromParser(t) {
    const e = [];
    for (const i of t.relationships)
      e.push({
        category: i.category,
        id: i.id,
        name: i.name
      });
    return e;
  }
  static addFromRelatingElt(t, e) {
    const i = t.related, n = t.type;
    if (n != null)
      if (!e.has(n) && i !== null)
        e.set(n, {
          related: this.pushRelatedItemFromParser(i),
          relating: []
        });
      else {
        const r = t.related;
        if (r !== null)
          for (const o of r.relationships) {
            const l = e.get(n);
            l !== void 0 && this.findBimObjectInArray(l.related, {
              id: o.id,
              category: o.category,
              name: o.name
            }) === !1 && l.related.push({
              id: o.id,
              category: o.category,
              name: o.name
            });
          }
      }
  }
  static findBimObjectInArray(t, e) {
    for (const i of t)
      if (i.category === e.category && i.name === e.name && i.id === e.id)
        return !0;
    return !1;
  }
  static addFromRelatedElt(t, e) {
    const i = t.type;
    i !== null && !e.has(i) && t.relating !== null && e.set(i, {
      related: [],
      relating: [
        {
          category: t.relating.relationElt.category,
          id: t.relating.relationElt.id,
          name: t.relating.relationElt.name
        }
      ]
    });
  }
  static findIndexInRelated(t, e) {
    let i = -1, n = 0;
    for (const r of e) {
      if (r.id === t) {
        i = n;
        break;
      }
      n++;
    }
    return i;
  }
}
class ho extends El {
  static parseXml(t, e, i, n) {
    return ji.parseXml(t, e, i, n);
  }
  static parseBinary(t, e, i, n) {
    return ji.parseBinary(t, e, i, n);
  }
  static reify(t, e, i, n) {
    const r = Vi(i), o = new ho(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  constructor(t, e, i, n) {
    super(t, e, i, n), this._bits &= ~Hi.InitiallyShown, t.registerViewFrame(this, n.inclusionKey);
  }
  getName() {
    const t = super.getName();
    return t !== null ? t : "CAD View frame";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = Ni.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = qi(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return qo(this._nodeId, this);
  }
}
var Vt = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.LoadedNodesOnly = 1] = "LoadedNodesOnly", s))(Vt || {});
class r_ {
  constructor(t) {
    this._configuration = t.configuration, this._visibilityFormatter = t.visibilityFormatter, this._resetNonAffectedToDefault = t.resetNonAffectedToDefault, this._resetNonAffectedPmiToDefault = t.resetNonAffectedPmiToDefault, this._state = {
      currentNode: null,
      nodeConfiguration: null,
      appliedVisibility: null,
      inheritedVisibilityStack: [],
      bodiesToShow: [],
      bodiesToHide: []
    }, this.enterProductOccurrence = this.enterProductOccurrence.bind(this), this.leaveProductOccurrence = this.leaveProductOccurrence.bind(this), this.enterAnyBody = this.enterAnyBody.bind(this), this.leaveAnyBody = this.leaveAnyBody.bind(this), this.enterCadView = this.enterCadView.bind(this), this.leaveCadView = this.leaveCadView.bind(this), this.enterPmi = this.enterPmi.bind(this), this.leavePmi = this.leavePmi.bind(this);
  }
  /**
   * Get the visibility formatter of the updater.
   */
  get visibilityFormatter() {
    return this._visibilityFormatter;
  }
  /**
   * Set the visibility formatter of the updater.
   * @param func the formatter to use.
   */
  set visibilityFormatter(t) {
    this._visibilityFormatter = t;
  }
  /**
   * The currently visited node
   */
  get currentNode() {
    return this._state.currentNode;
  }
  /**
   * Getter for the visitor's configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Getter for the current node's configuration
   */
  get nodeConfiguration() {
    return this._state.nodeConfiguration;
  }
  /**
   * Getter for the output visibility for the current node
   */
  get appliedVisibility() {
    return this._state.appliedVisibility;
  }
  /**
   * Getter for the visitor's state
   */
  get state() {
    return this._state;
  }
  /**
   * Getter for the visit result
   *
   * Mainly the bodies to update.
   */
  get result() {
    return {
      bodies: {
        hide: this._state.bodiesToHide,
        show: this._state.bodiesToShow
      }
    };
  }
  /**
   * Update the visitor state and set the node visibility
   * @param node the node to update
   */
  _updateNodeVisibility(t) {
    this._updateVisitorState(t, !1);
    const e = this.appliedVisibility;
    e !== null && t.setVisibility(e);
  }
  /**
   * Get the visibility config for the current node
   * it contains several fields:
   * explicitVisibility: the value of the node from the visibilityFormatter for the current
   * node, if any visible: whether or not the current node is visible initiallyShown: the node
   * initial visibility
   * initiallyOrConfigurationShown: if configuration.initially.shown is true it
   * returns initiallyShown, otherwise it return initiallyShown or true if the configuration
   * is on the same branch.
   * @returns The current node visibility config
   */
  _getVisibilityConfig() {
    const t = this.currentNode, e = t.isInitiallyShown();
    let i = e;
    return !this._configuration.initially.shown && this._configuration.filterByConfiguration && (i = i || !this._configuration.containsAnyConfig || this._configuration.containsCurrentConfig), {
      explicitVisibility: this._visibilityFormatter ? this._visibilityFormatter(t) : void 0,
      visible: t.isVisible(),
      initiallyShown: e,
      initiallyOrConfigurationShown: i
    };
  }
  /**
   * Get the visibility for a PmiBody node
   *
   * For PMI we allow to switch them to visible if you just set the visibility on the PMI
   * (not its body instance subnode), it's because we don't display the PMI body instance in
   * the tree anymore.
   * @returns true or null
   */
  _getPmiBodyVisibility() {
    const e = this.currentNode.getParent();
    return this._visibilityFormatter && this._visibilityFormatter(e) === !0 ? !0 : null;
  }
  /**
   * If a node is initially hidden and has no explicit visibility set then we keep it
   * hidden by returning null, except for a some exceptions like PmiBody nodes.
   * @returns Null for regular node a boolean otherwise.
   */
  _getInitiallyHiddenNodeVisibility() {
    return this.currentNode instanceof Bs ? this._getPmiBodyVisibility() : null;
  }
  /**
   * Get the inherited visibility value of the node
   * @returns The inherited visibility value of the node if it's different than its current visibility or null
   */
  _getInheritedVisibility() {
    const t = this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1];
    return t !== this.nodeConfiguration.visible ? t && !this.nodeConfiguration.initiallyShown && this._configuration.initially.immutableHidden ? this._getInitiallyHiddenNodeVisibility() : t : null;
  }
  /**
   * When a node is not affected by the traversal, it visibility status is reinitialized if
   * resetNonAffectedToDefault is set and if its not already set to the expected value.
   * When resetNonAffectedPmiToDefault is defined it will be applied on pmis in place of resetNonAffectedToDefault, if it's not defined pmis follow resetNonAffectedToDefault
   * @returns The new visibility status if it's different from the current, null otherwise
   */
  _handleNonAffectedNodeVisibility() {
    return typeof this._resetNonAffectedPmiToDefault < "u" && this.state.currentNode !== null && (this.state.currentNode instanceof Mn || this.state.currentNode instanceof Bs) ? this._resetNonAffectedPmiToDefault && this.nodeConfiguration.visible !== this.nodeConfiguration.initiallyOrConfigurationShown ? this._state.nodeConfiguration.initiallyOrConfigurationShown : null : this._resetNonAffectedToDefault && this.nodeConfiguration.visible !== this.nodeConfiguration.initiallyOrConfigurationShown ? this._state.nodeConfiguration.initiallyOrConfigurationShown : null;
  }
  /**
   * Get the visibility status of the current node
   * @param preventFromResetting whether or not unaffected node will be reinitialized
   * @returns The new visibility status of the node if it's different from the current one, null otherwise
   */
  _getNodeVisibility(t) {
    return this.nodeConfiguration && this.nodeConfiguration.explicitVisibility !== void 0 ? this.nodeConfiguration.explicitVisibility : Do(this.currentNode) ? null : this._configuration.node !== void 0 && this._configuration.filterByConfiguration && this._configuration.containsAnyConfig && !this._configuration.containsCurrentConfig ? !1 : this._state.inheritedVisibilityStack.length > 0 ? this._getInheritedVisibility() : t ? null : this._handleNonAffectedNodeVisibility();
  }
  /**
   * Update the state of the visitor.
   * It set the given node as the current node, generates it visibility config, update the
   * hierarchy and compute the new visibility status.
   * @param node The current node to visit
   * @param preventFromResetting whether or not to reinitialize the node if its not affected.
   */
  _updateVisitorState(t, e) {
    this._state.currentNode = t, this._state.nodeConfiguration = this._getVisibilityConfig(), this._state.nodeConfiguration.explicitVisibility !== void 0 ? this._state.inheritedVisibilityStack.push(this._state.nodeConfiguration.explicitVisibility) : this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.push(
      this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1]
    ), this._state.appliedVisibility = this._getNodeVisibility(e);
  }
  /**
   * When the node is left it's popped out of the hierarchy
   */
  leaveNode() {
    this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.pop();
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current node
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !0, this._configuration.node === t && (this._configuration.containsCurrentConfig = !0)), this._updateNodeVisibility(t);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it removes the tag so the visitor knows the current
   * branch does not contains the configuration node anymore.
   * @param node
   */
  leaveProductOccurrence(t) {
    this.leaveNode(), t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !1, this._configuration.node === t && (this._configuration.containsCurrentConfig = !1));
  }
  /**
   * Updates visibility for Pmi node
   * @param pmi the current Pmi Node
   */
  enterPmi(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops Pmi from hierarchy
   * @param _ not used
   */
  leavePmi(t) {
    this.leaveNode();
  }
  /**
   * Updates visibility for CadView node
   * @param cadView the current CadView Node
   */
  enterCadView(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops CadView from hierarchy
   * @param _ not used
   */
  leaveCadView(t) {
    this.leaveNode();
  }
  /**
   * Updates the visitor's state and apply the new visibility status if any. If the Visibility
   * changes the body is stored in the list of the bodies to hide or to show depending of it's
   * new status.
   * @param body the current AnyBody node
   */
  enterAnyBody(t) {
    const e = t.preventFromResetting();
    this._updateVisitorState(t, e);
    const i = this.appliedVisibility;
    i !== null && (t.setVisibility(i), i ? this._state.bodiesToShow.push(t) : this._state.bodiesToHide.push(t));
  }
  /**
   * Pops AnyBody from hierarchy
   * @param _ not used
   */
  leaveAnyBody(t) {
    return this.leaveNode();
  }
}
class x0 extends r_ {
  constructor(t) {
    super(t), this.enterProductOccurrence = this.enterProductOccurrence.bind(this);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visitor
   * status without updating the node visibility status.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current ProductOccurence
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this.configuration.containsAnyConfig = !0, this.configuration.node === t && (this.configuration.containsCurrentConfig = !0)), this._updateVisitorState(t, !0);
  }
}
async function o_(s, t = !1) {
  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = (l) => t ? l.isInitiallyShown() : l.isVisible(), r = {
    enterAnyBody: (l) => {
      if (l instanceof ji) {
        const h = l.getRuntimeId();
        n(l) ? e.add(h) : i.add(h);
      }
    }
  };
  await Ln.walk(r, s, Vt.None);
  const o = e.size >= i.size;
  return new Ab(o, o ? i : e);
}
function Ku(s) {
  const t = [];
  for (const e of s) {
    const i = e.getInstanceInc();
    t.push(i[0], i[1]);
  }
  return t;
}
function Np(s) {
  const t = [];
  for (const e of s) {
    const i = e.getRuntimeId();
    t.push(i);
  }
  return t;
}
class a_ {
  constructor(t) {
    this._assemblyTree = t.assemblyTree, this._engine = t.engine, this._callbackManager = t.callbackManager, this._startNode = t.startNode, this._setVisibility = t.setVisibility, this._initiallyHiddenStayHidden = t.initiallyHiddenStayHidden, this._configurationNode = t.configurationNode, this._configuration = null;
  }
  /**
   * Get the visibility formatter for the given attach context
   * @param attachContext the attach context
   * @param setVisibility the visibility directive to apply
   * @returns the default formatter for attach context
   */
  static getAttachContextFormatter(t, e) {
    return (i) => {
      if (i instanceof _e && t.getChildren().indexOf(i) !== -1)
        switch (e) {
          case ao.Hide:
            return !1;
          case ao.Show:
            return !0;
          case ao.Initial:
            return;
        }
    };
  }
  /**
   * Get the updater configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Generates the configuration for the updater
   *
   * Determine if the configuration we're activating has initially visible nodes or not.
   *
   * It also checks whether the configuration node is an ancestor of the start node. In this
   * case it tags the configuration so it knows the current branch contains the configuration.
   *
   * In the case of older SCs (pre 2022 SP1) non-default configurations had all their nodes
   * set to initially hidden. Since then that has been changed so that the initial visibility states
   * of nodes under configurations reflects their visibility when the configuration is activated.
   * Thus, we need to know which of those cases we're dealing with, by checking for any nodes set to be
   * initially shown.
   *
   * If we're working with configurations we may need to show initially hidden nodes
   * regardless of assembly tree settings.
   * We want to reveal hidden nodes if the configuration has marked them as hidden.
   * See comment the comment above for more details.
   *
   * @returns a promise resolving with the configuration
   */
  async _generateConfig() {
    let t = !1, e = !1, i = !1, n = !1;
    if (this._configurationNode) {
      console.assert(this._configurationNode.isAConfigurationNode()), t = !0;
      const r = await o_(this._configurationNode, !0);
      if ((r.defaultVisibility || r.visibilityExceptions.size !== 0) && (n = !0), !(this._startNode instanceof Pn)) {
        let o = this._startNode;
        for (; o !== null; ) {
          if (o instanceof _e && o.isAConfigurationNode()) {
            i = !0, o === this._configurationNode && (e = !0);
            break;
          }
          const l = o.getParent();
          if (!(l instanceof _e))
            break;
          o = l;
        }
      }
    }
    return this._initiallyHiddenStayHidden === void 0 && (this._configurationNode !== void 0 ? this._initiallyHiddenStayHidden = n : this._initiallyHiddenStayHidden = this._assemblyTree.getInitiallyHiddenStayHidden()), {
      filterByConfiguration: t,
      containsCurrentConfig: e,
      containsAnyConfig: i,
      node: this._configurationNode,
      setVisibility: this._setVisibility,
      initially: {
        shown: n,
        immutableHidden: this._initiallyHiddenStayHidden
      }
    };
  }
  /**
   * Update the visibility of the bodies in the graphic engine.
   *
   * Once the assembly tree has been updated we need to tell the engine that some instances
   * need to be updated so that it can refresh the view.
   *
   * @param bodies the lists of the bodies to show and to hide
   */
  _applyVisibilities(t) {
    if (this._setVisibility) {
      const e = this._startNode.getAttachScope();
      console.assert(e !== ba.OfInitialEmptyModel), this._engine.setVisibilityByAttachment(e, this._setVisibility);
    } else {
      const e = Ku(t.show), i = Ku(t.hide);
      if (this._engine.pauseAllRendering(), this._engine.setPartVisibility(e, !0, !0), this._engine.setPartVisibility(i, !1, !0), this._engine.resumeAllRendering(), this._callbackManager) {
        const n = Np(t.show), r = Np(t.hide);
        this._callbackManager.trigger("visibilityChanged", n, r);
      }
    }
  }
  /**
   * Traverse the assembly tree within a walker to to allow the given visitor to update it.
   * @param visitor The visitor that will update the assembly tree
   * @param {optional} startNode The root of the traversal, default: the updater startNode
   */
  async traverse(t, e) {
    await Ln.walk(t, e || this._startNode, Vt.None);
  }
  /**
   * Initialize the configuration and the attach context if needed
   */
  async init() {
    this._startNode instanceof Pn || console.assert(this._setVisibility === void 0), this._configuration = await this._generateConfig();
  }
  /**
   * Not effect.
   * To allow inheriting classes to cool down or check result after the update.
   */
  async quit() {
  }
  /**
   * Update the assembly tree and the view using the given visitor.
   * @param visitor the Visitor that will update the assembly tree.
   */
  async update(t, e, ...i) {
    const n = new t({ ...e, configuration: this.configuration }, ...i);
    return await this.traverse(n), this._applyVisibilities(n.result.bodies), n;
  }
  /**
   * Update the assembly tree separately with each node as start node
   * @param visitor the visitor used to update the assembly.
   * @param nodeVisibilities the node roots and their visible status.
   */
  async updatePerNode(t, e, i, ...n) {
    const r = new t({ ...i, configuration: this.configuration }, ...n);
    return e.forEach(async (o, l) => {
      const h = r.visibilityFormatter;
      r.visibilityFormatter = (u) => u === u ? o : h ? h(u) : void 0, await this.traverse(r, l), r.visibilityFormatter = h;
    }), this._applyVisibilities(r.result.bodies), r;
  }
}
async function I0(s) {
  return lg({
    ...s,
    startNode: s.attachContext,
    visibilityFormatter: a_.getAttachContextFormatter(
      s.attachContext,
      s.setVisibility
    ),
    resetNonAffectedToDefault: s.setVisibility === ao.Initial,
    initiallyHiddenStayHidden: s.setVisibility !== ao.Show
  });
}
async function If(s) {
  return lg(s);
}
async function C0(s) {
  return lg({
    ...s,
    visitorType: x0
  });
}
async function lg(s, ...t) {
  const e = new a_({
    assemblyTree: s.assemblyTree,
    engine: s.engine,
    callbackManager: s.callbackManager,
    startNode: s.startNode,
    setVisibility: s.setVisibility !== null ? s.setVisibility : void 0,
    initiallyHiddenStayHidden: s.initiallyHiddenStayHidden,
    configurationNode: s.configurationNode
  });
  await e.init();
  const i = await e.update(
    s.visitorType || r_,
    {
      visibilityFormatter: s.visibilityFormatter,
      resetNonAffectedToDefault: s.resetNonAffectedToDefault,
      resetNonAffectedPmiToDefault: s.resetNonAffectedPmiToDefault
    },
    ...t
  );
  console.assert(i.state.inheritedVisibilityStack.length === 0), await e.quit();
}
async function S0(s, t) {
  const e = [], i = [], n = {
    enterAnyBody: (l) => {
      if (l instanceof Bs || l instanceof ho) {
        const h = l.isVisible();
        l.setVisibility(h), h ? e.push(l) : i.push(l);
      }
    }
  };
  await Ln.walk(n, t, Vt.None);
  const r = Ku(e), o = Ku(i);
  s.pauseAllRendering(), s.synchronizeVisibilities(r, !0), s.synchronizeVisibilities(o, !1), s.resumeAllRendering();
}
const Ka = 0, tf = (s) => (s + 1 >>> 1) - 1, du = (s) => (s << 1) + 1, ec = (s) => s + 1 << 1;
class M0 {
  constructor(t) {
    this._heap = [], this._comparator = t;
  }
  clear() {
    this._heap.length = 0;
  }
  get length() {
    return this._heap.length;
  }
  peek() {
    return this._heap[Ka];
  }
  push(t) {
    this._heap.push(t), this._siftUp();
  }
  pop() {
    const t = this.peek(), e = this.length - 1;
    return e > Ka && this._swap(Ka, e), this._heap.pop(), this._siftDown(), t;
  }
  replace(t) {
    const e = this.peek();
    return this._heap[Ka] = t, this._siftDown(), e;
  }
  _greater(t, e) {
    return this._comparator(this._heap[t], this._heap[e]);
  }
  _swap(t, e) {
    [this._heap[t], this._heap[e]] = [this._heap[e], this._heap[t]];
  }
  _siftUp() {
    let t = this.length - 1;
    for (; t > Ka && this._greater(t, tf(t)); )
      this._swap(t, tf(t)), t = tf(t);
  }
  _siftDown() {
    let t = Ka;
    for (; du(t) < this.length && this._greater(du(t), t) || ec(t) < this.length && this._greater(ec(t), t); ) {
      const e = ec(t) < this.length && this._greater(ec(t), du(t)) ? ec(t) : du(t);
      this._swap(t, e), t = e;
    }
  }
}
class l_ {
  constructor(t, e, i) {
    this._lazyPromise = t, this._wrapperPromise = e, i !== null && (this.compareValue = i);
  }
  kill() {
    this._lazyPromise = null;
  }
  /*
   * Causes this promise to be killed, and the associated open promise to be resolved.
   * This allows anything waiting on the associated open promise to resolve.
   */
  cancel(t) {
    this._lazyPromise = null, this._wrapperPromise.resolve(t);
  }
  fetch(t, e) {
    this._lazyPromise === null ? (this._wrapperPromise.reject(null), setTimeout(e, 0)) : t(this._lazyPromise).then((i) => {
      this._wrapperPromise.resolve(i);
    }).catch((i) => {
      this._wrapperPromise.reject(i);
    });
  }
}
class c_ {
  constructor(t, e, i) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, this._latestPromise = Promise.resolve(), this._needsResorting = !1, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._deferredPromises = e, this._failureFailsAll = i;
  }
  maxActivePromises() {
    return this._maxActivePromises;
  }
  activePromiseCount() {
    return this._activePromiseCount;
  }
  isIdle() {
    return this._activePromiseCount === 0;
  }
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failureFailsAll && this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = vi()), this._idlePromise;
  }
  killDeferred() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      e.kill(), t.push(e);
    }
    for (const e of t)
      this._queue(e);
  }
  _push(t, e) {
    typeof t == "function" && (t = Cs.create(t));
    let i;
    return this._activePromiseCount < this._maxActivePromises ? i = this._immediatePromise(t) : i = this._deferPromise(t, e), this._latestPromise = i, i;
  }
  _resort() {
    console.assert(this._needsResorting), this._needsResorting = !1;
    const t = this._drainQueue();
    for (const e of t)
      this._queue(e);
  }
  _drainQueue() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      t.push(e);
    }
    return t;
  }
  _deferPromise(t, e) {
    const i = vi(), n = new l_(t, i, e);
    return this._queue(n), i;
  }
  async _immediatePromise(t) {
    if (this._failureFailsAll && this._failed)
      throw this._failureError;
    ++this._activePromiseCount;
    try {
      const e = await t.get();
      return this._finalizePromise(), e;
    } catch (e) {
      throw this._failureFailsAll && !this._failed && (this._failed = !0, this._failureError = e, this._idlePromise !== null && this._idlePromise.reject(e)), this._finalizePromise(), e;
    }
  }
  // Kicks off the next item in the queue.
  // Precondition: _deferredPromises.length > 0 && _activePromiseCount < _maxActivePromises
  _fetchNext() {
    this._dequeue().fetch(
      (t) => this._immediatePromise(t),
      () => {
        this._finalizePromise();
      }
    );
  }
  _finalizePromise() {
    --this._activePromiseCount, this._deferredPromises.length > 0 ? (this._needsResorting && this._resort(), this._fetchNext()) : this._activePromiseCount === 0 && (this._idlePromise !== null && (this._failureFailsAll && this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null), this._latestPromise = Promise.resolve());
  }
}
class Uo extends c_ {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e) {
    super(t, new Km(), e);
  }
  push(t) {
    return this._push(t, null);
  }
  async waitOnLatest() {
    await this._latestPromise;
  }
}
class h_ extends c_ {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e, i) {
    const n = (o, l) => e(o.compareValue, l.compareValue), r = new M0(n);
    super(t, r, i);
  }
  push(t, e) {
    return this._push(t, e);
  }
  markDirty() {
    this._needsResorting = !0;
  }
}
class P0 extends Uo {
  _queue(t) {
    this._deferredPromises.clear(), this._deferredPromises.push(t);
  }
  constructor(t) {
    super(1, t);
  }
}
class k0 extends h_ {
  constructor(t, e, i, n, r) {
    super(i, n, r), this._cutoffAttachments = [], this._attachPriorityManager = e, this._cutoffScale = t;
  }
  setCutoffScale(t) {
    this._cutoffScale = Math.max(Math.min(t, 2), 0);
  }
  cutoffEnabled() {
    return this._cutoffScale !== 0;
  }
  isEmpty() {
    return this._cutoffAttachments.length === 0 && this._deferredPromises.length === 0;
  }
  /*
   * This method will effectively 'cancel' a pending loadSubtreebyXXX operation.
   * The difference between this and the base implementation is that all deferred promises will acually be resolved.
   * This allows for the promise returned by the initial method invocation to resolve when in stream cutoff mode if all items never passed the cutoff test.
   */
  killDeferred() {
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [];
    for (const i of t) i.cancel(null);
    for (const i of e) i.cancel(null);
  }
  /*
   * gets the calculated cutoff value from the attachPriorityManager.
   * Attachments must have a projected size equal to or grater than this value with the current camerta to be considered for fetching.
   * The value returned takes into account the sorting method implemented by the PriorityPromiseQueue
   */
  _getCutoffValue() {
    return this._cutoffScale * -this._attachPriorityManager.getCalculatedCutoff() - 1;
  }
  /*
   * Main entrypoint for items into the prefetch queue.  If cutoff is disabled, then the default behavior will be used and all items streamed.
   * When cutoff scale is enabled, then an items projected size will determine if it is enqueued for fetching or held back for reconsideration on camera update.
   */
  push(t, e) {
    if (!this.cutoffEnabled()) return this._push(t, e);
    const i = this._attachPriorityManager.getPriorityCompareValue(e), n = this._getCutoffValue();
    if (i > n) {
      typeof t == "function" && (t = Cs.create(t));
      const r = vi(), o = new l_(t, r, e);
      return this._cutoffAttachments.push(o), r;
    } else
      return this._push(t, e);
  }
  /*
   * Override method which will apply the cutoff scale logic on all items currently needing to be fetched.
   * This may cause some items which were in the queue to be held back, and new items cycled in to be fetched based on
   * their projected size and the current camera.
   */
  _resort() {
    if (!this.cutoffEnabled()) {
      super._resort();
      return;
    }
    this._needsResorting = !1;
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [], this._updateDeferredPromiseArray(t), this._updateDeferredPromiseArray(e);
  }
  /*
   * If the queue has deferred promises left, it will automatically be resorted by the PromiseQueueImpl when the next promise finalizes.
   * Otherwise, we want to force a resort now and kick off the next attachment fetch
   */
  update() {
    if (!this.cutoffEnabled()) {
      this.markDirty();
      return;
    }
    this._cutoffAttachments.length > 0 && (this._resort(), this._refillQueue());
  }
  _refillQueue() {
    const t = Math.min(
      this.maxActivePromises() - this.activePromiseCount(),
      this._deferredPromises.length
    );
    for (let e = 0; e < t; e++) this._fetchNext();
  }
  /*
   * This method will scan an array of deferred promises and either place them in the queue to be fetched if they pass the cutoff scale test.
   * items which do not make the cut will be held back for reconsideration when the camera is updated again.
   */
  _updateDeferredPromiseArray(t) {
    for (const e of t) {
      const i = this._attachPriorityManager.getPriorityCompareValue(
        e.compareValue
      ), n = this._getCutoffValue();
      i > n ? this._cutoffAttachments.push(e) : this._queue(e);
    }
  }
}
async function dc(s, t, e, i) {
  const n = [], r = [], o = [], l = /* @__PURE__ */ new Set(), h = (_, x) => {
    if (!_.hasModifiers()) return x;
    const b = _.getLocalTransform();
    if (b != null) {
      const I = x;
      if (_.ignoreParentScale() && _.ignoreParentRotation())
        x = Gn.copy(b);
      else if (_.ignoreParentScale()) {
        const C = new m(x[0], x[1], x[2]).length(), M = new m(b[0], b[1], b[2]).length();
        if (C > 0) {
          const P = M / C, O = new wt();
          O.setScaleComponent(P, P, P), x = Gn.multiply(x, O.m);
        }
      } else {
        const C = new m(x[0], x[1], x[2]).length();
        if (C > 0) {
          const M = C, P = new wt();
          P.setScaleComponent(M, M, M), x = P.m;
        }
      }
      x[12] = I[12], x[13] = I[13], x[14] = I[14];
    }
    return x;
  }, u = (_) => {
    if (l.has(_))
      return !1;
    l.add(_);
    const x = _.getLocalTransform();
    if (x !== null) {
      let b = n[n.length - 1];
      b = Gn.multiply(x, b), n.push(b);
    }
    return !0;
  }, f = (_) => {
    _.getLocalTransform() !== null && (console.assert(n.length > 1), n.pop());
  }, g = {
    followProductOccurrence: u,
    leaveProductOccurrence: f,
    followPmi: u,
    leavePmi: f,
    followCadView: u,
    leaveCadView: f,
    followAnyBody: u,
    enterAnyBody: (_) => {
      if (!_.isOutOfHierarchy() || i) {
        const x = _.getInstanceInc();
        o.push(x[0], x[1]);
        const b = h(_, n[n.length - 1]);
        r.push(wt.createFromArray(b));
      }
    },
    leaveAnyBody: f
  }, y = new Uo(1, !0);
  for (const _ of e) {
    const x = Cs.create(async () => {
      console.assert(n.length === 0);
      const b = eh(_.getParent());
      n.push(b), await Ln.walk(g, _, Vt.None), console.assert(n.length === 1), n.pop();
    });
    y.push(x);
  }
  await y.waitForIdle(), console.assert(2 * r.length === o.length), s.setMatrices(o, r), t.trigger("_updateTransform", i);
}
function fu(s) {
  return s.isLoaded();
}
function Xa() {
  return !0;
}
function $s() {
}
class u_ {
  constructor(t, e) {
    this.followProductOccurrence = Xa, this.enterProductOccurrence = $s, this.leaveProductOccurrence = $s, this.followPartDefinition = Xa, this.enterPartDefinition = $s, this.leavePartDefinition = $s, this.followRepresentationItem = Xa, this.enterRepresentationItem = $s, this.leaveRepresentationItem = $s, this.followAnyBody = Xa, this.enterAnyBody = $s, this.leaveAnyBody = $s, this.followCadView = Xa, this.enterCadView = $s, this.leaveCadView = $s, this.followPmi = Xa, this.enterPmi = $s, this.leavePmi = $s, e === Vt.LoadedNodesOnly && (console.assert(t.followProductOccurrence === void 0), console.assert(t.followAnyBody === void 0), console.assert(t.followCadView === void 0), console.assert(t.followPmi === void 0), this.followProductOccurrence = fu, this.followAnyBody = fu, this.followCadView = fu, this.followPmi = fu), t.followProductOccurrence !== void 0 && (this.followProductOccurrence = t.followProductOccurrence), t.enterProductOccurrence !== void 0 && (this.enterProductOccurrence = t.enterProductOccurrence), t.leaveProductOccurrence !== void 0 && (this.leaveProductOccurrence = t.leaveProductOccurrence), t.followPartDefinition !== void 0 && (this.followPartDefinition = t.followPartDefinition), t.enterPartDefinition !== void 0 && (this.enterPartDefinition = t.enterPartDefinition), t.leavePartDefinition !== void 0 && (this.leavePartDefinition = t.leavePartDefinition), t.followRepresentationItem !== void 0 && (this.followRepresentationItem = t.followRepresentationItem), t.enterRepresentationItem !== void 0 && (this.enterRepresentationItem = t.enterRepresentationItem), t.leaveRepresentationItem !== void 0 && (this.leaveRepresentationItem = t.leaveRepresentationItem), t.followAnyBody !== void 0 && (this.followAnyBody = t.followAnyBody), t.enterAnyBody !== void 0 && (this.enterAnyBody = t.enterAnyBody), t.leaveAnyBody !== void 0 && (this.leaveAnyBody = t.leaveAnyBody), t.followCadView !== void 0 && (this.followCadView = t.followCadView), t.enterCadView !== void 0 && (this.enterCadView = t.enterCadView), t.leaveCadView !== void 0 && (this.leaveCadView = t.leaveCadView), t.followPmi !== void 0 && (this.followPmi = t.followPmi), t.enterPmi !== void 0 && (this.enterPmi = t.enterPmi), t.leavePmi !== void 0 && (this.leavePmi = t.leavePmi);
  }
}
class Ph {
  static walk(t, e, i) {
    if (i === Vt.LoadedNodesOnly && !e.isLoaded())
      return;
    const n = new Ph(t, i);
    return e instanceof _e ? n._walkProductOccurrence(e) : e instanceof Mn ? n._walkPmi(e) : e instanceof ls ? n._walkCadView(e) : n._walkAnyBody(e);
  }
  constructor(t, e) {
    this._visitor = new u_(t, e);
  }
  _walkRepresentationItem(t) {
    console.assert(t.isLoaded()), this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    console.assert(t.isLoaded()), this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (console.assert(t.isLoaded()), this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    if (console.assert(t.isLoaded()), this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const e = t.getPartDefinitionSync();
      e !== null && this._walkPartDefinition(e);
      const i = t.getChildrenSync();
      for (const l of i)
        this._walkProductOccurrence(l);
      const n = t.getBodyInstances();
      for (const l of n)
        this._walkAnyBody(l);
      const r = t.getPmis();
      for (const l of r)
        this._walkPmi(l);
      const o = t.getCadViews();
      for (const l of o)
        this._walkCadView(l);
      this._visitor.leaveProductOccurrence(t);
    }
  }
}
function d_(s, t, e, i, n, r) {
  const o = [], h = {
    enterAnyBody: (f) => {
      if (n.has(f))
        return;
      if (n.add(f), f instanceof ji) {
        if (!ne(e, Wt.BodyInstance) || f.isOutOfHierarchy() && !i)
          return;
      } else if (f instanceof Bs) {
        if (!ne(e, Wt.PmiBody))
          return;
      } else if (!ne(e, Wt.ViewFrame))
        return;
      const g = f.getInstanceInc();
      o.push(g[0], g[1]);
    }
  }, u = s.walk(h, t, r);
  return u ? u.then(() => o) : o;
}
function f_(s, t, e, i) {
  return d_(
    Ln,
    s,
    t,
    e,
    i,
    Vt.None
  );
}
function Yc(s, t, e, i, n) {
  return d_(
    Ph,
    s,
    t,
    e,
    i,
    n
  );
}
function g_(s, t, e, i) {
  let n = null;
  const r = /* @__PURE__ */ new Set();
  for (const o of t) {
    const l = s.lookupAnyTreeNode(o);
    if (l === null)
      throw new Ns(o);
    const h = Do(l), u = Yc(
      l,
      e,
      h,
      r,
      i
    );
    if (n === null)
      n = u;
    else
      for (const f of u)
        n.push(f);
  }
  return n !== null ? n : [];
}
async function p_(s, t, e, i, n, r) {
  const o = g_(
    s,
    e,
    i,
    Vt.None
  );
  if (o.length === 0)
    throw new oe("Cannot get the bounding of node without geometry.");
  return t.getPartsBounding(o, n, r);
}
function E0(s, t) {
  const e = new Uo(1, !0);
  e.push(() => s.clear());
  for (const i of t)
    e.push(() => s.addPlane(i, null));
  return e.waitForIdle();
}
function A0(s, t, e) {
  const i = e.getRuntimeId(), n = s.get(i);
  n !== void 0 ? (e.overrideLocalTransform(n), t.push(e)) : e.hasLocalTransformOverride() && (e.removeLocalTransformOverride(), t.push(e));
}
function T0(s, t) {
  t.hasLocalTransformOverride() && (t.removeLocalTransformOverride(), s.push(t));
}
class ls extends is {
  static parseXml(t, e, i, n) {
    let r = 0;
    const o = ui.parseNodeId(e, "Id");
    if (o === null)
      throw new si('Expected "Id" attribute.');
    const l = e.getAttribute("Name");
    if (l === null)
      throw new si('Expected "Name" attribute');
    const h = (K, J, rt, ft) => {
      const H = K.getAttribute("Enabled");
      if (H === null)
        throw new si(`Expected ${rt} attribute`);
      return J = fa(J, ft, H === "1"), J;
    }, u = e.getAttribute("isAnnotationView");
    u === null ? r = fa(r, Si.IsAnnotationView, !1) : r = fa(r, Si.IsAnnotationView, u === "true");
    let f = null, g = null, y = [], _ = [], x = [], b = [], I = /* @__PURE__ */ new Map(), C = [];
    const M = (K) => {
      const J = ui.parseUint(K, "Projection");
      if (J === null)
        throw new si('Expected "Projection" attribute');
      const rt = K.getAttribute("field");
      if (rt === null)
        throw new si('Expected "field" attribute');
      const ft = rt.split(" ");
      if (ft.length !== 2)
        throw new si("Expected 2 field values");
      const H = parseFloat(ft[0]), $ = parseFloat(ft[1]), D = K.getAttribute("definition");
      if (D === null)
        throw new si('Expected "definition" attribute');
      const R = D.split(" ");
      if (R.length !== 9)
        throw new si("Expected 9 definition values");
      const U = (Nt, lt) => new m(
        parseFloat(Nt[lt]),
        parseFloat(Nt[lt + 1]),
        parseFloat(Nt[lt + 2])
      ), it = U(R, 0), at = U(R, 3), mt = U(R, 6);
      return Sn.create(it, at, mt, J, H, $);
    }, P = (K) => {
      if (ui.parseUint(K, "Count") === null)
        throw new si('Expected "Count" attribute');
      const rt = ui.parseUints(K, "FilterIds");
      if (rt === null)
        throw new si('Expected "FilterIds" attribute');
      return rt;
    }, O = (K) => {
      const J = [];
      if (ui.parseUint(K, "Count") === null)
        throw new si('Expected "PMIToShow Count" attribute');
      const ft = ui.parseNodeIds(K, "IDs");
      if (ft === null)
        throw new si('Expected "PMIToShow Ids" attribute');
      for (let H = 0; H < ft.length; H += 2)
        J.push(ft[H + 1]);
      return J;
    }, B = (K) => {
      const J = [], rt = ui.parseUint(K, "Count");
      if (rt === null)
        throw new si('Expected "ClipPlanes Count" attribute');
      const ft = ui.parseFloats(K, "Plane");
      if (ft === null)
        throw new si('Expected "Plane" attribute');
      if (ft.length / 4 !== rt)
        throw new si(`Expected ${rt} Planes`);
      for (let H = 0; H < ft.length; H += 4)
        J.push(
          ln.createFromCoefficients(ft[H], ft[H + 1], ft[H + 2], ft[H + 3])
        );
      return J;
    }, j = (K) => {
      const J = /* @__PURE__ */ new Map(), rt = ui.parseUint(K, "Count");
      if (rt === null)
        throw new si('Expected "IDLocalTransform Count" attribute');
      const ft = ui.parseFloats(K, "IDTransform");
      if (ft === null)
        throw new si('Expected "IDTransform" attribute');
      {
        if (ft.length / 13 !== rt)
          throw new si(`Expected ${rt} IDTransform values`);
        const H = ($, D) => {
          const R = Gn.getIdentity();
          return R[1] = $[D + 1], R[2] = $[D + 2], R[3] = $[D + 3], R[4] = $[D + 4], R[6] = $[D + 5], R[7] = $[D + 6], R[8] = $[D + 7], R[9] = $[D + 8], R[11] = $[D + 9], R[12] = $[D + 10], R[13] = $[D + 11], R[14] = $[D + 12], R;
        };
        for (let $ = 0; $ < ft.length; $ += 13) {
          const D = ft[$], R = H(ft, $);
          J.set(D, R);
        }
      }
      return J;
    };
    let F = e.firstElementChild;
    for (; F !== null; )
      F.localName === "Camera" ? (console.assert(f === null), f = M(F)) : F.localName === "Frame" ? g = ho.parseXml(
        t,
        F,
        i.getInclusionKey(),
        n
      ) : F.localName === "PMIToShow" ? y = O(F) : F.localName === "InstanceToShow" ? _ = ui.parseNodeIds(F, "IDs") : F.localName === "InstanceToHide" ? x = ui.parseNodeIds(F, "IDs") : F.localName === "ClipPlanes" ? C = B(F) : F.localName === "IDLocalTransform" ? I = j(F) : F.localName === "IsCameraSet" ? r = h(
        F,
        r,
        "IsCameraSet",
        Si.IsCameraSet
      ) : F.localName === "IsPMIFilteringSet" ? r = h(
        F,
        r,
        "IsPMIFilteringSet",
        Si.IsPmiFilteringSet
      ) : F.localName === "IsGeomFilteringSet" ? r = h(
        F,
        r,
        "IsGeomFilteringSet",
        Si.IsGeomFilteringSet
      ) : F.localName === "IsCrosssectionSet" ? r = h(
        F,
        r,
        "IsCrosssectionSet",
        Si.IsCrossSectionSet
      ) : F.localName === "IsExplosionSet" ? r = h(
        F,
        r,
        "IsExplosionSet",
        Si.IsExplosionSet
      ) : F.localName === "IsCombineState" ? r = h(
        F,
        r,
        "IsCombineState",
        Si.IsCombineState
      ) : F.localName === "Filters" && (b = P(F)), F = F.nextElementSibling;
    return {
      nodeId: o,
      name: l,
      camera: f,
      instanceMarkupKeysToShow: y,
      viewFrameInfo: g,
      nodesToShow: _ ?? [],
      nodesToHide: x ?? [],
      filters: b ?? [],
      transformMap: I,
      cuttingPlanes: C,
      bits: r
    };
  }
  static parseBinary(t, e, i, n) {
    const r = i.parseViewParseBits(), o = i.parseNodeId();
    let l = null;
    ne(r, bn.Name) && (l = i.parseCString());
    let h = 0, u = !1;
    ne(r, bn.IsAnnotationView) ? (u = !0, l += " # Annotation View") : l !== null && l.indexOf("# Annotation View") >= 0 && (u = !0), u && (h |= Si.IsAnnotationView), ne(r, bn.IsNotPmiFilteringSet) || (h |= Si.IsPmiFilteringSet), ne(r, bn.IsNotGeomFilteringSet) || (h |= Si.IsGeomFilteringSet), ne(r, bn.IsNotCrosssectionSet) || (h |= Si.IsCrossSectionSet), ne(r, bn.IsNotExplosionSet) || (h |= Si.IsExplosionSet), ne(r, bn.IsCombineState) && (h |= Si.IsCombineState), ne(r, bn.IsDefaultView) && (h |= Si.IsDefaultView);
    const f = ne(r, bn.IsPerspective);
    f && (h |= Si.IsPerspective);
    let g = null;
    if (ne(r, bn.Camera)) {
      const P = f ? ri.Perspective : ri.Orthographic, O = i.parsePoint3_32(), B = i.parsePoint3_32(), j = i.parsePoint3_32(), F = i.parseFloat_32(), K = i.parseFloat_32();
      ne(r, bn.IsNotCameraSet) || (h |= Si.IsCameraSet, g = Sn.create(O, B, j, P, F, K), (F < 0 || K < 0) && (h |= Si.HasDynamicFrame));
    }
    const y = [];
    if (ne(r, bn.Pmi)) {
      const P = i.parseCount_32();
      for (let O = 0; O < P; ++O) {
        const B = i.parseInstanceKey();
        y.push(B);
      }
    }
    let _ = null;
    ne(r, bn.Frame) && (_ = ho.parseBinary(t, e, i, n));
    const x = [];
    if (ne(r, bn.ShowNodes)) {
      const P = i.parseCount_32();
      for (let O = 0; O < P; ++O) {
        const B = i.parseNodeId();
        x.push(B);
      }
    }
    const b = [];
    if (ne(r, bn.HideNodes)) {
      const P = i.parseCount_32();
      for (let O = 0; O < P; ++O) {
        const B = i.parseNodeId();
        b.push(B);
      }
    }
    const I = new Array();
    if (ne(r, bn.ViewFilters)) {
      const P = i.parseCount_32();
      for (let O = 0; O < P; ++O) {
        const B = i.parseUInt32();
        I.push(B);
      }
    }
    const C = /* @__PURE__ */ new Map();
    if (ne(r, bn.MoveNodes)) {
      const P = i.parseCount_32();
      for (let O = 0; O < P; ++O) {
        const B = i.parseNodeId(), j = Gn.parseBinary(i);
        C.set(B, j);
      }
    }
    const M = [];
    if (ne(r, bn.CuttingPlanes)) {
      const P = i.parseCount_32();
      for (let O = 0; O < P; ++O) {
        const B = i.parsePlane3_32();
        M.push(B);
      }
    }
    return {
      nodeId: o,
      name: l,
      camera: g,
      instanceMarkupKeysToShow: y,
      viewFrameInfo: _,
      nodesToShow: x,
      nodesToHide: b,
      filters: I,
      transformMap: C,
      cuttingPlanes: M,
      bits: h
    };
  }
  static reify(t, e, i, n) {
    const r = Vi(e), o = new ls(t, e, i, 0, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, n, r, o, l, h, u) {
    const f = qi(e), g = t.generateDynamicNodeId(), y = [];
    let _ = Si.IsCameraSet;
    if (r != null) {
      _ = fa(_, Si.IsPmiFilteringSet, !0);
      for (const I of r)
        for (const C of I.getPmiBodies()) {
          const M = qi(C);
          console.assert(f === M);
          const O = C.getInstanceInc()[1];
          y.push(O);
        }
    }
    const x = {
      nodeId: g,
      name: i,
      camera: n,
      instanceMarkupKeysToShow: y,
      viewFrameInfo: null,
      nodesToShow: o,
      nodesToHide: l,
      filters: [],
      transformMap: h,
      cuttingPlanes: u !== null ? [u] : [],
      bits: _
    };
    return new ls(
      t,
      f,
      x,
      1,
      e
    );
  }
  static isAuthoredViewInfo(t, e) {
    return e === 0;
  }
  constructor(t, e, i, n, r) {
    const l = Vi(e).getMasterModelKey(), h = {
      nodeId: i.nodeId,
      bits: 0,
      name: i.name,
      localTransform: null,
      attributes: [],
      header: Zs.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    if (super(t, l, h), this._parent = r, this._bits |= i.bits, i.camera !== null && (this._camera = {
      initial: i.camera.copy(),
      derived: i.camera.copy()
    }), i.filters.length > 0 && (this._filters = i.filters), this._instanceMarkupKeysToShow = Cc(i.instanceMarkupKeysToShow), ls.isAuthoredViewInfo(i, n) ? (this._nodesToShow = ls._toRuntimeIds(e, i.nodesToShow), this._nodesToHide = ls._toRuntimeIds(e, i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = /* @__PURE__ */ new Map(), i.transformMap.forEach((u, f) => {
      const g = e.toRuntimeId(f);
      this._transformMap.set(g, Gn.copy(u));
    }))) : (this._nodesToShow = Cc(i.nodesToShow), this._nodesToHide = Cc(i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = cd(i.transformMap))), i.viewFrameInfo !== null && (this._viewFrame = this._loadViewFrame(t, l, i.viewFrameInfo)), i.cuttingPlanes.length > 0) {
      this._cuttingPlanes = bs(i.cuttingPlanes);
      let u = 1;
      const f = Lp(this), g = Vi(f), y = mr(g);
      if (y) {
        const _ = f.getMeasurementUnit(), x = y.getMeasurementUnit();
        _ !== x && (u = _ / x);
      }
      u !== 1 && hi(this._cuttingPlanes).forEach((_) => {
        _.d *= u;
      });
    }
    t.registerCadView(this);
  }
  getFilters() {
    return this._filters !== void 0 ? this._filters : null;
  }
  static _toRuntimeIds(t, e) {
    const i = /* @__PURE__ */ new Set();
    for (const n of e) {
      const r = t.toRuntimeId(n);
      i.add(r);
    }
    return i;
  }
  _loadViewFrame(t, e, i) {
    return ho.reify(t, e, this, i);
  }
  getViewFrame() {
    return this._viewFrame ?? null;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return qo(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? ue.Shown : ue.Hidden;
    return this._viewFrame !== void 0 && !this._viewFrame.isOutOfHierarchy() && (t |= this._viewFrame.isVisible() ? ue.Shown : ue.Hidden), t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  isPmiFilteringSet() {
    return this._hasBits(Si.IsPmiFilteringSet);
  }
  isDefaultView() {
    return this._hasBits(Si.IsDefaultView);
  }
  IsCombineState() {
    return this._hasBits(Si.IsCombineState);
  }
  deactivate(t) {
    return t.clearAllCuttingSections();
  }
  async _replaceCuttingPlanes(t, e) {
    await t.clearAllCuttingSections();
    const i = t.getCuttingSectionCount();
    if (e.length > i)
      throw new oe(
        `System does not support more than ${i} cutting planes in a CadView`
      );
    const n = e.reduce(
      (r, o, l) => {
        const h = t.getCuttingSection(l);
        return console.assert(h !== null), r.push(E0(h, [o])), r;
      },
      []
    );
    await Promise.all(n), await t.activateCuttingSections();
  }
  async activate(t, e, i, n, r, o, l, h) {
    return await this._activateView(
      t,
      e,
      i,
      n,
      h
    ), this._activateCamera(t, e, r, o, l);
  }
  // XXX: I have doubts that this is implemented correctly. Intentionally matching old behavior for now.
  async _activateView(t, e, i, n, r) {
    const o = t.getRootNode();
    r !== null && console.assert(r.isAConfigurationNode());
    const l = (r == null ? void 0 : r.getRuntimeId()) ?? Ts;
    let h = Ts;
    const u = /* @__PURE__ */ new Map(), f = [], g = [];
    let y = T0;
    this._transformMap !== void 0 && (y = (C, M) => {
      A0(this._transformMap, C, M);
    });
    const _ = {
      enterProductOccurrence: (C) => {
        const M = C;
        M.isAConfigurationNode() && (h = M.getRuntimeId());
        const P = h, O = M.forEachPmi((B) => {
          const j = B.getPmiBodies();
          if (j.length !== 0 && this.isPmiFilteringSet()) {
            let F = !1;
            for (const K of j) {
              const rt = K.getInstanceInc()[1];
              if (this._instanceMarkupKeysToShow.has(rt)) {
                F = !0;
                break;
              }
            }
            r !== null && (F = F && (P === l || P === Ts)), u.set(B, F);
            for (const K of j)
              u.set(K, F);
          }
        }).then(() => {
          const B = M.getRuntimeId();
          return this._nodesToHide.has(B) || M.isADrawingSheetNode() ? u.set(M, !1) : this._nodesToShow.has(B) && (r !== null ? u.set(
            M,
            P === l || P === Ts
          ) : u.set(M, !0)), y(f, M), M.forEachCadView((j) => {
            const F = j;
            if (F._viewFrame !== void 0) {
              let K = F === this;
              r !== null && (K = K && (P === l || P === Ts)), u.set(j, K), u.set(F._viewFrame, K);
            }
          });
        });
        g.push(O);
      },
      leaveProductOccurrence: (C) => {
        C.isAConfigurationNode() && (h = Ts);
      },
      enterAnyBody: (C) => {
        if (C.isOutOfHierarchy())
          return;
        y(f, C);
        let M = C.getParent();
        for (; M !== null && !(M instanceof Mn); ) {
          const O = M.getRuntimeId();
          if (this._nodesToHide.has(O)) {
            u.set(M, !1);
            break;
          } else if (this._nodesToShow.has(O)) {
            u.set(M, !0);
            break;
          }
          M = v_(M.getParent());
        }
        const P = C.getRuntimeId();
        this._nodesToShow.has(P) ? u.set(C, !0) : this._nodesToHide.has(P) && u.set(C, !1), r !== null && h !== Ts && h !== l && u.set(C, !1);
      }
    };
    await Ln.walk(_, o, Vt.None), await Promise.all(g);
    const x = [];
    let b = If({
      assemblyTree: t,
      engine: e,
      startNode: o,
      visibilityFormatter: (C) => u.get(C),
      resetNonAffectedToDefault: !0,
      resetNonAffectedPmiToDefault: this.isPmiFilteringSet(),
      configurationNode: r ?? void 0,
      callbackManager: i,
      initiallyHiddenStayHidden: !1
    });
    x.push(b), b = dc(e, i, f, !1), x.push(b), await We(x);
    const I = hi(this._cuttingPlanes);
    await this._replaceCuttingPlanes(n, I);
  }
  async _activateCamera(t, e, i, n, r) {
    const o = this._camera;
    if (o === void 0) {
      t.disableAutomaticFitWorld() || await i.fitWorld(n);
      return;
    }
    if (!r)
      return i._setCameraPromise(o.initial, n);
    const l = Lp(this), h = Vi(l), u = mr(h);
    let f = wt.createFromArray(eh(h));
    if (u !== null) {
      const g = l.getMeasurementUnit(), y = u.getMeasurementUnit();
      if (g !== y) {
        const _ = g / y, x = new wt();
        x.setScaleComponent(_, _, _), f = wt.multiply(x, f);
      }
    }
    if (o.derived = o.initial.transform(f), this._hasBits(Si.HasDynamicFrame)) {
      const y = this._viewFrame !== void 0 ? await p_(
        t,
        e,
        [this._viewFrame.getRuntimeId()],
        Wt.All,
        !1,
        !1
      ) : await e.getModelBounding(!0, !1, !1), _ = m.subtract(o.derived.getTarget(), o.derived.getPosition()), x = y.extents().length(), b = _.copy().normalize().scale(x), I = y.center(), C = m.subtract(I, b);
      return o.derived.setPosition(C), o.derived.setTarget(I), o.derived.setWidth(x), o.derived.setHeight(x), i._setCameraPromise(o.derived, n);
    } else if (o.derived.getProjection() === ri.Orthographic) {
      const g = m.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), y = await e.getModelBounding(!0, !1, !1), _ = m.subtract(y.center(), o.derived.getPosition()), x = 1 / g.length(), b = x * m.dot(g, _);
      if (b > 0) {
        g.scale(x);
        const I = Math.max(o.derived.getWidth(), o.derived.getHeight()), C = m.add(
          o.derived.getPosition(),
          m.scale(g, b)
        ), M = m.subtract(
          C,
          m.scale(g, 2.5 * I)
        );
        o.derived.setPosition(M), o.derived.setTarget(C);
      }
      return i._setCameraPromise(o.derived, n);
    } else if (o.derived.getProjection() === ri.Perspective) {
      const y = await e.getModelBounding(!0, !1, !1), _ = m.subtract(y.max, y.min).length(), x = m.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), b = x.length(), I = b / _;
      if (_ === 0 || I > 0.01)
        return i._setCameraPromise(o.derived, n);
      const C = _ * 0.01 * 1.001, M = o.derived.getWidth() / b, P = o.derived.getHeight() / b, O = M * C, B = P * C, j = x.copy().normalize().scale(C), F = m.add(o.derived.getPosition(), j);
      return o.derived.setTarget(F), o.derived.setWidth(O), o.derived.setHeight(B), i._setCameraPromise(o.derived, n);
    } else
      return i._setCameraPromise(o.derived, n);
  }
  hasPmi(t) {
    const e = qi(this).getInclusionKey(), i = qi(t).getInclusionKey();
    if (e !== i)
      return !1;
    for (const n of t.getPmiBodies()) {
      const r = n.getInstanceInc()[1];
      if (this._instanceMarkupKeysToShow.has(r))
        return !0;
    }
    return !1;
  }
  isAnnotationView() {
    return this._hasBits(Si.IsAnnotationView);
  }
  isCombineStateView() {
    return this._hasBits(Si.IsCombineState);
  }
  setViewFrame(t) {
    console.assert(this._viewFrame === void 0), this._viewFrame = t;
  }
}
class Ln {
  static walk(t, e, i) {
    if (i === Vt.LoadedNodesOnly && !e.isLoaded())
      return Promise.resolve();
    const n = new Ln(t, i);
    if (e instanceof is)
      return n._walkAnyTreeNode(e);
    {
      const r = new Sc(1, !1), o = e.getChildren();
      for (const l of o)
        r.push(() => n._walkAnyTreeNode(l));
      return r.waitForIdle();
    }
  }
  static forceLazyPromises(t) {
    return this.walk({}, t, Vt.None);
  }
  constructor(t, e) {
    this._visitor = new u_(t, e);
  }
  _walkAnyTreeNode(t) {
    let e;
    return t instanceof _e ? e = this._walkProductOccurrence(t) : t instanceof Mn ? e = this._walkPmi(t) : t instanceof ls ? e = this._walkCadView(t) : e = this._walkAnyBody(t), e === void 0 ? Promise.resolve() : e;
  }
  _walkRepresentationItem(t) {
    this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    const e = new Sc(1, !1);
    if (this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const i = t.getRawPartDefinition();
      i !== null && (i instanceof Wn ? e.push(() => {
        if (i.isResolved())
          return this._walkPartDefinition(i.getResolved());
      }) : e.push(() => i.then((h) => {
        if (h !== null) {
          const u = h.value;
          if (u.isResolved())
            return this._walkPartDefinition(u.getResolved());
        }
        return Promise.resolve();
      })));
      const n = t.tryGetChildrenSync();
      if (n !== null)
        for (const h of n)
          e.push(() => this._walkProductOccurrence(h));
      else
        e.push(() => t.getChildren().then((h) => {
          if (h.length === 0)
            return;
          const u = new Sc(1, !1);
          for (const f of h)
            u.push(() => this._walkProductOccurrence(f));
          if (!u.isIdle())
            return u.waitForIdle();
        }));
      const r = t.getBodyInstances();
      for (const h of r)
        e.push(() => this._walkAnyBody(h));
      const o = t.getPmis();
      for (const h of o)
        e.push(() => this._walkPmi(h));
      const l = t.getCadViews();
      for (const h of l)
        e.push(() => this._walkCadView(h));
      e.push(() => this._visitor.leaveProductOccurrence(t));
    }
    if (!e.isIdle())
      return e.waitForIdle();
  }
}
function m_(s) {
  const t = s.getPrototype();
  if (t === null)
    return;
  let e;
  const i = t.getProductOccurrence();
  return i.isResolved() ? e = Cf(i.getResolved()) : e = i.then(Cf), e.then(() => {
    console.assert(i.isResolved()), i.getResolved().markLoaded();
  });
}
async function Cf(s) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const n = m_(i);
      n !== void 0 && t.push(n);
    }
  };
  return await Ln.walk(e, s, Vt.None), We(t);
}
function Op(s) {
  s.markLoaded();
  const t = s.getRepresentationItems();
  for (const e of t)
    e.markLoaded();
}
function Rp(s) {
  const t = s.getRawPartDefinition();
  if (t !== null)
    return t instanceof Wn ? t.isResolved() ? void 0 : t.then(Op) : t.then((e) => {
      if (e === null)
        return;
      const i = e.value;
      if (!i.isResolved())
        return i.then(Op);
    });
}
function Zc(s) {
  const t = m_(s);
  return t !== void 0 ? t.then(() => Rp(s)) : Rp(s);
}
async function D0(s) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const n = Zc(i);
      n !== void 0 && t.push(n);
    }
  };
  return await Ln.walk(e, s, Vt.None), We(t);
}
class cg {
  constructor(t) {
    this._referrers = null, this._prototype = t;
  }
  _addReferrer(t) {
    this._referrers = Qn(this._referrers, t);
  }
  _getReferrers() {
    return hi(this._referrers);
  }
  _getPrototype() {
    return this._prototype;
  }
  _removeReferrer(t) {
    let e = !1, i = hi(this._referrers);
    return i = i.filter((n) => n === t ? (e = !0, !1) : !0), e ? (i.length === 0 ? this._referrers = null : this._referrers = bs(i), !0) : !1;
  }
  async _purgeContents() {
    this._prototype.isUnforced() || await (await this._prototype).purgeContents();
  }
  _isLoaded() {
    return this._prototype.isResolved() && this._prototype.getResolved().isLoaded();
  }
}
class rl {
  constructor(t, e) {
    t instanceof cg && (t = Oo.create(t)), this._shared = t, this._inclusionContext = e;
  }
  getInclusionContext() {
    return this._inclusionContext;
  }
  addReferrer(t) {
    this._shared.get()._addReferrer(t);
  }
  getReferrers() {
    return this._shared.get()._getReferrers();
  }
  getProductOccurrence() {
    return this._shared.get()._getPrototype();
  }
  removeReferrer(t) {
    if (this._shared.get()._removeReferrer(t)) {
      const e = t.removePrototype();
      return console.assert(this === e), !0;
    }
    return !1;
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t)
      this.removeReferrer(e) || console.assert(!1);
  }
  purgeContents() {
    return this._shared.get()._purgeContents();
  }
  isLoaded() {
    return this._shared.get()._isLoaded();
  }
}
function Qc(s) {
  return "modelName" in s;
}
function N0(s) {
  return !Qc(s);
}
function __(s) {
  return s.config.implicitlyLoadXmlExternalModels || N0(s);
}
class hg {
  static create(t) {
    return new hg(t);
  }
  constructor(t) {
    this.value = t;
  }
}
function ug(s) {
  if (s.length === 0)
    return;
  const t = s[0].getBranchVisibility();
  for (let e = 1, i = s.length; e < i; ++e)
    if (t !== s[e].getBranchVisibility())
      return ue.Mixed;
  return t;
}
function O0(s) {
  const t = s.getBodyInstances();
  if (t.length === 0)
    return;
  const e = t[0].isVisible();
  for (let i = 1, n = t.length; i < n; ++i)
    if (e !== t[i].isVisible())
      return ue.Mixed;
  return e ? ue.Shown : ue.Hidden;
}
function R0(s) {
  return ug(s.getChildrenSync());
}
function L0(s) {
  return ug(s.getPmis());
}
function F0(s) {
  return ug(s.getCadViews());
}
function B0(s) {
  const t = s.isVisible() ? ue.Shown : ue.Hidden, e = R0(s);
  if (e !== void 0 && e !== t)
    return ue.Mixed;
  const i = O0(s);
  if (i !== void 0 && i !== t)
    return ue.Mixed;
  const n = L0(s);
  if (n !== void 0 && n !== t)
    return ue.Mixed;
  const r = F0(s);
  return r !== void 0 && r !== t ? ue.Mixed : e === void 0 && i === void 0 && n === void 0 && r === void 0 ? null : t;
}
const V0 = -2;
function Ja(s, t) {
  const e = [];
  for (const i of s) {
    const n = t(i);
    n && e.push(n);
  }
  return We(e);
}
var Sf = /* @__PURE__ */ ((s) => (s[s.NodeTypeDrawingSheet = 6] = "NodeTypeDrawingSheet", s))(Sf || {}), ci = ((s) => (s[s.IsAConfigurationNode = pi.IsAConfigurationNode] = "IsAConfigurationNode", s[s.NodeTypeProduct = pi.NodeTypeProduct] = "NodeTypeProduct", s[s.NodeTypeGroup = pi.NodeTypeGroup] = "NodeTypeGroup", s[s.NodeTypeDrawingSheet = pi.NodeTypeDrawingSheet] = "NodeTypeDrawingSheet", s[s.NodeTypeDrawingView = pi.NodeTypeDrawingView] = "NodeTypeDrawingView", s[s.IsADefaultNodeType = pi.IsADefaultNodeType] = "IsADefaultNodeType", s[s.BranchVisibilityHidden = pi.BranchVisibilityHidden] = "BranchVisibilityHidden", s[s.BranchVisibilityShown = pi.BranchVisibilityShown] = "BranchVisibilityShown", s[s.BranchVisibilityDirty = pi.BranchVisibilityDirty] = "BranchVisibilityDirty", s[s.IsMissing = pi.IsMissing] = "IsMissing", s[s.OutOfHierarchy = pi.OutOfHierarchy] = "OutOfHierarchy", s[s.IsExternalModelRoot = pi.IsExternalModelRoot] = "IsExternalModelRoot", s))(ci || {});
class _e extends is {
  static parseXml(t, e, i, n, r) {
    const o = i.getInclusionKey(), l = Ho.parseXml(e, n, t), h = ui.parseFloat(n, "Unit"), u = [], f = [], g = [], y = [], _ = [], x = [];
    let b = null, I = null, C = null, M = n.firstElementChild;
    for (; M !== null; ) {
      if (M.localName === "PartDefinition") {
        b = as.parseXml(e, M, t);
        break;
      } else if (M.localName === "BodyInstance") {
        const P = ji.parseXml(
          e,
          M,
          o,
          t
        );
        u.push(P);
      } else if (M.localName === "Material")
        console.assert(I === null), I = rg.parseXml(M);
      else if (M.localName === "ExternalModel") {
        console.assert(C === null);
        const P = M.getAttribute("Name");
        if (P !== null) {
          const O = ui.parseFloat(M, "Unit"), B = ui.parseBounding(M, "BoundingBox"), j = 0, F = ui.parseUint(M, "CancelUnitScale") === 1, K = ui.parseUint(M, "AutoUnitScale");
          C = {
            config: t,
            modelName: P,
            bounding: B,
            measurementUnit: O,
            toAttachData: r,
            reservedNodeIdOffset: j,
            cancelUnitScale: F,
            autoUnitScale: K === null || K === 1
          };
        }
      } else if (M.localName === "CADView" && !t.ignoreCadViews) {
        const P = ls.parseXml(e, M, i, t);
        x.push(P);
      } else if (M.localName === "Filter" && !t.ignoreFilters)
        f.push(Jc.parseXml(M));
      else if (M.localName === "Layer" && !t.ignoreLayers) {
        const P = co.parseXml(M);
        P !== null && g.push(P);
      } else if (M.localName === "Relationships" && !t.ignoreBimRelationships) {
        const P = Sa.parseXml(M);
        if (P !== null && y.push(P), P.related !== null)
          for (const O of P.related.relationships)
            ga.findBimObjectInArray(_, O) === !1 && _.push(O);
        P.relating !== null && ga.findBimObjectInArray(
          _,
          P.relating.relationElt
        ) === !1 && _.push(P.relating.relationElt);
      }
      M = M.nextElementSibling;
    }
    return {
      nodeInfo: l,
      productBits: 0,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: b,
      quickAccessPartDefinitionDataId: null,
      externalModelInfo: C,
      bodyInstanceInfos: u,
      cadViewInfos: x,
      pmiInfos: [],
      measurementUnit: h,
      simpleMaterial: I,
      layerInfos: g,
      filters: f,
      relationships: y,
      bimInfos: _
    };
  }
  static parseBinary(t, e, i, n) {
    const r = Vi(i), o = r.getRemapper(), l = n.parseNodeParseBits();
    if (l.hasBits1(ti.VersionNumber) && n.parseAssemblyDataVersion(2), l.hasBits2(yr.GenericTypes)) {
      const F = n.parseGenericTypes();
      t.ignoreGenericTypes || r.setGenericTypeMaps(F);
    }
    const h = Ho.parseBinary(e, n, l, t);
    let u = 0;
    l.hasBits1(ti.ProductBits) && (u = n.parseProductBits());
    const f = [];
    if (l.hasBits1(ti.SubNodes)) {
      const F = n.parseCount_32();
      for (let K = 0; K < F; ++K) {
        const J = n.parseDataKey();
        f.push(J);
      }
    }
    let g = null, y = null;
    if (l.hasBits1(ti.Instance) && (g = n.parseDataKey(), l.hasBits1(ti.InstanceQuickAccess))) {
      const F = n.parseModelKey(o);
      console.assert(F !== Is.Local);
      const K = n.parseDataKey();
      y = [F, K];
    }
    const _ = [];
    if (l.hasBits1(ti.BodyInstances)) {
      const F = n.parseCount_32();
      for (let K = 0; K < F; ++K) {
        const J = ji.parseBinary(
          e,
          i,
          n,
          t
        );
        _.push(J);
      }
    }
    let x = null;
    if (l.hasBits1(ti.ExternalModel)) {
      const F = n.parseModelKey(o);
      console.assert(F !== Is.Local);
      const K = n.parseInclusionKey(o, F);
      x = {
        config: t,
        inclusionKey: K,
        modelKey: F
      };
    }
    let b = null;
    if (l.hasBits1(ti.PartDataLink)) {
      let F = n.parseModelKey(o);
      F === Is.Local && (F = r.getMasterModelKey());
      const K = n.parseDataKey();
      b = [F, K];
    }
    const I = [];
    if (l.hasBits1(ti.Views)) {
      const F = n.parseCount_32();
      for (let K = 0; K < F; ++K) {
        const J = ls.parseBinary(e, i, n, t);
        t.ignoreCadViews || I.push(J);
      }
    }
    const C = [];
    if (l.hasBits1(ti.Pmis)) {
      const F = n.parseCount_32();
      for (let K = 0; K < F; ++K) {
        const J = Mn.parseBinary(e, i, n, t);
        C.push(J);
      }
    }
    let M = null;
    if (l.hasBits1(ti.Unit) && (M = n.parseFloat_64()), l.hasBits1(ti.FrontUpVector)) {
      const F = n.parsePoint3_64(), K = n.parsePoint3_64();
      e.setViewAxes(F, K);
    }
    const P = [];
    if (l.hasBits1(ti.LayerList)) {
      const F = n.parseCount_32();
      for (let K = 0; K < F; ++K) {
        const J = co.parseBinary(n);
        t.ignoreLayers || P.push(J);
      }
    }
    const O = [];
    if (l.hasBits1(ti.Filters)) {
      const F = n.parseCount_32();
      for (let K = 0; K < F; ++K) {
        const J = Jc.parseBinary(n);
        t.ignoreFilters || O.push(J);
      }
    }
    const B = [], j = [];
    if (l.hasBits2(yr.Relationships)) {
      const F = n.parseCount_32();
      for (let K = 0; K < F; ++K) {
        const J = Sa.parseBinary(i, n);
        if (t.ignoreBimRelationships || B.push(J), J.relating !== null && !t.ignoreBimRelationships && (ga.findBimObjectInArray(j, J.relating.relationElt) === !1 && j.push(J.relating.relationElt), J.related !== null))
          for (const rt of J.related.relationships)
            ga.findBimObjectInArray(j, rt) === !1 && j.push(rt);
      }
    }
    return {
      nodeInfo: h,
      productBits: u,
      childDataKeys: f,
      prototypeDataKey: g,
      partDefinition: b,
      quickAccessPartDefinitionDataId: y,
      externalModelInfo: x,
      bodyInstanceInfos: _,
      cadViewInfos: I,
      pmiInfos: C,
      measurementUnit: M,
      simpleMaterial: null,
      layerInfos: P,
      filters: O,
      relationships: B,
      bimInfos: j
    };
  }
  /**
   * Like `reify` but with a synchronous return result.
   *
   * Usage requirements:
   *      - `info.childDataKeys` must be empty.
   *      - `info.externalModelInfo` must be `null`.
   */
  static reifySync(t, e, i, n, r, o) {
    console.assert(r.childDataKeys.length === 0), console.assert(r.externalModelInfo === null);
    const l = Vi(n), h = new _e(
      null,
      t,
      e,
      i,
      n,
      o,
      r
    );
    return l.attachedInvisibly() && h.setVisibility(!1), h;
  }
  static async reify(t, e, i, n, r, o) {
    const l = vi(), h = new _e(
      l,
      t,
      e,
      i,
      n,
      o,
      r
    );
    return await l, h;
  }
  static createDynamic(t, e, i, n, r, o, l = !1, h = null) {
    const u = qi(e), f = t.massageAuthoredUserId(u, n), g = o ? Hi.InitiallyShown : 0, y = {
      nodeId: f,
      bits: g,
      name: i,
      localTransform: r,
      attributes: [],
      header: Zs.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    }, _ = l ? ci.OutOfHierarchy : 0, x = {
      nodeInfo: y,
      productBits: _,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: null,
      quickAccessPartDefinitionDataId: null,
      bodyInstanceInfos: [],
      externalModelInfo: null,
      cadViewInfos: [],
      pmiInfos: [],
      measurementUnit: h,
      simpleMaterial: null,
      layerInfos: [],
      filters: [],
      relationships: [],
      bimInfos: []
    }, b = new Ma();
    return b.attachInvisibly = !o, new _e(
      null,
      b,
      null,
      t,
      u,
      e,
      x
    );
  }
  static createMissing(t, e) {
    const i = this.createDynamic(t, e, "Missing", null, null, !1);
    return i._bits |= ci.IsMissing, i;
  }
  isMissing() {
    return this._hasBits(ci.IsMissing);
  }
  static _amendInfo(t, e) {
    if (e.nodeInfo.name !== null)
      return e;
    let i = null;
    if (ne(e.productBits, ci.NodeTypeProduct) ? i = t.generateProductName() : ne(e.productBits, ci.NodeTypeGroup) ? i = t.generateGroupName() : ne(e.productBits, ci.NodeTypeDrawingSheet) ? i = t.generateDrawingSheetName() : ne(e.productBits, ci.NodeTypeDrawingView) && (i = t.generateDrawingViewName()), i === null)
      return e;
    const n = { ...e.nodeInfo, name: i };
    return { ...e, nodeInfo: n };
  }
  constructor(t, e, i, n, r, o, l) {
    l = _e._amendInfo(n, l);
    const h = Vi(r), u = h.getMasterModelKey(), f = Ys(h);
    super(n, u, l.nodeInfo), this._parent = o, this._bits |= l.productBits | ci.BranchVisibilityDirty;
    const g = l.nodeInfo.header, y = [];
    if (l.prototypeDataKey !== null && (console.assert(i !== null), this._prototypeContext = this._loadPrototypeContext(
      e,
      i,
      n,
      r,
      l.prototypeDataKey,
      g
    )), console.assert(l.quickAccessPartDefinitionDataId === null || l.partDefinition === null), l.partDefinition !== null ? Array.isArray(l.partDefinition) ? this._partDefinition = this._lazyLoadPartDefinitionById(
      n,
      r,
      l.partDefinition,
      g,
      e
    ) : this._partDefinition = this._lazyLoadPartDefinitionByInfo(
      n,
      r,
      l.partDefinition,
      u
    ) : l.quickAccessPartDefinitionDataId !== null && (this._partDefinition = this._lazyLoadPartDefinitionById(
      n,
      r,
      l.quickAccessPartDefinitionDataId,
      g,
      e
    )), l.childDataKeys.length > 0) {
      console.assert(i !== null);
      const x = (async () => {
        const b = await this._loadProductOccurrences(
          e,
          i,
          n,
          r,
          l.childDataKeys,
          g
        );
        this._children = bs(b);
      })();
      y.push(x);
    }
    if (l.bodyInstanceInfos.length > 0) {
      const x = this._loadBodyInstances(
        n,
        u,
        l.bodyInstanceInfos
      );
      this._bodyInstances = bs(x);
    }
    if (l.cadViewInfos.length > 0) {
      const x = this._loadCadViews(n, r, l.cadViewInfos);
      this._cadViews = bs(x);
    }
    if (l.pmiInfos.length > 0) {
      const x = this._loadPmis(n, r, l.pmiInfos);
      this._pmis = bs(x);
    }
    if (l.measurementUnit !== null && (this._measurementUnit = l.measurementUnit), l.externalModelInfo !== null)
      if (console.assert(t !== null), console.assert(i !== null), __(l.externalModelInfo)) {
        const x = this._loadAndAttachExternalModel(
          i,
          r,
          l.externalModelInfo
        );
        y.push(x);
      } else
        this._pendingExternalModels = Qn(this._pendingExternalModels, l.externalModelInfo);
    for (const x of l.layerInfos) {
      const b = f.getRuntimeLayerId(x.id);
      b === null ? n.createLayer(x.id, x.name, f) : x.name !== null && n.updateLayerName(b, x.name);
    }
    for (const x of l.filters)
      n.addFilter(x, f);
    for (const x of l.relationships)
      r.addRelationship(x);
    for (const x of l.bimInfos)
      r.addBimInfos(x);
    const _ = this.getAuthoredLayerId();
    if (_ !== null && (n.registerNodeInLayer(this, _), this.isOutOfHierarchy() || n.registerTreeNodeInLayer(this, _)), n.registerProductOccurrence(this), t === null) {
      if (y.length > 0)
        throw new oi();
    } else
      t.resolve(We(y));
  }
  async _loadExternalModel(t, e, i) {
    if (Qc(i))
      return t.attachByExternalModelInfo(i, this, e);
    const n = this.getAuthoredId();
    return Ys(e).handleExternalModel(n, e, i.inclusionKey) ? t.attachByExternalModelInfo(i, this, e) : null;
  }
  async _loadAndAttachExternalModel(t, e, i) {
    const n = await this._loadExternalModel(
      t,
      e,
      i
    );
    return n !== null && this.addAttachContext(n), n;
  }
  async loadPendingExternalModels(t) {
    if (!this.hasPendingExternalModels())
      return [];
    const e = qi(this), i = [];
    for (const r of hi(this._pendingExternalModels)) {
      const o = this._loadAndAttachExternalModel(t, e, r);
      i.push(o);
    }
    delete this._pendingExternalModels;
    const n = [];
    for (const r of await Promise.all(i))
      r !== null && n.push(r);
    return n;
  }
  _lazyLoadPartDefinitionByInfo(t, e, i, n) {
    const r = n, o = as.reify(t, e, r, i);
    return Wn.create(o);
  }
  _lazyLoadPartDefinitionById(t, e, i, n, r) {
    const o = t.getAbstractScEngine(), l = Ys(e);
    let h = t.lookupPartDefinitionByDataId(
      l,
      i[0],
      i[1]
    );
    return h !== null ? Wn.create(async () => {
      const u = await h;
      return u.addReferrer(this), u;
    }) : (h = Wn.create(async () => {
      const u = i[0], f = i[1], g = await t.enqueue(() => o.safeGetMetaData(u, f));
      if (g !== null) {
        const y = new ya(n, g), _ = new th(y), x = as.parseBinary(t, _, r), b = as.reify(t, e, u, x);
        return b.addReferrer(this), b;
      }
      return as.createMissing(t);
    }), t.registerPartDefinitionByDataId(
      l,
      i[0],
      i[1],
      h
    ), h);
  }
  static async _loadProductOccurrence(t, e, i, n, r, o) {
    const l = new th(r), h = _e.parseBinary(t, i, n, l);
    return _e.reify(
      t,
      e,
      i,
      n,
      h,
      o
    );
  }
  _loadPrototypeContext(t, e, i, n, r, o) {
    const l = Vi(n), h = Ys(l), f = l.getMasterModelKey(), g = {
      prototypeContext: null,
      sharedPrototypeContext: i.lookupPrototypeByDataId(
        h,
        f,
        r
      )
    };
    if (g.sharedPrototypeContext === null) {
      const y = Wn.create(async () => {
        const _ = i.getAbstractScEngine(), x = await i.enqueue(() => _.safeGetMetaData(f, r));
        if (x !== null) {
          const b = new ya(o, x);
          return _e._loadProductOccurrence(
            t,
            e,
            i,
            n,
            b,
            g.prototypeContext
          );
        }
        return _e.createMissing(i, g.prototypeContext);
      });
      g.sharedPrototypeContext = new cg(y), i.registerPrototypeByDataId(
        h,
        f,
        r,
        g.sharedPrototypeContext
      );
    }
    return g.prototypeContext = new rl(g.sharedPrototypeContext, n), g.prototypeContext.addReferrer(this), g.prototypeContext;
  }
  async _loadProductOccurrences(t, e, i, n, r, o) {
    const u = Vi(n).getMasterModelKey(), f = i.getAbstractScEngine(), g = await i.enqueue(() => f.safeGetMetaDatas(u, r)), y = [];
    for (let _ = 0; _ < r.length; ++_) {
      let x;
      if (g !== null) {
        const b = g[_];
        g[_] = new Uint8Array(0);
        const I = new ya(o, b);
        x = await _e._loadProductOccurrence(
          t,
          e,
          i,
          n,
          I,
          this
        );
        const C = e.onLoadChildProductOccurrence();
        C && await C;
      } else
        x = _e.createMissing(i, this);
      y.push(x);
    }
    return y;
  }
  _loadBodyInstances(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = ji.reify(t, e, this, r);
      n.push(o);
    }
    return n;
  }
  _loadCadViews(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = ls.reify(t, e, r, this);
      n.push(o), o.markLoaded();
    }
    return n;
  }
  _loadPmis(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = Mn.reify(t, e, r, this);
      n.push(o);
    }
    return n;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return qo(this._nodeId, this);
  }
  isAbsoluteRoot() {
    return this._nodeId === V0;
  }
  getPrototype() {
    return this._prototypeContext !== void 0 ? this._prototypeContext : null;
  }
  isAConfigurationNode() {
    return this._hasBits(ci.IsAConfigurationNode);
  }
  isADefaultNode() {
    return this._hasBits(ci.IsADefaultNodeType);
  }
  isAProductNode() {
    return ne(this._bits, ci.NodeTypeProduct);
  }
  isAGroupNode() {
    return ne(this._bits, ci.NodeTypeGroup);
  }
  isADrawingSheetNode() {
    return ne(this._bits, ci.NodeTypeDrawingSheet);
  }
  isADrawingViewNode() {
    return ne(this._bits, ci.NodeTypeDrawingView);
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._children = Qn(this._children, t), this._itemWasAdded();
  }
  addBodyInstance(t) {
    console.assert(t.getParent() === this), this._bodyInstances = Qn(this._bodyInstances, t), this._itemWasAdded();
  }
  addCadView(t) {
    console.assert(t.getParent() === this), this._cadViews = Qn(this._cadViews, t), this._itemWasAdded();
  }
  addPmi(t) {
    console.assert(t.getParent() === this), this._pmis = Qn(this._pmis, t), this._itemWasAdded();
  }
  addLoadContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Qn(this._childContexts, t), this._itemWasAdded();
  }
  addAttachContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Qn(this._childContexts, t), this._itemWasAdded();
  }
  _followPrototypesWhileEmpty() {
    if (this._prototypeContext === void 0 || this._children !== void 0 || this._childContexts !== void 0)
      return this;
    const t = this._prototypeContext.getProductOccurrence();
    return t.isResolved() ? t.getResolved()._followPrototypesWhileEmpty() : this;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  getRawPartDefinition() {
    if (this._partDefinition !== void 0)
      return this._partDefinition;
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      return t.isResolved() ? t.getResolved().getRawPartDefinition() : null;
    }
    return null;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  async getPartDefinition() {
    const t = this.getRawPartDefinition();
    return t instanceof Wn ? hg.create(t) : t instanceof Promise ? t : null;
  }
  getPartDefinitionSync() {
    if (console.assert(this.isLoaded()), this._partDefinition !== void 0 && this._partDefinition.isResolved())
      return this._partDefinition.getResolved();
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      if (t.isResolved())
        return t.getResolved().getPartDefinitionSync();
    }
    return null;
  }
  getChildContexts() {
    return hi(this._childContexts);
  }
  _getChildren() {
    const t = hi(this._children), e = hi(this._childContexts);
    for (const i of e)
      t.push(...i.getChildren());
    return t;
  }
  async getChildren() {
    return (await this._followPrototypesWhileEmpty())._getChildren();
  }
  getChildrenSync() {
    console.assert(this.isLoaded());
    const t = this.tryGetChildrenSync();
    if (t === null)
      throw new oi();
    return t;
  }
  tryGetChildrenSync() {
    const t = this._followPrototypesWhileEmpty();
    return t instanceof Promise ? null : t._getChildren();
  }
  async forEachChild(t) {
    const e = await this.getChildren();
    return Ja(e, t);
  }
  forEachBodyInstance(t) {
    const e = this.getBodyInstances();
    return Ja(e, t);
  }
  forEachPmi(t) {
    const e = this.getPmis();
    return Ja(e, t);
  }
  forEachCadView(t) {
    const e = this.getCadViews();
    return Ja(e, t);
  }
  hasBodyInstances() {
    return this._bodyInstances !== void 0;
  }
  getBodyInstances() {
    return hi(this._bodyInstances);
  }
  getCadViews() {
    return hi(this._cadViews);
  }
  getPmis() {
    return hi(this._pmis);
  }
  setMeasurementUnit(t) {
    this._measurementUnit = t;
  }
  unsetMeasurementUnit() {
    this._measurementUnit = void 0;
  }
  hasMeasurementUnit() {
    return this._measurementUnit !== void 0;
  }
  getMeasurementUnit() {
    let t = this;
    do {
      if (t._measurementUnit !== void 0)
        return t._measurementUnit;
      t = mr(t._parent);
    } while (t !== null);
    return 1;
  }
  async getPhysicalProperties(t) {
    const e = async () => {
      if (Array.isArray(this._children)) {
        const y = [];
        for (const M of this._children)
          await Zc(M), y.push(await M.getPhysicalProperties(t));
        if (!y.some((M) => M !== null))
          return null;
        let _ = 0, x = 0;
        const b = m.zero();
        let I = 0;
        if (y.forEach((M) => {
          M !== null && (I += 1, _ += M.volume, x += M.surfaceArea, b.add(M.centerOfGravity));
        }), I === 0)
          return null;
        const C = m.scale(b, 1 / I);
        return Promise.resolve(new _a(x, _, C));
      }
      return this._children instanceof _e ? (await Zc(this._children), this._children.getPhysicalProperties(t)) : null;
    }, i = await this.getPartDefinition();
    if (i === null)
      return t ? e() : null;
    const r = (await i.value).getRepresentationItems();
    if (r.length === 0)
      return t ? e() : null;
    let o = 0, l = 0;
    const h = m.zero();
    let u = 0;
    for (const y of r) {
      const _ = y.getPhysicalProperties();
      _ !== null && (o += _.volume, l += _.surfaceArea, h.add(_.centerOfGravity), u++);
    }
    u !== 0 && h.scale(1 / u);
    const f = new _a(l, o, h), g = await e();
    return g !== null ? new _a(
      f.surfaceArea + g.surfaceArea,
      f.volume + g.volume,
      m.add(f.centerOfGravity, g.centerOfGravity).scale(0.5)
    ) : f;
  }
  setPartDefinition(t) {
    console.assert(this._partDefinition === void 0), this._partDefinition = Wn.create(t);
  }
  setPrototype(t) {
    console.assert(this._prototypeContext === void 0), this._prototypeContext = t, this._markBranchVisibilityDirty(!1);
  }
  removePrototype() {
    if (this._prototypeContext === void 0)
      throw new oi();
    const t = this._prototypeContext;
    return delete this._prototypeContext, this._markBranchVisibilityDirty(!1), t;
  }
  getBranchVisibility() {
    return this._updateBranchVisibility(), this._getBranchVisibility();
  }
  _getBranchVisibility() {
    let t = this.isVisible() ? ue.Shown : ue.Hidden;
    return this._hasBits(ci.BranchVisibilityShown) && t !== ue.Shown && (t = ue.Mixed), this._hasBits(ci.BranchVisibilityHidden) && t !== ue.Hidden && (t = ue.Mixed), t;
  }
  _setBranchVisibility(t) {
    const e = this.isVisible();
    console.assert(e ? t !== ue.Hidden : t === ue.Hidden), this._bits &= ~(ci.BranchVisibilityHidden | ci.BranchVisibilityShown), (t === ue.Hidden || t === ue.Mixed) && (this._bits |= ci.BranchVisibilityHidden), (ne(t, ue.Shown) || t === ue.Mixed) && (this._bits |= ci.BranchVisibilityShown);
  }
  _updateBranchVisibility() {
    if (!this._hasBits(ci.BranchVisibilityDirty))
      return;
    let t = this.isVisible() ? ue.Shown : ue.Hidden;
    const e = this._getSubBranchVisibilities();
    e !== null && e !== t && (t = ue.Mixed), this._setBranchVisibility(t), this._bits &= ~ci.BranchVisibilityDirty;
  }
  _getSubBranchVisibilities() {
    return B0(this);
  }
  _itemWasAdded() {
    this._getBranchVisibility() !== ue.Mixed && this._markBranchVisibilityDirty(!0);
  }
  _onItemRemoved() {
    this._getBranchVisibility() !== ue.Hidden && this._markBranchVisibilityDirty(!1);
  }
  markBranchVisibilityDirty() {
    this._markBranchVisibilityDirty(!1);
  }
  _markBranchVisibilityDirty(t) {
    if (!this._hasBits(ci.BranchVisibilityDirty) && !(t && this._getBranchVisibility() === ue.Mixed))
      if (this._bits |= ci.BranchVisibilityDirty, this._parent instanceof rl) {
        const e = this._parent.getReferrers();
        for (const i of e)
          i._markBranchVisibilityDirty(t);
      } else {
        const e = mr(this._parent);
        if (e !== null)
          return e._markBranchVisibilityDirty(t);
      }
  }
  setVisibility(t) {
    this.isVisible() !== t && (this._setVisibility(t), this._markBranchVisibilityDirty(!1));
  }
  _removeDirectChild(t) {
    let e = hi(this._children);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === i ? !1 : (e.length === 0 ? delete this._children : this._children = bs(e), this._onItemRemoved(), !0);
  }
  _removeIndirectChild(t) {
    let e = !1, i = hi(this._childContexts);
    for (const n of i)
      if (n.removeProductOccurrence(t)) {
        e = !0;
        break;
      }
    return e ? (i = i.filter((n) => n.hasChildren()), i.length === 0 ? delete this._childContexts : this._childContexts = bs(i), this._onItemRemoved(), !0) : !1;
  }
  removeProductOccurrence(t) {
    return this._removeDirectChild(t) ? !0 : this._removeIndirectChild(t);
  }
  removePmi(t) {
    let e = hi(this._pmis);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === i ? !1 : (e.length === 0 ? delete this._pmis : this._pmis = bs(e), this._onItemRemoved(), !0);
  }
  removeBodyInstance(t) {
    let e = hi(this._bodyInstances);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === i ? !1 : (e.length === 0 ? delete this._bodyInstances : this._bodyInstances = bs(e), this._onItemRemoved(), !0);
  }
  purgeContents() {
    this._markBranchVisibilityDirty(!1);
    const t = [];
    let e;
    this._partDefinition !== void 0 && (this._partDefinition.isUnforced() || (e = this._partDefinition.then((r) => {
      r.removeAllReferrers(), delete this._partDefinition;
    }), t.push(e))), this._prototypeContext !== void 0 && (e = this._prototypeContext.purgeContents(), t.push(e), this._prototypeContext.removeReferrer(this), delete this._prototypeContext);
    const i = hi(this._children);
    e = Ja(i, (r) => r.purgeContents()), t.push(e), delete this._children;
    const n = hi(this._childContexts);
    return e = Ja(n, (r) => r.purgeContents()), t.push(e), delete this._childContexts, delete this._bodyInstances, delete this._cadViews, delete this._pmis, delete this._measurementUnit, We(t);
  }
  removePartDefinition() {
    if (this._partDefinition === void 0 || !this._partDefinition.isResolved())
      throw new oi();
    const t = this._partDefinition;
    return delete this._partDefinition, t.getResolved();
  }
  isOutOfHierarchy() {
    return this._hasBits(ci.OutOfHierarchy);
  }
  markIsExternalModelRoot(t) {
    console.assert(!this._hasBits(ci.IsExternalModelRoot)), this._bits |= ci.IsExternalModelRoot, t.markSeenExternalModel();
  }
  isExternalModelRoot() {
    return this._hasBits(ci.IsExternalModelRoot);
  }
  addPendingExternalModel(t) {
    this._pendingExternalModels = Qn(this._pendingExternalModels, t);
  }
  hasPendingExternalModels() {
    return !Yv(this._pendingExternalModels);
  }
}
class y_ {
  constructor() {
    this._leftToRight = /* @__PURE__ */ new Map(), this._rightToLeft = /* @__PURE__ */ new Map();
  }
  set(t, e) {
    this._leftToRight.set(t, e), this._rightToLeft.set(e, t);
  }
  getLeft(t) {
    return this._rightToLeft.get(t);
  }
  getRight(t) {
    return this._leftToRight.get(t);
  }
}
class w_ {
  constructor() {
    this._bits1 = 0, this._bits2 = 0;
  }
  hasBits1(t) {
    return ne(this._bits1, t);
  }
  hasBits2(t) {
    return ne(this._bits2, t);
  }
  parseBits1(t) {
    this._bits1 = t.parseIndex_32();
  }
  parseBits2(t) {
    this.hasBits1(ti.UseNodeParseBits2) && (this._bits2 = t.parseIndex_32());
  }
}
class z0 {
  constructor(t, e) {
    this.shown = t, this.removed = e;
  }
}
class th {
  constructor(t) {
    this._bytes = t.bytes, this._header = t.header, this._dataView = new DataView(
      this._bytes.buffer,
      this._bytes.byteOffset,
      this._bytes.byteLength
    ), this._currentPos = 0;
  }
  hasNext() {
    return this._currentPos < this._bytes.length;
  }
  parseCount_32() {
    return this._parseUint_32();
  }
  parseIndex_32() {
    return this._parseUint_32();
  }
  parseAssemblyDataVersion(t) {
    const e = [];
    for (let i = 0; i < t; ++i)
      e.push(this._parseUint_32());
    return e;
  }
  parseAssemblyDataHeaderVersion() {
    return this._parseUint_32();
  }
  parseVisibility() {
    let t;
    ((r) => {
      r[r.Removed = 1] = "Removed", r[r.Shown = 2] = "Shown";
    })(t || (t = {}));
    const e = this._parseInt_8(), i = ne(
      e,
      2
      /* Shown */
    ), n = ne(
      e,
      1
      /* Removed */
    );
    return new z0(i, n);
  }
  parseProductBits() {
    let t = this._parseUint_8();
    return this._header !== null && this._header.headerVersion >= 2 || !ne(t, Sf.NodeTypeDrawingSheet) || (t &= ~Sf.NodeTypeDrawingSheet, t |= ci.NodeTypeDrawingSheet), t;
  }
  parseUnits() {
    const t = this.parseInt32(), e = [];
    for (let i = 0; i < t; i++) {
      const n = this.parseUInt32(), r = this.parseInt32(), o = this.parseFloat_64();
      e.push({
        basicUnit: n,
        exponent: r,
        factor: o
      });
    }
    return e;
  }
  parseCString() {
    const t = this._currentPos;
    let e = this._bytes[this._currentPos++];
    for (; e !== 0; )
      e = this._bytes[this._currentPos++];
    return $v(this._bytes.subarray(t, this._currentPos - 1));
  }
  parseUInt32() {
    return this._parseUint_32();
  }
  parseInt32() {
    return this._parseInt_32();
  }
  parseBytes(t) {
    const e = this._currentPos;
    this._currentPos += t;
    const i = this._bytes.subarray(e, this._currentPos);
    return new Uint8Array(i);
  }
  parseNodeId() {
    const t = this._parseUint_32();
    return console.assert(t !== Ts), t;
  }
  parseLayerId() {
    const t = this._parseUint_32();
    return console.assert(t !== Ts), t;
  }
  parseGenericTypes() {
    const t = this._parseUint_32(), e = new y_();
    for (let i = 0; i < t; i++) {
      const n = this.parseCString(), r = this._parseUint_32();
      e.set(r, n);
    }
    return e;
  }
  parseGenericTypeId() {
    return this._parseUint_32();
  }
  parseGenericId() {
    return this.parseCString();
  }
  parseModifiers() {
    return this._parseUint_32();
  }
  _parseScKey() {
    const t = this._parseUint_32();
    return console.assert(t !== tg.Invalid), t;
  }
  parseDataKey() {
    return this._parseScKey();
  }
  parseInstanceKey() {
    return this._parseScKey();
  }
  parseMeshKey() {
    return this._parseScKey();
  }
  parseModelKey(t) {
    const e = this._parseScKey();
    return t !== null ? t.getEffectiveModelKey(e) : e;
  }
  parseInclusionKey(t, e) {
    const i = this._parseScKey();
    return t !== null ? t.getEffectiveInclusionKey(i, e) : i;
  }
  parseMatrix() {
    const t = this._header !== null && this._header.doublePrecisionMatrices ? () => this.parseFloat_64() : () => this.parseFloat_32(), e = Gn.getIdentity();
    for (let i = 0; i < 4; ++i)
      for (let n = 0; n < 3; ++n)
        e[4 * i + n] = t();
    return e;
  }
  _parseInt_8() {
    return this._dataView.getInt8(this._currentPos++);
  }
  _parseUint_8() {
    return this._dataView.getUint8(this._currentPos++);
  }
  _parseUint_32() {
    const t = this._dataView.getUint32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseInt_32() {
    const t = this._dataView.getInt32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_32() {
    const t = this._dataView.getFloat32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_64() {
    const t = this._dataView.getFloat64(this._currentPos, !0);
    return this._currentPos += 8, t;
  }
  parseFloat_32() {
    return this._parseFloat_32();
  }
  parseFloat_64() {
    return this._parseFloat_64();
  }
  parseAttributeType() {
    return this._parseInt_8();
  }
  parseNodeParseBits() {
    const t = new w_();
    return t.parseBits1(this), t.parseBits2(this), t;
  }
  parseViewParseBits() {
    return this._parseUint_32();
  }
  parsePmiParseBits() {
    return this._parseUint_32();
  }
  parseLayerParseBits() {
    return this._parseUint_32();
  }
  parseAttributeParseBits() {
    return this._parseUint_32();
  }
  parseRelationshipParseBits() {
    return this._parseUint_32();
  }
  parseBoolean() {
    return this._parseUint_8() !== 0;
  }
  parsePoint3_32() {
    return new m(this._parseFloat_32(), this._parseFloat_32(), this._parseFloat_32());
  }
  parsePoint3_64() {
    return new m(this._parseFloat_64(), this._parseFloat_64(), this._parseFloat_64());
  }
  parsePlane3_32() {
    return ln.createFromCoefficients(
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32()
    );
  }
  parsePmiType() {
    return this._parseUint_32();
  }
  parsePmiSubType() {
    return this._parseUint_32();
  }
  parsePmiTopoRef() {
    return this._parseInt_8();
  }
  parseBodyType() {
    return this._parseUint_8();
  }
  parseFaceType() {
    return this._parseInt_8();
  }
  parseEdgeType() {
    return this._parseInt_8();
  }
  parseUserDataIndex() {
    const t = this._parseUint_32(), e = this._parseUint_32();
    return e <= 2097151 ? 4294967296 * e + t : `${e.toString(16)}${Xv(t)}`.toUpperCase();
  }
  getHeader() {
    return this._header;
  }
}
function H0(s, t) {
  const e = (n) => {
    t.push(n);
  }, i = {
    enterProductOccurrence: e,
    enterAnyBody: e,
    enterCadView: e,
    enterPmi: e,
    enterPartDefinition: e,
    enterRepresentationItem: e
  };
  return Ln.walk(i, s, Vt.None);
}
async function pa(s) {
  const t = [], e = [];
  for (const i of s) {
    const n = H0(i, e);
    t.push(n);
  }
  await We(t);
  for (const i of e)
    i.markLoaded();
}
class U0 {
  constructor(t, e) {
    this.value = t, this.kids = e.slice();
  }
}
const dg = [25, 4, 0];
class aa {
  constructor(t) {
    this.referencedInfo = t;
  }
}
function ef(s) {
  return s instanceof aa ? s.referencedInfo : s;
}
function j0(s, t) {
  let e = s.nodeInfo.localTransform;
  return e === null ? e = t : e = Gn.multiply(e, t), {
    ...s,
    nodeInfo: {
      ...s.nodeInfo,
      localTransform: e
    }
  };
}
class nf {
  /**
   * This is used to parse `ModelFileInfo` without adding it to the tree.
   */
  static parseXml(t, e, i, n, r) {
    console.assert(n.localName === "ModelFile");
    const o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), u = (_) => {
      let x = _e.parseXml(
        t,
        e,
        i,
        _,
        r
      );
      const b = x.nodeInfo.nodeId;
      if (h.has(x.nodeInfo.nodeId)) {
        const P = new aa(x);
        o.set(b, P);
      } else
        l.has(x.nodeInfo.nodeId) || (l.set(x.nodeInfo.nodeId, null), t.additionalMatrix !== null && (x = j0(x, t.additionalMatrix.m))), o.set(b, x);
      const C = ui.parseNodeIds(_, "Children") ?? [];
      for (const P of C)
        l.set(P, x);
      const M = ui.parseNodeId(_, "InstanceRef");
      if (M !== null) {
        const P = h.get(M);
        P === void 0 ? h.set(M, [x]) : P.push(x);
      }
    };
    let f = n.firstElementChild;
    for (; f !== null; ) {
      if (f.localName !== "ProductOccurence")
        throw new si(`Unexpected element "${f.localName}".`);
      if (ui.parseNodeId(f, "Id") === null)
        throw new si('Expected "Id" attribute.');
      u(f), f = f.nextElementSibling;
    }
    const g = this._parentMapToChildMap(o, l, h);
    return {
      treeInfos: this._childMapRoseTrees(g)
    };
  }
  static _parentMapToChildMap(t, e, i) {
    const n = /* @__PURE__ */ new Map(), r = (o, l) => {
      const h = n.get(o);
      h === void 0 ? n.set(o, [l]) : h.push(l);
    };
    return e.forEach((o, l) => {
      const h = t.get(l);
      if (h instanceof aa)
        throw new si('Expected a referenced node for "InstanceRef".');
      r(o, h);
    }), i.forEach((o, l) => {
      console.assert(o.length > 0);
      const h = t.get(l);
      if (!(h instanceof aa))
        throw new si(
          `Node is both an "InstanceRef" and contained in another node's "Children" list.`
        );
      for (const u of o)
        r(u, h);
    }), n;
  }
  static _childMapRoseTrees(t) {
    const e = (r) => {
      const o = [], l = ef(r), h = t.get(l);
      if (h !== void 0) {
        console.assert(h.length > 0);
        for (const u of h) {
          const f = e(u);
          o.push(f);
        }
      }
      return new U0(r, o);
    }, i = t.get(null);
    if (i === void 0)
      return console.assert(t.size === 0), [];
    const n = [];
    for (const r of i) {
      if (r instanceof aa) {
        console.assert(!1);
        continue;
      }
      const o = e(r);
      n.push(o);
    }
    return n;
  }
  /**
   * Inserts `ModelFileInfo` into the assembly tree.
   */
  static async reify(t, e, i, n, r, o) {
    const l = [], h = [], u = [];
    for (const g of o.treeInfos) {
      if (g.value instanceof aa) {
        console.assert(!1);
        continue;
      }
      const y = this._reifyProductOccurrence(
        t,
        e,
        i,
        n,
        r,
        r,
        g,
        l
      );
      h.push(y), u.push(y.getRuntimeId());
    }
    const f = e.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      u,
      uo.LoadModel
    );
    return l.push(f), await We(l), h;
  }
  static _rectifyExternalModelInfo(t, e) {
    let i = {
      ...e.referencedInfo.externalModelInfo,
      reservedNodeIdOffset: 0
    };
    if (i === null)
      throw new si('"InstanceRef" node does not contain "ExternalModel".');
    if (!Qc(i))
      throw new oi();
    console.assert(i.reservedNodeIdOffset === 0);
    const n = t.newNodeIdOffset();
    return i = {
      ...i,
      reservedNodeIdOffset: n
    }, i;
  }
  static _reifyProductOccurrence(t, e, i, n, r, o, l, h) {
    const u = ef(l.value);
    if (u.childDataKeys.length !== 0)
      throw new oi();
    if (u.externalModelInfo !== null)
      throw new Kr('Unexpected "ExternalModel". Should be a child of an "InstanceRef".');
    const f = _e.reifySync(
      t,
      i,
      n,
      r,
      u,
      o
    );
    o.addProductOccurrence(f), f.markLoaded();
    for (const g of l.kids)
      if (g.value instanceof aa) {
        console.assert(g.kids.length === 0);
        const y = this._rectifyExternalModelInfo(n, g.value);
        if (__(y)) {
          const _ = i.attachByExternalModelInfo(y, f, r).then(async (x) => {
            if (x === null)
              return;
            await pa([x]), f.addAttachContext(x);
            const b = x.getChildren().map((I) => I.getRuntimeId());
            await e.promiseTrigger(
              "_subtreeLoaded",
              "subtreeLoaded",
              b,
              uo.LoadModel
            );
          });
          h.push(_);
        } else
          f.addPendingExternalModel(y);
      } else
        console.assert(g.value.externalModelInfo === null), this._reifyProductOccurrence(
          t,
          e,
          i,
          n,
          r,
          f,
          g,
          h
        );
    return f;
  }
  static _parseBounding(t, e) {
    const i = ef(t.value);
    let n = Ds;
    i.measurementUnit !== null && (n = i.measurementUnit);
    let r = 1;
    n === Ds ? n = e : e !== Ds && (r = n / e);
    let o = new wt().setScaleComponent(r, r, r);
    const l = i.nodeInfo.localTransform;
    if (l !== null) {
      const f = wt.createFromArray(l);
      o = wt.multiply(f, o);
    }
    const h = wn.invalid();
    for (const f of t.kids) {
      let g = this._parseBounding(f, n);
      g = o.transformBox(g), h.addBox(g);
    }
    const u = i.externalModelInfo;
    if (u !== null) {
      if (!Qc(u))
        throw new oi();
      let f = u.bounding;
      if (f !== null && !f.isDegenerate()) {
        const g = u.measurementUnit || Ds;
        if (e !== Ds && g !== Ds) {
          const y = g / n, _ = new wt().setScaleComponent(
            y,
            y,
            y
          );
          o = wt.multiply(_, o);
        }
        f = o.transformBox(f), h.addBox(f);
      }
    }
    return h;
  }
  static parseBounding(t, e) {
    const i = wn.invalid();
    for (const n of t.treeInfos)
      for (const r of n.kids) {
        const o = this._parseBounding(r, e);
        i.addBox(o);
      }
    return i;
  }
  constructor() {
  }
}
const Eo = class Eo {
  constructor(t, e, i, n, r, o, l, h) {
    this.headerVersion = t, this._rootAssemblyDataKey = e, this.isDrawing = i, this.isMeasurable = n, this.originalFileName = r, this.originalFileType = o, this.doublePrecisionMatrices = l, this.assemblyDataVersion = h;
  }
  supportsAttributeBits() {
    return this.headerVersion >= 5;
  }
  rootAssemblyDataKey() {
    return console.assert(this._rootAssemblyDataKey !== Lu.Invalid), this._rootAssemblyDataKey;
  }
  // double precision matrices
  static parseBinary(t) {
    if (t.length === 0)
      return null;
    const e = new th(new ya(null, t)), i = new w_();
    if (i.parseBits1(e), !i.hasBits1(ti.Header))
      return null;
    const n = e.parseAssemblyDataHeaderVersion();
    if (n > Eo._maxHeaderVersion)
      throw new Pa(`Unknown header version: ${n}`);
    let r = [];
    if (n >= 4 && (r = e.parseAssemblyDataVersion(3), !qc(dg, r)))
      throw new Pa(`Invalid version: ${Gm(r)}`);
    i.parseBits2(e);
    const o = e.parseDataKey(), l = e.parseBoolean();
    let h, u = "", f = ul.Unknown, g = !1;
    return n >= 1 ? h = e.parseBoolean() : h = !0, n >= 3 && (g = i.hasBits2(yr.DoublePrecisionMatrices), i.hasBits2(yr.OriginalName) && (u = e.parseCString()), f = e.parseIndex_32()), new Eo(
      n,
      o,
      l,
      h,
      u,
      f,
      g,
      r
    );
  }
};
Eo._maxHeaderVersion = 5, Eo.dynamic = new Eo(
  Eo._maxHeaderVersion,
  Lu.Invalid,
  !1,
  // isDrawing
  !1,
  // isMeasurable
  "",
  // originalFileName
  ul.Unknown,
  !0,
  []
);
let Zs = Eo;
class ya {
  constructor(t, e) {
    this.header = t, this.bytes = e;
  }
}
class $n {
  constructor(t, e, i, n) {
    this._productOccurrences = null, this._relationship = [], this._bimNodeIdMap = /* @__PURE__ */ new Map(), this._bimInfos = [], console.assert(i !== void 0), console.assert(i === Ni.Local == (n === Is.Local)), this._attachContext = e, this._inclusionKey = i, this._modelKey = n;
    let r = e.getReservedNodeIdOffset();
    r !== null ? e.forgetReservedNodeIdOffset() : r = t.newNodeIdOffset(), this._nodeIdOffset = r, t.registerInclusionContext(this);
  }
  split(t, e) {
    return new $n(t, e, this._inclusionKey, this._modelKey);
  }
  getIdOffset() {
    return this._nodeIdOffset;
  }
  toRuntimeId(t) {
    return console.assert(Pl(t)), t + this._nodeIdOffset;
  }
  getInclusionKey() {
    return this._inclusionKey;
  }
  getModelKey() {
    return this._modelKey;
  }
  getParent() {
    return this._attachContext;
  }
  /** Naming clarity for when you know you want it as the attach-context */
  getAttachContext() {
    return this._attachContext;
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._productOccurrences = Qn(this._productOccurrences, t);
  }
  getChildren() {
    return hi(this._productOccurrences);
  }
  removeProductOccurrence(t) {
    let e = hi(this._productOccurrences);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === 0 ? this._productOccurrences = null : this._productOccurrences = bs(e), e.length < i;
  }
  purgeContents() {
    const t = [], e = hi(this._productOccurrences);
    for (const i of e) {
      const n = i.purgeContents();
      t.push(n);
    }
    return this._productOccurrences = null, this._relationship.length = 0, We(t);
  }
  hasChildren() {
    return this._productOccurrences !== null;
  }
  isLoaded() {
    if (this._productOccurrences instanceof _e)
      return this._productOccurrences.isLoaded();
    if (this._productOccurrences === null)
      return !0;
    for (const t of this._productOccurrences)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  addRelationship(t) {
    this._relationship.push(t);
  }
  getRelationships() {
    return this._relationship;
  }
  addBimInfos(t) {
    this._bimInfos.push(t);
  }
  getBimInfos() {
    return this._bimInfos;
  }
  addBimIdToMap(t, e) {
    this._bimNodeIdMap.set(t, e);
  }
  getRuntimeNodeFromBimId(t) {
    const e = this._bimNodeIdMap.get(t);
    return e !== void 0 ? e : null;
  }
}
class Pn {
  constructor(t, e, i, n, r) {
    this._reservedNodeIdOffset = null, this._inclusionContexts = null, this._originalFileName = "", this._originalFileType = kc.Unknown, this._assemblyDataVersion = [], this._genericTypeMaps = null, console.assert(n !== jr.Invalid), this._remapper = t, this._attachScope = e, this._attachedInvisibly = i, this._masterModelKey = n, this._parent = r;
  }
  async getRootNodeMetaData(t) {
    if (this._masterModelKey === jr.Invalid)
      return null;
    const e = t.getAbstractScEngine(), i = this._masterModelKey, r = await e.safeGetMetaData(i, 1);
    if (r !== null) {
      const o = t.tryParseHeader(r);
      if (o === null)
        return new ya(null, r);
      const l = await o;
      this._originalFileName = l.originalFileName, this._originalFileType = l.originalFileType, this._assemblyDataVersion = l.assemblyDataVersion;
      const h = await e.safeGetMetaData(i, l.rootAssemblyDataKey());
      return h !== null ? new ya(l, h) : null;
    }
    return null;
  }
  getAttachScope() {
    return this._attachScope;
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  getMasterModelKey() {
    return this._masterModelKey;
  }
  addInclusionContext(t) {
    console.assert(t.getParent() === this), this._inclusionContexts = Qn(this._inclusionContexts, t);
  }
  getRemapper() {
    return this._remapper;
  }
  getParent() {
    return this._parent;
  }
  getChildren() {
    const t = this._inclusionContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const n = t[i];
        e.push(...n.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getInclusionContexts() {
    return hi(this._inclusionContexts);
  }
  split(t, e, i) {
    return new Pn(
      this._remapper,
      t,
      e,
      this._masterModelKey,
      i
    );
  }
  hasChildren() {
    return this._inclusionContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = hi(this._inclusionContexts);
    for (const n of i)
      if (n.removeProductOccurrence(t)) {
        e = n;
        break;
      }
    return e === null ? !1 : (i = i.filter((n) => n.hasChildren()), i.length === 0 ? this._inclusionContexts = null : this._inclusionContexts = bs(i), !0);
  }
  purgeContents() {
    const t = [], e = hi(this._inclusionContexts);
    for (const i of e) {
      const n = i.purgeContents();
      t.push(n);
    }
    return this._inclusionContexts = null, We(t);
  }
  isLoaded() {
    if (this._inclusionContexts instanceof $n)
      return this._inclusionContexts.isLoaded();
    if (this._inclusionContexts === null)
      return !0;
    for (const t of this._inclusionContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  setReservedNodeIdOffset(t) {
    console.assert(this._reservedNodeIdOffset === null), this._reservedNodeIdOffset = t;
  }
  getReservedNodeIdOffset() {
    return this._reservedNodeIdOffset;
  }
  forgetReservedNodeIdOffset() {
    console.assert(this._reservedNodeIdOffset !== null), this._reservedNodeIdOffset = null;
  }
  getOriginalFileName() {
    return this._originalFileName;
  }
  getOriginalFileType() {
    return this._originalFileType;
  }
  setGenericTypeMaps(t) {
    this._genericTypeMaps = t;
  }
  getGenericTypeMaps() {
    return this._genericTypeMaps;
  }
  getAssemblyDataVersion() {
    return this._assemblyDataVersion;
  }
}
function W0(s) {
  if (typeof s == "string")
    throw new oi();
  return s;
}
class Ls {
  constructor(t, e, i) {
    this._handledExternalModels = null, this._attachContexts = null, this._registeredScsModelKeys = /* @__PURE__ */ new Map(), this._layerIdMap = new y_(), this._parent = t, this._scsBufferCache = i;
  }
  /**
   * Returns whether or not an authored external model should be handled or not.
   */
  handleExternalModel(t, e, i) {
    const n = e.getInclusionKey(), r = `${Qd(i)} ${Qd(
      n
    )} ${Qd(t)}`;
    return this._handledExternalModels === null && (this._handledExternalModels = /* @__PURE__ */ new Set()), this._handledExternalModels.has(r) ? !1 : (this._handledExternalModels.add(r), !0);
  }
  getParent() {
    return this._parent;
  }
  addAttachContext(t) {
    this._attachContexts = Qn(this._attachContexts, t);
  }
  getChildren() {
    const t = this._attachContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const n = t[i];
        e.push(...n.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getAttachContexts() {
    return this._attachContexts === null ? [] : Array.isArray(this._attachContexts) ? this._attachContexts : [this._attachContexts];
  }
  hasChildren() {
    return this._attachContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = hi(this._attachContexts);
    for (const n of i)
      if (n.removeProductOccurrence(t)) {
        e = n;
        break;
      }
    return e === null ? !1 : (i = i.filter((n) => n.hasChildren()), i.length === 0 ? this._attachContexts = null : this._attachContexts = bs(i), !0);
  }
  purgeContents() {
    const t = [], e = hi(this._attachContexts);
    for (const i of e) {
      const n = i.purgeContents();
      t.push(n);
    }
    return this._attachContexts = null, We(t);
  }
  isLoaded() {
    if (this._attachContexts instanceof Pn)
      return this._attachContexts.isLoaded();
    if (this._attachContexts === null)
      return !0;
    for (const t of this._attachContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  /**
   * This should not be called more than once per `ExternalModelName` in a given `LoadContext`.
   */
  initializeScsModelKeysOf(t) {
    console.assert(this._registeredScsModelKeys.get(t) === void 0), this._registeredScsModelKeys.set(t, hd());
  }
  /**
   * Gets the model keys of an SCS model by its external name from a shattered XML file.
   *
   * Returns:
   *  - `null` if `initializeScsModelKeysOf` was not called for the given model.
   *  - `TrackedOpenPromise<null>` if the model has no attachment data.
   *  - `TrackedOpenPromise<ModelKey[]>` if the model has attachment data.
   */
  getScsModelKeysOf(t) {
    const e = this._registeredScsModelKeys.get(t);
    return e === void 0 ? null : e;
  }
  markAsFirstLoad() {
    console.assert(this._isFirstLoad === void 0), this._isFirstLoad = !0;
  }
  isFirstLoad() {
    return this._isFirstLoad === !0;
  }
  async toScsBuffer(t, e) {
    const i = Wn.create(async () => {
      const n = await e(t);
      return W0(n);
    });
    return this._scsBufferCache === null ? i : this._scsBufferCache.load(t, i);
  }
  // This gets called on both successful and erroneous loads.
  onLoadComplete() {
    this._scsBufferCache = null;
  }
  addLayerIdToMap(t, e) {
    this._layerIdMap.set(t, e);
  }
  getAuthoredLayerId(t) {
    const e = this._layerIdMap.getRight(t);
    return e !== void 0 ? e : null;
  }
  getRuntimeLayerId(t) {
    const e = this._layerIdMap.getLeft(t);
    return e !== void 0 ? e : null;
  }
  // Maps runtime layer IDs to authored layer IDs
}
function eh(s) {
  let t = Gn.getIdentity(), e = s;
  for (; e !== null; )
    if (e instanceof is) {
      const i = e.getLocalTransform();
      i && (t = Gn.multiply(t, i)), e instanceof as ? e = null : e = e.getParent();
    } else if (e instanceof $n)
      e = e.getParent();
    else if (e instanceof Pn)
      e = e.getParent();
    else if (e instanceof Ls)
      e = e.getParent();
    else
      return t;
  return t;
}
function v_(s) {
  let t = s;
  for (; ; )
    if (t instanceof is)
      if (t instanceof El)
        t = t.getParent();
      else
        return t;
    else if (t instanceof Ls)
      t = t.getParent();
    else if (t instanceof $n)
      t = t.getParent();
    else if (t instanceof Pn)
      t = t.getParent();
    else {
      if (t === null)
        return null;
      console.assert(!1), t = t.getInclusionContext();
    }
}
function Do(s) {
  return s instanceof El || s instanceof _e ? s.isOutOfHierarchy() : !1;
}
function G0(s) {
  return s instanceof _e || s instanceof Mn || s instanceof ls ? s.getBranchVisibility() : s.isVisible() ? ue.Shown : ue.Hidden;
}
function $0(s) {
  if (s instanceof _e)
    return s.isADrawingSheetNode() ? Le.DrawingSheet : s.hasBodyInstances() ? Le.PartInstance : Le.AssemblyNode;
  if (s instanceof as)
    return Le.Part;
  if (s instanceof Bs)
    return Le.PmiBody;
  if (s instanceof ho)
    return Le.ViewFrame;
  if (s instanceof ji)
    return Le.BodyInstance;
  if (s instanceof en)
    switch (s.getBodyType()) {
      case Ya.BRep:
        return Le.BrepBody;
      case Ya.Tessellation:
        return Le.TessBody;
      case Ya.Wireframe:
        return Le.WireBody;
      case Ya.PointCloud:
        return Le.PointsBody;
      case Ya.Unknown:
      default:
        return Le.Body;
    }
  else return s instanceof Mn ? Le.Pmi : Le.CadView;
}
function ih(s) {
  const t = s.getGenericTypeId();
  if (t !== null) {
    const i = Vi(s).getGenericTypeMaps();
    if (i !== null)
      return i.getRight(t) || null;
  }
  return null;
}
function qi(s) {
  let t = s;
  for (; ; )
    if (t instanceof is)
      t = t.getParent();
    else {
      if (t instanceof $n)
        return t;
      if (t instanceof Bs)
        t = t.getParent();
      else if (t instanceof ho)
        t = t.getParent();
      else
        return t.getInclusionContext();
    }
}
function Ys(s) {
  let t = s;
  for (; ; )
    if (t instanceof Pn)
      t = t.getParent();
    else {
      if (t instanceof Ls)
        return t;
      t instanceof is || t instanceof $n ? t = t.getParent() : t = t.getInclusionContext();
    }
}
function Vi(s) {
  let t = s;
  for (; ; )
    if (t instanceof $n)
      t = t.getParent();
    else {
      if (t instanceof Pn)
        return t;
      if (t instanceof is)
        t = t.getParent();
      else if (t instanceof Ls) {
        const e = t.getParent();
        if (e === null)
          throw new oi();
        t = e;
      } else
        t = t.getInclusionContext();
    }
}
function Lp(s) {
  let t = null, e = s;
  for (; ; )
    if (e instanceof _e)
      t = e, e = e.getParent();
    else if (e instanceof is)
      e = e.getParent();
    else if (e instanceof $n) {
      if (t === null)
        throw new oi();
      return t;
    } else
      e = e.getInclusionContext();
}
function mr(s) {
  let t = s;
  for (; ; ) {
    if (t instanceof _e)
      return t;
    if (t instanceof Pn)
      t = t.getParent();
    else if (t instanceof $n)
      t = t.getParent();
    else if (t instanceof Ls) {
      const e = t.getParent();
      if (e === null)
        return null;
      t = e;
    } else if (t instanceof El)
      t = t.getParent();
    else if (t instanceof Mn)
      t = t.getParent();
    else if (t instanceof ls)
      t = t.getParent();
    else
      return console.assert(!1), null;
  }
}
const q0 = "IFCCOLUMN", K0 = "IFCCOVERING", X0 = "IFCCURTAINWALL", J0 = "IFCDOOR", Y0 = "IFCRAMP", Z0 = "IFCROOF", Q0 = "IFCSLAB", tb = "IFCSTAIR", eb = "IFCSTAIRFLIGHT", ib = "IFCTRANSPORTELEMENT", nb = "IFCWALL", sb = "IFCWALLSTANDARDCASE", rb = "IFCWINDOW";
function ob(s, t) {
  let e = s;
  for (; e !== null; ) {
    if (e.getName() === t || ih(e) === t)
      return !0;
    e = mr(e.getParent());
  }
  return !1;
}
function ab(s) {
  switch (s) {
    case q0:
    case X0:
    case tb:
    case eb:
    case nb:
    case sb:
    case rb:
      return _n.Wall | _n.Floor;
    case K0:
    case Y0:
    case Z0:
    case Q0:
      return _n.Floor;
    case J0:
    case ib:
      return _n.Door | _n.Floor;
  }
  return _n.None;
}
async function lb(s, t, e, i) {
  const n = await t.getNodeOrRepItem(e);
  if (n === null || n instanceof en || n instanceof as)
    return _n.None;
  let r = ih(n);
  if (r === null) {
    if (i === null)
      return _n.None;
    const l = await n.getAttributes();
    for (const h of l)
      if (h.getTitle() === i) {
        r = h.getValue();
        break;
      }
    if (r === null)
      return _n.None;
  }
  const o = s(r);
  return o !== _n.None ? o : _n.None;
}
async function cb(s) {
  const t = [], e = {
    enterAnyBody: (i) => {
      i instanceof ji && t.push(i);
    }
  };
  return await Ln.walk(e, s, Vt.None), t;
}
async function hb(s) {
  const t = await cb(s), e = /* @__PURE__ */ new Set();
  for (const i of t) {
    const n = i.getParent();
    e.add(n);
  }
  return lo(e);
}
async function ub(s, t, e, i) {
  const n = [];
  for (const u of e) {
    const f = lb(
      s,
      t,
      u,
      i
    );
    n.push(f);
  }
  const r = await Promise.all(n), o = [], l = [], h = [];
  for (let u = 0; u < e.length; ++u) {
    const f = e[u], g = r[u];
    g !== _n.None && ((g & _n.Floor) !== 0 && o.push(f), (g & _n.Wall) !== 0 && l.push(f), (g & _n.Door) !== 0 && h.push(f));
  }
  return {
    floors: o,
    walls: l,
    doors: h
  };
}
function sf(s) {
  const t = [];
  for (const e of s) {
    const i = e.getBodyInstances();
    for (const n of i) {
      const r = n.getInstanceInc();
      t.push(r[0], r[1]);
    }
  }
  return t;
}
async function db(s, t, e, i, n) {
  const r = await hb(i), o = await ub(
    s,
    e,
    r,
    n
  ), l = sf(o.floors);
  t.registerBimInstances(l, bc.Floor);
  const h = sf(o.walls);
  t.registerBimInstances(h, bc.Wall);
  const u = sf(o.doors);
  t.registerBimInstances(u, bc.Door);
}
async function fb(s, t, e) {
  const i = [], n = [], r = {
    enterAnyBody: (u) => {
      if (u instanceof ji && !u.isOutOfHierarchy()) {
        i.push(u);
        const f = u.getInstanceInc();
        n.push(f[0], f[1]);
      }
    }
  };
  await Ln.walk(r, s, Vt.None);
  const o = /* @__PURE__ */ new Map(), l = await t.getPartColor(n, e), h = l.length;
  console.assert(h === i.length);
  for (let u = 0; u < h; ++u) {
    const f = l[u];
    f !== null && o.set(i[u].getRuntimeId(), f);
  }
  return o;
}
function pl(s) {
  return [s.x, s.y, s.z];
}
function gb(s) {
  return [Math.abs(s[0]), Math.abs(s[1]), Math.abs(s[2])];
}
function pb(s, t) {
  return [s[0] * t[0], s[1] * t[1], s[2] * t[2]];
}
function mb(s, t) {
  return [s[0] + t[0], s[1] + t[1], s[2] + t[2]];
}
function _b(s, t) {
  return [s[0] - t[0], s[1] - t[1], s[2] - t[2]];
}
function yb(s, t) {
  return [s[0] + t[0], s[1] + t[1], s[2] + t[2], s[3] + t[3]];
}
function Mf(s, t) {
  return [s[0] - t[0], s[1] - t[1], s[2] - t[2], s[3] - t[3]];
}
function no(s, t) {
  return s[0] * t[0] + s[1] * t[1] + s[2] * t[2];
}
function fg(s) {
  const t = s[0], e = s[1], i = s[2];
  return t * t + e * e + i * i;
}
function Fp(s) {
  return Math.sqrt(fg(s));
}
function wb(s, t) {
  return [s * t[0], s * t[1], s * t[2]];
}
function rf(s) {
  return [s.x, s.y, s.z, s.w];
}
function fc(s, t) {
  const e = s.m, i = t;
  return [e[i], e[i + 4], e[i + 8], e[i + 12]];
}
function Bp(s) {
  const t = s[0], e = s[1], i = s[2], n = s[3];
  return t * t + e * e + i * i + n * n;
}
function of(s, t) {
  return [s * t[0], s * t[1], s * t[2], s * t[3]];
}
function vb(s, t, e) {
  let i = no(s, e) + e[3];
  return i *= i, i < 1e-5 && (i = 1e-5), t / i;
}
const cs = 400, wa = "_empty", gg = Ts;
function gu(s) {
  return s;
}
class Pc {
  // View with ViewKey 0
  /** @hidden */
  constructor(t, e) {
    this._pmiColor = yt.black(), this._pmiColorOverride = !1, this._viewAxes = new Vp(), this._viewAxesSet = !1, this._engine = t, this._callbackManager = e, this._callbackManager.bind({
      _firstModelLoaded: async (i) => {
      },
      _resetAssemblyTreeBegin: async () => {
        this._viewAxes = new Vp(), this._viewAxesSet = !1;
      }
    });
  }
  /** @hidden */
  _setModelStructure(t) {
    console.assert(this._modelStructure === void 0), this._modelStructure = t;
  }
  /** @hidden */
  _setDefaultView(t) {
    this._defaultView = t;
  }
  /**
   * Sets the up and front vectors for the model coordinate system.
   * Both the upVector and frontVector must be unique, cardinal axes.
   * @param frontVector
   * @param upVector
   */
  setViewAxes(t, e) {
    if (t.isAxis() && e.isAxis() && !t.equals(e))
      this._viewAxes.frontVector = t, this._viewAxes.upVector = e, this._callbackManager.trigger("viewAxes", t, e), this._viewAxesSet = !0;
    else
      throw new oe("The upVector and frontVector must be unique, cardinal axes.");
  }
  /**
   * Gets whether there has been a successful call to setViewAxes.
   */
  viewAxesHaveBeenSet() {
    return this._viewAxesSet;
  }
  /**
   * @returns the up and front vectors for the model coordinate system.
   */
  getViewAxes() {
    return this._viewAxes;
  }
  /**
   * Gets the world space bounding box for the model.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getModelBounding(t, e, i = !1) {
    let n = new wn();
    try {
      n = await this._engine.getModelBounding(
        t,
        e,
        i
      );
    } catch (r) {
      console.assert(ca(r) && jm(r) === ng.Cancelled);
    }
    return n;
  }
  /**
   * Gets the world space bounding box for the model. This does not take node visibility into account.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getLooseBounding() {
    return this._engine.getLooseBounding();
  }
  /** @hidden */
  _allowNodeDeletion(t) {
    return this._modelStructure.allowNodeDeletion(t);
  }
  /** @hidden */
  _preventNodeDeletion(t) {
    return this._modelStructure.preventNodeDeletion(t);
  }
  /** @hidden */
  _preventMeshDeletion(t) {
    return console.assert(t[0] === Is.Local), this._modelStructure.preventMeshDeletion(t[1]);
  }
  /** @hidden */
  _getNodeFromInstanceInc(t, e, i, n) {
    return this._modelStructure.getNodeFromInstanceInc(
      t,
      e,
      i,
      n
    );
  }
  /**
   * Gets the world space bounding box for a list of nodes.
   * @param nodeIds IDs of the nodes for which you wish to get the bounding box.
   * @param config Allows fine control of what body types to compute the bounding against. If not provided, all body types are considered.
   * @returns Promise that resolves with the world space bounding box for the given IDs.
   */
  getNodesBounding(t, e) {
    let i = Wt.All;
    return (e == null ? void 0 : e.bodyInstance) === !1 && (i &= ~Wt.BodyInstance), (e == null ? void 0 : e.pmiBody) === !1 && (i &= ~Wt.PmiBody), (e == null ? void 0 : e.viewFrame) === !1 && (i &= ~Wt.ViewFrame), this._modelStructure.getBounding(
      t,
      i,
      (e == null ? void 0 : e.ignoreInvisible) ?? !1,
      (e == null ? void 0 : e.tightBounding) ?? !1
    );
  }
  /**
   * Gets the world space bounding box for a node including any effects (explosion, camera suppression, etc).
   * Note: This function can have performance implications when used on nodes with many children.
   * @param nodeId ID of the node for which you wish to get the bounding box.
   * @param view View to use for determining visibility.
   * @returns Promise that resolves with the world space bounding box for the given ID.
   */
  async getNodeRealBounding(t, e) {
    const i = e !== void 0 ? e.id : Ae.Default, n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.None
    );
    if (n.length === 0)
      throw new oe("Cannot get bounding of node without geometry.");
    return this._engine.getDrawnPartsBounding(n, i);
  }
  /**
   * Sets the visibility for a given set of nodes.
   * @param mapping The mapping of node IDs to boolean value indicating the visibility setting for that node.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibilities(t, e = null) {
    return t = Ep(t), this._modelStructure.setVisibilitiesByMap(
      t,
      e !== null ? e : void 0
    );
  }
  /**
   * Sets visibility for a given list of nodes.
   * @param nodeIds The node IDs whose visibilities will be set.
   * @param visibility If true, nodes will be shown. If false, they will be hidden.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibility(t, e, i = null) {
    return this._modelStructure.setVisibilitiesByValue(
      t,
      e,
      i
    );
  }
  setBodyNodesVisibility(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i === null)
      throw new Ns(t);
    const n = typeof e == "boolean" ? (r) => e : e;
    return this._modelStructure.setBodyNodesVisibility(
      i,
      (r) => n(r.getRuntimeId())
    );
  }
  /**
   * Resets visibility for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesVisibility() {
    return this.isDrawing() ? this._callbackManager.promiseTrigger("_resetDrawing", null) : this._modelStructure.resetAllVisibilities();
  }
  /**
   * Returns a defaultVisibility boolean value and a visibilityException set of NodeIds.
   * defaultVisibility will be true if there are more nodes visible than hidden, and false otherwise.
   * If defaultVisibility is true, set of nodes that are hidden, if false, nodes that are visible.
   */
  async getVisibilityState(t) {
    const e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new Ns(t);
    return o_(e);
  }
  /**
   * Resets transform for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesTransform() {
    return this._modelStructure.resetAllTransforms();
  }
  /**
   * Resets the state of the model to its default
   * @returns Promise that resolves when the operation has completed.
   */
  reset() {
    return this.resetModelOpacity(), this._modelStructure.reset();
  }
  /**
   * Remove all nodes, CAD views, configurations, and sheets from the model.
   *
   * If you intend to load additional models via the `loadSubtree` family
   * of methods, you should wait on the resolution of this promise before doing so.
   */
  clear() {
    return this._modelStructure.clear();
  }
  /**
   * Sets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesFaceColor(t, e) {
    return this._setNodesFaceColor(t, e), Promise.resolve();
  }
  /**
   * Sets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesAmbientColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartAmbientColor(i, Jt.Faces, e);
  }
  /**
   * Sets the ambient mix on the faces for a given list of nodes.
   * The mix is between the material ambient light and the global ambient light,
   * with 1.0 representing full material ambient mix and 0.0 representing full global
   * ambient light.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the decimal value to set, between 0 and 1
   */
  setNodesAmbientMix(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartAmbientMix(i, Jt.Faces, e);
  }
  /**
   * Gets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to get
   */
  getNodesAmbientColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartAmbientColor(e, Jt.Faces) : Promise.resolve([]);
  }
  /**
   * Gets the ambient color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveAmbientColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEffectiveAmbientColor(e, Jt.Faces) : Promise.resolve([]);
  }
  /**
   * Unsets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to unset
   */
  unsetNodesAmbientColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartAmbientColor(e, Jt.Faces);
  }
  /**
   * Sets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceEmissiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartEmissiveColor(i, Jt.Faces, e);
  }
  /**
   * Gets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to get
   */
  getNodesFaceEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEmissiveColor(e, Jt.Faces) : Promise.resolve([]);
  }
  /**
   * Gets the emissive color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEffectiveEmissiveColor(e, Jt.Faces) : Promise.resolve([]);
  }
  /**
   * Resets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartEmissiveColor(e, Jt.Faces);
  }
  /**
   * Sets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceSpecularColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartSpecularColor(i, Jt.Faces, e);
  }
  /**
   * Gets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to get
   */
  getNodesFaceSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartSpecularColor(e, Jt.Faces) : Promise.resolve([]);
  }
  /**
   * Gets the specular color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEffectiveSpecularColor(e, Jt.Faces) : Promise.resolve([]);
  }
  /**
   * Resets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartSpecularColor(e, Jt.Faces);
  }
  /**
   * Sets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the value to set
   */
  setNodesFaceSpecularIntensity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartSpecularIntensity(i, Jt.Faces, e);
  }
  /**
   * Resets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   */
  unsetNodesFaceSpecularIntensity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartSpecularIntensity(e, Jt.Faces);
  }
  _setNodesFaceColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartColor(i, Jt.Faces, e);
  }
  _unsetNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.unsetPartColor(i, e);
  }
  /**
   * Unsets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesFaceColor(t) {
    return this._unsetNodesColor(t, Jt.Faces), Promise.resolve();
  }
  /**
   * Sets the color on the lines/edges for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesLineColor(t, e) {
    return this._setNodesLineColor(t, e), Promise.resolve();
  }
  _setNodesLineColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartColor(i, Jt.Lines, e);
  }
  /**
   * Unsets the color on the lines for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesLineColor(t) {
    return this._unsetNodesColor(t, Jt.Lines), Promise.resolve();
  }
  /**
   * Sets whether the supplied nodes should appear highlighted. When a node is highlighted,
   * the highlight color will override any color previously set on the model.
   *
   * *Tip:* An easy way to unhighlight the entire model is to call [[setNodesHighlighted]]
   * on the root node of the model:
   * ```
   * hwv.model.setNodesHighlighted([hwv.model.getAbsoluteRootNode()], false);
   * ```
   * (In this case, `hwv` is your instance of [[WebViewer]].)
   *
   * @param nodeIds array of IDs for this operation.
   * @param highlighted value indicating whether the supplied nodes should be highlighted.
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesHighlighted(t, e) {
    if (t.length === 0) return Promise.resolve();
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.LoadedNodesOnly
    );
    return i.length > 0 && this._engine.highlightParts(i, e), Promise.resolve();
  }
  /**
   * Returns whether the supplied nodes have been highlighted with [[setNodesHighlighted]].
   * @param nodeIds the list of nodes to be queried
   */
  getNodesHighlighted(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartHighlighted(e) : Promise.resolve([]);
  }
  /**
   * Sets colors for a given set of nodes.
   *
   * @param params object mapping node IDs to color to set for that node
   * @param alsoApplyToWireframe change or not lines color
   * @param alsoApplyToPoints change or not points color
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesColors(t, e = !1, i = !1) {
    const n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map(), o = (l, h) => {
      const u = this._modelStructure.lookupAnyTreeNode(l);
      if (u !== null) {
        const f = Yc(
          u,
          Wt.All,
          !1,
          n,
          Vt.None
        );
        if (f.length > 0) {
          const g = (h.r << 16) + (h.g << 8) + h.b, y = r.get(g);
          y ? r.set(g, y.concat(f)) : r.set(g, f);
        }
      }
    };
    if (t instanceof Map)
      t.forEach((l, h) => {
        o(h, l);
      });
    else {
      const l = Object.keys(t);
      for (const h of l) {
        const u = parseInt(h, 10);
        o(u, t[u]);
      }
    }
    return r.forEach((l, h) => {
      const u = new yt(h >> 16, (h & 65280) >> 8, h & 255);
      this._engine.setPartColor(l, Jt.Faces, u), e && this._engine.setPartColor(l, Jt.Lines, u), i && this._engine.setPartColor(l, Jt.Points, u);
    }), Promise.resolve();
  }
  /**
   * Gets an array of PMI topology references linking a PMI node to a body element, like a face or an edge.
   * @param pmiNodeId the ID of the PMI node.
   */
  getPmiTopologyReferences(t) {
    const e = [], i = (r, o, l) => {
      const h = new Mb();
      return h.bodyId = r, h.subElementType = o, h.subElementIndex = l, h;
    }, n = this._modelStructure.getPmiTopologyReferences(t);
    if (n !== null)
      for (const r of n) {
        const o = r.body.getRuntimeId(), l = r.faceIds;
        for (const u of l)
          e.push(i(o, sh.Face, u));
        const h = r.edgeIds;
        for (const u of h)
          e.push(i(o, sh.Edge, u));
      }
    return e.length === 0 ? null : e;
  }
  /**
   * Returns names and ids of all the PMIs available in the scene
   * @returns a map associating PMI IDs to PMI names
   */
  getPmis() {
    return this._modelStructure.getPmis();
  }
  /**
   * Returns the type of a given PMI
   * @param idPMI ID of the PMI
   * @returns Type of the PMI (Dimension, Datum, GD&T...)
   */
  getPmiType(t) {
    return this._modelStructure.getPmiType(t);
  }
  /**
   * Returns the subtype of a given PMI
   * @param idPMI ID of the PMI
   * @returns Subtype of the PMI (Dimension distance, Datum target, GD&T fcf...)
   */
  getPmiSubtype(t) {
    return this._modelStructure.getPmiSubType(t);
  }
  /**
   * Saves a PMI override color
   * @param color the override color
   */
  setPmiColor(t) {
    this._pmiColor.assign(t);
  }
  /**
   * Returns the set PMI override color  (if none is set, defaults to black)
   * @returns color
   */
  getPmiColor() {
    return this._pmiColor.copy();
  }
  /**
   * Takes a boolean value and either enables the set PMI override color or resets all PMI colors to their default
   * @returns Promise that resolves when this operation has completed.
   */
  setPmiColorOverride(t, e) {
    return this._pmiColorOverride = t, t ? this._modelStructure.setPmiColor(this._pmiColor, e) : this._modelStructure.resetPmiColor(e), Promise.resolve();
  }
  /**
   * @returns a boolean value indicating the status of the PMI override color.
   */
  getPmiColorOverride() {
    return this._pmiColorOverride;
  }
  /**
   * Computes the distance between two bodies
   * @param partId1 id for the part which the first face belongs to
   * @param partId2 id for the part which the second face belongs to
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumBodyBodyDistance(t, e) {
    const i = this._modelStructure.lookupAnyBody(t);
    if (i === null)
      throw new os(t, Cn.AnyBody);
    const n = this._modelStructure.lookupAnyBody(e);
    if (n === null)
      throw new os(e, Cn.AnyBody);
    const r = i.getInstanceInc(), o = n.getInstanceInc();
    return this._engine.computeMinimumBodyBodyDistance(r, o);
  }
  /**
   * Computes the distance between two faces
   * @param partId1 id for the part which the first face belongs to
   * @param faceId1 id for the face in the first part
   * @param partId2 id for the part which the second face belongs to
   * @param faceId2 id for the face in the second part
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceFaceDistance(t, e, i, n) {
    const r = this._modelStructure.lookupAnyBody(t);
    if (r === null)
      throw new os(t, Cn.AnyBody);
    const o = this._modelStructure.lookupAnyBody(i);
    if (o === null)
      throw new os(i, Cn.AnyBody);
    const l = r.getInstanceInc(), h = o.getInstanceInc();
    return this._engine.computeMininimumFaceFaceDistance(
      [l[0], l[1]],
      e,
      [h[0], h[1]],
      n
    );
  }
  /**
   * Computers the minimum distance between a face and a ray.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the ray to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceRayDistance(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new os(t, Cn.AnyBody);
    const r = n.getInstanceInc();
    return this._engine.computeMinimumFaceRayDistance(r, e, i);
  }
  /**
   * Computers the minimum distance between a face and an infinite line.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the line (in the form of a ray) to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceLineDistance(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new os(t, Cn.AnyBody);
    const r = n.getInstanceInc();
    return this._engine.computeMinimumFaceLineDistance(r, e, i);
  }
  /**
   * Sets the color for a face element. This color will take precedence over any currently set color on the node
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color set
   * @param color the color to set
   */
  setNodeFaceColor(t, e, i) {
    return this._setNodeFaceColor(t, e, i), Promise.resolve();
  }
  _setNodeFaceColor(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.None
    );
    if (n.length === 2) {
      const r = n;
      this._engine.setElementColor(r, Jt.Faces, e, 1, i);
    }
  }
  /**
   * Sets the visibility for a face element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the face
   * @param faceId the Id of the face in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeFaceVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, Jt.Faces);
  }
  /**
   * Clears the visibility for a node's face elements, resetting them to default.
   * @param partId the Id of the part to be reset
   */
  clearNodeFaceVisibility(t) {
    this._clearNodeElementVisibility(t, Jt.Faces);
  }
  _setNodeElementVisibility(t, e, i, n) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.None
    );
    if (r.length === 2) {
      const o = r;
      this._engine.setElementVisibility(o, n, e, 1, i);
    }
  }
  _clearNodeElementVisibility(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.None
    );
    if (i.length === 2) {
      const n = i;
      this._engine.clearElementVisibility(n, e);
    }
  }
  _unsetElementColor(t, e, i) {
    if (i < 0)
      return;
    const n = this._getInstanceIncFromSingleLeafNode(t);
    this._engine.unsetElementColor(n, e, i, 1);
  }
  /**
   * Unsets the color for a face element. This will return the face's color to its default state.
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color unset
   */
  unsetNodeFaceColor(t, e) {
    return this._unsetElementColor(t, Jt.Faces, e), Promise.resolve();
  }
  /**
   * Sets whether the face element for a given node should appear highlighted.
   * When a face element is highlighted, the highlight color will override
   * any color previously set on the element.
   * @param nodeId the id for the node containing the face element.
   * @param faceId the face Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied face element should be highlighted.
   */
  setNodeFaceHighlighted(t, e, i) {
    return this._setNodeFaceHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeFaceHighlighted(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.LoadedNodesOnly
    );
    n.length > 0 && this._engine.highlightElements(n, Jt.Faces, e, 1, i);
  }
  async _getElementHighlighted(t, e, i) {
    const n = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementHighlighted(n, e, i);
    return r;
  }
  /**
   * Returns whether the supplied face element has been highlighted with [[setNodeFaceHighlighted]].
   * @param nodeId the ID of the node containing the face element
   * @param faceIndex the index of the face within the node
   */
  getNodeFaceHighlighted(t, e) {
    return this._getElementHighlighted(t, Jt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectivePointColor]]
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   */
  getNodePointColor(t, e) {
    return this._getNodeElementColor(t, Jt.Points, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element. If no color has been set,
   * the node's point color will be returned. If the node's point color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   * @param view the View to use for calculating view effects
   */
  getNodeEffectivePointColor(t, e, i) {
    return this._getNodeEffectiveElementColor(t, Jt.Points, e, i);
  }
  /**
   * Sets the color for a point element.
   * @param partId the Id of the node containing the point.
   * @param pointId the Id of the point in the node that will have its color set.
   * @param color the color to set.
   */
  setNodePointColor(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new os(t, Cn.AnyBody);
    const r = n.getInstanceInc();
    this._engine.setElementColor(r, Jt.Points, e, 1, i);
  }
  /**
   * Unsets the color for a point element. This will return the point's color to its default state.
   * @param partId the Id of the node containing the point
   * @param pointId the Id of the point in the node that will have its color unset
   */
  unsetNodePointColor(t, e) {
    this._unsetElementColor(t, Jt.Points, e);
  }
  /**
   * Gets the color set via [[setNodesPointColor]] on the points of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectivePointColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesPointColor(t) {
    return this._getNodesColor(t, Jt.Points);
  }
  /**
   * Gets the color set on the points of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectivePointColor(t) {
    return this._getNodesEffectiveColor(t, Jt.Points);
  }
  /**
   * Sets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesPointColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartColor(i, Jt.Points, e);
  }
  /**
   * Unsets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   */
  unsetNodesPointColor(t) {
    this._unsetNodesColor(t, Jt.Points);
  }
  /**
   * Sets the color for a line element.
   * @param nodeId the Id of the node containing the line.
   * @param lineId the Id of the line in the node that will have its color set.
   * @param color the color to set.
   */
  setNodeLineColor(t, e, i) {
    return this._setNodeLineColor(t, e, i), Promise.resolve();
  }
  _setNodeLineColor(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new os(t, Cn.AnyBody);
    const r = n.getInstanceInc();
    this._engine.setElementColor(r, Jt.Lines, e, 1, i);
  }
  /**
   * Unsets the color for a line element. This will return the line's color to its default state.
   * @param nodeId the Id of the node containing the line
   * @param lineId the Id of the line in the node that will have its color unset
   */
  unsetNodeLineColor(t, e) {
    return this._unsetElementColor(t, Jt.Lines, e), Promise.resolve();
  }
  /**
   * Sets the visibility for a line element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the line
   * @param lineId the Id of the line in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeLineVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, Jt.Lines);
  }
  /**
   * Clears the visibility for a node's line elements, resetting them to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodeLineVisibility(t) {
    this._clearNodeElementVisibility(t, Jt.Lines);
  }
  /**
   * Sets whether the line element for a given node should appear highlighted. When a line element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the line element.
   * @param lineId the line Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied line element should be highlighted.
   */
  setNodeLineHighlighted(t, e, i) {
    return this._setNodeLineHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeLineHighlighted(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.LoadedNodesOnly
    );
    n.length > 0 && this._engine.highlightElements(n, Jt.Lines, e, 1, i);
  }
  /**
   * Returns whether the supplied line element has been highlighted with [[setNodeLineHighlighted]].
   * @param nodeId the ID of the node containing the line element
   * @param lineIndex the index of the line within the node
   */
  getNodeLineHighlighted(t, e) {
    return this._getElementHighlighted(t, Jt.Lines, e);
  }
  /**
   * Sets the visibility for a point element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the point
   * @param pointId the Id of the point in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodePointVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, Jt.Points);
  }
  /**
   * Clears the visibility for a node's point elements, resetting it to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodePointVisibility(t) {
    this._clearNodeElementVisibility(t, Jt.Points);
  }
  /**
   * Sets whether the point element for a given node should appear highlighted. When a point element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the point element.
   * @param pointId the point Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied point element should be highlighted.
   */
  setNodePointHighlighted(t, e, i) {
    return this._setNodePointHighlighted(t, e, i), Promise.resolve();
  }
  _setNodePointHighlighted(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new os(t, Cn.AnyBody);
    const r = n.getInstanceInc();
    this._engine.highlightElements(r, Jt.Points, e, 1, i);
  }
  /**
   * Returns whether the supplied point element has been highlighted with [[setNodePointHighlighted]].
   * @param nodeId the ID of the node containing the point element
   * @param pointIndex the index of the point within the node
   */
  getNodePointHighlighted(t, e) {
    return this._getElementHighlighted(t, Jt.Points, e);
  }
  /**
   * Resets color for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetNodesColor() {
    return this._engine.resetColors(), Promise.resolve();
  }
  /**
   * Sets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be set
   * @param opacity opacity value to apply to each node. The value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartOpacity(i, e);
  }
  /**
   * Returns whether nodes with the given NodeIds have an opacity value that is not fully opaque.
   * @param nodeIds IDs of nodes to query.
   * @returns array of boolean values corresponding to the id array passed into the function.  A value of true indicates that the node contains transparency and is not fully opaque.
   */
  getNodesHaveTransparency(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartHasTransparency(e) : Promise.resolve([]);
  }
  /**
   * Sets opacity for a given set of nodes.
   * @param params object mapping node IDs to opacity to set for that NodeId. The opacity value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacities(t) {
    t = Ep(t);
    const e = /* @__PURE__ */ new Set();
    t.forEach((i, n) => {
      const r = this._modelStructure.lookupAnyTreeNode(n);
      if (r !== null) {
        const o = Yc(
          r,
          Wt.BodyInstance,
          !1,
          e,
          Vt.None
        );
        o.length > 0 && this._engine.setPartOpacity(o, i);
      }
    });
  }
  /**
   * Resets opacity for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelOpacity() {
    this._engine.resetOpacity(), this._callbackManager.trigger("_resetOpacity");
  }
  /**
   * Resets highlight for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelHighlight() {
    return this._engine.clearHighlight(), Promise.resolve();
  }
  /**
   * Resets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be reset to their default values
   */
  resetNodesOpacity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartOpacity(e);
  }
  _getNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return i.length > 0 ? this._engine.getPartColor(i, e) : Promise.resolve([]);
  }
  _getNodesEffectiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return i.length > 0 ? this._engine.getEffectivePartColor(i, e) : Promise.resolve([]);
  }
  /**
   * Gets the color set via [[setNodesFaceColor]] on the faces of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectiveFaceColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesFaceColor(t) {
    return this._getNodesColor(t, Jt.Faces);
  }
  /**
   * Gets the color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveFaceColor(t) {
    return this._getNodesEffectiveColor(t, Jt.Faces);
  }
  /**
   * Gets the color set via [[setNodesLineColor]] on the lines of a list of leaf nodes.
   * If no color has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesLineColor(t) {
    return this._getNodesColor(t, Jt.Lines);
  }
  /**
   * Gets the color set on the lines of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveLineColor(t) {
    return this._getNodesEffectiveColor(t, Jt.Lines);
  }
  /**
   * Gets a map associating NodeIds to colors that are set on those nodes.
   * Only NodeIds of nodes that have a color set will be included.
   * @param startNodeId The start node to walk when building the color map.
   * @param elementType Returned colors are of this element type.
   */
  async getNodeColorMap(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i !== null)
      return fb(i, this._engine, e);
    throw new Ns(t);
  }
  /**
   * Gets the opacity set via [[setNodesOpacity]] on a list of leaf nodes.
   * If no value has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesOpacity(t) {
    return Promise.resolve(this._getNodesOpacity(t));
  }
  _getNodesOpacity(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartOpacity(e) : [];
  }
  /**
   * Gets the opacity set on a list of leaf nodes multiplied by the opacity
   * specified when the model was authored. If no opacity has been set,
   * the opacity specified when the model was authored will be returned directly.
   * @param nodeIds IDs of the nodes to be queried
   * @param elementType the type of element (faces, lines or points) to query
   */
  getNodesEffectiveOpacity(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return i && i.length > 0 ? this._engine.getEffectivePartOpacity(i, e) : Promise.resolve([]);
  }
  async _getNodeElementColor(t, e, i) {
    const n = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementColor(n, e, i);
    return r;
  }
  async _getNodeEffectiveElementColor(t, e, i, n) {
    const r = n !== void 0 ? n.id : Ae.Default, o = this._getInstanceIncFromSingleLeafNode(t), [l] = await this._engine.getEffectiveElementColor(
      o,
      e,
      i,
      r
    );
    return l;
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectiveFaceColor]]
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   */
  getNodeFaceColor(t, e) {
    return this._getNodeElementColor(t, Jt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element. If no color has been set,
   * the node's face color will be returned. If the node's face color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   * @param view the View to use when calculating view effects
   */
  getNodeEffectiveFaceColor(t, e, i) {
    return this._getNodeEffectiveElementColor(t, Jt.Faces, e, i);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element.
   * If no color has been set, `null` will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   */
  getNodeLineColor(t, e) {
    return this._getNodeElementColor(t, Jt.Lines, e);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element. If no color has been set,
   * the node's line color will be returned. If the node's line color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   * @param view the View to use when calculating view effects
   */
  getNodeEffectiveLineColor(t, e, i) {
    return this._getNodeEffectiveElementColor(t, Jt.Lines, e, i);
  }
  /**
   * Returns "Out Of Hierarchy" status for child node for the given Id.
   * @param id Node id to get children of
   * @returns false if node is Out Of Hierarchy, true if it is
   */
  getOutOfHierarchy(t) {
    return this._modelStructure.isOutOfHierarchy(t);
  }
  /**
   * Returns the absolute root node of the assembly tree.
   * @returns Id for the model tree root node or null if the model structure is not loaded.
   */
  getAbsoluteRootNode() {
    return this._modelStructure.getAbsoluteRootNodeId();
  }
  /**
   * Returns IDs for child nodes for the given Id.
   * @param id Node id to get children of
   * @param includeOutOfHierarchy true to include Out Of Hierarchy node, false or null to exclude them
   * @returns ID for the children of this node, or null if the ID is invalid
   */
  getNodeChildren(t, e) {
    return this._modelStructure.getChildIds(t, e || !1);
  }
  /**
   * Returns IDs of nodes who instance the same part as the supplied node.
   * This method should be called on nodes whose type is `PartInstance`.
   * @param id ID of a `PartInstance` node.
   * @returns Array containing `PartInstance` node IDs. These nodes all instance the same part as the supplied node.  If this method is called on a node which is not of type `PartInstance` then `null` will be returned.
   */
  getNodesInstancingSamePart(t) {
    return this._modelStructure.getPartReferrers(t);
  }
  /**
   * Returns the unit multiplier affecting the supplied node.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   * @returns The unit multiplier for the model (in mm)
   */
  getNodeUnitMultiplier(t) {
    return this._modelStructure.getUnit(t);
  }
  /**
   * Creates a CAD view. This method will trigger a "cadViewCreated" callback if the creation is successful.
   * @param id Node id to attach the created view to
   * @param viewName Name of the view
   * @param camera Camera that will be set when the view gets activated
   * @param pmiIds (optional, if undefined or null no change applied to pmis) Node IDs of the PMI to show for the view others will be hidden
   * @param nodesToShow (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility on
   * @param nodesToHide (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility off
   * @param nodeIdsAndLocalTransforms (optional, pass null or empty array if none to send) array of node ID and matrix pair, defining specific local transform to apply
   * @param cuttingPlane (optional, pass null if none to send) Cutting plane to set when the view gets activated. Distance of the planes must be in the same unit as the model.
   * @param meshInstanceData (optional, pass null if none to send) object that specifies the data for the mesh instance of the rectangular frame (mostly found on capture views)
   * @returns id of the view, null is returned if the function fails
   */
  createCadView(t, e, i, n, r, o, l, h, u) {
    n === void 0 && (n = null), r || (r = []), o || (o = []), l || (l = []), h === void 0 && (h = null), u === void 0 && (u = null);
    const f = this._modelStructure.createCadView(
      t,
      e,
      i,
      n,
      r,
      o,
      l,
      h,
      u
    );
    return f !== null && this._callbackManager.trigger("cadViewCreated", f, e), f;
  }
  /**
   * Gets CAD View information for this model.
   * @returns a map mapping associating CAD View ID to name
   */
  getCadViewMap() {
    return this._modelStructure.getCadViewMap();
  }
  /**
   * Activates a CAD View
   * @param id ID of the CAD View to activate.
   * @param duration camera transition time in milliseconds.
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @param view View to activate the CAD View in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateCadView(t, e = cs, i = !0, n = this._defaultView) {
    return this.resetModelOpacity(), this._modelStructure.activateCadView(n, t, e, i);
  }
  /**
   * Get PMI IDs for a CAD View
   * @param id ID of the CAD View
   * @returns IDs of visible PMIs for the view
   */
  getCadViewPmis(t) {
    return this._modelStructure.getCadViewPmis(t);
  }
  /**
   * Gets whether or not cad configurations are enabled
   * @returns Boolean indicating whether or not cad configurations are enabled
   */
  cadConfigurationsEnabled() {
    return this._modelStructure.cadConfigurationsEnabled();
  }
  /**
   * Gets CAD configurations
   * @returns an object mapping CAD configuration ID to config name
   */
  getCadConfigurations() {
    return this._modelStructure.getCadConfigurations();
  }
  /**
   * Gets CAD default configuration
   * @returns ID of default CAD Configuration
   */
  getDefaultCadConfiguration() {
    return this._modelStructure.getDefaultCadConfiguration();
  }
  /**
   * Gets CAD default view
   * @returns ID of default CAD Configuration
   */
  getDefaultCadView() {
    return this._modelStructure.getDefaultCadView();
  }
  /**
   * Activate the default CAD view
   * @param duration Duration of the camera animation
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @param view View to set the CAD View in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateDefaultCadView(t = cs, e = !0, i = this._defaultView) {
    return this._modelStructure.activateDefaultCadView(i, t, e);
  }
  /**
   * Gets Active CAD configuration
   * @returns ID of activated CAD Configuration
   */
  getActiveCadConfiguration() {
    return this._modelStructure.getActiveCadConfiguration();
  }
  /**
   * Get the configuration in which the view is defined
   * @returns ID of CAD Configuration of the view
   */
  getCadViewConfiguration(t) {
    return this._modelStructure.getCadViewConfiguration(t);
  }
  /**
   * Activates a CAD configuration
   * @param id ID of the CAD Configuration to activate
   * @param view View to set the CAD Configuration in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateCadConfiguration(t, e = this._defaultView) {
    return this._modelStructure.activateCadConfiguration(e, t, !0);
  }
  /**
   * Activates Default CAD configuration
   * @param fitNodes Fit view to visible nodes if possible (default true)
   * @param view View to set the CAD Configuration in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateDefaultCadConfiguration(t = !0, e = this._defaultView) {
    return this._modelStructure.activateDefaultCadConfiguration(e, t);
  }
  /**
   * Returns point attributes for a node of the given node and point.
   * @param nodeId Node to retrieve point properties from
   * @param pointIndex Index of point for which to retrieve point attributes
   * @returns Promise for the requested point attributes. Properties returned will be null if none associated with the point.
   */
  getPointAttributes(t, e) {
    return this._modelStructure.getPointAttributes(t, e);
  }
  /**
   * Returns edge count for a node of the given node.
   * @param nodeId Node to retrieve edge count from
   * @returns Promise providing the number of edges
   */
  getEdgeCount(t) {
    return this._modelStructure.getEdgeCount(t);
  }
  /**
   * Returns edge attributes for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeIndex Index of edge for which to retrieve edge attributes
   * @returns Promise for the requested edge attributes. Properties returned will be null if none associated with the edge.
   */
  getEdgeAttributes(t, e) {
    return this._modelStructure.getEdgeAttributes(t, e);
  }
  /**
   * Returns edge properties for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeid ID of edge for which to retrieve edge properties
   * @returns Promise for the requested edge properties. Properties returned will be null if none associated with the edge.
   */
  getEdgeProperty(t, e) {
    return this._modelStructure.getEdgeProperty(t, e);
  }
  /**
   * Returns face count for a node of the given node and face.
   * @param nodeId Node to retrieve face count from
   * @returns Promise providing the number of faces
   */
  getFaceCount(t) {
    return this._modelStructure.getFaceCount(t);
  }
  /**
   * Returns face attributes for a node of the given node and face.
   * @param nodeId Node to retrieve edge properties from
   * @param faceIndex Index of face for which to retrieve face attributes
   * @returns Promise for the requested face attributes. Properties returned will be null if none associated with the edge.
   */
  getFaceAttributes(t, e) {
    return this._modelStructure.getFaceAttributes(t, e);
  }
  /**
   * Returns Face properties for a node of the given node and face.
   * @param nodeId Node to retrieve face properties from
   * @param faceid ID of face for which to retrieve face properties
   * @returns Promise for the requested face properties. Properties returned will be null if none associated with the face.
   */
  getFaceProperty(t, e) {
    return this._modelStructure.getFaceProperty(t, e);
  }
  /**
   * Set edge property for a node of the given node and edge.
   * @param id Node to set edge properties to
   * @param edgeid ID of edge
   * @param prop property (CircleElement, LineElement...)
   */
  setEdgeProperty(t, e, i) {
    this._modelStructure.setEdgeProperty(t, e, i);
  }
  /**
   * Set face property for a node of the given node and face.
   * @param id Node to set edge properties to
   * @param faceid ID of face
   * @param prop property (CylinderElement, PlaneElement...)
   */
  setFaceProperty(t, e, i) {
    this._modelStructure.setFaceProperty(t, e, i);
  }
  /**
   * Fetch the mesh data for a particular node
   * @param nodeId the node's ID
   */
  async getNodeMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.None
    );
    if (e.length === 0) throw new oe("Node does not refer to a mesh instance");
    if (e.length > 2) throw new oe("Node refers to multiple mesh instances");
    const i = e, n = await this._engine.getInstancesMeshData(i);
    if (n[1] === vc.Invalid)
      throw new oe("Node has instance, but no mesh data");
    return this._engine.getMeshData(n);
  }
  /**
   * Fetch the mesh data for any capping geometry on a particular node
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodeCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.None
    );
    if (e.length === 0) throw new oe("Node does not refer to a mesh instance");
    if (e.length > 2) throw new oe("Node refers to multiple mesh instances");
    const i = e, n = await this._engine.getInstancesCappingMeshData(i);
    return n[1] === vc.Invalid ? null : this._engine.getMeshData(n);
  }
  /**
   * Fetch the mesh data for any capping geometry on a list of nodes and their children
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodesCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    ), i = await this._engine.getInstancesCappingMeshData(e), n = [];
    for (let r = 1; r < i.length; r += 2)
      if (i[r] !== vc.Invalid) {
        const o = [i[r - 1], i[r]], l = await this._engine.getMeshData(o);
        n.push(l);
      }
    return n;
  }
  /**
   * Returns a copy of the Matrix for a node of the given ID
   * @param id Node to retrieve matrix from
   * @returns Copy of the Matrix of the node
   */
  getNodeMatrix(t) {
    return this._modelStructure.getMatrix(t);
  }
  /**
   * Sets Matrix for a node of the given ID
   * @param id Node to set matrix on
   * @param Matrix of the Node
   * @param setAsInitial tells if you want to change the node initial matrix or not
   */
  setNodeMatrix(t, e, i = !1) {
    return this._modelStructure.setMatrix(t, e, i);
  }
  /**
   * Used by Animation system to efficiently update the matrix of many nodes at once.
   * Currently not part of public API due to difference in signature with other bulk operations which use Map based parameter.
   * @hidden
   */
  _setNodesMatrices(t, e, i = !1) {
    return this._modelStructure.setMatrices(t, e, i);
  }
  /**
   * Reset node matrix to the one set as the initial one
   * @param id Node to set matrix on
   */
  resetNodeMatrixToInitial(t) {
    return this._modelStructure.resetToInitialMatrix(t);
  }
  /**
   * Returns net matrix for a node of the given ID
   * @param id Node to retrieve net matrix from
   * @returns Net Matrix of the Node
   */
  getNodeNetMatrix(t) {
    return wt.createFromArray(this._modelStructure.getNetMatrix(t));
  }
  /**
   * Returns the parent Id for the given node id.
   * @param id node id to get the parent of
   * @returns ID of the parent node for the supplied ID. If the ID is invalid or the root ID, null is returned.
   */
  getNodeParent(t) {
    return this._modelStructure.getParentId(t);
  }
  /**
   * Returns the type of the node with the given ID.
   * @param id The ID of the node to get the type for.
   * @returns The type of the node.
   */
  getNodeType(t) {
    return this._modelStructure.getType(t);
  }
  /**
   * Returns the properties for the given node ID.
   * @param id Node ID to get the parent of
   * @param computeFromChildren If true physical properties will be computed from child nodes.
   * @returns object properties for the supplied ID, or null if the ID was invalid
   */
  getNodeProperties(t, e = !0) {
    return this._modelStructure.getProperties(t, e);
  }
  /**
   * Purpose: Adds a property to the node
   * @Param nodeId node id to set the property on
   * @Param property name
   * @Param property value
   * @returns true if all went right, false otherwise
   */
  addPropertyToNode(t, e, i, n) {
    return this._modelStructure.addProperty(t, e, i, n);
  }
  /**
   * Purpose: Sets physical properties
   * @Param nodeId node id to set the property on, the node id has to be a body node
   * @Param gravityCenter gravity center in local coordinates
   * @Param surfaceArea surface area, in squared current unit
   * @Param volume volume, in cubed current unit
   * @returns true if all went right, false otherwise
   */
  setPhysicalProperties(t, e, i, n) {
    return this._modelStructure.setPhysicalProperties(t, e, i, n);
  }
  /**
   * Specifies nodes for the system to load. This method is useful when the viewer was created with the <code>streamOnDemand</code> option set to true.
   * @param nodeIds array of unique IDs for the system to load
   */
  requestNodes(t) {
    return this._modelStructure.requestNodes(t);
  }
  /**
   * Returns the name for a node in the assembly tree.
   * @param nodeId The node ID to get the name of.
   * @returns The name of the node with the given nodeId or null if no name is found.
   */
  getNodeName(t) {
    return this._modelStructure.getName(t) || null;
  }
  /**
   * Returns the Exchange ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The Exchange ID of the node with the given nodeId or null if no Exchange ID is found.
   */
  getNodeExchangeId(t) {
    return this._modelStructure.getNodeExchangeId(t);
  }
  /**
   * Returns names and ids of all filters available in the scene
   * @returns a map associating Filter IDs to filter names
   */
  getFilters() {
    return this._modelStructure.getFilters();
  }
  /**
   * @returns The name of a filter for the given filter ID index or null if filter was not found
   */
  getFilterName(t) {
    return this._modelStructure.getFilterName(t);
  }
  /**
   * @param nodeId The ID of the node to query.
   * @returns Filters which retain or remove the given node.
   */
  getFiltersWithNode(t) {
    return this._modelStructure.getFiltersWithNode(t);
  }
  /**
   * @param filtersId array of filters indexes to take in account
   * @returns nodesId of nodes retained by the given filter indices and the type of filter (inclusive or not). Returns null if no filter is found.
   */
  getNodesFromFiltersId(t) {
    return this._modelStructure.getNodesFromFilterIds(t);
  }
  /**
   * Returns names and ids of all layers available in the scene
   * @returns a map associating Layer IDs to Layer names
   */
  getLayers() {
    return this._modelStructure.getLayers();
  }
  /**
   * Return names of layers. Different layers can have the same name. Some layers can be unnamed.
   * @returns Names of layers
   */
  getUniqueLayerNames() {
    return this._modelStructure.getUniqueLayerNames();
  }
  /**
   * @returns The name of a layer for the given filter ID or null if layer was not found
   */
  getLayerName(t) {
    return this._modelStructure.getLayerName(t);
  }
  /**
   * @returns Id of layers for the given filter name or null if no layers are found
   */
  getLayerIdsFromName(t) {
    return this._modelStructure.getLayerIdsFromName(t);
  }
  /**
   * Returns the layer ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The layer ID of the node with the given nodeId or null if no layer is found.
   */
  getNodeLayerId(t) {
    return this._modelStructure.getNodeLayerId(t);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layerId The layer ID to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerId or null if no layers are found.
   */
  getNodesFromLayer(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayer(t, e);
  }
  /**
   * Returns IDs of nodes in given layers.
   * @param layersId Array of layers Id to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with one of the given layerId or null if no layers are found.
   */
  getNodesFromLayers(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayers(t, e);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layer name the name of layer to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerName or null if no layers are found.
   */
  getNodesFromLayerName(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayerName(t, e);
  }
  /**
   * Returns the current visibility for a node.
   * @param nodeId ID of the node to get visibility for.
   * @returns true if the current node's visibility state is on or false if it is not.
   */
  getNodeVisibility(t) {
    return this._modelStructure.isVisible(t);
  }
  /**
   * Branch visibility indicates the visibility state for all of a node's children.
   * @param nodeId ID of the node at the root of the branch.
   * @returns Shown/Hidden if all children have the same visibility state, Mixed otherwise.
   */
  getBranchVisibility(t) {
    const e = this._modelStructure.getBranchVisibility(t);
    return e === ue.Shown ? ue.Shown : e === ue.Hidden ? ue.Hidden : (console.assert(e === ue.Mixed), ue.Mixed);
  }
  /**
   * Returns a data object. During the authoring phase, a user can store general data within a model. (This is how
   * properties are stored, for example.) This function allows you to retrieve the data from the client application.
   *
   * @see {@link https://docs.techsoft3d.com/communicator/latest/api_ref/data_import/libsc/classSC_1_1Store_1_1Model.html#_CPPv4N2SC5Store5Model6InsertE8uint32_tPK7uint8_t8uint32_t Model::Insert}
   *
   * @param an Array of ModelKey-DataKey pairs ([ModelKey, DataKey, ModelKey, DataKey, ModelKey, DataKey...]
   * @returns promise that resolves when this operation has completed returning an array of 8bits int arrays for each ModelKey-DataKey pairs
   */
  getDataFromIds(t) {
    return this._engine.getDataFromIds(t);
  }
  /**
   * @param meshData [[MeshData]] object containing data to insert into the scene.
   * @returns Promise that resolves with a [[MeshId]] when the mesh has been created. The [[MeshId]] can be used to create instances of the mesh using [[createMeshInstance]].
   */
  async createMesh(t, e) {
    const i = await this._engine.createMesh(t);
    return e && e.doNotDelete && this._preventMeshDeletion(i), i;
  }
  static _flatArrayToPairArray(t) {
    const e = [];
    for (let i = 0; i < t.length; i += 2)
      e.push([t[i], t[i + 1]]);
    return e;
  }
  static _pairArrayToFlatArray(t) {
    const e = [];
    for (const i of t)
      e.push(i[0], i[1]);
    return e;
  }
  /**
   * Retrieve the [[MeshId]] associated with the mesh data attached to the given nodes.
   */
  async getMeshIds(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    ), i = await this._engine.getInstancesMeshData(e);
    return Pc._flatArrayToPairArray(i);
  }
  /**
   * Replace a mesh's data. This will affect all instances of that mesh.
   * @param key the [[MeshId]] identifying the mesh
   * @param data the new data
   */
  replaceMesh(t, e) {
    return this._engine.replaceMesh(t, e);
  }
  /**
   * Creates an instance of a mesh that has been created using [[createMesh]] or retrieved using [[getMeshIds]].
   * @param data object that specifies the data for this mesh instance
   * @param parentNodeId the ID of the desired parent node
   * @param preventFromResetting if set to true, then the visibility and positioning won't be reset when resetxxx() functions gets called.
   * @param isOutOfHierarchy True if the node created shouldn't appear in the model structure.
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance.
   */
  createMeshInstance(t, e, i, n) {
    return e === void 0 && (e = null), i || (i = !1), n || (n = !1), this._createMeshInstance(t, e, i, n);
  }
  async _createMeshInstance(t, e, i, n) {
    const r = t.getMatrix(), o = r !== null || e !== null;
    let l = t.getCreationFlags();
    i && (l |= ee.DoNotReset), console.assert(
      !e || !n,
      "Out of hierarchy instances should not have a parent node."
    );
    const h = e === null || this.getNodeVisibility(e);
    let u = t;
    (o || !h) && (u = t.copy(), u.setCreationFlags(l | ee.Invisible));
    const f = await this._engine.createMeshInstance(u), g = this._modelStructure.createMeshInstance(
      f[0],
      f[1],
      t.getInstanceName(),
      e,
      i,
      n,
      !1
    );
    if (o || !h) {
      const x = r || new wt();
      await this.setNodeMatrix(g, x, !0), (l & ee.Invisible) === 0 && h && this._engine.setPartVisibility(f, !0, !0);
    }
    let y = h;
    (l & ee.Invisible) !== 0 && (y = !1);
    const _ = this._modelStructure.lookupAnyTreeNode(g);
    return _ !== null && _.setVisibility(y), e !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [g],
      uo.CreateInstance
    ), g;
  }
  /**
   * Creates a PMI Instance from a mesh that has been created using the createMesh method.
   * @param data object that specifies the data for the PMI graphic representation
   * @param pmiType see PmiType enum (Datum, Gdt, Dimension...)
   * @param pmiSubType see PmiSubType enum (DatumTarget, GdtFcf, DimensionDistance...)
   * @param refOnTopoItems see RefOnTopoItem. It defines the PMI links to a body element, like a face or an edge
   * @param parentNodeId the ID of the desired parent node
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance. You can use deleteMeshInstances() to delete the PMI
   */
  async createPmiInstance(t, e, i, n, r) {
    r === void 0 && (r = null);
    const o = [];
    for (const u of n) {
      const f = this._modelStructure.lookupBodyInstance(u.bodyId);
      if (f === null)
        throw new Ns(u.bodyId);
      const g = gl.fromBodyInstance(
        f,
        u.subElementType,
        u.subElementIndex
      );
      o.push(g);
    }
    const l = await this._engine.createMeshInstance(t), h = this._modelStructure.createPmiInstance(
      l[0],
      l[1],
      e,
      i,
      o,
      t.getInstanceName(),
      r
    );
    return r !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [h],
      uo.CreatePmi
    ), h;
  }
  /**
   * Creates an image that can be applied as a texture via [[setNodesTexture]].
   * See [[deleteImages]].
   * @param primaryImage The image data and associated options
   * @param thumbnailImage If specified, an uncompressed image that will be used as a
   *                       placeholder for the primary image until it is fully loaded.
   *                       Only useful when `primaryImage` is a compressed image.
   */
  createImage(t, e) {
    return this._engine.createImage(t, e);
  }
  /**
   * Deletes images created with [[createImage]].
   * @param imageIds The IDs of the images to be deleted
   */
  deleteImages(t) {
    return this._engine.destroyImages(Pc._pairArrayToFlatArray(t));
  }
  /**
   * Apply an image to a node as a texture map. See [[createImage]] and [[unsetNodesTexture]].
   * @param nodeIds The nodes on which to apply the texture
   * @param options Options specifying how the texture is applied
   */
  setNodesTexture(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.setTexture(i, e);
  }
  /**
   * Remove one or more textures applied via [[setNodesTexture]].
   * @param nodeIds The nodes from which to remove the texture or textures
   */
  unsetNodesTexture(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    this._engine.unsetTexture(e);
  }
  /**
   * Deletes meshes that have been created at run time.
   *
   * In order for this method to succeed, all mesh instances created for the given IDs
   * must have also been destroyed with [[deleteMeshInstances]].
   *
   * @param meshIds The IDs of meshes that should be deleted
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshes(t) {
    return this._engine.destroyMeshes(Pc._pairArrayToFlatArray(t));
  }
  /**
   * Deletes mesh instances that have been created at run time
   * @param nodeIds array of IDs for mesh instances created at run time that should be destroyed
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshInstances(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    ), i = [];
    if (e.length > 0) {
      for (const n of t)
        i.push(this._modelStructure.deleteNode(n));
      i.push(this._engine.destroyLocalInstances(e));
    }
    return We(i);
  }
  _obtainLoadSubtreeConfig(t) {
    if (t[0] instanceof Ma)
      return t[0].copy();
    {
      const e = new Ma();
      return e.additionalMatrix = t[0] || null, e.allowMissingExternalModels = !!t[1], e.copy();
    }
  }
  loadSubtreeFromXmlFile(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = gu), this._modelStructure.loadSubtreeFromXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromXmlBuffer(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = gu), this._modelStructure.loadSubtreeFromXmlDoc(t, e, i, r);
  }
  loadSubtreeFromScsXmlFile(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = gu), this._modelStructure.loadSubtreeFromScsXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromScsXmlBuffer(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = gu), this._modelStructure.loadSubtreeFromScsXmlDoc(t, e, i, r);
  }
  loadSubtreeFromModel(t, e, ...i) {
    const n = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromStream(t, e, n);
  }
  loadSubtreeFromScsFile(t, e, ...i) {
    const n = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsFile(t, e, n);
  }
  loadSubtreeFromScsBuffer(t, e, ...i) {
    const n = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsBuffer(t, e, n);
  }
  /**
   * Loads measurement data from a JSON object
   * @param json JSON object containing measurement data
   */
  loadMeasurementFromJson(t) {
    return this._modelStructure.loadMeasurementFromJson(t);
  }
  /**
   * Loads measurement data from a JSON string
   * @param str JSON string containing measurement data
   */
  loadMeasurementFromString(t) {
    return this._modelStructure.loadMeasurementFromString(t);
  }
  /**
   * Loads measurement data from a ZIP file
   * @param filename Name of a file containing ZIP measurement data
   */
  loadMeasurementFromFile(t) {
    return this._modelStructure.loadMeasurementFromFile(t);
  }
  /**
   * Delete all the current scene and load the specified model instead. Also triggers a "modelSwitched" when finished.
   * @param newModelFilename Name of the model file to load after the existing scene gets deleted
   * @returns A `Promise` of the newly loaded model's root nodes IDs.
   */
  switchToModel(t) {
    return this._callbackManager.trigger("modelLoadBegin"), this._modelStructure.switchToModel(t);
  }
  /**
   * Creates a node
   * @param parentNodeId ID of the node to link the child node to. This ID should not have a type of Body or BodyInstance. If this parameter is `undefined`, the child node will be linked to the root.
   * @param name of the node to create
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored a new one will be set automatically.
   * @param localMatrix (optional) Initial local matrix of the node (identity if none set)
   * @param visibility (optional) Initial visibility of the node (visible if nothing set)
   * @param measurmentUnit (optional) Specifies optional measurement units for this node. When set to null (the default), the node will inheret the unit setting of the parent node. If set, a scaling matrix will be computed
   *    that scales appropriately based on the unit scaling and applied to the newly created node. If a non-null localMatrix has been specified, that matrix will be combined with the computed scaling matrix.
   * @returns child node ID
   */
  createNode(t, e, i, n, r, o) {
    t === void 0 && (t = null), i === void 0 && (i = null), n === void 0 && (n = null), r == null && (r = !0);
    const l = this._modelStructure.createNode(
      t,
      e,
      i,
      n,
      r,
      o
    );
    return l !== null && this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [l],
      uo.CreateNode
    ), l;
  }
  /**
   * Delete a node and all its children
   * @param ID of the node
   */
  async deleteNode(t) {
    const e = this._modelStructure.gatherInclusionKeysFromNodeIds([t]);
    await this._modelStructure.deleteNode(t), await this._engine.detachInclusions(e), this._callbackManager.trigger("subtreeDeleted", [t]);
  }
  /**
   * Creates an part node
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored and new one will be set automatically.
   * @returns a node ID to access the created part node
   */
  createPart(t) {
    return t === void 0 && (t = null), this._modelStructure.createPart(t);
  }
  /**
   * Set a part on an assembly node
   * @param assemblyNodeID ID of the assembly node
   * @param partNodeID ID of the part node
   * @returns true if all went right, false otherwise
   */
  setPart(t, e) {
    return t == null || e == null ? !1 : this._modelStructure.setPart(t, e);
  }
  /**
   * Creates a representation item on a part
   * @param partNodeId ID of the part node
   * @param repItemId (optional) Id you want the node to have, if not specified the nodeId will be set automatically. Be aware that if the specified node Id is already used by another node, then it will be ignored and a new one will be set automatically.
   * @returns node ID to access the created representation item, null is returned if something went wrong
   */
  createAndAddRepresentationItem(t, e) {
    return t == null ? null : (e === void 0 && (e = null), this._modelStructure.createAndAddRepItem(t, e));
  }
  /**
   * Returns the lowest available node ID
   */
  getLowestAvailableNodeId() {
    return this._modelStructure.getLowestAvailableNodeId();
  }
  /**
   * Allows changing the behavior in the viewer
   * @param instanceModifier InstanceModifier
   * @param nodeIds Array of node ids
   * @param value boolean
   */
  setInstanceModifier(t, e, i) {
    return this._setInstanceModifier(t, e, i, Wt.All), Promise.resolve();
  }
  /** @hidden */
  _setInstanceModifier(t, e, i, n) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      e,
      n,
      Vt.None
    );
    r.length > 0 && this._engine.setInstanceModifier(t, r, i);
  }
  /**
   * Returns the SC ID of a body instance
   * @param nodeId node instance ID. This must be a body node
   * @returns SC instance ID, a pair of numbers consisting of the inclusion ID and the instance ID. null is returned if the function fails.
   */
  getScInstanceKey(t) {
    const e = this._modelStructure.lookupBodyInstance(t);
    return e !== null ? e.getInstanceInc() : null;
  }
  /**
   * Returns the body node instance ID for the given SC instance ID
   * @returns body node instance ID
   */
  getNodeIdFromScInstanceKey(t, e) {
    return this._modelStructure.getNodeFromInstanceInc(
      !1,
      t,
      e,
      !1
    );
  }
  getAssociatedModelKey(t) {
    const e = this._modelStructure.getAssociatedModelKey(t);
    return Promise.resolve(e);
  }
  hasDepthRange(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.hasDepthRange(e);
  }
  /**
   * Remaps the depth values used for z-ordering of pixels to the given
   * range, which must be a subset of `[0,1]`. The depth value at the
   * near plane (normally `0`) is mapped to `min` and the value at
   * the far plane (normally `1`) is mapped to `max`.
   *
   * The smaller the range, the more z-fighting you will see among
   * objects set to that range.
   *
   * @param nodeIds the node IDs to operate on
   * @param min the depth value at the near plane
   * @param max the depth value at the far plane
   */
  setDepthRange(t, e, i) {
    return this._setDepthRange(t, e, i), Promise.resolve();
  }
  _setDepthRange(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    this._engine.setDepthRange(n, e, i);
  }
  /**
   * Unsets the depth range set by [[setDepthRange]].
   * @param nodeIds the node IDs to operate on
   */
  unsetDepthRange(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    this._engine.unsetDepthRange(e);
  }
  /** @hidden */
  _gatherInstanceIncsFromNodeIds(t, e = Wt.All) {
    return this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      e,
      Vt.None
    );
  }
  _getInstanceIncsFromLeafNodes(t) {
    const e = [];
    for (const i of t) {
      const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
        [i],
        Wt.All,
        Vt.None
      );
      if (n.length === 2) {
        const r = n;
        e.push(r[0], r[1]);
      } else
        throw new oe("Non-leaf node encountered");
    }
    return e;
  }
  _getInstanceIncFromSingleLeafNode(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      Wt.All,
      Vt.None
    );
    if (e.length === 2)
      return e;
    throw new oe("Non-leaf node encountered");
  }
  /**
   * Sets the desired mesh level
   * @param nodeIds IDs of nodes in the assembly on which mesh level will be set
   * @param meshLevel 0 standard, 1 low, 2 extra low
   * @returns Promise that resolves when the operation has completed.
   */
  setMeshLevel(t, e) {
    return this._modelStructure.setMeshLevel(t, e), Promise.resolve();
  }
  /**
   * Sets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will be upgraded to use this mode.
   * @param nodeIds List of nodes to set material properties for
   * @param metallicFactor The metalness of the material
   * @param roughnessFactor The roughness of the material
   */
  setMetallicRoughness(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    this._engine.setMetallicRoughness(n, e, i);
  }
  /**
   * Gets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will have a null entry
   * @param nodeIds List of nodes to get material properties for
   */
  getMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return this._engine.getMetallicRoughness(e);
  }
  /**
   * Unsets the metallic and roughness values set with [[setMetallicRoughness]]
   * These materials will no longer use the Metallic Roughness shading model.
   * @param nodeIds List of nodes to unset material properties for
   */
  unsetMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    this._engine.unsetMetallicRoughness(e);
  }
  /**
   * If enabled then models loaded into an existing scene with a different unit value will be scaled to the unit value of the current scene.
   * @param enabled value indicating if automatic unit scaling will be active
   */
  setEnableAutomaticUnitScaling(t) {
    return this._modelStructure.setEnableAutomaticUnitScaling(t);
  }
  /**
   * By default, objects that are initially hidden stays hidden unless specifically set to be shown. This function allows this behavior to be disabled.
   * @param enabled value indicating if initially hidden objects stay hidden
   */
  setBehaviorInitiallyHidden(t) {
    return this._modelStructure.setBehaviorInitiallyHidden(t);
  }
  /**
   * Tells if the model is a CAD drawing or not
   * @returns true if the model is a CAD drawing
   */
  isDrawing() {
    return this._modelStructure.isACadDrawing();
  }
  /**
   * @returns true if the model contains measurement data.
   */
  isMeasurable() {
    return this._modelStructure.isMeasurable();
  }
  /**
   * @param bodyId ID of the body node containing the line
   * @param lineIndex Index of the line ot be checked
   * @returns true if the line has associated measurement data
   */
  isLineMeasurable(t, e) {
    return this._modelStructure.isLineMeasurable(t, e);
  }
  isFaceMeasurable(t, e) {
    return this._modelStructure.isFaceMeasurable(t, e);
  }
  /**
   * @returns the original file name of the model which contain the given node or null if the node is not found.
   */
  getModelFileNameFromNode(t) {
    return this._modelStructure.getModelFileNameFromNode(t);
  }
  /**
   * @returns the original file type of the model which contain the given node or null if the node is not found.
   */
  getModelFileTypeFromNode(t) {
    return this._modelStructure.getModelFileTypeFromNode(t);
  }
  /**
   * @returns the generic type of the given node or null if the node is not found.
   */
  getNodeGenericType(t) {
    return this._modelStructure.getNodeGenericType(t);
  }
  /**
   * @returns the generic id of the given node or null if the node is not found.
   */
  getNodeGenericId(t) {
    return this._modelStructure.getNodeGenericId(t);
  }
  /**
   * This function recursively discovers BIM nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @param attributeToMask The callback used to obtain a node's [[BimMask]] from its attributes.
   * @returns Promise that resolves when the operation has completed.
   */
  async registerBimNodes(t, e, i = null) {
    const n = this._modelStructure.lookupAnyTreeNode(t);
    if (n !== null)
      return typeof i == "boolean" && (i = i ? "TYPE" : null), db(
        e,
        this._engine,
        this._modelStructure,
        n,
        i
      );
  }
  /**
   * Gets all generic types and NodeIds with that type.
   * @returns Map containing generic types and NodeIds
   */
  getGenericTypeIdMap() {
    return this._modelStructure.getGenericTypeIdMap();
  }
  /**
   * This function returns all NodeIds with an IFC type.
   * @param genericType
   * @returns All NodeIds with an IFC type
   */
  getNodesByGenericType(t) {
    return this._modelStructure.getNodesByGenericType(t);
  }
  /**
   * This function gets all generic types contained in the model.
   * @returns All generic types.
   */
  getGenericTypes() {
    return this._modelStructure.getGenericTypes();
  }
  /**
   * Checks if a [[NodeId]] is a generic type.
   * @param nodeId
   * @param genericType
   */
  hasEffectiveGenericType(t, e) {
    return this._modelStructure.hasEffectiveGenericType(t, e);
  }
  /**
   * This function recursively discovers IFC nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @returns Promise that resolves when the operation has completed.
   */
  registerIfcNodes(t, e = null) {
    return this.registerBimNodes(t, ab, e);
  }
  /**
   * Tells if the view is an annotation view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is an annotation view
   */
  isAnnotationView(t) {
    return this._modelStructure.isAnnotationView(t);
  }
  /**
   * Tells if the view is a combine state view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is a combine state view
   */
  isCombineStateView(t) {
    return this._modelStructure.isCombineStateView(t);
  }
  /**
   * Sets a vector and angle used to determine an object's visibility based on camera orientation.
   * @param space The space in which the culling vector is defined.
   * @param vector A vector that will be compared with the view vector.
   * @param toleranceDegrees The maximum angle between the culling vector and the view vector within which the object will be visible.
   */
  setNodesCullingVector(t, e, i, n) {
    return this._setNodesCullingVector(t, e, i, n), Promise.resolve();
  }
  _setNodesCullingVector(t, e, i, n) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    return this._engine.setCullingVector(r, e, i, n);
  }
  /**
   * Unsets the vector and angle used to determine an object's visibility based on camera orientation.
   * @param nodeIds The nodes to unset culling vectors on.
   */
  unsetNodesCullingVectors(t) {
    return this._unsetNodesCullingVectors(t), Promise.resolve();
  }
  _unsetNodesCullingVectors(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    );
    this._engine.unsetCullingVector(e);
  }
  /**
   * Retrieves the vector and angle used to determine an object's visibility based on camera orientation.
   * If unset, `null` will appear at the corresponding array index.
   * @param nodeIds The nodes to query culling vectors from.
   * @returns A promise of culling vectors.
   */
  getNodesCullingVectors(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.getCullingVector(e);
  }
  /**
   * Retrieves the node ID offset for a given node.
   * @param nodeId The node to obtain the node ID offset from.
   * @returns The node ID offset for the supplied node.
   */
  getNodeIdOffset(t) {
    return this._modelStructure.getIdOffset(t);
  }
  /**
   * Queries if a node is fully loaded or not.
   * @param nodeId The node to query.
   * @returns True if the node is fully loaded; false otherwise.
   */
  isNodeLoaded(t) {
    return this._modelStructure.isNodeLoaded(t);
  }
  /**
   * Triangulates the supplied polygon.
   * @param polygonPoints An array of point data for the polygon. Points are stored [XYZXYZXYZ...] format.
   * @param normal The normal of the polygon to triangulate.
   * @returns An array containing the point data for the generated triangles. Points are stored [XYZXYZXYZ...] format.
   *          This returned list is always divisible by 9 (3 points per triangle; 3 floats per point).
   */
  triangulatePolygon(t, e) {
    const i = pl(e);
    return this._engine.triangulatePolygon(t, i);
  }
  /**
   * Applies the given line pattern to the specified nodes. See also [[unsetNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   * @param pattern The line pattern. See [[LinePattern]] for details.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the length of the pattern is measured. See [[LinePatternLengthUnit]] for details.
   */
  setNodesLinePattern(t, e, i, n) {
    const r = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.setLinePattern(r, e, i, n);
  }
  /**
   * Removes the line pattern applied by [[setNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   */
  unsetNodesLinePattern(t) {
    const e = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.unsetLinePattern(e);
  }
  /** @hidden */
  async _hwfAwaitAssemblyTreeReady() {
    const t = this.getAbsoluteRootNode(), e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new oi();
    const i = Ys(e);
    await Ln.forceLazyPromises(i), await pa([i]);
  }
  /**
   * Returns all the `UserDataIndex` items associated with the input node.
   * @param nodeId The ID of the node to query.
   * @returns A list of `UserDataIndex`, possibly empty.
   * @throws `InvalidNodeIdError`
   */
  getNodeUserDataIndices(t) {
    return this._modelStructure.getUserDataIndices(t);
  }
  /**
   * Returns the user data for a given node and index.
   * @param nodeId The ID of the node to query.
   * @param index The index of the data.
   * @returns The user data.
   * @throws `InvalidNodeIdError` `InvalidIndexError`
   */
  getNodeUserData(t, e) {
    return this._modelStructure.getUserData(t, e);
  }
  /**
   * Returns a list of node IDs given a list of generic IDs. Note that the
   * returned list of node IDs may be longer than the provided list of generic
   * IDs since one ID can be used by more than one node.
   * @param genericIds Array of generic IDs to find nodes fore
   * @returns Array of node ids corresponding to the provided generic IDs
   */
  getNodeIdsByGenericIds(t) {
    const e = [];
    for (const i of t) {
      const n = this._modelStructure.getNodesByGenericId(i);
      n !== null && n.forEach((r) => {
        e.push(r);
      });
    }
    return e;
  }
  /** @hidden */
  _getModelStructure() {
    return this._modelStructure;
  }
  /**
   * Returns true if the node is within an external model.
   * @param nodeId
   */
  isWithinExternalModel(t) {
    return this._modelStructure.isWithinExternalModel(t);
  }
  /** @hidden */
  _firstAssemblyDataHeader() {
    return this._modelStructure.firstAssemblyDataHeader();
  }
  /**
   * Retrieves the bim id of the corresponding node id.
   * @param node the id of the node for which you want its bim id.
   * @returns the bim id corresponding to the node or null if none.
   */
  getBimIdFromNode(t) {
    return this._modelStructure.getBimIdFromNode(t);
  }
  /**
   * Retrieves the bim ids of the corresponding generic id.
   * @param ifcGuid the generic id for which you want its bim id.
   * @returns the bim id corresponding to the ifcGuid or null if none.
   */
  getBimIdsFromGenericId(t) {
    const e = [], i = this._modelStructure.getNodesByGenericId(t);
    return i !== null && i.forEach((n) => {
      const r = this.getBimIdFromNode(n);
      r !== null && e.push(r);
    }), e;
  }
  /**
   * Retrieves the node id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimID bim id for which you want its node id.
   * @returns the node id corresponding to the BimId or null if none.
   */
  getNodeIdFromBimId(t, e) {
    return this._modelStructure.getRuntimeNodeFromBimId(t, e);
  }
  /**
   * Retrieves the generic id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its generic id.
   * @returns the generic id corresponding to the BimId or null if none.
   */
  getGenericIdFromBimId(t, e) {
    const i = this._modelStructure.getRuntimeNodeFromBimId(t, e);
    return i !== null ? this._modelStructure.getNodeGenericId(i) : null;
  }
  /**
   * Retrieves all type of relationships that a bim id has.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its types of relationships.
   * @returns array of type of relationship corresponding to the BimId.
   */
  getRelationshipTypesFromBimId(t, e) {
    const i = [], n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      i.push(r.type);
    return i;
  }
  /**
   * Retrieve all related relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its related relationships.
   * @returns array of bim id which are the related relationship of the BimId.
   */
  getBimIdRelatedElements(t, e, i) {
    const n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      if (r.type === i)
        return r.relateds;
    return [];
  }
  /**
   * Retrieve all relating relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relating relationships.
   * @returns array of bim id which are the relating relationship of the BimId.
   */
  getBimIdRelatingElements(t, e, i) {
    const n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      if (r.type === i)
        return r.relatings;
    return [];
  }
  /**
   * Retrieve all relationships that a bim id have, sorted in 2 arrays (relateds and relatings)
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relationships.
   * @returns double array of bim id of relationship of the BimId sorted by its relateds and its relatings.
   */
  getBimIdConnectedElements(t, e, i) {
    const n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      if (r.type === i)
        return { relateds: r.relateds, relatings: r.relatings };
    return { relateds: [], relatings: [] };
  }
  /**
   * Retrieve the name of the bim element
   * @param bimId bim id for which you want the bim element name.
   * @param node any known node id of the working model.
   * @returns the name and the info regarding the connection to a node of the bim element.
   */
  getBimInfoFromBimId(t, e) {
    return this._modelStructure.getInfoOfBimId(t, e);
  }
}
var bb = /* @__PURE__ */ ((s) => s)(bb || {}), xb = /* @__PURE__ */ ((s) => s)(xb || {}), uo = /* @__PURE__ */ ((s) => (s[s.LoadModel = 0] = "LoadModel", s[s.CreateNode = 1] = "CreateNode", s[s.CreateInstance = 2] = "CreateInstance", s[s.CreatePmi = 3] = "CreatePmi", s))(uo || {}), Ib = /* @__PURE__ */ ((s) => (s[s.Desktop = 0] = "Desktop", s[s.Mobile = 1] = "Mobile", s))(Ib || {}), Jt = /* @__PURE__ */ ((s) => (s[s.Faces = 0] = "Faces", s[s.Lines = 1] = "Lines", s[s.Points = 2] = "Points", s))(Jt || {}), ri = /* @__PURE__ */ ((s) => (s[s.Perspective = 0] = "Perspective", s[s.Orthographic = 1] = "Orthographic", s))(ri || {}), Ct = /* @__PURE__ */ ((s) => (s[s.Top = 0] = "Top", s[s.Bottom = 1] = "Bottom", s[s.Left = 2] = "Left", s[s.Right = 3] = "Right", s[s.Front = 4] = "Front", s[s.Back = 5] = "Back", s[s.Iso = 6] = "Iso", s[s.TopRightFront = 7] = "TopRightFront", s[s.TopLeftFront = 8] = "TopLeftFront", s[s.TopLeftBack = 9] = "TopLeftBack", s[s.TopRightBack = 10] = "TopRightBack", s[s.TopBack = 11] = "TopBack", s[s.TopFront = 12] = "TopFront", s[s.TopLeft = 13] = "TopLeft", s[s.TopRight = 14] = "TopRight", s[s.BottomRightBack = 15] = "BottomRightBack", s[s.BottomLeftBack = 16] = "BottomLeftBack", s[s.BottomLeftFront = 17] = "BottomLeftFront", s[s.BottomRightFront = 18] = "BottomRightFront", s[s.BottomFront = 19] = "BottomFront", s[s.BottomBack = 20] = "BottomBack", s[s.BottomLeft = 21] = "BottomLeft", s[s.BottomRight = 22] = "BottomRight", s[s.RightBottomBack = 23] = "RightBottomBack", s[s.RightBottomFront = 24] = "RightBottomFront", s[s.RightTopFront = 25] = "RightTopFront", s[s.RightTopBack = 26] = "RightTopBack", s[s.RightTop = 27] = "RightTop", s[s.RightBottom = 28] = "RightBottom", s[s.RightFront = 29] = "RightFront", s[s.RightBack = 30] = "RightBack", s[s.LeftBottomFront = 31] = "LeftBottomFront", s[s.LeftBottomBack = 32] = "LeftBottomBack", s[s.LeftTopBack = 33] = "LeftTopBack", s[s.LeftTopFront = 34] = "LeftTopFront", s[s.LeftTop = 35] = "LeftTop", s[s.LeftBottom = 36] = "LeftBottom", s[s.LeftBack = 37] = "LeftBack", s[s.LeftFront = 38] = "LeftFront", s[s.FrontBottomRight = 39] = "FrontBottomRight", s[s.FrontTopRight = 40] = "FrontTopRight", s[s.FrontTopLeft = 41] = "FrontTopLeft", s[s.FrontBottomLeft = 42] = "FrontBottomLeft", s[s.FrontRight = 43] = "FrontRight", s[s.FrontLeft = 44] = "FrontLeft", s[s.FrontTop = 45] = "FrontTop", s[s.FrontBottom = 46] = "FrontBottom", s[s.BackTopRight = 47] = "BackTopRight", s[s.BackBottomRight = 48] = "BackBottomRight", s[s.BackBottomLeft = 49] = "BackBottomLeft", s[s.BackTopLeft = 50] = "BackTopLeft", s[s.BackLeft = 51] = "BackLeft", s[s.BackRight = 52] = "BackRight", s[s.BackBottom = 53] = "BackBottom", s[s.BackTop = 54] = "BackTop", s))(Ct || {}), Ze = /* @__PURE__ */ ((s) => (s[s.X = 0] = "X", s[s.Y = 1] = "Y", s[s.Z = 2] = "Z", s))(Ze || {}), Te = /* @__PURE__ */ ((s) => (s[s.None = -1] = "None", s[s.Left = 0] = "Left", s[s.Middle = 1] = "Middle", s[s.Right = 2] = "Right", s))(Te || {}), ws = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Left = 1] = "Left", s[s.Right = 2] = "Right", s[s.Middle = 4] = "Middle", s))(ws || {}), zr = /* @__PURE__ */ ((s) => (s[s.Axis = 0] = "Axis", s[s.Plane = 1] = "Plane", s[s.ViewPlane = 2] = "ViewPlane", s[s.Rotate = 3] = "Rotate", s))(zr || {}), Co = /* @__PURE__ */ ((s) => (s[s.Translate = 0] = "Translate", s[s.Rotate = 1] = "Rotate", s))(Co || {}), ve = /* @__PURE__ */ ((s) => (s[s.Invalid = -1] = "Invalid", s[s.None = 0] = "None", s[s.Navigate = 1] = "Navigate", s[s.Orbit = 2] = "Orbit", s[s.Pan = 3] = "Pan", s[s.Zoom = 4] = "Zoom", s[s.WindowZoom = 5] = "WindowZoom", s[s.Walk = 6] = "Walk", s[s.KeyboardWalk = 7] = "KeyboardWalk", s[s.WalkMode = 8] = "WalkMode", s[s.Turntable = 9] = "Turntable", s[s.Select = 10] = "Select", s[s.AreaSelect = 11] = "AreaSelect", s[s.RayDrillSelect = 12] = "RayDrillSelect", s[s.RedlineCircle = 13] = "RedlineCircle", s[s.RedlineText = 14] = "RedlineText", s[s.RedlineRectangle = 15] = "RedlineRectangle", s[s.RedlinePolyline = 16] = "RedlinePolyline", s[s.MeasureEdgeLength = 17] = "MeasureEdgeLength", s[s.MeasureFaceFaceDistance = 18] = "MeasureFaceFaceDistance", s[s.MeasureLineLineAngle = 19] = "MeasureLineLineAngle", s[s.MeasurePointPointDistance = 20] = "MeasurePointPointDistance", s[s.MeasureBodyBodyDistance = 21] = "MeasureBodyBodyDistance", s[s.MeasureFaceFaceAngle = 22] = "MeasureFaceFaceAngle", s[s.MeasurePolylineDistance = 23] = "MeasurePolylineDistance", s[s.MeasurePolygonArea = 24] = "MeasurePolygonArea", s[s.Note = 25] = "Note", s[s.Cutting = 26] = "Cutting", s[s.Handle = 27] = "Handle", s[s.NavCube = 28] = "NavCube", s[s.AxisTriad = 29] = "AxisTriad", s[s.Floorplan = 30] = "Floorplan", s[s.SpaceMouse = 31] = "SpaceMouse", s))(ve || {}), le = /* @__PURE__ */ ((s) => (s[s.MouseDown = 0] = "MouseDown", s[s.MouseMove = 1] = "MouseMove", s[s.MouseUp = 2] = "MouseUp", s[s.Mousewheel = 3] = "Mousewheel", s[s.TouchStart = 4] = "TouchStart", s[s.TouchMove = 5] = "TouchMove", s[s.TouchEnd = 6] = "TouchEnd", s[s.KeyDown = 7] = "KeyDown", s[s.KeyUp = 8] = "KeyUp", s[s.ViewOrientationChange = 9] = "ViewOrientationChange", s))(le || {}), Mi = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Shift = 2] = "Shift", s[s.Alt = 4] = "Alt", s[s.Control = 8] = "Control", s[s.Command = 16] = "Command", s))(Mi || {}), _r = /* @__PURE__ */ ((s) => (s[s.Down = 0] = "Down", s[s.Up = 1] = "Up", s[s.Move = 2] = "Move", s[s.Wheel = 3] = "Wheel", s))(_r || {}), Su = /* @__PURE__ */ ((s) => (s[s.Start = 0] = "Start", s[s.Move = 1] = "Move", s[s.End = 2] = "End", s))(Su || {}), Pf = /* @__PURE__ */ ((s) => (s[s.Down = 0] = "Down", s[s.Up = 1] = "Up", s))(Pf || {}), Re = /* @__PURE__ */ ((s) => (s[s.Forward = 0] = "Forward", s[s.Backward = 1] = "Backward", s[s.Left = 2] = "Left", s[s.Right = 3] = "Right", s[s.Up = 4] = "Up", s[s.Down = 5] = "Down", s[s.RotateRight = 6] = "RotateRight", s[s.RotateLeft = 7] = "RotateLeft", s[s.TiltUp = 8] = "TiltUp", s[s.TiltDown = 9] = "TiltDown", s))(Re || {}), Qe = /* @__PURE__ */ ((s) => (s[s.Backspace = 8] = "Backspace", s[s.Shift = 16] = "Shift", s[s.Escape = 27] = "Escape", s[s.PgUp = 33] = "PgUp", s[s.PgDown = 34] = "PgDown", s[s.LeftArrow = 37] = "LeftArrow", s[s.UpArrow = 38] = "UpArrow", s[s.RightArrow = 39] = "RightArrow", s[s.DownArrow = 40] = "DownArrow", s[s.Delete = 46] = "Delete", s[s.a = 65] = "a", s[s.b = 66] = "b", s[s.c = 67] = "c", s[s.d = 68] = "d", s[s.e = 69] = "e", s[s.f = 70] = "f", s[s.g = 71] = "g", s[s.h = 72] = "h", s[s.i = 73] = "i", s[s.j = 74] = "j", s[s.k = 75] = "k", s[s.l = 76] = "l", s[s.m = 77] = "m", s[s.n = 78] = "n", s[s.o = 79] = "o", s[s.p = 80] = "p", s[s.q = 81] = "q", s[s.r = 82] = "r", s[s.s = 83] = "s", s[s.t = 84] = "t", s[s.u = 85] = "u", s[s.v = 86] = "v", s[s.w = 87] = "w", s[s.x = 88] = "x", s[s.y = 89] = "y", s[s.z = 90] = "z", s[s._0 = 48] = "_0", s[s._1 = 49] = "_1", s[s._2 = 50] = "_2", s[s._3 = 51] = "_3", s[s._4 = 52] = "_4", s[s._5 = 53] = "_5", s[s._6 = 54] = "_6", s[s._7 = 55] = "_7", s[s._8 = 56] = "_8", s[s._9 = 57] = "_9", s[s.NumPad_0 = 96] = "NumPad_0", s[s.NumPad_1 = 97] = "NumPad_1", s[s.NumPad_2 = 98] = "NumPad_2", s[s.NumPad_3 = 99] = "NumPad_3", s[s.NumPad_4 = 100] = "NumPad_4", s[s.NumPad_5 = 101] = "NumPad_5", s[s.NumPad_6 = 102] = "NumPad_6", s[s.NumPad_7 = 103] = "NumPad_7", s[s.NumPad_8 = 104] = "NumPad_8", s[s.NumPad_9 = 105] = "NumPad_9", s))(Qe || {}), Pe = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Face = 1] = "Face", s[s.Line = 2] = "Line", s[s.Point = 4] = "Point", s[s.All = 7] = "All", s))(Pe || {}), On = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Face = 1] = "Face", s[s.Line = 2] = "Line", s[s.Point = 3] = "Point", s[s.Part = 4] = "Part", s))(On || {}), In = /* @__PURE__ */ ((s) => (s[s.Set = 0] = "Set", s[s.Add = 1] = "Add", s[s.Toggle = 2] = "Toggle", s))(In || {}), Dr = /* @__PURE__ */ ((s) => (s[s.HighlightOnly = 0] = "HighlightOnly", s[s.OutlineOnly = 1] = "OutlineOnly", s[s.HighlightAndOutline = 2] = "HighlightAndOutline", s))(Dr || {}), Cb = /* @__PURE__ */ ((s) => (s[s.Info = 0] = "Info", s[s.Warning = 1] = "Warning", s[s.Error = 2] = "Error", s))(Cb || {}), Ro = /* @__PURE__ */ ((s) => (s[s.Interactive = 1] = "Interactive", s[s.All = 2] = "All", s[s.OnDemand = 4] = "OnDemand", s[
  s.Default = 1
  /* Interactive */
] = "Default", s))(Ro || {}), nh = /* @__PURE__ */ ((s) => (s[s.Client = 0] = "Client", s[s.Server = 1] = "Server", s))(nh || {}), cr = /* @__PURE__ */ ((s) => (s[s.Wireframe = 0] = "Wireframe", s[s.Shaded = 1] = "Shaded", s[s.WireframeOnShaded = 2] = "WireframeOnShaded", s[s.HiddenLine = 3] = "HiddenLine", s[s.XRay = 4] = "XRay", s[s.Gooch = 5] = "Gooch", s[s.Toon = 6] = "Toon", s))(cr || {}), Sb = /* @__PURE__ */ ((s) => (s[s.Unsorted = 0] = "Unsorted", s[s.SingleLayer = 1] = "SingleLayer", s))(Sb || {}), pg = /* @__PURE__ */ ((s) => (s[s.SMAA = 0] = "SMAA", s[s.None = 1] = "None", s))(pg || {}), tn = /* @__PURE__ */ ((s) => (s[s.DoNotExplode = 0] = "DoNotExplode", s[s.DoNotCut = 1] = "DoNotCut", s[s.DoNotSelect = 2] = "DoNotSelect", s[s.SuppressCameraScale = 3] = "SuppressCameraScale", s[s.OverrideSceneVisibility = 4] = "OverrideSceneVisibility", s[s.DoNotLight = 5] = "DoNotLight", s[s.DoNotOutlineHighlight = 6] = "DoNotOutlineHighlight", s[s.ExcludeBounding = 7] = "ExcludeBounding", s[s.DoNotUseVertexColors = 8] = "DoNotUseVertexColors", s[s.AlwaysDraw = 9] = "AlwaysDraw", s[s.DoNotXRay = 10] = "DoNotXRay", s[s.ScreenOriented = 11] = "ScreenOriented", s[s.ScreenSpace = 12] = "ScreenSpace", s[s.ScreenSpaceStretched = 13] = "ScreenSpaceStretched", s[s.DoNotReset = 14] = "DoNotReset", s))(tn || {}), ee = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.SuppressCameraScale = 1] = "SuppressCameraScale", s[s.ScreenOriented = 2] = "ScreenOriented", s[s.DoNotCut = 4] = "DoNotCut", s[s.DoNotExplode = 8] = "DoNotExplode", s[s.DoNotSelect = 16] = "DoNotSelect", s[s.DoNotLight = 32] = "DoNotLight", s[s.DoNotOutlineHighlight = 64] = "DoNotOutlineHighlight", s[s.ExcludeBounding = 128] = "ExcludeBounding", s[s.DoNotUseVertexColors = 256] = "DoNotUseVertexColors", s[s.Invisible = 512] = "Invisible", s[s.DoNotXRay = 1024] = "DoNotXRay", s[s.AlwaysDraw = 2048] = "AlwaysDraw", s[s.OverrideSceneVisibility = 4096] = "OverrideSceneVisibility", s[s.ScreenSpace = 8192] = "ScreenSpace", s[s.ScreenSpaceStretched = 16384] = "ScreenSpaceStretched", s[s.DoNotReset = 32768] = "DoNotReset", s))(ee || {}), So = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Model = 1] = "Model", s[s.Instance = 2] = "Instance", s[s.Ejected = 4] = "Ejected", s[s.All = 7] = "All", s))(So || {}), gc = /* @__PURE__ */ ((s) => (s[s.CameraTarget = 0] = "CameraTarget", s[s.ModelCenter = 1] = "ModelCenter", s[s.OrbitTarget = 2] = "OrbitTarget", s))(gc || {}), pc = /* @__PURE__ */ ((s) => (s[s.Mouse = 0] = "Mouse", s[s.Keyboard = 1] = "Keyboard", s))(pc || {}), Le = /* @__PURE__ */ ((s) => (s[s.AssemblyNode = 0] = "AssemblyNode", s[s.PartInstance = 1] = "PartInstance", s[s.Part = 2] = "Part", s[s.BodyInstance = 3] = "BodyInstance", s[s.PmiBody = 4] = "PmiBody", s[s.ViewFrame = 5] = "ViewFrame", s[s.Body = 6] = "Body", s[s.BrepBody = 7] = "BrepBody", s[s.TessBody = 8] = "TessBody", s[s.WireBody = 9] = "WireBody", s[s.PointsBody = 10] = "PointsBody", s[s.Pmi = 11] = "Pmi", s[s.CadView = 12] = "CadView", s[s.DrawingSheet = 13] = "DrawingSheet", s[s.Unknown = 14] = "Unknown", s))(Le || {}), b_ = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Text = 1] = "Text", s[s.Dimension = 2] = "Dimension", s[s.Arrow = 3] = "Arrow", s[s.Balloon = 4] = "Balloon", s[s.CircleCenter = 5] = "CircleCenter", s[s.Coordinate = 6] = "Coordinate", s[s.Datum = 7] = "Datum", s[s.Fastener = 8] = "Fastener", s[s.Gdt = 9] = "Gdt", s[s.Locator = 10] = "Locator", s[s.MeasurementPoint = 11] = "MeasurementPoint", s[s.Roughness = 12] = "Roughness", s[s.Welding = 13] = "Welding", s[s.Table = 14] = "Table", s[s.Other = 15] = "Other", s[s.GeometricalTolerance = 16] = "GeometricalTolerance", s))(b_ || {}), x_ = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.DatumIdent = 1] = "DatumIdent", s[s.DatumTarget = 2] = "DatumTarget", s[s.DimensionDistance = 1] = "DimensionDistance", s[s.DimensionDistanceOffset = 2] = "DimensionDistanceOffset", s[s.DimensionDistanceCumulate = 3] = "DimensionDistanceCumulate", s[s.DimensionChamfer = 4] = "DimensionChamfer", s[s.DimensionSlope = 5] = "DimensionSlope", s[s.DimensionOrdinate = 6] = "DimensionOrdinate", s[s.DimensionRadius = 7] = "DimensionRadius", s[s.DimensionRadiusTangent = 8] = "DimensionRadiusTangent", s[s.DimensionRadiusCylinder = 9] = "DimensionRadiusCylinder", s[s.DimensionRadiusEdge = 10] = "DimensionRadiusEdge", s[s.DimensionDiameter = 11] = "DimensionDiameter", s[s.DimensionDiameterTangent = 12] = "DimensionDiameterTangent", s[s.DimensionDiameterCylinder = 13] = "DimensionDiameterCylinder", s[s.DimensionDiameterEdge = 14] = "DimensionDiameterEdge", s[s.DimensionDiameterCone = 15] = "DimensionDiameterCone", s[s.DimensionLength = 16] = "DimensionLength", s[s.DimensionLengthCurvilinear = 17] = "DimensionLengthCurvilinear", s[s.DimensionLengthCircular = 18] = "DimensionLengthCircular", s[s.DimensionAngle = 19] = "DimensionAngle", s[s.GdtFcf = 1] = "GdtFcf", s[s.WeldingLine = 1] = "WeldingLine", s[s.WeldingSpot = 2] = "WeldingSpot", s[s.OtherSymbolUser = 1] = "OtherSymbolUser", s[s.OtherSymbolUtility = 2] = "OtherSymbolUtility", s[s.OtherSymbolCustom = 3] = "OtherSymbolCustom", s[s.OtherGeometricReference = 4] = "OtherGeometricReference", s[s.OtherRegion = 5] = "OtherRegion", s))(x_ || {}), sh = /* @__PURE__ */ ((s) => (s[s.Unknown = -1] = "Unknown", s[s.Context = 1] = "Context", s[s.Item = 2] = "Item", s[s.MultipleVertex = 3] = "MultipleVertex", s[s.UniqueVertex = 4] = "UniqueVertex", s[s.WireEdge = 5] = "WireEdge", s[s.Edge = 6] = "Edge", s[s.CoEdge = 7] = "CoEdge", s[s.Loop = 8] = "Loop", s[s.Face = 9] = "Face", s[s.Shell = 10] = "Shell", s[s.Connex = 11] = "Connex", s[s.Body = 12] = "Body", s[s.SingleWireBody = 13] = "SingleWireBody", s[s.BrepData = 14] = "BrepData", s[s.WireBody = 17] = "WireBody", s))(sh || {}), Qs = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Clockwise = 1] = "Clockwise", s[s.CounterClockwise = 2] = "CounterClockwise", s))(Qs || {}), qe = /* @__PURE__ */ ((s) => (s[s.UpperLeftCorner = 0] = "UpperLeftCorner", s[s.LowerLeftCorner = 1] = "LowerLeftCorner", s[s.LowerRightCorner = 2] = "LowerRightCorner", s[s.UpperRightCorner = 3] = "UpperRightCorner", s[s.TopCenter = 4] = "TopCenter", s[s.LeftCenter = 5] = "LeftCenter", s[s.RightCenter = 6] = "RightCenter", s[s.BottomCenter = 7] = "BottomCenter", s[s.Center = 8] = "Center", s))(qe || {}), Fe = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfCanvas = 1] = "ProportionOfCanvas", s[s.MinimumProportionOfCanvas = 2] = "MinimumProportionOfCanvas", s[s.ProportionOfOtherDimension = 3] = "ProportionOfOtherDimension", s))(Fe || {}), kf = /* @__PURE__ */ ((s) => (s[s.ScreenPixels = 0] = "ScreenPixels", s[s.CSSPixels = 1] = "CSSPixels", s[s.World = 2] = "World", s[s.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", s[s.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", s))(kf || {}), Ef = /* @__PURE__ */ ((s) => (s[s.Square = 0] = "Square", s[s.Disk = 1] = "Disk", s[s.Sphere = 2] = "Sphere", s))(Ef || {});
class Mb {
  constructor() {
    this.bodyId = gg, this.subElementType = -1, this.subElementIndex = -1;
  }
}
var ue = /* @__PURE__ */ ((s) => (s[s.Hidden = 0] = "Hidden", s[s.Shown = 1] = "Shown", s[s.Mixed = 2] = "Mixed", s))(ue || {}), Pb = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s))(Pb || {}), be = /* @__PURE__ */ ((s) => (s[s.First = 8] = "First", s[
  s.Handles = 8
  /* First */
] = "Handles", s[s.AxisTriad = 9] = "AxisTriad", s[s.NavCube = 10] = "NavCube", s[s.Floorplan = 11] = "Floorplan", s[s.TestFramework = 12] = "TestFramework", s))(be || {});
class kb {
  constructor() {
    this.pos1 = m.zero(), this.pos2 = m.zero(), this.distance = 0;
  }
}
class Vp {
  constructor() {
    this.frontVector = new m(-1, 0, 0), this.upVector = new m(0, 0, 1);
  }
}
var Eb = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s[s.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", s))(Eb || {}), rh = /* @__PURE__ */ ((s) => (s[s.Selected = 0] = "Selected", s[s.Unselected = 1] = "Unselected", s))(rh || {}), Xs = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfWidth = 1] = "ProportionOfWidth", s[s.ProportionOfHeight = 2] = "ProportionOfHeight", s))(Xs || {}), Hr = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Int = 1] = "Int", s[s.Float = 2] = "Float", s[s.Time = 3] = "Time", s[s.String = 4] = "String", s[s.Ignored = 5] = "Ignored", s))(Hr || {});
class zp {
  constructor(t, e) {
    this.isInclusive = t, this.nodeIds = e;
  }
}
class Ab {
  constructor(t, e) {
    this.defaultVisibility = t, this.visibilityExceptions = e;
  }
}
class Ma {
  constructor() {
    this.additionalMatrix = null, this.allowMissingExternalModels = !1, this.attachInvisibly = !1, this.implicitlyLoadXmlExternalModels = !0, this.ignoreCadViews = !1, this.ignoreFilters = !1, this.ignoreLayers = !1, this.ignoreGenericTypes = !1, this.ignoreBimRelationships = !1, this._allowSubtreeLoadedCallback = !0;
  }
  copy() {
    const t = new Ma();
    return t.additionalMatrix = this.additionalMatrix, t.additionalMatrix !== null && (t.additionalMatrix = t.additionalMatrix.copy()), t.allowMissingExternalModels = this.allowMissingExternalModels, t.attachInvisibly = this.attachInvisibly, t.implicitlyLoadXmlExternalModels = this.implicitlyLoadXmlExternalModels, t.ignoreCadViews = this.ignoreCadViews, t.ignoreFilters = this.ignoreFilters, t.ignoreLayers = this.ignoreLayers, t.ignoreGenericTypes = this.ignoreGenericTypes, t.ignoreBimRelationships = this.ignoreBimRelationships, t._allowSubtreeLoadedCallback = this._allowSubtreeLoadedCallback, t;
  }
}
var kc = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Catia = 2] = "Catia", s[s.CatiaV5 = 3] = "CatiaV5", s[s.Cadds = 4] = "Cadds", s[s.Unigraphics = 5] = "Unigraphics", s[s.Parasolid = 6] = "Parasolid", s[s.Euclid = 7] = "Euclid", s[s.Iges = 9] = "Iges", s[s.Unisurf = 10] = "Unisurf", s[s.Vda = 11] = "Vda", s[s.Stl = 12] = "Stl", s[s.Wrl = 13] = "Wrl", s[s.Dxf = 14] = "Dxf", s[s.Acis = 15] = "Acis", s[s.ProE = 16] = "ProE", s[s.Step = 18] = "Step", s[s.Ideas = 19] = "Ideas", s[s.Jt = 20] = "Jt", s[s.Slw = 22] = "Slw", s[s.Cgr = 23] = "Cgr", s[s.Prc = 24] = "Prc", s[s.Xvl = 25] = "Xvl", s[s.Hpgl = 26] = "Hpgl", s[s.TopSolid = 27] = "TopSolid", s[s.OneSpaceDesigner = 28] = "OneSpaceDesigner", s[s._3dxml = 29] = "_3dxml", s[s.Inventor = 30] = "Inventor", s[s.PostScript = 31] = "PostScript", s[s.Pdp = 32] = "Pdp", s[s.U3d = 33] = "U3d", s[s.Ifc = 34] = "Ifc", s[s.Dwg = 35] = "Dwg", s[s.Dwf = 36] = "Dwf", s[s.Se = 37] = "Se", s[s.Obj = 38] = "Obj", s[s.Kmz = 39] = "Kmz", s[s.Dae = 40] = "Dae", s[s._3ds = 41] = "_3ds", s[s.Rhino = 43] = "Rhino", s[s.Xml = 44] = "Xml", s[s._3mf = 45] = "_3mf", s[s.Scs = 46] = "Scs", s[s._3dHtml = 47] = "_3dHtml", s[s.Hsf = 48] = "Hsf", s[s.Gltf = 49] = "Gltf", s[s.Revit = 50] = "Revit", s[s.Fbx = 51] = "Fbx", s))(kc || {}), Af = /* @__PURE__ */ ((s) => (s[s.World = 0] = "World", s[s.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", s))(Af || {}), Tb = /* @__PURE__ */ ((s) => (s[s.Default = 0] = "Default", s[s.PerNode = 1] = "PerNode", s))(Tb || {}), ol = /* @__PURE__ */ ((s) => (s[s.NorthUp = 0] = "NorthUp", s[s.AvatarUp = 1] = "AvatarUp", s))(ol || {}), I_ = /* @__PURE__ */ ((s) => (s[s.ContainedInSpatialStructure = 0] = "ContainedInSpatialStructure", s[s.Aggregates = 1] = "Aggregates", s[s.VoidsElement = 2] = "VoidsElement", s[s.FillsElement = 3] = "FillsElement", s[s.SpaceBoundary = 4] = "SpaceBoundary", s[s.ConnectsPathElements = 5] = "ConnectsPathElements", s[s.Undefined = 6] = "Undefined", s))(I_ || {}), C_ = /* @__PURE__ */ ((s) => (s[s.FixedFramerate = 0] = "FixedFramerate", s[s.OcclusionCulling = 1] = "OcclusionCulling", s))(C_ || {}), ys = /* @__PURE__ */ ((s) => (s[s.Rgba32 = 0] = "Rgba32", s[s.Rgb24 = 1] = "Rgb24", s[s.Gray8 = 2] = "Gray8", s[s.GrayAlpha16 = 3] = "GrayAlpha16", s[s.Jpeg = 4] = "Jpeg", s[s.Png = 5] = "Png", s))(ys || {}), Tf = /* @__PURE__ */ ((s) => (s[s.Clamp = 0] = "Clamp", s[s.Repeat = 1] = "Repeat", s[s.Trim = 2] = "Trim", s))(Tf || {}), Db = /* @__PURE__ */ ((s) => (s[s.UV = 0] = "UV", s))(Db || {}), Nb = /* @__PURE__ */ ((s) => (s[s.Decal = 1] = "Decal", s))(Nb || {}), Ec = /* @__PURE__ */ ((s) => (s[s.Model = 1] = "Model", s[s.Svg = 2] = "Svg", s[s.Html = 4] = "Html", s[s.All = 7] = "All", s))(Ec || {});
class oe extends Error {
  /**
   * Creates a new CommunicatorError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, oe.prototype);
  }
}
class mg extends oe {
  /**
   * Creates a new InvalidIndexError
   */
  constructor(t) {
    super(`Invalid index (${t}).`), Object.setPrototypeOf(this, mg.prototype);
  }
}
class No extends oe {
  /**
   * Creates a new PickOutsideCanvasError
   */
  constructor() {
    super("Cannot pick from outside the canvas area."), Object.setPrototypeOf(this, No.prototype);
  }
}
class so extends oe {
  /**
   * Creates a new SelectionInvalidatedError
   */
  constructor() {
    super("Selection invalidated."), Object.setPrototypeOf(this, so.prototype);
  }
}
class oi extends oe {
  /**
   * Creates a new InternalLogicError
   */
  constructor() {
    super("Internal logic error."), Object.setPrototypeOf(this, oi.prototype);
  }
}
class Ns extends oe {
  /**
   * Creates a new InvalidNodeIdError
   */
  constructor(t) {
    super(`Invalid node (${t}).`), Object.setPrototypeOf(this, Ns.prototype), this.nodeId = t;
  }
}
class os extends oe {
  /**
   * Creates a new InvalidNodeTypeError
   */
  constructor(t, e, ...i) {
    i.push(e);
    const n = [];
    for (const l of i)
      switch (l) {
        case Cn.ProductOccurrence:
          n.push(Le.DrawingSheet, Le.PartInstance, Le.AssemblyNode);
          break;
        case Cn.AnyBody:
          n.push(Le.BodyInstance), n.push(Le.PmiBody), n.push(Le.ViewFrame);
          break;
        case Cn.BodyInstance:
          n.push(Le.BodyInstance);
          break;
        case Cn.CadView:
          n.push(Le.CadView);
          break;
        default:
          qr();
      }
    n.sort();
    const r = [];
    for (const l of n)
      r.push(Le[l]);
    const o = r.length === 1 ? `type (${r[0]})` : `types ${r}`;
    super(`Expected node (${t}) to be of ${o}.`), Object.setPrototypeOf(this, os.prototype), this.nodeId = t, this.expectedTypes = n;
  }
}
class Kr extends oe {
  /**
   * Creates a new LoadError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Kr.prototype);
  }
}
class dd extends Kr {
  /**
   * Creates a new LoadCancelledError
   */
  constructor() {
    super("Load cancelled."), Object.setPrototypeOf(this, dd.prototype);
  }
}
class fd extends Kr {
  /**
   * Creates a new MissingModelError
   */
  constructor(t) {
    super(`Missing model: '${t}'.`), Object.setPrototypeOf(this, fd.prototype);
  }
}
class Rs extends oe {
  /**
   * Creates a new ParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Rs.prototype);
  }
}
class Pa extends Rs {
  /**
   * Creates a new AssemblyDataParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Pa.prototype);
  }
}
class si extends Rs {
  /**
   * Creates a new XmlParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, si.prototype);
  }
}
function Ob(s) {
  return Rb(s);
}
function Rb(s) {
  const t = new S_();
  for (const i of s)
    i._gatherForExport(t);
  const e = {};
  if (!t.buffers.isEmpty()) {
    e.buffers = [];
    for (const i of t.buffers.toArray())
      e.buffers.push(i._export());
  }
  if (!t.samplers.isEmpty()) {
    e.samplers = [];
    for (const i of t.samplers.toArray())
      e.samplers.push(i._export(t));
  }
  if (!t.colorMaps.isEmpty()) {
    e.colorMaps = [];
    for (const i of t.colorMaps.toArray())
      e.colorMaps.push(Fb(i));
  }
  if (s.length !== 0) {
    e.animations = [];
    for (const i of s)
      e.animations.push(i._export(t));
  }
  return {
    ...e
  };
}
function Lb(s) {
  const t = s, e = new M_();
  if (t.buffers !== void 0)
    for (const n of t.buffers)
      e.buffers.push(dh._import(n));
  if (t.samplers !== void 0)
    for (const n of t.samplers)
      e.samplers.push(Wc._import(e, n));
  if (t.colorMaps !== void 0)
    for (const n of t.colorMaps)
      e.colorMaps.push(Bb(n));
  const i = [];
  if (t.animations !== void 0)
    for (const n of t.animations)
      i.push(ad._import(e, n));
  return i;
}
function Fb(s) {
  const t = [];
  for (const e of s)
    t.push([e.position, e.color.r, e.color.g, e.color.b]);
  return t;
}
function Bb(s) {
  const t = [];
  for (const e of s)
    t.push({
      position: e[0],
      color: new yt(e[1], e[2], e[3])
    });
  return t;
}
class S_ {
  constructor() {
    this.buffers = new Mu(), this.samplers = new Mu(), this.colorMaps = new Mu();
  }
}
class M_ {
  constructor() {
    this.buffers = [], this.samplers = [], this.colorMaps = [];
  }
}
class Mu {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(t) {
    this.map.has(t) || this.map.set(t, this.map.size);
  }
  getIndex(t) {
    const e = this.map.get(t);
    if (e === void 0)
      throw new oi();
    return e;
  }
  /**
   * Returns an array containing each element of the set placed at its
   * assigned index.
   */
  toArray() {
    const t = [];
    return this.map.forEach((e, i) => {
      t[e] = i;
    }), t;
  }
  isEmpty() {
    return this.map.size === 0;
  }
}
var P_ = /* @__PURE__ */ ((s) => (s[s.Stopped = 0] = "Stopped", s[s.Playing = 1] = "Playing", s[s.Paused = 2] = "Paused", s[s.Complete = 3] = "Complete", s))(P_ || {});
const Fg = class Fg {
  /** @hidden Do not use.  Create via Animation.Manager API instead. */
  constructor(t, e) {
    this._viewer = t, this.animation = e, this._nodeValues = /* @__PURE__ */ new Map(), this._disabledChannels = /* @__PURE__ */ new Set(), this._currentTime = 0, this._lastUpdate = 0, this.speed = 1, this._animationTime = 0, this._state = 0, this.loop = 0, this._loopCount = 0, this.onComplete = null, this.nodeIdOffset = 0, this.reload();
  }
  /** Sets the enabled state for a channel in this players animation.
   * All channels are enabled by default when a player is created.
   * A channel that has been disabled will not have its value interpolated by the system until it is re-enabled
   * @param channel a channel from the underlying animation
   * @param enabled boolean value indicating whether the channel should be enabled.
   */
  setChannelEnabled(t, e) {
    e ? this._disabledChannels.delete(t) : this._disabledChannels.add(t);
  }
  /**
   * Updates internal state of animation player.
   *
   * Call this method after any part of the underlying animation has been updated.
   * */
  reload() {
    this._nodeValues.clear(), this._animationTime = 0;
    for (const t of this.animation.nodeChannels) {
      const e = t.sampler.buffer.times.length;
      if (e !== 0) {
        if (!this._nodeValues.has(t.nodeId)) {
          const i = new Pm(t.nodeId);
          i.pivotPoint = this.animation.pivotPoints.get(t.nodeId), this._nodeValues.set(t.nodeId, i);
        }
        this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]);
      }
    }
    for (const t of this.animation.cameraChannels) {
      const e = t.sampler.buffer.times.length;
      e !== 0 && (this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]));
    }
  }
  /**
   * Called automatically by the Animation.Manager when it is updating all animations.
   * @returns True if values were modified.
   * @hidden
   */
  _tick(t, e) {
    if (this._state !== 1)
      return !1;
    const i = (t - this._lastUpdate) / 1e3;
    return this._tickTime(i, e), this._lastUpdate = t, !0;
  }
  /**
   * Updates the animation using the supplied delta time specified in seconds.
   * @returns True if values were modified.
   * @hidden
   */
  _tickTime(t, e) {
    if (this._state !== 1)
      return !1;
    this._currentTime += t * this.speed;
    const i = this._currentTime < 0, n = this._currentTime > this._animationTime;
    return i || n ? this.loop < 0 || this.loop > this._loopCount ? (this._loopCount += 1, this._currentTime = i ? this._animationTime : 0, this.evaluate(this._currentTime, e)) : (this._currentTime = this._animationTime, this.evaluate(this._currentTime, e), this._state = 3, this._loopCount = 0, this.onComplete && this.onComplete()) : this.evaluate(this._currentTime, e), !0;
  }
  /** Starts playing the animation. */
  play() {
    this._state !== 1 && (this._state === 3 && (this._currentTime = 0), this._lastUpdate = performance.now(), this._state = 1);
  }
  /** Pauses animation playback. */
  pause() {
    this._state === 1 && (this._state = 2);
  }
  /** Stops animation playback and resets the current time to 0. */
  stop() {
    this._state = 0, this.setTime(0);
  }
  /**
   * Sets the current animation time.
   * @param time time in milliseconds
   */
  setTime(t) {
    const e = new Nu();
    this._currentTime = Math.min(t, this._animationTime), this.evaluate(this._currentTime, e), e.apply(this._viewer);
  }
  /**
   * Calculate the values for each channel of the associated [[Animation]]
   * at the given time.
   *
   * @param time The time at which to evaluate the animation.
   * @param out Storage for the evaluated values. If supplied, this object
   * will be returned instead of a new [[BatchedValues]] object. This
   * allows values gathered from multiple players to be combined into one
   * batch.
   */
  evaluate(t, e) {
    e === void 0 && (e = new Nu());
    for (const i of this.animation.nodeChannels) {
      const n = this._nodeValues.get(i.nodeId);
      n !== void 0 && !this._disabledChannels.has(i) && i._getValue(t, n);
    }
    this._nodeValues.forEach((i) => {
      if (e === void 0)
        throw new oi();
      const n = i.nodeId + this.nodeIdOffset;
      (i.flags & Dn.Transform) === Dn.Transform && (i.updateMatrix(), e.node.matrixNodeIds.push(n), e.node.matrices.push(i.matrix)), (i.flags & Dn.Opacity) === Dn.Opacity && e.node.opacities.set(n, i.opacity), (i.flags & Dn.Visibility) === Dn.Visibility && (i.visibility !== 0 ? e.node.visibilityOn.push(n) : e.node.visibilityOff.push(n)), (i.flags & Dn.Color) === Dn.Color && e.node.colors.set(
        n,
        new yt(i.color.x, i.color.y, i.color.z)
      ), i.flags = Dn.None;
    });
    for (const i of this.animation.cameraChannels)
      i.sampler.buffer.times.length > 0 && !this._disabledChannels.has(i) && i._getValue(t, e.camera);
    return e;
  }
  /** Gets the current animation state. */
  getState() {
    return this._state;
  }
  /** Gets the current time in seconds that the animation has been playing. */
  getCurrentTime() {
    return this._currentTime;
  }
  /** Gets the current time in seconds of the entire animation. */
  getAnimationTime() {
    return this._animationTime;
  }
};
Fg.LoopIndefinitely = -1;
let Xu = Fg;
class k_ {
  /** @hidden Created during IWebViewer Initialization. */
  constructor(t) {
    this._viewer = t, this._players = [], this._intervalHandle = null, this._batch = new Nu(), this._viewer.setCallbacks({
      assemblyTreeReady: () => {
        this.setTickInterval(50);
      }
    });
  }
  /** Creates a new animation player for the supplied animation. */
  createPlayer(t) {
    const e = new Xu(this._viewer, t);
    return this._players.push(e), e;
  }
  /** Removes the player at the provided index from control of the manager. Returns `true` if a player was removed */
  removePlayerByIndex(t) {
    return t >= this._players.length ? !1 : (this._players.splice(t, 1), !0);
  }
  /** Removes the provided player from control of the manager. Returns `true` is a player was removed */
  removePlayer(t) {
    for (let e = 0; e < this._players.length; e++)
      if (this._players[e] === t)
        return this._players.splice(e, 1), !0;
    return !1;
  }
  /** Removes all players from control of the manager. */
  clear() {
    this._players = [];
  }
  _tick() {
    if (this._players.length === 0)
      return;
    this._batch.clear();
    let t = !1;
    const e = performance.now();
    for (const i of this._players)
      i._tick(e, this._batch) && (t = !0);
    t && (this._viewer.pauseRendering(), this._batch.apply(this._viewer), this._viewer.resumeRendering());
  }
  /** @hidden  Called by the web viewer only*/
  _shutdown() {
    this._intervalHandle !== null && clearInterval(this._intervalHandle);
  }
  /**
   * Sets the interval at which animations are updated.
   * @param milliseconds number of milliseconds between update intervals
   */
  setTickInterval(t) {
    this._intervalHandle && clearInterval(this._intervalHandle), this._intervalHandle = setInterval(() => {
      this._tick();
    }, t);
  }
}
function ic(s, t, e, i) {
  const n = e === gr.Width || e === gr.Height ? Os.Scalar : Os.Vec3, r = new dh(n), o = new Wc(r, i);
  return s.createCameraChannel(t, e, o);
}
function Vb(s, t, e) {
  const i = [];
  return i.push(
    ic(
      s,
      `${t}-Position`,
      gr.Position,
      e
    )
  ), i.push(
    ic(
      s,
      `${t}-Target`,
      gr.Target,
      e
    )
  ), i.push(
    ic(s, `${t}-Up`, gr.Up, e)
  ), i.push(
    ic(s, `${t}-Width`, gr.Width, e)
  ), i.push(
    ic(
      s,
      `${t}-Height`,
      gr.Height,
      e
    )
  ), i;
}
function zb(s, t, e) {
  const i = t.getPosition();
  e.cameraChannels[0].sampler.buffer.insertVec3Keyframe(
    s,
    i.x,
    i.y,
    i.z
  );
  const n = t.getTarget();
  e.cameraChannels[1].sampler.buffer.insertVec3Keyframe(s, n.x, n.y, n.z);
  const r = t.getUp();
  e.cameraChannels[2].sampler.buffer.insertVec3Keyframe(s, r.x, r.y, r.z), e.cameraChannels[3].sampler.buffer.insertScalarKeyframe(s, t.getWidth()), e.cameraChannels[4].sampler.buffer.insertScalarKeyframe(s, t.getHeight());
}
const tS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animation: ad,
  BatchedCameraValues: km,
  BatchedNodeValues: Em,
  BatchedValues: Nu,
  CameraChannel: jc,
  CameraProperty: gr,
  ExportContext: S_,
  ImportContext: M_,
  IndexedSet: Mu,
  InterpolationType: Ru,
  KeyType: Os,
  KeyframeBuffer: dh,
  Manager: k_,
  NodeChannel: Uc,
  NodeProperty: Ou,
  NodeValues: Pm,
  NodeValuesFlags: Dn,
  Player: Xu,
  PlayerState: P_,
  Sampler: Wc,
  createCameraChannels: Vb,
  exportAnimations: Ob,
  importAnimations: Lb,
  keyframeCamera: zb
}, Symbol.toStringTag, { value: "Module" }));
var Js = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.v1_0 = 1] = "v1_0", s[s.v2_0 = 2] = "v2_0", s[s.v2_1 = 3] = "v2_1", s))(Js || {}), Yn = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.TopicFolder = 1] = "TopicFolder", s[s.Version = 2] = "Version", s[s.Markup = 3] = "Markup", s[s.Snapshot = 4] = "Snapshot", s[s.Viewpoint = 5] = "Viewpoint", s[s.Schema = 6] = "Schema", s[s.Project = 7] = "Project", s))(Yn || {});
const Nr = "HOOPS Communicator";
function mc(s) {
  return s ? "true" : "false";
}
function Pu(s, t) {
  const e = s.createElement("Component");
  return t.ifcGuid !== void 0 && e.setAttribute("IfcGuid", t.ifcGuid), t.originatingSystem !== void 0 && e.setAttribute("OriginatingSystem", t.originatingSystem), t.authoringToolId !== void 0 && e.setAttribute("AuthoringToolId", t.authoringToolId.toString()), e;
}
function pu(s) {
  return s.length === 1 ? `0${s}` : s;
}
function E_(s, t) {
  const e = t ? pu(Math.round(t).toString(16)) : "", i = pu(Math.round(s.r).toString(16)), n = pu(Math.round(s.g).toString(16)), r = pu(Math.round(s.b).toString(16));
  return `${e}${i}${n}${r}`;
}
function hr(s, t, e) {
  const i = s.createElement("X"), n = s.createElement("Y"), r = s.createElement("Z");
  i.innerHTML = e.x.toString(), n.innerHTML = e.y.toString(), r.innerHTML = e.z.toString(), t.appendChild(i), t.appendChild(n), t.appendChild(r);
}
function Or(s, t, e) {
  e != null && s.setAttribute(t, e);
}
function Lr(s, t, e, i) {
  const n = s.createElement(e);
  n.innerHTML = i, t.appendChild(n);
}
function on(s, t, e, i) {
  i != null && Lr(s, t, e, i);
}
function _c(s) {
  return s == null ? null : s.toISOString();
}
function Df(s) {
  return s == null ? null : s.toString();
}
function ku(s) {
  return s == null ? null : s ? "true" : "false";
}
function mu(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var af = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
var Hp;
function Hb() {
  return Hp || (Hp = 1, function(s, t) {
    (function(e) {
      s.exports = e();
    })(function() {
      return function e(i, n, r) {
        function o(u, f) {
          if (!n[u]) {
            if (!i[u]) {
              var g = typeof mu == "function" && mu;
              if (!f && g) return g(u, !0);
              if (l) return l(u, !0);
              var y = new Error("Cannot find module '" + u + "'");
              throw y.code = "MODULE_NOT_FOUND", y;
            }
            var _ = n[u] = { exports: {} };
            i[u][0].call(_.exports, function(x) {
              var b = i[u][1][x];
              return o(b || x);
            }, _, _.exports, e, i, n, r);
          }
          return n[u].exports;
        }
        for (var l = typeof mu == "function" && mu, h = 0; h < r.length; h++) o(r[h]);
        return o;
      }({ 1: [function(e, i, n) {
        var r = e("./utils"), o = e("./support"), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        n.encode = function(h) {
          for (var u, f, g, y, _, x, b, I = [], C = 0, M = h.length, P = M, O = r.getTypeOf(h) !== "string"; C < h.length; ) P = M - C, g = O ? (u = h[C++], f = C < M ? h[C++] : 0, C < M ? h[C++] : 0) : (u = h.charCodeAt(C++), f = C < M ? h.charCodeAt(C++) : 0, C < M ? h.charCodeAt(C++) : 0), y = u >> 2, _ = (3 & u) << 4 | f >> 4, x = 1 < P ? (15 & f) << 2 | g >> 6 : 64, b = 2 < P ? 63 & g : 64, I.push(l.charAt(y) + l.charAt(_) + l.charAt(x) + l.charAt(b));
          return I.join("");
        }, n.decode = function(h) {
          var u, f, g, y, _, x, b = 0, I = 0, C = "data:";
          if (h.substr(0, C.length) === C) throw new Error("Invalid base64 input, it looks like a data url.");
          var M, P = 3 * (h = h.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (h.charAt(h.length - 1) === l.charAt(64) && P--, h.charAt(h.length - 2) === l.charAt(64) && P--, P % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (M = o.uint8array ? new Uint8Array(0 | P) : new Array(0 | P); b < h.length; ) u = l.indexOf(h.charAt(b++)) << 2 | (y = l.indexOf(h.charAt(b++))) >> 4, f = (15 & y) << 4 | (_ = l.indexOf(h.charAt(b++))) >> 2, g = (3 & _) << 6 | (x = l.indexOf(h.charAt(b++))), M[I++] = u, _ !== 64 && (M[I++] = f), x !== 64 && (M[I++] = g);
          return M;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, n) {
        var r = e("./external"), o = e("./stream/DataWorker"), l = e("./stream/Crc32Probe"), h = e("./stream/DataLengthProbe");
        function u(f, g, y, _, x) {
          this.compressedSize = f, this.uncompressedSize = g, this.crc32 = y, this.compression = _, this.compressedContent = x;
        }
        u.prototype = { getContentWorker: function() {
          var f = new o(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new h("data_length")), g = this;
          return f.on("end", function() {
            if (this.streamInfo.data_length !== g.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), f;
        }, getCompressedWorker: function() {
          return new o(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, u.createWorkerFrom = function(f, g, y) {
          return f.pipe(new l()).pipe(new h("uncompressedSize")).pipe(g.compressWorker(y)).pipe(new h("compressedSize")).withStreamInfo("compression", g);
        }, i.exports = u;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, n) {
        var r = e("./stream/GenericWorker");
        n.STORE = { magic: "\0\0", compressWorker: function() {
          return new r("STORE compression");
        }, uncompressWorker: function() {
          return new r("STORE decompression");
        } }, n.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, n) {
        var r = e("./utils"), o = function() {
          for (var l, h = [], u = 0; u < 256; u++) {
            l = u;
            for (var f = 0; f < 8; f++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
            h[u] = l;
          }
          return h;
        }();
        i.exports = function(l, h) {
          return l !== void 0 && l.length ? r.getTypeOf(l) !== "string" ? function(u, f, g, y) {
            var _ = o, x = y + g;
            u ^= -1;
            for (var b = y; b < x; b++) u = u >>> 8 ^ _[255 & (u ^ f[b])];
            return -1 ^ u;
          }(0 | h, l, l.length, 0) : function(u, f, g, y) {
            var _ = o, x = y + g;
            u ^= -1;
            for (var b = y; b < x; b++) u = u >>> 8 ^ _[255 & (u ^ f.charCodeAt(b))];
            return -1 ^ u;
          }(0 | h, l, l.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, i, n) {
        n.base64 = !1, n.binary = !1, n.dir = !1, n.createFolders = !0, n.date = null, n.compression = null, n.compressionOptions = null, n.comment = null, n.unixPermissions = null, n.dosPermissions = null;
      }, {}], 6: [function(e, i, n) {
        var r = null;
        r = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: r };
      }, { lie: 37 }], 7: [function(e, i, n) {
        var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), l = e("./utils"), h = e("./stream/GenericWorker"), u = r ? "uint8array" : "array";
        function f(g, y) {
          h.call(this, "FlateWorker/" + g), this._pako = null, this._pakoAction = g, this._pakoOptions = y, this.meta = {};
        }
        n.magic = "\b\0", l.inherits(f, h), f.prototype.processChunk = function(g) {
          this.meta = g.meta, this._pako === null && this._createPako(), this._pako.push(l.transformTo(u, g.data), !1);
        }, f.prototype.flush = function() {
          h.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
        }, f.prototype.cleanUp = function() {
          h.prototype.cleanUp.call(this), this._pako = null;
        }, f.prototype._createPako = function() {
          this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
          var g = this;
          this._pako.onData = function(y) {
            g.push({ data: y, meta: g.meta });
          };
        }, n.compressWorker = function(g) {
          return new f("Deflate", g);
        }, n.uncompressWorker = function() {
          return new f("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, n) {
        function r(_, x) {
          var b, I = "";
          for (b = 0; b < x; b++) I += String.fromCharCode(255 & _), _ >>>= 8;
          return I;
        }
        function o(_, x, b, I, C, M) {
          var P, O, B = _.file, j = _.compression, F = M !== u.utf8encode, K = l.transformTo("string", M(B.name)), J = l.transformTo("string", u.utf8encode(B.name)), rt = B.comment, ft = l.transformTo("string", M(rt)), H = l.transformTo("string", u.utf8encode(rt)), $ = J.length !== B.name.length, D = H.length !== rt.length, R = "", U = "", it = "", at = B.dir, mt = B.date, Nt = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          x && !b || (Nt.crc32 = _.crc32, Nt.compressedSize = _.compressedSize, Nt.uncompressedSize = _.uncompressedSize);
          var lt = 0;
          x && (lt |= 8), F || !$ && !D || (lt |= 2048);
          var ot = 0, Ht = 0;
          at && (ot |= 16), C === "UNIX" ? (Ht = 798, ot |= function(Rt, ei) {
            var ai = Rt;
            return Rt || (ai = ei ? 16893 : 33204), (65535 & ai) << 16;
          }(B.unixPermissions, at)) : (Ht = 20, ot |= function(Rt) {
            return 63 & (Rt || 0);
          }(B.dosPermissions)), P = mt.getUTCHours(), P <<= 6, P |= mt.getUTCMinutes(), P <<= 5, P |= mt.getUTCSeconds() / 2, O = mt.getUTCFullYear() - 1980, O <<= 4, O |= mt.getUTCMonth() + 1, O <<= 5, O |= mt.getUTCDate(), $ && (U = r(1, 1) + r(f(K), 4) + J, R += "up" + r(U.length, 2) + U), D && (it = r(1, 1) + r(f(ft), 4) + H, R += "uc" + r(it.length, 2) + it);
          var St = "";
          return St += `
\0`, St += r(lt, 2), St += j.magic, St += r(P, 2), St += r(O, 2), St += r(Nt.crc32, 4), St += r(Nt.compressedSize, 4), St += r(Nt.uncompressedSize, 4), St += r(K.length, 2), St += r(R.length, 2), { fileRecord: g.LOCAL_FILE_HEADER + St + K + R, dirRecord: g.CENTRAL_FILE_HEADER + r(Ht, 2) + St + r(ft.length, 2) + "\0\0\0\0" + r(ot, 4) + r(I, 4) + K + R + ft };
        }
        var l = e("../utils"), h = e("../stream/GenericWorker"), u = e("../utf8"), f = e("../crc32"), g = e("../signature");
        function y(_, x, b, I) {
          h.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = x, this.zipPlatform = b, this.encodeFileName = I, this.streamFiles = _, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        l.inherits(y, h), y.prototype.push = function(_) {
          var x = _.meta.percent || 0, b = this.entriesCount, I = this._sources.length;
          this.accumulate ? this.contentBuffer.push(_) : (this.bytesWritten += _.data.length, h.prototype.push.call(this, { data: _.data, meta: { currentFile: this.currentFile, percent: b ? (x + 100 * (b - I - 1)) / b : 100 } }));
        }, y.prototype.openedSource = function(_) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = _.file.name;
          var x = this.streamFiles && !_.file.dir;
          if (x) {
            var b = o(_, x, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: b.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = !0;
        }, y.prototype.closedSource = function(_) {
          this.accumulate = !1;
          var x = this.streamFiles && !_.file.dir, b = o(_, x, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(b.dirRecord), x) this.push({ data: function(I) {
            return g.DATA_DESCRIPTOR + r(I.crc32, 4) + r(I.compressedSize, 4) + r(I.uncompressedSize, 4);
          }(_), meta: { percent: 100 } });
          else for (this.push({ data: b.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, y.prototype.flush = function() {
          for (var _ = this.bytesWritten, x = 0; x < this.dirRecords.length; x++) this.push({ data: this.dirRecords[x], meta: { percent: 100 } });
          var b = this.bytesWritten - _, I = function(C, M, P, O, B) {
            var j = l.transformTo("string", B(O));
            return g.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(C, 2) + r(C, 2) + r(M, 4) + r(P, 4) + r(j.length, 2) + j;
          }(this.dirRecords.length, b, _, this.zipComment, this.encodeFileName);
          this.push({ data: I, meta: { percent: 100 } });
        }, y.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, y.prototype.registerPrevious = function(_) {
          this._sources.push(_);
          var x = this;
          return _.on("data", function(b) {
            x.processChunk(b);
          }), _.on("end", function() {
            x.closedSource(x.previous.streamInfo), x._sources.length ? x.prepareNextSource() : x.end();
          }), _.on("error", function(b) {
            x.error(b);
          }), this;
        }, y.prototype.resume = function() {
          return !!h.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
        }, y.prototype.error = function(_) {
          var x = this._sources;
          if (!h.prototype.error.call(this, _)) return !1;
          for (var b = 0; b < x.length; b++) try {
            x[b].error(_);
          } catch {
          }
          return !0;
        }, y.prototype.lock = function() {
          h.prototype.lock.call(this);
          for (var _ = this._sources, x = 0; x < _.length; x++) _[x].lock();
        }, i.exports = y;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, n) {
        var r = e("../compressions"), o = e("./ZipFileWorker");
        n.generateWorker = function(l, h, u) {
          var f = new o(h.streamFiles, u, h.platform, h.encodeFileName), g = 0;
          try {
            l.forEach(function(y, _) {
              g++;
              var x = function(M, P) {
                var O = M || P, B = r[O];
                if (!B) throw new Error(O + " is not a valid compression method !");
                return B;
              }(_.options.compression, h.compression), b = _.options.compressionOptions || h.compressionOptions || {}, I = _.dir, C = _.date;
              _._compressWorker(x, b).withStreamInfo("file", { name: y, dir: I, date: C, comment: _.comment || "", unixPermissions: _.unixPermissions, dosPermissions: _.dosPermissions }).pipe(f);
            }), f.entriesCount = g;
          } catch (y) {
            f.error(y);
          }
          return f;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, n) {
        function r() {
          if (!(this instanceof r)) return new r();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var o = new r();
            for (var l in this) typeof this[l] != "function" && (o[l] = this[l]);
            return o;
          };
        }
        (r.prototype = e("./object")).loadAsync = e("./load"), r.support = e("./support"), r.defaults = e("./defaults"), r.version = "3.10.1", r.loadAsync = function(o, l) {
          return new r().loadAsync(o, l);
        }, r.external = e("./external"), i.exports = r;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, n) {
        var r = e("./utils"), o = e("./external"), l = e("./utf8"), h = e("./zipEntries"), u = e("./stream/Crc32Probe"), f = e("./nodejsUtils");
        function g(y) {
          return new o.Promise(function(_, x) {
            var b = y.decompressed.getContentWorker().pipe(new u());
            b.on("error", function(I) {
              x(I);
            }).on("end", function() {
              b.streamInfo.crc32 !== y.decompressed.crc32 ? x(new Error("Corrupted zip : CRC32 mismatch")) : _();
            }).resume();
          });
        }
        i.exports = function(y, _) {
          var x = this;
          return _ = r.extend(_ || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: l.utf8decode }), f.isNode && f.isStream(y) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", y, !0, _.optimizedBinaryString, _.base64).then(function(b) {
            var I = new h(_);
            return I.load(b), I;
          }).then(function(b) {
            var I = [o.Promise.resolve(b)], C = b.files;
            if (_.checkCRC32) for (var M = 0; M < C.length; M++) I.push(g(C[M]));
            return o.Promise.all(I);
          }).then(function(b) {
            for (var I = b.shift(), C = I.files, M = 0; M < C.length; M++) {
              var P = C[M], O = P.fileNameStr, B = r.resolve(P.fileNameStr);
              x.file(B, P.decompressed, { binary: !0, optimizedBinaryString: !0, date: P.date, dir: P.dir, comment: P.fileCommentStr.length ? P.fileCommentStr : null, unixPermissions: P.unixPermissions, dosPermissions: P.dosPermissions, createFolders: _.createFolders }), P.dir || (x.file(B).unsafeOriginalName = O);
            }
            return I.zipComment.length && (x.comment = I.zipComment), x;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, n) {
        var r = e("../utils"), o = e("../stream/GenericWorker");
        function l(h, u) {
          o.call(this, "Nodejs stream input adapter for " + h), this._upstreamEnded = !1, this._bindStream(u);
        }
        r.inherits(l, o), l.prototype._bindStream = function(h) {
          var u = this;
          (this._stream = h).pause(), h.on("data", function(f) {
            u.push({ data: f, meta: { percent: 0 } });
          }).on("error", function(f) {
            u.isPaused ? this.generatedError = f : u.error(f);
          }).on("end", function() {
            u.isPaused ? u._upstreamEnded = !0 : u.end();
          });
        }, l.prototype.pause = function() {
          return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
        }, l.prototype.resume = function() {
          return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
        }, i.exports = l;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, n) {
        var r = e("readable-stream").Readable;
        function o(l, h, u) {
          r.call(this, h), this._helper = l;
          var f = this;
          l.on("data", function(g, y) {
            f.push(g) || f._helper.pause(), u && u(y);
          }).on("error", function(g) {
            f.emit("error", g);
          }).on("end", function() {
            f.push(null);
          });
        }
        e("../utils").inherits(o, r), o.prototype._read = function() {
          this._helper.resume();
        }, i.exports = o;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, n) {
        i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(r, o) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(r, o);
          if (typeof r == "number") throw new Error('The "data" argument must not be a number');
          return new Buffer(r, o);
        }, allocBuffer: function(r) {
          if (Buffer.alloc) return Buffer.alloc(r);
          var o = new Buffer(r);
          return o.fill(0), o;
        }, isBuffer: function(r) {
          return Buffer.isBuffer(r);
        }, isStream: function(r) {
          return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
        } };
      }, {}], 15: [function(e, i, n) {
        function r(B, j, F) {
          var K, J = l.getTypeOf(j), rt = l.extend(F || {}, f);
          rt.date = rt.date || /* @__PURE__ */ new Date(), rt.compression !== null && (rt.compression = rt.compression.toUpperCase()), typeof rt.unixPermissions == "string" && (rt.unixPermissions = parseInt(rt.unixPermissions, 8)), rt.unixPermissions && 16384 & rt.unixPermissions && (rt.dir = !0), rt.dosPermissions && 16 & rt.dosPermissions && (rt.dir = !0), rt.dir && (B = C(B)), rt.createFolders && (K = I(B)) && M.call(this, K, !0);
          var ft = J === "string" && rt.binary === !1 && rt.base64 === !1;
          F && F.binary !== void 0 || (rt.binary = !ft), (j instanceof g && j.uncompressedSize === 0 || rt.dir || !j || j.length === 0) && (rt.base64 = !1, rt.binary = !0, j = "", rt.compression = "STORE", J = "string");
          var H = null;
          H = j instanceof g || j instanceof h ? j : x.isNode && x.isStream(j) ? new b(B, j) : l.prepareContent(B, j, rt.binary, rt.optimizedBinaryString, rt.base64);
          var $ = new y(B, H, rt);
          this.files[B] = $;
        }
        var o = e("./utf8"), l = e("./utils"), h = e("./stream/GenericWorker"), u = e("./stream/StreamHelper"), f = e("./defaults"), g = e("./compressedObject"), y = e("./zipObject"), _ = e("./generate"), x = e("./nodejsUtils"), b = e("./nodejs/NodejsStreamInputAdapter"), I = function(B) {
          B.slice(-1) === "/" && (B = B.substring(0, B.length - 1));
          var j = B.lastIndexOf("/");
          return 0 < j ? B.substring(0, j) : "";
        }, C = function(B) {
          return B.slice(-1) !== "/" && (B += "/"), B;
        }, M = function(B, j) {
          return j = j !== void 0 ? j : f.createFolders, B = C(B), this.files[B] || r.call(this, B, null, { dir: !0, createFolders: j }), this.files[B];
        };
        function P(B) {
          return Object.prototype.toString.call(B) === "[object RegExp]";
        }
        var O = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(B) {
          var j, F, K;
          for (j in this.files) K = this.files[j], (F = j.slice(this.root.length, j.length)) && j.slice(0, this.root.length) === this.root && B(F, K);
        }, filter: function(B) {
          var j = [];
          return this.forEach(function(F, K) {
            B(F, K) && j.push(K);
          }), j;
        }, file: function(B, j, F) {
          if (arguments.length !== 1) return B = this.root + B, r.call(this, B, j, F), this;
          if (P(B)) {
            var K = B;
            return this.filter(function(rt, ft) {
              return !ft.dir && K.test(rt);
            });
          }
          var J = this.files[this.root + B];
          return J && !J.dir ? J : null;
        }, folder: function(B) {
          if (!B) return this;
          if (P(B)) return this.filter(function(J, rt) {
            return rt.dir && B.test(J);
          });
          var j = this.root + B, F = M.call(this, j), K = this.clone();
          return K.root = F.name, K;
        }, remove: function(B) {
          B = this.root + B;
          var j = this.files[B];
          if (j || (B.slice(-1) !== "/" && (B += "/"), j = this.files[B]), j && !j.dir) delete this.files[B];
          else for (var F = this.filter(function(J, rt) {
            return rt.name.slice(0, B.length) === B;
          }), K = 0; K < F.length; K++) delete this.files[F[K].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(B) {
          var j, F = {};
          try {
            if ((F = l.extend(B || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = F.type.toLowerCase(), F.compression = F.compression.toUpperCase(), F.type === "binarystring" && (F.type = "string"), !F.type) throw new Error("No output type specified.");
            l.checkSupport(F.type), F.platform !== "darwin" && F.platform !== "freebsd" && F.platform !== "linux" && F.platform !== "sunos" || (F.platform = "UNIX"), F.platform === "win32" && (F.platform = "DOS");
            var K = F.comment || this.comment || "";
            j = _.generateWorker(this, F, K);
          } catch (J) {
            (j = new h("error")).error(J);
          }
          return new u(j, F.type || "string", F.mimeType);
        }, generateAsync: function(B, j) {
          return this.generateInternalStream(B).accumulate(j);
        }, generateNodeStream: function(B, j) {
          return (B = B || {}).type || (B.type = "nodebuffer"), this.generateInternalStream(B).toNodejsStream(j);
        } };
        i.exports = O;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, n) {
        i.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, i, n) {
        var r = e("./DataReader");
        function o(l) {
          r.call(this, l);
          for (var h = 0; h < this.data.length; h++) l[h] = 255 & l[h];
        }
        e("../utils").inherits(o, r), o.prototype.byteAt = function(l) {
          return this.data[this.zero + l];
        }, o.prototype.lastIndexOfSignature = function(l) {
          for (var h = l.charCodeAt(0), u = l.charCodeAt(1), f = l.charCodeAt(2), g = l.charCodeAt(3), y = this.length - 4; 0 <= y; --y) if (this.data[y] === h && this.data[y + 1] === u && this.data[y + 2] === f && this.data[y + 3] === g) return y - this.zero;
          return -1;
        }, o.prototype.readAndCheckSignature = function(l) {
          var h = l.charCodeAt(0), u = l.charCodeAt(1), f = l.charCodeAt(2), g = l.charCodeAt(3), y = this.readData(4);
          return h === y[0] && u === y[1] && f === y[2] && g === y[3];
        }, o.prototype.readData = function(l) {
          if (this.checkOffset(l), l === 0) return [];
          var h = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, h;
        }, i.exports = o;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, n) {
        var r = e("../utils");
        function o(l) {
          this.data = l, this.length = l.length, this.index = 0, this.zero = 0;
        }
        o.prototype = { checkOffset: function(l) {
          this.checkIndex(this.index + l);
        }, checkIndex: function(l) {
          if (this.length < this.zero + l || l < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + l + "). Corrupted zip ?");
        }, setIndex: function(l) {
          this.checkIndex(l), this.index = l;
        }, skip: function(l) {
          this.setIndex(this.index + l);
        }, byteAt: function() {
        }, readInt: function(l) {
          var h, u = 0;
          for (this.checkOffset(l), h = this.index + l - 1; h >= this.index; h--) u = (u << 8) + this.byteAt(h);
          return this.index += l, u;
        }, readString: function(l) {
          return r.transformTo("string", this.readData(l));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var l = this.readInt(4);
          return new Date(Date.UTC(1980 + (l >> 25 & 127), (l >> 21 & 15) - 1, l >> 16 & 31, l >> 11 & 31, l >> 5 & 63, (31 & l) << 1));
        } }, i.exports = o;
      }, { "../utils": 32 }], 19: [function(e, i, n) {
        var r = e("./Uint8ArrayReader");
        function o(l) {
          r.call(this, l);
        }
        e("../utils").inherits(o, r), o.prototype.readData = function(l) {
          this.checkOffset(l);
          var h = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, h;
        }, i.exports = o;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, n) {
        var r = e("./DataReader");
        function o(l) {
          r.call(this, l);
        }
        e("../utils").inherits(o, r), o.prototype.byteAt = function(l) {
          return this.data.charCodeAt(this.zero + l);
        }, o.prototype.lastIndexOfSignature = function(l) {
          return this.data.lastIndexOf(l) - this.zero;
        }, o.prototype.readAndCheckSignature = function(l) {
          return l === this.readData(4);
        }, o.prototype.readData = function(l) {
          this.checkOffset(l);
          var h = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, h;
        }, i.exports = o;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, n) {
        var r = e("./ArrayReader");
        function o(l) {
          r.call(this, l);
        }
        e("../utils").inherits(o, r), o.prototype.readData = function(l) {
          if (this.checkOffset(l), l === 0) return new Uint8Array(0);
          var h = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, h;
        }, i.exports = o;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, n) {
        var r = e("../utils"), o = e("../support"), l = e("./ArrayReader"), h = e("./StringReader"), u = e("./NodeBufferReader"), f = e("./Uint8ArrayReader");
        i.exports = function(g) {
          var y = r.getTypeOf(g);
          return r.checkSupport(y), y !== "string" || o.uint8array ? y === "nodebuffer" ? new u(g) : o.uint8array ? new f(r.transformTo("uint8array", g)) : new l(r.transformTo("array", g)) : new h(g);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, n) {
        n.LOCAL_FILE_HEADER = "PK", n.CENTRAL_FILE_HEADER = "PK", n.CENTRAL_DIRECTORY_END = "PK", n.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", n.ZIP64_CENTRAL_DIRECTORY_END = "PK", n.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, i, n) {
        var r = e("./GenericWorker"), o = e("../utils");
        function l(h) {
          r.call(this, "ConvertWorker to " + h), this.destType = h;
        }
        o.inherits(l, r), l.prototype.processChunk = function(h) {
          this.push({ data: o.transformTo(this.destType, h.data), meta: h.meta });
        }, i.exports = l;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, n) {
        var r = e("./GenericWorker"), o = e("../crc32");
        function l() {
          r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(l, r), l.prototype.processChunk = function(h) {
          this.streamInfo.crc32 = o(h.data, this.streamInfo.crc32 || 0), this.push(h);
        }, i.exports = l;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, n) {
        var r = e("../utils"), o = e("./GenericWorker");
        function l(h) {
          o.call(this, "DataLengthProbe for " + h), this.propName = h, this.withStreamInfo(h, 0);
        }
        r.inherits(l, o), l.prototype.processChunk = function(h) {
          if (h) {
            var u = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = u + h.data.length;
          }
          o.prototype.processChunk.call(this, h);
        }, i.exports = l;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, n) {
        var r = e("../utils"), o = e("./GenericWorker");
        function l(h) {
          o.call(this, "DataWorker");
          var u = this;
          this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, h.then(function(f) {
            u.dataIsReady = !0, u.data = f, u.max = f && f.length || 0, u.type = r.getTypeOf(f), u.isPaused || u._tickAndRepeat();
          }, function(f) {
            u.error(f);
          });
        }
        r.inherits(l, o), l.prototype.cleanUp = function() {
          o.prototype.cleanUp.call(this), this.data = null;
        }, l.prototype.resume = function() {
          return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, r.delay(this._tickAndRepeat, [], this)), !0);
        }, l.prototype._tickAndRepeat = function() {
          this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
        }, l.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return !1;
          var h = null, u = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              h = this.data.substring(this.index, u);
              break;
            case "uint8array":
              h = this.data.subarray(this.index, u);
              break;
            case "array":
            case "nodebuffer":
              h = this.data.slice(this.index, u);
          }
          return this.index = u, this.push({ data: h, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, i.exports = l;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, n) {
        function r(o) {
          this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        r.prototype = { push: function(o) {
          this.emit("data", o);
        }, end: function() {
          if (this.isFinished) return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (o) {
            this.emit("error", o);
          }
          return !0;
        }, error: function(o) {
          return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
        }, on: function(o, l) {
          return this._listeners[o].push(l), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(o, l) {
          if (this._listeners[o]) for (var h = 0; h < this._listeners[o].length; h++) this._listeners[o][h].call(this, l);
        }, pipe: function(o) {
          return o.registerPrevious(this);
        }, registerPrevious: function(o) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
          var l = this;
          return o.on("data", function(h) {
            l.processChunk(h);
          }), o.on("end", function() {
            l.end();
          }), o.on("error", function(h) {
            l.error(h);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return !1;
          var o = this.isPaused = !1;
          return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
        }, flush: function() {
        }, processChunk: function(o) {
          this.push(o);
        }, withStreamInfo: function(o, l) {
          return this.extraStreamInfo[o] = l, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        }, toString: function() {
          var o = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + o : o;
        } }, i.exports = r;
      }, {}], 29: [function(e, i, n) {
        var r = e("../utils"), o = e("./ConvertWorker"), l = e("./GenericWorker"), h = e("../base64"), u = e("../support"), f = e("../external"), g = null;
        if (u.nodestream) try {
          g = e("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
        function y(x, b) {
          return new f.Promise(function(I, C) {
            var M = [], P = x._internalType, O = x._outputType, B = x._mimeType;
            x.on("data", function(j, F) {
              M.push(j), b && b(F);
            }).on("error", function(j) {
              M = [], C(j);
            }).on("end", function() {
              try {
                var j = function(F, K, J) {
                  switch (F) {
                    case "blob":
                      return r.newBlob(r.transformTo("arraybuffer", K), J);
                    case "base64":
                      return h.encode(K);
                    default:
                      return r.transformTo(F, K);
                  }
                }(O, function(F, K) {
                  var J, rt = 0, ft = null, H = 0;
                  for (J = 0; J < K.length; J++) H += K[J].length;
                  switch (F) {
                    case "string":
                      return K.join("");
                    case "array":
                      return Array.prototype.concat.apply([], K);
                    case "uint8array":
                      for (ft = new Uint8Array(H), J = 0; J < K.length; J++) ft.set(K[J], rt), rt += K[J].length;
                      return ft;
                    case "nodebuffer":
                      return Buffer.concat(K);
                    default:
                      throw new Error("concat : unsupported type '" + F + "'");
                  }
                }(P, M), B);
                I(j);
              } catch (F) {
                C(F);
              }
              M = [];
            }).resume();
          });
        }
        function _(x, b, I) {
          var C = b;
          switch (b) {
            case "blob":
            case "arraybuffer":
              C = "uint8array";
              break;
            case "base64":
              C = "string";
          }
          try {
            this._internalType = C, this._outputType = b, this._mimeType = I, r.checkSupport(C), this._worker = x.pipe(new o(C)), x.lock();
          } catch (M) {
            this._worker = new l("error"), this._worker.error(M);
          }
        }
        _.prototype = { accumulate: function(x) {
          return y(this, x);
        }, on: function(x, b) {
          var I = this;
          return x === "data" ? this._worker.on(x, function(C) {
            b.call(I, C.data, C.meta);
          }) : this._worker.on(x, function() {
            r.delay(b, arguments, I);
          }), this;
        }, resume: function() {
          return r.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(x) {
          if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
          return new g(this, { objectMode: this._outputType !== "nodebuffer" }, x);
        } }, i.exports = _;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, n) {
        if (n.base64 = !0, n.array = !0, n.string = !0, n.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", n.nodebuffer = typeof Buffer < "u", n.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") n.blob = !1;
        else {
          var r = new ArrayBuffer(0);
          try {
            n.blob = new Blob([r], { type: "application/zip" }).size === 0;
          } catch {
            try {
              var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              o.append(r), n.blob = o.getBlob("application/zip").size === 0;
            } catch {
              n.blob = !1;
            }
          }
        }
        try {
          n.nodestream = !!e("readable-stream").Readable;
        } catch {
          n.nodestream = !1;
        }
      }, { "readable-stream": 16 }], 31: [function(e, i, n) {
        for (var r = e("./utils"), o = e("./support"), l = e("./nodejsUtils"), h = e("./stream/GenericWorker"), u = new Array(256), f = 0; f < 256; f++) u[f] = 252 <= f ? 6 : 248 <= f ? 5 : 240 <= f ? 4 : 224 <= f ? 3 : 192 <= f ? 2 : 1;
        u[254] = u[254] = 1;
        function g() {
          h.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function y() {
          h.call(this, "utf-8 encode");
        }
        n.utf8encode = function(_) {
          return o.nodebuffer ? l.newBufferFrom(_, "utf-8") : function(x) {
            var b, I, C, M, P, O = x.length, B = 0;
            for (M = 0; M < O; M++) (64512 & (I = x.charCodeAt(M))) == 55296 && M + 1 < O && (64512 & (C = x.charCodeAt(M + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (C - 56320), M++), B += I < 128 ? 1 : I < 2048 ? 2 : I < 65536 ? 3 : 4;
            for (b = o.uint8array ? new Uint8Array(B) : new Array(B), M = P = 0; P < B; M++) (64512 & (I = x.charCodeAt(M))) == 55296 && M + 1 < O && (64512 & (C = x.charCodeAt(M + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (C - 56320), M++), I < 128 ? b[P++] = I : (I < 2048 ? b[P++] = 192 | I >>> 6 : (I < 65536 ? b[P++] = 224 | I >>> 12 : (b[P++] = 240 | I >>> 18, b[P++] = 128 | I >>> 12 & 63), b[P++] = 128 | I >>> 6 & 63), b[P++] = 128 | 63 & I);
            return b;
          }(_);
        }, n.utf8decode = function(_) {
          return o.nodebuffer ? r.transformTo("nodebuffer", _).toString("utf-8") : function(x) {
            var b, I, C, M, P = x.length, O = new Array(2 * P);
            for (b = I = 0; b < P; ) if ((C = x[b++]) < 128) O[I++] = C;
            else if (4 < (M = u[C])) O[I++] = 65533, b += M - 1;
            else {
              for (C &= M === 2 ? 31 : M === 3 ? 15 : 7; 1 < M && b < P; ) C = C << 6 | 63 & x[b++], M--;
              1 < M ? O[I++] = 65533 : C < 65536 ? O[I++] = C : (C -= 65536, O[I++] = 55296 | C >> 10 & 1023, O[I++] = 56320 | 1023 & C);
            }
            return O.length !== I && (O.subarray ? O = O.subarray(0, I) : O.length = I), r.applyFromCharCode(O);
          }(_ = r.transformTo(o.uint8array ? "uint8array" : "array", _));
        }, r.inherits(g, h), g.prototype.processChunk = function(_) {
          var x = r.transformTo(o.uint8array ? "uint8array" : "array", _.data);
          if (this.leftOver && this.leftOver.length) {
            if (o.uint8array) {
              var b = x;
              (x = new Uint8Array(b.length + this.leftOver.length)).set(this.leftOver, 0), x.set(b, this.leftOver.length);
            } else x = this.leftOver.concat(x);
            this.leftOver = null;
          }
          var I = function(M, P) {
            var O;
            for ((P = P || M.length) > M.length && (P = M.length), O = P - 1; 0 <= O && (192 & M[O]) == 128; ) O--;
            return O < 0 || O === 0 ? P : O + u[M[O]] > P ? O : P;
          }(x), C = x;
          I !== x.length && (o.uint8array ? (C = x.subarray(0, I), this.leftOver = x.subarray(I, x.length)) : (C = x.slice(0, I), this.leftOver = x.slice(I, x.length))), this.push({ data: n.utf8decode(C), meta: _.meta });
        }, g.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: n.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, n.Utf8DecodeWorker = g, r.inherits(y, h), y.prototype.processChunk = function(_) {
          this.push({ data: n.utf8encode(_.data), meta: _.meta });
        }, n.Utf8EncodeWorker = y;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, n) {
        var r = e("./support"), o = e("./base64"), l = e("./nodejsUtils"), h = e("./external");
        function u(b) {
          return b;
        }
        function f(b, I) {
          for (var C = 0; C < b.length; ++C) I[C] = 255 & b.charCodeAt(C);
          return I;
        }
        e("setimmediate"), n.newBlob = function(b, I) {
          n.checkSupport("blob");
          try {
            return new Blob([b], { type: I });
          } catch {
            try {
              var C = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return C.append(b), C.getBlob(I);
            } catch {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var g = { stringifyByChunk: function(b, I, C) {
          var M = [], P = 0, O = b.length;
          if (O <= C) return String.fromCharCode.apply(null, b);
          for (; P < O; ) I === "array" || I === "nodebuffer" ? M.push(String.fromCharCode.apply(null, b.slice(P, Math.min(P + C, O)))) : M.push(String.fromCharCode.apply(null, b.subarray(P, Math.min(P + C, O)))), P += C;
          return M.join("");
        }, stringifyByChar: function(b) {
          for (var I = "", C = 0; C < b.length; C++) I += String.fromCharCode(b[C]);
          return I;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch {
            return !1;
          }
        }(), nodebuffer: function() {
          try {
            return r.nodebuffer && String.fromCharCode.apply(null, l.allocBuffer(1)).length === 1;
          } catch {
            return !1;
          }
        }() } };
        function y(b) {
          var I = 65536, C = n.getTypeOf(b), M = !0;
          if (C === "uint8array" ? M = g.applyCanBeUsed.uint8array : C === "nodebuffer" && (M = g.applyCanBeUsed.nodebuffer), M) for (; 1 < I; ) try {
            return g.stringifyByChunk(b, C, I);
          } catch {
            I = Math.floor(I / 2);
          }
          return g.stringifyByChar(b);
        }
        function _(b, I) {
          for (var C = 0; C < b.length; C++) I[C] = b[C];
          return I;
        }
        n.applyFromCharCode = y;
        var x = {};
        x.string = { string: u, array: function(b) {
          return f(b, new Array(b.length));
        }, arraybuffer: function(b) {
          return x.string.uint8array(b).buffer;
        }, uint8array: function(b) {
          return f(b, new Uint8Array(b.length));
        }, nodebuffer: function(b) {
          return f(b, l.allocBuffer(b.length));
        } }, x.array = { string: y, array: u, arraybuffer: function(b) {
          return new Uint8Array(b).buffer;
        }, uint8array: function(b) {
          return new Uint8Array(b);
        }, nodebuffer: function(b) {
          return l.newBufferFrom(b);
        } }, x.arraybuffer = { string: function(b) {
          return y(new Uint8Array(b));
        }, array: function(b) {
          return _(new Uint8Array(b), new Array(b.byteLength));
        }, arraybuffer: u, uint8array: function(b) {
          return new Uint8Array(b);
        }, nodebuffer: function(b) {
          return l.newBufferFrom(new Uint8Array(b));
        } }, x.uint8array = { string: y, array: function(b) {
          return _(b, new Array(b.length));
        }, arraybuffer: function(b) {
          return b.buffer;
        }, uint8array: u, nodebuffer: function(b) {
          return l.newBufferFrom(b);
        } }, x.nodebuffer = { string: y, array: function(b) {
          return _(b, new Array(b.length));
        }, arraybuffer: function(b) {
          return x.nodebuffer.uint8array(b).buffer;
        }, uint8array: function(b) {
          return _(b, new Uint8Array(b.length));
        }, nodebuffer: u }, n.transformTo = function(b, I) {
          if (I = I || "", !b) return I;
          n.checkSupport(b);
          var C = n.getTypeOf(I);
          return x[C][b](I);
        }, n.resolve = function(b) {
          for (var I = b.split("/"), C = [], M = 0; M < I.length; M++) {
            var P = I[M];
            P === "." || P === "" && M !== 0 && M !== I.length - 1 || (P === ".." ? C.pop() : C.push(P));
          }
          return C.join("/");
        }, n.getTypeOf = function(b) {
          return typeof b == "string" ? "string" : Object.prototype.toString.call(b) === "[object Array]" ? "array" : r.nodebuffer && l.isBuffer(b) ? "nodebuffer" : r.uint8array && b instanceof Uint8Array ? "uint8array" : r.arraybuffer && b instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, n.checkSupport = function(b) {
          if (!r[b.toLowerCase()]) throw new Error(b + " is not supported by this platform");
        }, n.MAX_VALUE_16BITS = 65535, n.MAX_VALUE_32BITS = -1, n.pretty = function(b) {
          var I, C, M = "";
          for (C = 0; C < (b || "").length; C++) M += "\\x" + ((I = b.charCodeAt(C)) < 16 ? "0" : "") + I.toString(16).toUpperCase();
          return M;
        }, n.delay = function(b, I, C) {
          setImmediate(function() {
            b.apply(C || null, I || []);
          });
        }, n.inherits = function(b, I) {
          function C() {
          }
          C.prototype = I.prototype, b.prototype = new C();
        }, n.extend = function() {
          var b, I, C = {};
          for (b = 0; b < arguments.length; b++) for (I in arguments[b]) Object.prototype.hasOwnProperty.call(arguments[b], I) && C[I] === void 0 && (C[I] = arguments[b][I]);
          return C;
        }, n.prepareContent = function(b, I, C, M, P) {
          return h.Promise.resolve(I).then(function(O) {
            return r.blob && (O instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(O)) !== -1) && typeof FileReader < "u" ? new h.Promise(function(B, j) {
              var F = new FileReader();
              F.onload = function(K) {
                B(K.target.result);
              }, F.onerror = function(K) {
                j(K.target.error);
              }, F.readAsArrayBuffer(O);
            }) : O;
          }).then(function(O) {
            var B = n.getTypeOf(O);
            return B ? (B === "arraybuffer" ? O = n.transformTo("uint8array", O) : B === "string" && (P ? O = o.decode(O) : C && M !== !0 && (O = function(j) {
              return f(j, r.uint8array ? new Uint8Array(j.length) : new Array(j.length));
            }(O))), O) : h.Promise.reject(new Error("Can't read the data of '" + b + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, n) {
        var r = e("./reader/readerFor"), o = e("./utils"), l = e("./signature"), h = e("./zipEntry"), u = e("./support");
        function f(g) {
          this.files = [], this.loadOptions = g;
        }
        f.prototype = { checkSignature: function(g) {
          if (!this.reader.readAndCheckSignature(g)) {
            this.reader.index -= 4;
            var y = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(y) + ", expected " + o.pretty(g) + ")");
          }
        }, isSignature: function(g, y) {
          var _ = this.reader.index;
          this.reader.setIndex(g);
          var x = this.reader.readString(4) === y;
          return this.reader.setIndex(_), x;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var g = this.reader.readData(this.zipCommentLength), y = u.uint8array ? "uint8array" : "array", _ = o.transformTo(y, g);
          this.zipComment = this.loadOptions.decodeFileName(_);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var g, y, _, x = this.zip64EndOfCentralSize - 44; 0 < x; ) g = this.reader.readInt(2), y = this.reader.readInt(4), _ = this.reader.readData(y), this.zip64ExtensibleData[g] = { id: g, length: y, value: _ };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var g, y;
          for (g = 0; g < this.files.length; g++) y = this.files[g], this.reader.setIndex(y.localHeaderOffset), this.checkSignature(l.LOCAL_FILE_HEADER), y.readLocalPart(this.reader), y.handleUTF8(), y.processAttributes();
        }, readCentralDir: function() {
          var g;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(l.CENTRAL_FILE_HEADER); ) (g = new h({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(g);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var g = this.reader.lastIndexOfSignature(l.CENTRAL_DIRECTORY_END);
          if (g < 0) throw this.isSignature(0, l.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          this.reader.setIndex(g);
          var y = g;
          if (this.checkSignature(l.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, (g = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(g), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, l.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var _ = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (_ += 20, _ += 12 + this.zip64EndOfCentralSize);
          var x = y - _;
          if (0 < x) this.isSignature(y, l.CENTRAL_FILE_HEADER) || (this.reader.zero = x);
          else if (x < 0) throw new Error("Corrupted zip: missing " + Math.abs(x) + " bytes.");
        }, prepareReader: function(g) {
          this.reader = r(g);
        }, load: function(g) {
          this.prepareReader(g), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, i.exports = f;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, n) {
        var r = e("./reader/readerFor"), o = e("./utils"), l = e("./compressedObject"), h = e("./crc32"), u = e("./utf8"), f = e("./compressions"), g = e("./support");
        function y(_, x) {
          this.options = _, this.loadOptions = x;
        }
        y.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(_) {
          var x, b;
          if (_.skip(22), this.fileNameLength = _.readInt(2), b = _.readInt(2), this.fileName = _.readData(this.fileNameLength), _.skip(b), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((x = function(I) {
            for (var C in f) if (Object.prototype.hasOwnProperty.call(f, C) && f[C].magic === I) return f[C];
            return null;
          }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
          this.decompressed = new l(this.compressedSize, this.uncompressedSize, this.crc32, x, _.readData(this.compressedSize));
        }, readCentralPart: function(_) {
          this.versionMadeBy = _.readInt(2), _.skip(2), this.bitFlag = _.readInt(2), this.compressionMethod = _.readString(2), this.date = _.readDate(), this.crc32 = _.readInt(4), this.compressedSize = _.readInt(4), this.uncompressedSize = _.readInt(4);
          var x = _.readInt(2);
          if (this.extraFieldsLength = _.readInt(2), this.fileCommentLength = _.readInt(2), this.diskNumberStart = _.readInt(2), this.internalFileAttributes = _.readInt(2), this.externalFileAttributes = _.readInt(4), this.localHeaderOffset = _.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          _.skip(x), this.readExtraFields(_), this.parseZIP64ExtraField(_), this.fileComment = _.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var _ = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), _ == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), _ == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var _ = r(this.extraFields[1].value);
            this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = _.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = _.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = _.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = _.readInt(4));
          }
        }, readExtraFields: function(_) {
          var x, b, I, C = _.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); _.index + 4 < C; ) x = _.readInt(2), b = _.readInt(2), I = _.readData(b), this.extraFields[x] = { id: x, length: b, value: I };
          _.setIndex(C);
        }, handleUTF8: function() {
          var _ = g.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
          else {
            var x = this.findExtraFieldUnicodePath();
            if (x !== null) this.fileNameStr = x;
            else {
              var b = o.transformTo(_, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(b);
            }
            var I = this.findExtraFieldUnicodeComment();
            if (I !== null) this.fileCommentStr = I;
            else {
              var C = o.transformTo(_, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(C);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var _ = this.extraFields[28789];
          if (_) {
            var x = r(_.value);
            return x.readInt(1) !== 1 || h(this.fileName) !== x.readInt(4) ? null : u.utf8decode(x.readData(_.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var _ = this.extraFields[25461];
          if (_) {
            var x = r(_.value);
            return x.readInt(1) !== 1 || h(this.fileComment) !== x.readInt(4) ? null : u.utf8decode(x.readData(_.length - 5));
          }
          return null;
        } }, i.exports = y;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, n) {
        function r(x, b, I) {
          this.name = x, this.dir = I.dir, this.date = I.date, this.comment = I.comment, this.unixPermissions = I.unixPermissions, this.dosPermissions = I.dosPermissions, this._data = b, this._dataBinary = I.binary, this.options = { compression: I.compression, compressionOptions: I.compressionOptions };
        }
        var o = e("./stream/StreamHelper"), l = e("./stream/DataWorker"), h = e("./utf8"), u = e("./compressedObject"), f = e("./stream/GenericWorker");
        r.prototype = { internalStream: function(x) {
          var b = null, I = "string";
          try {
            if (!x) throw new Error("No output type specified.");
            var C = (I = x.toLowerCase()) === "string" || I === "text";
            I !== "binarystring" && I !== "text" || (I = "string"), b = this._decompressWorker();
            var M = !this._dataBinary;
            M && !C && (b = b.pipe(new h.Utf8EncodeWorker())), !M && C && (b = b.pipe(new h.Utf8DecodeWorker()));
          } catch (P) {
            (b = new f("error")).error(P);
          }
          return new o(b, I, "");
        }, async: function(x, b) {
          return this.internalStream(x).accumulate(b);
        }, nodeStream: function(x, b) {
          return this.internalStream(x || "nodebuffer").toNodejsStream(b);
        }, _compressWorker: function(x, b) {
          if (this._data instanceof u && this._data.compression.magic === x.magic) return this._data.getCompressedWorker();
          var I = this._decompressWorker();
          return this._dataBinary || (I = I.pipe(new h.Utf8EncodeWorker())), u.createWorkerFrom(I, x, b);
        }, _decompressWorker: function() {
          return this._data instanceof u ? this._data.getContentWorker() : this._data instanceof f ? this._data : new l(this._data);
        } };
        for (var g = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], y = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, _ = 0; _ < g.length; _++) r.prototype[g[_]] = y;
        i.exports = r;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, n) {
        (function(r) {
          var o, l, h = r.MutationObserver || r.WebKitMutationObserver;
          if (h) {
            var u = 0, f = new h(x), g = r.document.createTextNode("");
            f.observe(g, { characterData: !0 }), o = function() {
              g.data = u = ++u % 2;
            };
          } else if (r.setImmediate || r.MessageChannel === void 0) o = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
            var b = r.document.createElement("script");
            b.onreadystatechange = function() {
              x(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null;
            }, r.document.documentElement.appendChild(b);
          } : function() {
            setTimeout(x, 0);
          };
          else {
            var y = new r.MessageChannel();
            y.port1.onmessage = x, o = function() {
              y.port2.postMessage(0);
            };
          }
          var _ = [];
          function x() {
            var b, I;
            l = !0;
            for (var C = _.length; C; ) {
              for (I = _, _ = [], b = -1; ++b < C; ) I[b]();
              C = _.length;
            }
            l = !1;
          }
          i.exports = function(b) {
            _.push(b) !== 1 || l || o();
          };
        }).call(this, typeof ac < "u" ? ac : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 37: [function(e, i, n) {
        var r = e("immediate");
        function o() {
        }
        var l = {}, h = ["REJECTED"], u = ["FULFILLED"], f = ["PENDING"];
        function g(C) {
          if (typeof C != "function") throw new TypeError("resolver must be a function");
          this.state = f, this.queue = [], this.outcome = void 0, C !== o && b(this, C);
        }
        function y(C, M, P) {
          this.promise = C, typeof M == "function" && (this.onFulfilled = M, this.callFulfilled = this.otherCallFulfilled), typeof P == "function" && (this.onRejected = P, this.callRejected = this.otherCallRejected);
        }
        function _(C, M, P) {
          r(function() {
            var O;
            try {
              O = M(P);
            } catch (B) {
              return l.reject(C, B);
            }
            O === C ? l.reject(C, new TypeError("Cannot resolve promise with itself")) : l.resolve(C, O);
          });
        }
        function x(C) {
          var M = C && C.then;
          if (C && (typeof C == "object" || typeof C == "function") && typeof M == "function") return function() {
            M.apply(C, arguments);
          };
        }
        function b(C, M) {
          var P = !1;
          function O(F) {
            P || (P = !0, l.reject(C, F));
          }
          function B(F) {
            P || (P = !0, l.resolve(C, F));
          }
          var j = I(function() {
            M(B, O);
          });
          j.status === "error" && O(j.value);
        }
        function I(C, M) {
          var P = {};
          try {
            P.value = C(M), P.status = "success";
          } catch (O) {
            P.status = "error", P.value = O;
          }
          return P;
        }
        (i.exports = g).prototype.finally = function(C) {
          if (typeof C != "function") return this;
          var M = this.constructor;
          return this.then(function(P) {
            return M.resolve(C()).then(function() {
              return P;
            });
          }, function(P) {
            return M.resolve(C()).then(function() {
              throw P;
            });
          });
        }, g.prototype.catch = function(C) {
          return this.then(null, C);
        }, g.prototype.then = function(C, M) {
          if (typeof C != "function" && this.state === u || typeof M != "function" && this.state === h) return this;
          var P = new this.constructor(o);
          return this.state !== f ? _(P, this.state === u ? C : M, this.outcome) : this.queue.push(new y(P, C, M)), P;
        }, y.prototype.callFulfilled = function(C) {
          l.resolve(this.promise, C);
        }, y.prototype.otherCallFulfilled = function(C) {
          _(this.promise, this.onFulfilled, C);
        }, y.prototype.callRejected = function(C) {
          l.reject(this.promise, C);
        }, y.prototype.otherCallRejected = function(C) {
          _(this.promise, this.onRejected, C);
        }, l.resolve = function(C, M) {
          var P = I(x, M);
          if (P.status === "error") return l.reject(C, P.value);
          var O = P.value;
          if (O) b(C, O);
          else {
            C.state = u, C.outcome = M;
            for (var B = -1, j = C.queue.length; ++B < j; ) C.queue[B].callFulfilled(M);
          }
          return C;
        }, l.reject = function(C, M) {
          C.state = h, C.outcome = M;
          for (var P = -1, O = C.queue.length; ++P < O; ) C.queue[P].callRejected(M);
          return C;
        }, g.resolve = function(C) {
          return C instanceof this ? C : l.resolve(new this(o), C);
        }, g.reject = function(C) {
          var M = new this(o);
          return l.reject(M, C);
        }, g.all = function(C) {
          var M = this;
          if (Object.prototype.toString.call(C) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var P = C.length, O = !1;
          if (!P) return this.resolve([]);
          for (var B = new Array(P), j = 0, F = -1, K = new this(o); ++F < P; ) J(C[F], F);
          return K;
          function J(rt, ft) {
            M.resolve(rt).then(function(H) {
              B[ft] = H, ++j !== P || O || (O = !0, l.resolve(K, B));
            }, function(H) {
              O || (O = !0, l.reject(K, H));
            });
          }
        }, g.race = function(C) {
          var M = this;
          if (Object.prototype.toString.call(C) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var P = C.length, O = !1;
          if (!P) return this.resolve([]);
          for (var B = -1, j = new this(o); ++B < P; ) F = C[B], M.resolve(F).then(function(K) {
            O || (O = !0, l.resolve(j, K));
          }, function(K) {
            O || (O = !0, l.reject(j, K));
          });
          var F;
          return j;
        };
      }, { immediate: 36 }], 38: [function(e, i, n) {
        var r = {};
        (0, e("./lib/utils/common").assign)(r, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = r;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, n) {
        var r = e("./zlib/deflate"), o = e("./utils/common"), l = e("./utils/strings"), h = e("./zlib/messages"), u = e("./zlib/zstream"), f = Object.prototype.toString, g = 0, y = -1, _ = 0, x = 8;
        function b(C) {
          if (!(this instanceof b)) return new b(C);
          this.options = o.assign({ level: y, method: x, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: _, to: "" }, C || {});
          var M = this.options;
          M.raw && 0 < M.windowBits ? M.windowBits = -M.windowBits : M.gzip && 0 < M.windowBits && M.windowBits < 16 && (M.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
          var P = r.deflateInit2(this.strm, M.level, M.method, M.windowBits, M.memLevel, M.strategy);
          if (P !== g) throw new Error(h[P]);
          if (M.header && r.deflateSetHeader(this.strm, M.header), M.dictionary) {
            var O;
            if (O = typeof M.dictionary == "string" ? l.string2buf(M.dictionary) : f.call(M.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(M.dictionary) : M.dictionary, (P = r.deflateSetDictionary(this.strm, O)) !== g) throw new Error(h[P]);
            this._dict_set = !0;
          }
        }
        function I(C, M) {
          var P = new b(M);
          if (P.push(C, !0), P.err) throw P.msg || h[P.err];
          return P.result;
        }
        b.prototype.push = function(C, M) {
          var P, O, B = this.strm, j = this.options.chunkSize;
          if (this.ended) return !1;
          O = M === ~~M ? M : M === !0 ? 4 : 0, typeof C == "string" ? B.input = l.string2buf(C) : f.call(C) === "[object ArrayBuffer]" ? B.input = new Uint8Array(C) : B.input = C, B.next_in = 0, B.avail_in = B.input.length;
          do {
            if (B.avail_out === 0 && (B.output = new o.Buf8(j), B.next_out = 0, B.avail_out = j), (P = r.deflate(B, O)) !== 1 && P !== g) return this.onEnd(P), !(this.ended = !0);
            B.avail_out !== 0 && (B.avail_in !== 0 || O !== 4 && O !== 2) || (this.options.to === "string" ? this.onData(l.buf2binstring(o.shrinkBuf(B.output, B.next_out))) : this.onData(o.shrinkBuf(B.output, B.next_out)));
          } while ((0 < B.avail_in || B.avail_out === 0) && P !== 1);
          return O === 4 ? (P = r.deflateEnd(this.strm), this.onEnd(P), this.ended = !0, P === g) : O !== 2 || (this.onEnd(g), !(B.avail_out = 0));
        }, b.prototype.onData = function(C) {
          this.chunks.push(C);
        }, b.prototype.onEnd = function(C) {
          C === g && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = C, this.msg = this.strm.msg;
        }, n.Deflate = b, n.deflate = I, n.deflateRaw = function(C, M) {
          return (M = M || {}).raw = !0, I(C, M);
        }, n.gzip = function(C, M) {
          return (M = M || {}).gzip = !0, I(C, M);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, n) {
        var r = e("./zlib/inflate"), o = e("./utils/common"), l = e("./utils/strings"), h = e("./zlib/constants"), u = e("./zlib/messages"), f = e("./zlib/zstream"), g = e("./zlib/gzheader"), y = Object.prototype.toString;
        function _(b) {
          if (!(this instanceof _)) return new _(b);
          this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, b || {});
          var I = this.options;
          I.raw && 0 <= I.windowBits && I.windowBits < 16 && (I.windowBits = -I.windowBits, I.windowBits === 0 && (I.windowBits = -15)), !(0 <= I.windowBits && I.windowBits < 16) || b && b.windowBits || (I.windowBits += 32), 15 < I.windowBits && I.windowBits < 48 && (15 & I.windowBits) == 0 && (I.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
          var C = r.inflateInit2(this.strm, I.windowBits);
          if (C !== h.Z_OK) throw new Error(u[C]);
          this.header = new g(), r.inflateGetHeader(this.strm, this.header);
        }
        function x(b, I) {
          var C = new _(I);
          if (C.push(b, !0), C.err) throw C.msg || u[C.err];
          return C.result;
        }
        _.prototype.push = function(b, I) {
          var C, M, P, O, B, j, F = this.strm, K = this.options.chunkSize, J = this.options.dictionary, rt = !1;
          if (this.ended) return !1;
          M = I === ~~I ? I : I === !0 ? h.Z_FINISH : h.Z_NO_FLUSH, typeof b == "string" ? F.input = l.binstring2buf(b) : y.call(b) === "[object ArrayBuffer]" ? F.input = new Uint8Array(b) : F.input = b, F.next_in = 0, F.avail_in = F.input.length;
          do {
            if (F.avail_out === 0 && (F.output = new o.Buf8(K), F.next_out = 0, F.avail_out = K), (C = r.inflate(F, h.Z_NO_FLUSH)) === h.Z_NEED_DICT && J && (j = typeof J == "string" ? l.string2buf(J) : y.call(J) === "[object ArrayBuffer]" ? new Uint8Array(J) : J, C = r.inflateSetDictionary(this.strm, j)), C === h.Z_BUF_ERROR && rt === !0 && (C = h.Z_OK, rt = !1), C !== h.Z_STREAM_END && C !== h.Z_OK) return this.onEnd(C), !(this.ended = !0);
            F.next_out && (F.avail_out !== 0 && C !== h.Z_STREAM_END && (F.avail_in !== 0 || M !== h.Z_FINISH && M !== h.Z_SYNC_FLUSH) || (this.options.to === "string" ? (P = l.utf8border(F.output, F.next_out), O = F.next_out - P, B = l.buf2string(F.output, P), F.next_out = O, F.avail_out = K - O, O && o.arraySet(F.output, F.output, P, O, 0), this.onData(B)) : this.onData(o.shrinkBuf(F.output, F.next_out)))), F.avail_in === 0 && F.avail_out === 0 && (rt = !0);
          } while ((0 < F.avail_in || F.avail_out === 0) && C !== h.Z_STREAM_END);
          return C === h.Z_STREAM_END && (M = h.Z_FINISH), M === h.Z_FINISH ? (C = r.inflateEnd(this.strm), this.onEnd(C), this.ended = !0, C === h.Z_OK) : M !== h.Z_SYNC_FLUSH || (this.onEnd(h.Z_OK), !(F.avail_out = 0));
        }, _.prototype.onData = function(b) {
          this.chunks.push(b);
        }, _.prototype.onEnd = function(b) {
          b === h.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
        }, n.Inflate = _, n.inflate = x, n.inflateRaw = function(b, I) {
          return (I = I || {}).raw = !0, x(b, I);
        }, n.ungzip = x;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, n) {
        var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        n.assign = function(h) {
          for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
            var f = u.shift();
            if (f) {
              if (typeof f != "object") throw new TypeError(f + "must be non-object");
              for (var g in f) f.hasOwnProperty(g) && (h[g] = f[g]);
            }
          }
          return h;
        }, n.shrinkBuf = function(h, u) {
          return h.length === u ? h : h.subarray ? h.subarray(0, u) : (h.length = u, h);
        };
        var o = { arraySet: function(h, u, f, g, y) {
          if (u.subarray && h.subarray) h.set(u.subarray(f, f + g), y);
          else for (var _ = 0; _ < g; _++) h[y + _] = u[f + _];
        }, flattenChunks: function(h) {
          var u, f, g, y, _, x;
          for (u = g = 0, f = h.length; u < f; u++) g += h[u].length;
          for (x = new Uint8Array(g), u = y = 0, f = h.length; u < f; u++) _ = h[u], x.set(_, y), y += _.length;
          return x;
        } }, l = { arraySet: function(h, u, f, g, y) {
          for (var _ = 0; _ < g; _++) h[y + _] = u[f + _];
        }, flattenChunks: function(h) {
          return [].concat.apply([], h);
        } };
        n.setTyped = function(h) {
          h ? (n.Buf8 = Uint8Array, n.Buf16 = Uint16Array, n.Buf32 = Int32Array, n.assign(n, o)) : (n.Buf8 = Array, n.Buf16 = Array, n.Buf32 = Array, n.assign(n, l));
        }, n.setTyped(r);
      }, {}], 42: [function(e, i, n) {
        var r = e("./common"), o = !0, l = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          o = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          l = !1;
        }
        for (var h = new r.Buf8(256), u = 0; u < 256; u++) h[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
        function f(g, y) {
          if (y < 65537 && (g.subarray && l || !g.subarray && o)) return String.fromCharCode.apply(null, r.shrinkBuf(g, y));
          for (var _ = "", x = 0; x < y; x++) _ += String.fromCharCode(g[x]);
          return _;
        }
        h[254] = h[254] = 1, n.string2buf = function(g) {
          var y, _, x, b, I, C = g.length, M = 0;
          for (b = 0; b < C; b++) (64512 & (_ = g.charCodeAt(b))) == 55296 && b + 1 < C && (64512 & (x = g.charCodeAt(b + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (x - 56320), b++), M += _ < 128 ? 1 : _ < 2048 ? 2 : _ < 65536 ? 3 : 4;
          for (y = new r.Buf8(M), b = I = 0; I < M; b++) (64512 & (_ = g.charCodeAt(b))) == 55296 && b + 1 < C && (64512 & (x = g.charCodeAt(b + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (x - 56320), b++), _ < 128 ? y[I++] = _ : (_ < 2048 ? y[I++] = 192 | _ >>> 6 : (_ < 65536 ? y[I++] = 224 | _ >>> 12 : (y[I++] = 240 | _ >>> 18, y[I++] = 128 | _ >>> 12 & 63), y[I++] = 128 | _ >>> 6 & 63), y[I++] = 128 | 63 & _);
          return y;
        }, n.buf2binstring = function(g) {
          return f(g, g.length);
        }, n.binstring2buf = function(g) {
          for (var y = new r.Buf8(g.length), _ = 0, x = y.length; _ < x; _++) y[_] = g.charCodeAt(_);
          return y;
        }, n.buf2string = function(g, y) {
          var _, x, b, I, C = y || g.length, M = new Array(2 * C);
          for (_ = x = 0; _ < C; ) if ((b = g[_++]) < 128) M[x++] = b;
          else if (4 < (I = h[b])) M[x++] = 65533, _ += I - 1;
          else {
            for (b &= I === 2 ? 31 : I === 3 ? 15 : 7; 1 < I && _ < C; ) b = b << 6 | 63 & g[_++], I--;
            1 < I ? M[x++] = 65533 : b < 65536 ? M[x++] = b : (b -= 65536, M[x++] = 55296 | b >> 10 & 1023, M[x++] = 56320 | 1023 & b);
          }
          return f(M, x);
        }, n.utf8border = function(g, y) {
          var _;
          for ((y = y || g.length) > g.length && (y = g.length), _ = y - 1; 0 <= _ && (192 & g[_]) == 128; ) _--;
          return _ < 0 || _ === 0 ? y : _ + h[g[_]] > y ? _ : y;
        };
      }, { "./common": 41 }], 43: [function(e, i, n) {
        i.exports = function(r, o, l, h) {
          for (var u = 65535 & r | 0, f = r >>> 16 & 65535 | 0, g = 0; l !== 0; ) {
            for (l -= g = 2e3 < l ? 2e3 : l; f = f + (u = u + o[h++] | 0) | 0, --g; ) ;
            u %= 65521, f %= 65521;
          }
          return u | f << 16 | 0;
        };
      }, {}], 44: [function(e, i, n) {
        i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, i, n) {
        var r = function() {
          for (var o, l = [], h = 0; h < 256; h++) {
            o = h;
            for (var u = 0; u < 8; u++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
            l[h] = o;
          }
          return l;
        }();
        i.exports = function(o, l, h, u) {
          var f = r, g = u + h;
          o ^= -1;
          for (var y = u; y < g; y++) o = o >>> 8 ^ f[255 & (o ^ l[y])];
          return -1 ^ o;
        };
      }, {}], 46: [function(e, i, n) {
        var r, o = e("../utils/common"), l = e("./trees"), h = e("./adler32"), u = e("./crc32"), f = e("./messages"), g = 0, y = 4, _ = 0, x = -2, b = -1, I = 4, C = 2, M = 8, P = 9, O = 286, B = 30, j = 19, F = 2 * O + 1, K = 15, J = 3, rt = 258, ft = rt + J + 1, H = 42, $ = 113, D = 1, R = 2, U = 3, it = 4;
        function at(T, vt) {
          return T.msg = f[vt], vt;
        }
        function mt(T) {
          return (T << 1) - (4 < T ? 9 : 0);
        }
        function Nt(T) {
          for (var vt = T.length; 0 <= --vt; ) T[vt] = 0;
        }
        function lt(T) {
          var vt = T.state, pt = vt.pending;
          pt > T.avail_out && (pt = T.avail_out), pt !== 0 && (o.arraySet(T.output, vt.pending_buf, vt.pending_out, pt, T.next_out), T.next_out += pt, vt.pending_out += pt, T.total_out += pt, T.avail_out -= pt, vt.pending -= pt, vt.pending === 0 && (vt.pending_out = 0));
        }
        function ot(T, vt) {
          l._tr_flush_block(T, 0 <= T.block_start ? T.block_start : -1, T.strstart - T.block_start, vt), T.block_start = T.strstart, lt(T.strm);
        }
        function Ht(T, vt) {
          T.pending_buf[T.pending++] = vt;
        }
        function St(T, vt) {
          T.pending_buf[T.pending++] = vt >>> 8 & 255, T.pending_buf[T.pending++] = 255 & vt;
        }
        function Rt(T, vt) {
          var pt, q, W = T.max_chain_length, st = T.strstart, xt = T.prev_length, It = T.nice_match, nt = T.strstart > T.w_size - ft ? T.strstart - (T.w_size - ft) : 0, kt = T.window, Lt = T.w_mask, Tt = T.prev, Yt = T.strstart + rt, Ve = kt[st + xt - 1], xe = kt[st + xt];
          T.prev_length >= T.good_match && (W >>= 2), It > T.lookahead && (It = T.lookahead);
          do
            if (kt[(pt = vt) + xt] === xe && kt[pt + xt - 1] === Ve && kt[pt] === kt[st] && kt[++pt] === kt[st + 1]) {
              st += 2, pt++;
              do
                ;
              while (kt[++st] === kt[++pt] && kt[++st] === kt[++pt] && kt[++st] === kt[++pt] && kt[++st] === kt[++pt] && kt[++st] === kt[++pt] && kt[++st] === kt[++pt] && kt[++st] === kt[++pt] && kt[++st] === kt[++pt] && st < Yt);
              if (q = rt - (Yt - st), st = Yt - rt, xt < q) {
                if (T.match_start = vt, It <= (xt = q)) break;
                Ve = kt[st + xt - 1], xe = kt[st + xt];
              }
            }
          while ((vt = Tt[vt & Lt]) > nt && --W != 0);
          return xt <= T.lookahead ? xt : T.lookahead;
        }
        function ei(T) {
          var vt, pt, q, W, st, xt, It, nt, kt, Lt, Tt = T.w_size;
          do {
            if (W = T.window_size - T.lookahead - T.strstart, T.strstart >= Tt + (Tt - ft)) {
              for (o.arraySet(T.window, T.window, Tt, Tt, 0), T.match_start -= Tt, T.strstart -= Tt, T.block_start -= Tt, vt = pt = T.hash_size; q = T.head[--vt], T.head[vt] = Tt <= q ? q - Tt : 0, --pt; ) ;
              for (vt = pt = Tt; q = T.prev[--vt], T.prev[vt] = Tt <= q ? q - Tt : 0, --pt; ) ;
              W += Tt;
            }
            if (T.strm.avail_in === 0) break;
            if (xt = T.strm, It = T.window, nt = T.strstart + T.lookahead, kt = W, Lt = void 0, Lt = xt.avail_in, kt < Lt && (Lt = kt), pt = Lt === 0 ? 0 : (xt.avail_in -= Lt, o.arraySet(It, xt.input, xt.next_in, Lt, nt), xt.state.wrap === 1 ? xt.adler = h(xt.adler, It, Lt, nt) : xt.state.wrap === 2 && (xt.adler = u(xt.adler, It, Lt, nt)), xt.next_in += Lt, xt.total_in += Lt, Lt), T.lookahead += pt, T.lookahead + T.insert >= J) for (st = T.strstart - T.insert, T.ins_h = T.window[st], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[st + 1]) & T.hash_mask; T.insert && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[st + J - 1]) & T.hash_mask, T.prev[st & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = st, st++, T.insert--, !(T.lookahead + T.insert < J)); ) ;
          } while (T.lookahead < ft && T.strm.avail_in !== 0);
        }
        function ai(T, vt) {
          for (var pt, q; ; ) {
            if (T.lookahead < ft) {
              if (ei(T), T.lookahead < ft && vt === g) return D;
              if (T.lookahead === 0) break;
            }
            if (pt = 0, T.lookahead >= J && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + J - 1]) & T.hash_mask, pt = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), pt !== 0 && T.strstart - pt <= T.w_size - ft && (T.match_length = Rt(T, pt)), T.match_length >= J) if (q = l._tr_tally(T, T.strstart - T.match_start, T.match_length - J), T.lookahead -= T.match_length, T.match_length <= T.max_lazy_match && T.lookahead >= J) {
              for (T.match_length--; T.strstart++, T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + J - 1]) & T.hash_mask, pt = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart, --T.match_length != 0; ) ;
              T.strstart++;
            } else T.strstart += T.match_length, T.match_length = 0, T.ins_h = T.window[T.strstart], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + 1]) & T.hash_mask;
            else q = l._tr_tally(T, 0, T.window[T.strstart]), T.lookahead--, T.strstart++;
            if (q && (ot(T, !1), T.strm.avail_out === 0)) return D;
          }
          return T.insert = T.strstart < J - 1 ? T.strstart : J - 1, vt === y ? (ot(T, !0), T.strm.avail_out === 0 ? U : it) : T.last_lit && (ot(T, !1), T.strm.avail_out === 0) ? D : R;
        }
        function re(T, vt) {
          for (var pt, q, W; ; ) {
            if (T.lookahead < ft) {
              if (ei(T), T.lookahead < ft && vt === g) return D;
              if (T.lookahead === 0) break;
            }
            if (pt = 0, T.lookahead >= J && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + J - 1]) & T.hash_mask, pt = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), T.prev_length = T.match_length, T.prev_match = T.match_start, T.match_length = J - 1, pt !== 0 && T.prev_length < T.max_lazy_match && T.strstart - pt <= T.w_size - ft && (T.match_length = Rt(T, pt), T.match_length <= 5 && (T.strategy === 1 || T.match_length === J && 4096 < T.strstart - T.match_start) && (T.match_length = J - 1)), T.prev_length >= J && T.match_length <= T.prev_length) {
              for (W = T.strstart + T.lookahead - J, q = l._tr_tally(T, T.strstart - 1 - T.prev_match, T.prev_length - J), T.lookahead -= T.prev_length - 1, T.prev_length -= 2; ++T.strstart <= W && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + J - 1]) & T.hash_mask, pt = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), --T.prev_length != 0; ) ;
              if (T.match_available = 0, T.match_length = J - 1, T.strstart++, q && (ot(T, !1), T.strm.avail_out === 0)) return D;
            } else if (T.match_available) {
              if ((q = l._tr_tally(T, 0, T.window[T.strstart - 1])) && ot(T, !1), T.strstart++, T.lookahead--, T.strm.avail_out === 0) return D;
            } else T.match_available = 1, T.strstart++, T.lookahead--;
          }
          return T.match_available && (q = l._tr_tally(T, 0, T.window[T.strstart - 1]), T.match_available = 0), T.insert = T.strstart < J - 1 ? T.strstart : J - 1, vt === y ? (ot(T, !0), T.strm.avail_out === 0 ? U : it) : T.last_lit && (ot(T, !1), T.strm.avail_out === 0) ? D : R;
        }
        function Se(T, vt, pt, q, W) {
          this.good_length = T, this.max_lazy = vt, this.nice_length = pt, this.max_chain = q, this.func = W;
        }
        function Be() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = M, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * F), this.dyn_dtree = new o.Buf16(2 * (2 * B + 1)), this.bl_tree = new o.Buf16(2 * (2 * j + 1)), Nt(this.dyn_ltree), Nt(this.dyn_dtree), Nt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(K + 1), this.heap = new o.Buf16(2 * O + 1), Nt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * O + 1), Nt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function pe(T) {
          var vt;
          return T && T.state ? (T.total_in = T.total_out = 0, T.data_type = C, (vt = T.state).pending = 0, vt.pending_out = 0, vt.wrap < 0 && (vt.wrap = -vt.wrap), vt.status = vt.wrap ? H : $, T.adler = vt.wrap === 2 ? 0 : 1, vt.last_flush = g, l._tr_init(vt), _) : at(T, x);
        }
        function ki(T) {
          var vt = pe(T);
          return vt === _ && function(pt) {
            pt.window_size = 2 * pt.w_size, Nt(pt.head), pt.max_lazy_match = r[pt.level].max_lazy, pt.good_match = r[pt.level].good_length, pt.nice_match = r[pt.level].nice_length, pt.max_chain_length = r[pt.level].max_chain, pt.strstart = 0, pt.block_start = 0, pt.lookahead = 0, pt.insert = 0, pt.match_length = pt.prev_length = J - 1, pt.match_available = 0, pt.ins_h = 0;
          }(T.state), vt;
        }
        function ii(T, vt, pt, q, W, st) {
          if (!T) return x;
          var xt = 1;
          if (vt === b && (vt = 6), q < 0 ? (xt = 0, q = -q) : 15 < q && (xt = 2, q -= 16), W < 1 || P < W || pt !== M || q < 8 || 15 < q || vt < 0 || 9 < vt || st < 0 || I < st) return at(T, x);
          q === 8 && (q = 9);
          var It = new Be();
          return (T.state = It).strm = T, It.wrap = xt, It.gzhead = null, It.w_bits = q, It.w_size = 1 << It.w_bits, It.w_mask = It.w_size - 1, It.hash_bits = W + 7, It.hash_size = 1 << It.hash_bits, It.hash_mask = It.hash_size - 1, It.hash_shift = ~~((It.hash_bits + J - 1) / J), It.window = new o.Buf8(2 * It.w_size), It.head = new o.Buf16(It.hash_size), It.prev = new o.Buf16(It.w_size), It.lit_bufsize = 1 << W + 6, It.pending_buf_size = 4 * It.lit_bufsize, It.pending_buf = new o.Buf8(It.pending_buf_size), It.d_buf = 1 * It.lit_bufsize, It.l_buf = 3 * It.lit_bufsize, It.level = vt, It.strategy = st, It.method = pt, ki(T);
        }
        r = [new Se(0, 0, 0, 0, function(T, vt) {
          var pt = 65535;
          for (pt > T.pending_buf_size - 5 && (pt = T.pending_buf_size - 5); ; ) {
            if (T.lookahead <= 1) {
              if (ei(T), T.lookahead === 0 && vt === g) return D;
              if (T.lookahead === 0) break;
            }
            T.strstart += T.lookahead, T.lookahead = 0;
            var q = T.block_start + pt;
            if ((T.strstart === 0 || T.strstart >= q) && (T.lookahead = T.strstart - q, T.strstart = q, ot(T, !1), T.strm.avail_out === 0) || T.strstart - T.block_start >= T.w_size - ft && (ot(T, !1), T.strm.avail_out === 0)) return D;
          }
          return T.insert = 0, vt === y ? (ot(T, !0), T.strm.avail_out === 0 ? U : it) : (T.strstart > T.block_start && (ot(T, !1), T.strm.avail_out), D);
        }), new Se(4, 4, 8, 4, ai), new Se(4, 5, 16, 8, ai), new Se(4, 6, 32, 32, ai), new Se(4, 4, 16, 16, re), new Se(8, 16, 32, 32, re), new Se(8, 16, 128, 128, re), new Se(8, 32, 128, 256, re), new Se(32, 128, 258, 1024, re), new Se(32, 258, 258, 4096, re)], n.deflateInit = function(T, vt) {
          return ii(T, vt, M, 15, 8, 0);
        }, n.deflateInit2 = ii, n.deflateReset = ki, n.deflateResetKeep = pe, n.deflateSetHeader = function(T, vt) {
          return T && T.state ? T.state.wrap !== 2 ? x : (T.state.gzhead = vt, _) : x;
        }, n.deflate = function(T, vt) {
          var pt, q, W, st;
          if (!T || !T.state || 5 < vt || vt < 0) return T ? at(T, x) : x;
          if (q = T.state, !T.output || !T.input && T.avail_in !== 0 || q.status === 666 && vt !== y) return at(T, T.avail_out === 0 ? -5 : x);
          if (q.strm = T, pt = q.last_flush, q.last_flush = vt, q.status === H) if (q.wrap === 2) T.adler = 0, Ht(q, 31), Ht(q, 139), Ht(q, 8), q.gzhead ? (Ht(q, (q.gzhead.text ? 1 : 0) + (q.gzhead.hcrc ? 2 : 0) + (q.gzhead.extra ? 4 : 0) + (q.gzhead.name ? 8 : 0) + (q.gzhead.comment ? 16 : 0)), Ht(q, 255 & q.gzhead.time), Ht(q, q.gzhead.time >> 8 & 255), Ht(q, q.gzhead.time >> 16 & 255), Ht(q, q.gzhead.time >> 24 & 255), Ht(q, q.level === 9 ? 2 : 2 <= q.strategy || q.level < 2 ? 4 : 0), Ht(q, 255 & q.gzhead.os), q.gzhead.extra && q.gzhead.extra.length && (Ht(q, 255 & q.gzhead.extra.length), Ht(q, q.gzhead.extra.length >> 8 & 255)), q.gzhead.hcrc && (T.adler = u(T.adler, q.pending_buf, q.pending, 0)), q.gzindex = 0, q.status = 69) : (Ht(q, 0), Ht(q, 0), Ht(q, 0), Ht(q, 0), Ht(q, 0), Ht(q, q.level === 9 ? 2 : 2 <= q.strategy || q.level < 2 ? 4 : 0), Ht(q, 3), q.status = $);
          else {
            var xt = M + (q.w_bits - 8 << 4) << 8;
            xt |= (2 <= q.strategy || q.level < 2 ? 0 : q.level < 6 ? 1 : q.level === 6 ? 2 : 3) << 6, q.strstart !== 0 && (xt |= 32), xt += 31 - xt % 31, q.status = $, St(q, xt), q.strstart !== 0 && (St(q, T.adler >>> 16), St(q, 65535 & T.adler)), T.adler = 1;
          }
          if (q.status === 69) if (q.gzhead.extra) {
            for (W = q.pending; q.gzindex < (65535 & q.gzhead.extra.length) && (q.pending !== q.pending_buf_size || (q.gzhead.hcrc && q.pending > W && (T.adler = u(T.adler, q.pending_buf, q.pending - W, W)), lt(T), W = q.pending, q.pending !== q.pending_buf_size)); ) Ht(q, 255 & q.gzhead.extra[q.gzindex]), q.gzindex++;
            q.gzhead.hcrc && q.pending > W && (T.adler = u(T.adler, q.pending_buf, q.pending - W, W)), q.gzindex === q.gzhead.extra.length && (q.gzindex = 0, q.status = 73);
          } else q.status = 73;
          if (q.status === 73) if (q.gzhead.name) {
            W = q.pending;
            do {
              if (q.pending === q.pending_buf_size && (q.gzhead.hcrc && q.pending > W && (T.adler = u(T.adler, q.pending_buf, q.pending - W, W)), lt(T), W = q.pending, q.pending === q.pending_buf_size)) {
                st = 1;
                break;
              }
              st = q.gzindex < q.gzhead.name.length ? 255 & q.gzhead.name.charCodeAt(q.gzindex++) : 0, Ht(q, st);
            } while (st !== 0);
            q.gzhead.hcrc && q.pending > W && (T.adler = u(T.adler, q.pending_buf, q.pending - W, W)), st === 0 && (q.gzindex = 0, q.status = 91);
          } else q.status = 91;
          if (q.status === 91) if (q.gzhead.comment) {
            W = q.pending;
            do {
              if (q.pending === q.pending_buf_size && (q.gzhead.hcrc && q.pending > W && (T.adler = u(T.adler, q.pending_buf, q.pending - W, W)), lt(T), W = q.pending, q.pending === q.pending_buf_size)) {
                st = 1;
                break;
              }
              st = q.gzindex < q.gzhead.comment.length ? 255 & q.gzhead.comment.charCodeAt(q.gzindex++) : 0, Ht(q, st);
            } while (st !== 0);
            q.gzhead.hcrc && q.pending > W && (T.adler = u(T.adler, q.pending_buf, q.pending - W, W)), st === 0 && (q.status = 103);
          } else q.status = 103;
          if (q.status === 103 && (q.gzhead.hcrc ? (q.pending + 2 > q.pending_buf_size && lt(T), q.pending + 2 <= q.pending_buf_size && (Ht(q, 255 & T.adler), Ht(q, T.adler >> 8 & 255), T.adler = 0, q.status = $)) : q.status = $), q.pending !== 0) {
            if (lt(T), T.avail_out === 0) return q.last_flush = -1, _;
          } else if (T.avail_in === 0 && mt(vt) <= mt(pt) && vt !== y) return at(T, -5);
          if (q.status === 666 && T.avail_in !== 0) return at(T, -5);
          if (T.avail_in !== 0 || q.lookahead !== 0 || vt !== g && q.status !== 666) {
            var It = q.strategy === 2 ? function(nt, kt) {
              for (var Lt; ; ) {
                if (nt.lookahead === 0 && (ei(nt), nt.lookahead === 0)) {
                  if (kt === g) return D;
                  break;
                }
                if (nt.match_length = 0, Lt = l._tr_tally(nt, 0, nt.window[nt.strstart]), nt.lookahead--, nt.strstart++, Lt && (ot(nt, !1), nt.strm.avail_out === 0)) return D;
              }
              return nt.insert = 0, kt === y ? (ot(nt, !0), nt.strm.avail_out === 0 ? U : it) : nt.last_lit && (ot(nt, !1), nt.strm.avail_out === 0) ? D : R;
            }(q, vt) : q.strategy === 3 ? function(nt, kt) {
              for (var Lt, Tt, Yt, Ve, xe = nt.window; ; ) {
                if (nt.lookahead <= rt) {
                  if (ei(nt), nt.lookahead <= rt && kt === g) return D;
                  if (nt.lookahead === 0) break;
                }
                if (nt.match_length = 0, nt.lookahead >= J && 0 < nt.strstart && (Tt = xe[Yt = nt.strstart - 1]) === xe[++Yt] && Tt === xe[++Yt] && Tt === xe[++Yt]) {
                  Ve = nt.strstart + rt;
                  do
                    ;
                  while (Tt === xe[++Yt] && Tt === xe[++Yt] && Tt === xe[++Yt] && Tt === xe[++Yt] && Tt === xe[++Yt] && Tt === xe[++Yt] && Tt === xe[++Yt] && Tt === xe[++Yt] && Yt < Ve);
                  nt.match_length = rt - (Ve - Yt), nt.match_length > nt.lookahead && (nt.match_length = nt.lookahead);
                }
                if (nt.match_length >= J ? (Lt = l._tr_tally(nt, 1, nt.match_length - J), nt.lookahead -= nt.match_length, nt.strstart += nt.match_length, nt.match_length = 0) : (Lt = l._tr_tally(nt, 0, nt.window[nt.strstart]), nt.lookahead--, nt.strstart++), Lt && (ot(nt, !1), nt.strm.avail_out === 0)) return D;
              }
              return nt.insert = 0, kt === y ? (ot(nt, !0), nt.strm.avail_out === 0 ? U : it) : nt.last_lit && (ot(nt, !1), nt.strm.avail_out === 0) ? D : R;
            }(q, vt) : r[q.level].func(q, vt);
            if (It !== U && It !== it || (q.status = 666), It === D || It === U) return T.avail_out === 0 && (q.last_flush = -1), _;
            if (It === R && (vt === 1 ? l._tr_align(q) : vt !== 5 && (l._tr_stored_block(q, 0, 0, !1), vt === 3 && (Nt(q.head), q.lookahead === 0 && (q.strstart = 0, q.block_start = 0, q.insert = 0))), lt(T), T.avail_out === 0)) return q.last_flush = -1, _;
          }
          return vt !== y ? _ : q.wrap <= 0 ? 1 : (q.wrap === 2 ? (Ht(q, 255 & T.adler), Ht(q, T.adler >> 8 & 255), Ht(q, T.adler >> 16 & 255), Ht(q, T.adler >> 24 & 255), Ht(q, 255 & T.total_in), Ht(q, T.total_in >> 8 & 255), Ht(q, T.total_in >> 16 & 255), Ht(q, T.total_in >> 24 & 255)) : (St(q, T.adler >>> 16), St(q, 65535 & T.adler)), lt(T), 0 < q.wrap && (q.wrap = -q.wrap), q.pending !== 0 ? _ : 1);
        }, n.deflateEnd = function(T) {
          var vt;
          return T && T.state ? (vt = T.state.status) !== H && vt !== 69 && vt !== 73 && vt !== 91 && vt !== 103 && vt !== $ && vt !== 666 ? at(T, x) : (T.state = null, vt === $ ? at(T, -3) : _) : x;
        }, n.deflateSetDictionary = function(T, vt) {
          var pt, q, W, st, xt, It, nt, kt, Lt = vt.length;
          if (!T || !T.state || (st = (pt = T.state).wrap) === 2 || st === 1 && pt.status !== H || pt.lookahead) return x;
          for (st === 1 && (T.adler = h(T.adler, vt, Lt, 0)), pt.wrap = 0, Lt >= pt.w_size && (st === 0 && (Nt(pt.head), pt.strstart = 0, pt.block_start = 0, pt.insert = 0), kt = new o.Buf8(pt.w_size), o.arraySet(kt, vt, Lt - pt.w_size, pt.w_size, 0), vt = kt, Lt = pt.w_size), xt = T.avail_in, It = T.next_in, nt = T.input, T.avail_in = Lt, T.next_in = 0, T.input = vt, ei(pt); pt.lookahead >= J; ) {
            for (q = pt.strstart, W = pt.lookahead - (J - 1); pt.ins_h = (pt.ins_h << pt.hash_shift ^ pt.window[q + J - 1]) & pt.hash_mask, pt.prev[q & pt.w_mask] = pt.head[pt.ins_h], pt.head[pt.ins_h] = q, q++, --W; ) ;
            pt.strstart = q, pt.lookahead = J - 1, ei(pt);
          }
          return pt.strstart += pt.lookahead, pt.block_start = pt.strstart, pt.insert = pt.lookahead, pt.lookahead = 0, pt.match_length = pt.prev_length = J - 1, pt.match_available = 0, T.next_in = It, T.input = nt, T.avail_in = xt, pt.wrap = st, _;
        }, n.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, n) {
        i.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        };
      }, {}], 48: [function(e, i, n) {
        i.exports = function(r, o) {
          var l, h, u, f, g, y, _, x, b, I, C, M, P, O, B, j, F, K, J, rt, ft, H, $, D, R;
          l = r.state, h = r.next_in, D = r.input, u = h + (r.avail_in - 5), f = r.next_out, R = r.output, g = f - (o - r.avail_out), y = f + (r.avail_out - 257), _ = l.dmax, x = l.wsize, b = l.whave, I = l.wnext, C = l.window, M = l.hold, P = l.bits, O = l.lencode, B = l.distcode, j = (1 << l.lenbits) - 1, F = (1 << l.distbits) - 1;
          t: do {
            P < 15 && (M += D[h++] << P, P += 8, M += D[h++] << P, P += 8), K = O[M & j];
            e: for (; ; ) {
              if (M >>>= J = K >>> 24, P -= J, (J = K >>> 16 & 255) === 0) R[f++] = 65535 & K;
              else {
                if (!(16 & J)) {
                  if ((64 & J) == 0) {
                    K = O[(65535 & K) + (M & (1 << J) - 1)];
                    continue e;
                  }
                  if (32 & J) {
                    l.mode = 12;
                    break t;
                  }
                  r.msg = "invalid literal/length code", l.mode = 30;
                  break t;
                }
                rt = 65535 & K, (J &= 15) && (P < J && (M += D[h++] << P, P += 8), rt += M & (1 << J) - 1, M >>>= J, P -= J), P < 15 && (M += D[h++] << P, P += 8, M += D[h++] << P, P += 8), K = B[M & F];
                i: for (; ; ) {
                  if (M >>>= J = K >>> 24, P -= J, !(16 & (J = K >>> 16 & 255))) {
                    if ((64 & J) == 0) {
                      K = B[(65535 & K) + (M & (1 << J) - 1)];
                      continue i;
                    }
                    r.msg = "invalid distance code", l.mode = 30;
                    break t;
                  }
                  if (ft = 65535 & K, P < (J &= 15) && (M += D[h++] << P, (P += 8) < J && (M += D[h++] << P, P += 8)), _ < (ft += M & (1 << J) - 1)) {
                    r.msg = "invalid distance too far back", l.mode = 30;
                    break t;
                  }
                  if (M >>>= J, P -= J, (J = f - g) < ft) {
                    if (b < (J = ft - J) && l.sane) {
                      r.msg = "invalid distance too far back", l.mode = 30;
                      break t;
                    }
                    if ($ = C, (H = 0) === I) {
                      if (H += x - J, J < rt) {
                        for (rt -= J; R[f++] = C[H++], --J; ) ;
                        H = f - ft, $ = R;
                      }
                    } else if (I < J) {
                      if (H += x + I - J, (J -= I) < rt) {
                        for (rt -= J; R[f++] = C[H++], --J; ) ;
                        if (H = 0, I < rt) {
                          for (rt -= J = I; R[f++] = C[H++], --J; ) ;
                          H = f - ft, $ = R;
                        }
                      }
                    } else if (H += I - J, J < rt) {
                      for (rt -= J; R[f++] = C[H++], --J; ) ;
                      H = f - ft, $ = R;
                    }
                    for (; 2 < rt; ) R[f++] = $[H++], R[f++] = $[H++], R[f++] = $[H++], rt -= 3;
                    rt && (R[f++] = $[H++], 1 < rt && (R[f++] = $[H++]));
                  } else {
                    for (H = f - ft; R[f++] = R[H++], R[f++] = R[H++], R[f++] = R[H++], 2 < (rt -= 3); ) ;
                    rt && (R[f++] = R[H++], 1 < rt && (R[f++] = R[H++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (h < u && f < y);
          h -= rt = P >> 3, M &= (1 << (P -= rt << 3)) - 1, r.next_in = h, r.next_out = f, r.avail_in = h < u ? u - h + 5 : 5 - (h - u), r.avail_out = f < y ? y - f + 257 : 257 - (f - y), l.hold = M, l.bits = P;
        };
      }, {}], 49: [function(e, i, n) {
        var r = e("../utils/common"), o = e("./adler32"), l = e("./crc32"), h = e("./inffast"), u = e("./inftrees"), f = 1, g = 2, y = 0, _ = -2, x = 1, b = 852, I = 592;
        function C(H) {
          return (H >>> 24 & 255) + (H >>> 8 & 65280) + ((65280 & H) << 8) + ((255 & H) << 24);
        }
        function M() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function P(H) {
          var $;
          return H && H.state ? ($ = H.state, H.total_in = H.total_out = $.total = 0, H.msg = "", $.wrap && (H.adler = 1 & $.wrap), $.mode = x, $.last = 0, $.havedict = 0, $.dmax = 32768, $.head = null, $.hold = 0, $.bits = 0, $.lencode = $.lendyn = new r.Buf32(b), $.distcode = $.distdyn = new r.Buf32(I), $.sane = 1, $.back = -1, y) : _;
        }
        function O(H) {
          var $;
          return H && H.state ? (($ = H.state).wsize = 0, $.whave = 0, $.wnext = 0, P(H)) : _;
        }
        function B(H, $) {
          var D, R;
          return H && H.state ? (R = H.state, $ < 0 ? (D = 0, $ = -$) : (D = 1 + ($ >> 4), $ < 48 && ($ &= 15)), $ && ($ < 8 || 15 < $) ? _ : (R.window !== null && R.wbits !== $ && (R.window = null), R.wrap = D, R.wbits = $, O(H))) : _;
        }
        function j(H, $) {
          var D, R;
          return H ? (R = new M(), (H.state = R).window = null, (D = B(H, $)) !== y && (H.state = null), D) : _;
        }
        var F, K, J = !0;
        function rt(H) {
          if (J) {
            var $;
            for (F = new r.Buf32(512), K = new r.Buf32(32), $ = 0; $ < 144; ) H.lens[$++] = 8;
            for (; $ < 256; ) H.lens[$++] = 9;
            for (; $ < 280; ) H.lens[$++] = 7;
            for (; $ < 288; ) H.lens[$++] = 8;
            for (u(f, H.lens, 0, 288, F, 0, H.work, { bits: 9 }), $ = 0; $ < 32; ) H.lens[$++] = 5;
            u(g, H.lens, 0, 32, K, 0, H.work, { bits: 5 }), J = !1;
          }
          H.lencode = F, H.lenbits = 9, H.distcode = K, H.distbits = 5;
        }
        function ft(H, $, D, R) {
          var U, it = H.state;
          return it.window === null && (it.wsize = 1 << it.wbits, it.wnext = 0, it.whave = 0, it.window = new r.Buf8(it.wsize)), R >= it.wsize ? (r.arraySet(it.window, $, D - it.wsize, it.wsize, 0), it.wnext = 0, it.whave = it.wsize) : (R < (U = it.wsize - it.wnext) && (U = R), r.arraySet(it.window, $, D - R, U, it.wnext), (R -= U) ? (r.arraySet(it.window, $, D - R, R, 0), it.wnext = R, it.whave = it.wsize) : (it.wnext += U, it.wnext === it.wsize && (it.wnext = 0), it.whave < it.wsize && (it.whave += U))), 0;
        }
        n.inflateReset = O, n.inflateReset2 = B, n.inflateResetKeep = P, n.inflateInit = function(H) {
          return j(H, 15);
        }, n.inflateInit2 = j, n.inflate = function(H, $) {
          var D, R, U, it, at, mt, Nt, lt, ot, Ht, St, Rt, ei, ai, re, Se, Be, pe, ki, ii, T, vt, pt, q, W = 0, st = new r.Buf8(4), xt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!H || !H.state || !H.output || !H.input && H.avail_in !== 0) return _;
          (D = H.state).mode === 12 && (D.mode = 13), at = H.next_out, U = H.output, Nt = H.avail_out, it = H.next_in, R = H.input, mt = H.avail_in, lt = D.hold, ot = D.bits, Ht = mt, St = Nt, vt = y;
          t: for (; ; ) switch (D.mode) {
            case x:
              if (D.wrap === 0) {
                D.mode = 13;
                break;
              }
              for (; ot < 16; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              if (2 & D.wrap && lt === 35615) {
                st[D.check = 0] = 255 & lt, st[1] = lt >>> 8 & 255, D.check = l(D.check, st, 2, 0), ot = lt = 0, D.mode = 2;
                break;
              }
              if (D.flags = 0, D.head && (D.head.done = !1), !(1 & D.wrap) || (((255 & lt) << 8) + (lt >> 8)) % 31) {
                H.msg = "incorrect header check", D.mode = 30;
                break;
              }
              if ((15 & lt) != 8) {
                H.msg = "unknown compression method", D.mode = 30;
                break;
              }
              if (ot -= 4, T = 8 + (15 & (lt >>>= 4)), D.wbits === 0) D.wbits = T;
              else if (T > D.wbits) {
                H.msg = "invalid window size", D.mode = 30;
                break;
              }
              D.dmax = 1 << T, H.adler = D.check = 1, D.mode = 512 & lt ? 10 : 12, ot = lt = 0;
              break;
            case 2:
              for (; ot < 16; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              if (D.flags = lt, (255 & D.flags) != 8) {
                H.msg = "unknown compression method", D.mode = 30;
                break;
              }
              if (57344 & D.flags) {
                H.msg = "unknown header flags set", D.mode = 30;
                break;
              }
              D.head && (D.head.text = lt >> 8 & 1), 512 & D.flags && (st[0] = 255 & lt, st[1] = lt >>> 8 & 255, D.check = l(D.check, st, 2, 0)), ot = lt = 0, D.mode = 3;
            case 3:
              for (; ot < 32; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              D.head && (D.head.time = lt), 512 & D.flags && (st[0] = 255 & lt, st[1] = lt >>> 8 & 255, st[2] = lt >>> 16 & 255, st[3] = lt >>> 24 & 255, D.check = l(D.check, st, 4, 0)), ot = lt = 0, D.mode = 4;
            case 4:
              for (; ot < 16; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              D.head && (D.head.xflags = 255 & lt, D.head.os = lt >> 8), 512 & D.flags && (st[0] = 255 & lt, st[1] = lt >>> 8 & 255, D.check = l(D.check, st, 2, 0)), ot = lt = 0, D.mode = 5;
            case 5:
              if (1024 & D.flags) {
                for (; ot < 16; ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                D.length = lt, D.head && (D.head.extra_len = lt), 512 & D.flags && (st[0] = 255 & lt, st[1] = lt >>> 8 & 255, D.check = l(D.check, st, 2, 0)), ot = lt = 0;
              } else D.head && (D.head.extra = null);
              D.mode = 6;
            case 6:
              if (1024 & D.flags && (mt < (Rt = D.length) && (Rt = mt), Rt && (D.head && (T = D.head.extra_len - D.length, D.head.extra || (D.head.extra = new Array(D.head.extra_len)), r.arraySet(D.head.extra, R, it, Rt, T)), 512 & D.flags && (D.check = l(D.check, R, Rt, it)), mt -= Rt, it += Rt, D.length -= Rt), D.length)) break t;
              D.length = 0, D.mode = 7;
            case 7:
              if (2048 & D.flags) {
                if (mt === 0) break t;
                for (Rt = 0; T = R[it + Rt++], D.head && T && D.length < 65536 && (D.head.name += String.fromCharCode(T)), T && Rt < mt; ) ;
                if (512 & D.flags && (D.check = l(D.check, R, Rt, it)), mt -= Rt, it += Rt, T) break t;
              } else D.head && (D.head.name = null);
              D.length = 0, D.mode = 8;
            case 8:
              if (4096 & D.flags) {
                if (mt === 0) break t;
                for (Rt = 0; T = R[it + Rt++], D.head && T && D.length < 65536 && (D.head.comment += String.fromCharCode(T)), T && Rt < mt; ) ;
                if (512 & D.flags && (D.check = l(D.check, R, Rt, it)), mt -= Rt, it += Rt, T) break t;
              } else D.head && (D.head.comment = null);
              D.mode = 9;
            case 9:
              if (512 & D.flags) {
                for (; ot < 16; ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                if (lt !== (65535 & D.check)) {
                  H.msg = "header crc mismatch", D.mode = 30;
                  break;
                }
                ot = lt = 0;
              }
              D.head && (D.head.hcrc = D.flags >> 9 & 1, D.head.done = !0), H.adler = D.check = 0, D.mode = 12;
              break;
            case 10:
              for (; ot < 32; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              H.adler = D.check = C(lt), ot = lt = 0, D.mode = 11;
            case 11:
              if (D.havedict === 0) return H.next_out = at, H.avail_out = Nt, H.next_in = it, H.avail_in = mt, D.hold = lt, D.bits = ot, 2;
              H.adler = D.check = 1, D.mode = 12;
            case 12:
              if ($ === 5 || $ === 6) break t;
            case 13:
              if (D.last) {
                lt >>>= 7 & ot, ot -= 7 & ot, D.mode = 27;
                break;
              }
              for (; ot < 3; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              switch (D.last = 1 & lt, ot -= 1, 3 & (lt >>>= 1)) {
                case 0:
                  D.mode = 14;
                  break;
                case 1:
                  if (rt(D), D.mode = 20, $ !== 6) break;
                  lt >>>= 2, ot -= 2;
                  break t;
                case 2:
                  D.mode = 17;
                  break;
                case 3:
                  H.msg = "invalid block type", D.mode = 30;
              }
              lt >>>= 2, ot -= 2;
              break;
            case 14:
              for (lt >>>= 7 & ot, ot -= 7 & ot; ot < 32; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              if ((65535 & lt) != (lt >>> 16 ^ 65535)) {
                H.msg = "invalid stored block lengths", D.mode = 30;
                break;
              }
              if (D.length = 65535 & lt, ot = lt = 0, D.mode = 15, $ === 6) break t;
            case 15:
              D.mode = 16;
            case 16:
              if (Rt = D.length) {
                if (mt < Rt && (Rt = mt), Nt < Rt && (Rt = Nt), Rt === 0) break t;
                r.arraySet(U, R, it, Rt, at), mt -= Rt, it += Rt, Nt -= Rt, at += Rt, D.length -= Rt;
                break;
              }
              D.mode = 12;
              break;
            case 17:
              for (; ot < 14; ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              if (D.nlen = 257 + (31 & lt), lt >>>= 5, ot -= 5, D.ndist = 1 + (31 & lt), lt >>>= 5, ot -= 5, D.ncode = 4 + (15 & lt), lt >>>= 4, ot -= 4, 286 < D.nlen || 30 < D.ndist) {
                H.msg = "too many length or distance symbols", D.mode = 30;
                break;
              }
              D.have = 0, D.mode = 18;
            case 18:
              for (; D.have < D.ncode; ) {
                for (; ot < 3; ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                D.lens[xt[D.have++]] = 7 & lt, lt >>>= 3, ot -= 3;
              }
              for (; D.have < 19; ) D.lens[xt[D.have++]] = 0;
              if (D.lencode = D.lendyn, D.lenbits = 7, pt = { bits: D.lenbits }, vt = u(0, D.lens, 0, 19, D.lencode, 0, D.work, pt), D.lenbits = pt.bits, vt) {
                H.msg = "invalid code lengths set", D.mode = 30;
                break;
              }
              D.have = 0, D.mode = 19;
            case 19:
              for (; D.have < D.nlen + D.ndist; ) {
                for (; Se = (W = D.lencode[lt & (1 << D.lenbits) - 1]) >>> 16 & 255, Be = 65535 & W, !((re = W >>> 24) <= ot); ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                if (Be < 16) lt >>>= re, ot -= re, D.lens[D.have++] = Be;
                else {
                  if (Be === 16) {
                    for (q = re + 2; ot < q; ) {
                      if (mt === 0) break t;
                      mt--, lt += R[it++] << ot, ot += 8;
                    }
                    if (lt >>>= re, ot -= re, D.have === 0) {
                      H.msg = "invalid bit length repeat", D.mode = 30;
                      break;
                    }
                    T = D.lens[D.have - 1], Rt = 3 + (3 & lt), lt >>>= 2, ot -= 2;
                  } else if (Be === 17) {
                    for (q = re + 3; ot < q; ) {
                      if (mt === 0) break t;
                      mt--, lt += R[it++] << ot, ot += 8;
                    }
                    ot -= re, T = 0, Rt = 3 + (7 & (lt >>>= re)), lt >>>= 3, ot -= 3;
                  } else {
                    for (q = re + 7; ot < q; ) {
                      if (mt === 0) break t;
                      mt--, lt += R[it++] << ot, ot += 8;
                    }
                    ot -= re, T = 0, Rt = 11 + (127 & (lt >>>= re)), lt >>>= 7, ot -= 7;
                  }
                  if (D.have + Rt > D.nlen + D.ndist) {
                    H.msg = "invalid bit length repeat", D.mode = 30;
                    break;
                  }
                  for (; Rt--; ) D.lens[D.have++] = T;
                }
              }
              if (D.mode === 30) break;
              if (D.lens[256] === 0) {
                H.msg = "invalid code -- missing end-of-block", D.mode = 30;
                break;
              }
              if (D.lenbits = 9, pt = { bits: D.lenbits }, vt = u(f, D.lens, 0, D.nlen, D.lencode, 0, D.work, pt), D.lenbits = pt.bits, vt) {
                H.msg = "invalid literal/lengths set", D.mode = 30;
                break;
              }
              if (D.distbits = 6, D.distcode = D.distdyn, pt = { bits: D.distbits }, vt = u(g, D.lens, D.nlen, D.ndist, D.distcode, 0, D.work, pt), D.distbits = pt.bits, vt) {
                H.msg = "invalid distances set", D.mode = 30;
                break;
              }
              if (D.mode = 20, $ === 6) break t;
            case 20:
              D.mode = 21;
            case 21:
              if (6 <= mt && 258 <= Nt) {
                H.next_out = at, H.avail_out = Nt, H.next_in = it, H.avail_in = mt, D.hold = lt, D.bits = ot, h(H, St), at = H.next_out, U = H.output, Nt = H.avail_out, it = H.next_in, R = H.input, mt = H.avail_in, lt = D.hold, ot = D.bits, D.mode === 12 && (D.back = -1);
                break;
              }
              for (D.back = 0; Se = (W = D.lencode[lt & (1 << D.lenbits) - 1]) >>> 16 & 255, Be = 65535 & W, !((re = W >>> 24) <= ot); ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              if (Se && (240 & Se) == 0) {
                for (pe = re, ki = Se, ii = Be; Se = (W = D.lencode[ii + ((lt & (1 << pe + ki) - 1) >> pe)]) >>> 16 & 255, Be = 65535 & W, !(pe + (re = W >>> 24) <= ot); ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                lt >>>= pe, ot -= pe, D.back += pe;
              }
              if (lt >>>= re, ot -= re, D.back += re, D.length = Be, Se === 0) {
                D.mode = 26;
                break;
              }
              if (32 & Se) {
                D.back = -1, D.mode = 12;
                break;
              }
              if (64 & Se) {
                H.msg = "invalid literal/length code", D.mode = 30;
                break;
              }
              D.extra = 15 & Se, D.mode = 22;
            case 22:
              if (D.extra) {
                for (q = D.extra; ot < q; ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                D.length += lt & (1 << D.extra) - 1, lt >>>= D.extra, ot -= D.extra, D.back += D.extra;
              }
              D.was = D.length, D.mode = 23;
            case 23:
              for (; Se = (W = D.distcode[lt & (1 << D.distbits) - 1]) >>> 16 & 255, Be = 65535 & W, !((re = W >>> 24) <= ot); ) {
                if (mt === 0) break t;
                mt--, lt += R[it++] << ot, ot += 8;
              }
              if ((240 & Se) == 0) {
                for (pe = re, ki = Se, ii = Be; Se = (W = D.distcode[ii + ((lt & (1 << pe + ki) - 1) >> pe)]) >>> 16 & 255, Be = 65535 & W, !(pe + (re = W >>> 24) <= ot); ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                lt >>>= pe, ot -= pe, D.back += pe;
              }
              if (lt >>>= re, ot -= re, D.back += re, 64 & Se) {
                H.msg = "invalid distance code", D.mode = 30;
                break;
              }
              D.offset = Be, D.extra = 15 & Se, D.mode = 24;
            case 24:
              if (D.extra) {
                for (q = D.extra; ot < q; ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                D.offset += lt & (1 << D.extra) - 1, lt >>>= D.extra, ot -= D.extra, D.back += D.extra;
              }
              if (D.offset > D.dmax) {
                H.msg = "invalid distance too far back", D.mode = 30;
                break;
              }
              D.mode = 25;
            case 25:
              if (Nt === 0) break t;
              if (Rt = St - Nt, D.offset > Rt) {
                if ((Rt = D.offset - Rt) > D.whave && D.sane) {
                  H.msg = "invalid distance too far back", D.mode = 30;
                  break;
                }
                ei = Rt > D.wnext ? (Rt -= D.wnext, D.wsize - Rt) : D.wnext - Rt, Rt > D.length && (Rt = D.length), ai = D.window;
              } else ai = U, ei = at - D.offset, Rt = D.length;
              for (Nt < Rt && (Rt = Nt), Nt -= Rt, D.length -= Rt; U[at++] = ai[ei++], --Rt; ) ;
              D.length === 0 && (D.mode = 21);
              break;
            case 26:
              if (Nt === 0) break t;
              U[at++] = D.length, Nt--, D.mode = 21;
              break;
            case 27:
              if (D.wrap) {
                for (; ot < 32; ) {
                  if (mt === 0) break t;
                  mt--, lt |= R[it++] << ot, ot += 8;
                }
                if (St -= Nt, H.total_out += St, D.total += St, St && (H.adler = D.check = D.flags ? l(D.check, U, St, at - St) : o(D.check, U, St, at - St)), St = Nt, (D.flags ? lt : C(lt)) !== D.check) {
                  H.msg = "incorrect data check", D.mode = 30;
                  break;
                }
                ot = lt = 0;
              }
              D.mode = 28;
            case 28:
              if (D.wrap && D.flags) {
                for (; ot < 32; ) {
                  if (mt === 0) break t;
                  mt--, lt += R[it++] << ot, ot += 8;
                }
                if (lt !== (4294967295 & D.total)) {
                  H.msg = "incorrect length check", D.mode = 30;
                  break;
                }
                ot = lt = 0;
              }
              D.mode = 29;
            case 29:
              vt = 1;
              break t;
            case 30:
              vt = -3;
              break t;
            case 31:
              return -4;
            case 32:
            default:
              return _;
          }
          return H.next_out = at, H.avail_out = Nt, H.next_in = it, H.avail_in = mt, D.hold = lt, D.bits = ot, (D.wsize || St !== H.avail_out && D.mode < 30 && (D.mode < 27 || $ !== 4)) && ft(H, H.output, H.next_out, St - H.avail_out) ? (D.mode = 31, -4) : (Ht -= H.avail_in, St -= H.avail_out, H.total_in += Ht, H.total_out += St, D.total += St, D.wrap && St && (H.adler = D.check = D.flags ? l(D.check, U, St, H.next_out - St) : o(D.check, U, St, H.next_out - St)), H.data_type = D.bits + (D.last ? 64 : 0) + (D.mode === 12 ? 128 : 0) + (D.mode === 20 || D.mode === 15 ? 256 : 0), (Ht == 0 && St === 0 || $ === 4) && vt === y && (vt = -5), vt);
        }, n.inflateEnd = function(H) {
          if (!H || !H.state) return _;
          var $ = H.state;
          return $.window && ($.window = null), H.state = null, y;
        }, n.inflateGetHeader = function(H, $) {
          var D;
          return H && H.state ? (2 & (D = H.state).wrap) == 0 ? _ : ((D.head = $).done = !1, y) : _;
        }, n.inflateSetDictionary = function(H, $) {
          var D, R = $.length;
          return H && H.state ? (D = H.state).wrap !== 0 && D.mode !== 11 ? _ : D.mode === 11 && o(1, $, R, 0) !== D.check ? -3 : ft(H, $, R, R) ? (D.mode = 31, -4) : (D.havedict = 1, y) : _;
        }, n.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, n) {
        var r = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], h = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], u = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        i.exports = function(f, g, y, _, x, b, I, C) {
          var M, P, O, B, j, F, K, J, rt, ft = C.bits, H = 0, $ = 0, D = 0, R = 0, U = 0, it = 0, at = 0, mt = 0, Nt = 0, lt = 0, ot = null, Ht = 0, St = new r.Buf16(16), Rt = new r.Buf16(16), ei = null, ai = 0;
          for (H = 0; H <= 15; H++) St[H] = 0;
          for ($ = 0; $ < _; $++) St[g[y + $]]++;
          for (U = ft, R = 15; 1 <= R && St[R] === 0; R--) ;
          if (R < U && (U = R), R === 0) return x[b++] = 20971520, x[b++] = 20971520, C.bits = 1, 0;
          for (D = 1; D < R && St[D] === 0; D++) ;
          for (U < D && (U = D), H = mt = 1; H <= 15; H++) if (mt <<= 1, (mt -= St[H]) < 0) return -1;
          if (0 < mt && (f === 0 || R !== 1)) return -1;
          for (Rt[1] = 0, H = 1; H < 15; H++) Rt[H + 1] = Rt[H] + St[H];
          for ($ = 0; $ < _; $++) g[y + $] !== 0 && (I[Rt[g[y + $]]++] = $);
          if (F = f === 0 ? (ot = ei = I, 19) : f === 1 ? (ot = o, Ht -= 257, ei = l, ai -= 257, 256) : (ot = h, ei = u, -1), H = D, j = b, at = $ = lt = 0, O = -1, B = (Nt = 1 << (it = U)) - 1, f === 1 && 852 < Nt || f === 2 && 592 < Nt) return 1;
          for (; ; ) {
            for (K = H - at, rt = I[$] < F ? (J = 0, I[$]) : I[$] > F ? (J = ei[ai + I[$]], ot[Ht + I[$]]) : (J = 96, 0), M = 1 << H - at, D = P = 1 << it; x[j + (lt >> at) + (P -= M)] = K << 24 | J << 16 | rt | 0, P !== 0; ) ;
            for (M = 1 << H - 1; lt & M; ) M >>= 1;
            if (M !== 0 ? (lt &= M - 1, lt += M) : lt = 0, $++, --St[H] == 0) {
              if (H === R) break;
              H = g[y + I[$]];
            }
            if (U < H && (lt & B) !== O) {
              for (at === 0 && (at = U), j += D, mt = 1 << (it = H - at); it + at < R && !((mt -= St[it + at]) <= 0); ) it++, mt <<= 1;
              if (Nt += 1 << it, f === 1 && 852 < Nt || f === 2 && 592 < Nt) return 1;
              x[O = lt & B] = U << 24 | it << 16 | j - b | 0;
            }
          }
          return lt !== 0 && (x[j + lt] = H - at << 24 | 64 << 16 | 0), C.bits = U, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, i, n) {
        i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, i, n) {
        var r = e("../utils/common"), o = 0, l = 1;
        function h(W) {
          for (var st = W.length; 0 <= --st; ) W[st] = 0;
        }
        var u = 0, f = 29, g = 256, y = g + 1 + f, _ = 30, x = 19, b = 2 * y + 1, I = 15, C = 16, M = 7, P = 256, O = 16, B = 17, j = 18, F = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], K = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], J = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], rt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], ft = new Array(2 * (y + 2));
        h(ft);
        var H = new Array(2 * _);
        h(H);
        var $ = new Array(512);
        h($);
        var D = new Array(256);
        h(D);
        var R = new Array(f);
        h(R);
        var U, it, at, mt = new Array(_);
        function Nt(W, st, xt, It, nt) {
          this.static_tree = W, this.extra_bits = st, this.extra_base = xt, this.elems = It, this.max_length = nt, this.has_stree = W && W.length;
        }
        function lt(W, st) {
          this.dyn_tree = W, this.max_code = 0, this.stat_desc = st;
        }
        function ot(W) {
          return W < 256 ? $[W] : $[256 + (W >>> 7)];
        }
        function Ht(W, st) {
          W.pending_buf[W.pending++] = 255 & st, W.pending_buf[W.pending++] = st >>> 8 & 255;
        }
        function St(W, st, xt) {
          W.bi_valid > C - xt ? (W.bi_buf |= st << W.bi_valid & 65535, Ht(W, W.bi_buf), W.bi_buf = st >> C - W.bi_valid, W.bi_valid += xt - C) : (W.bi_buf |= st << W.bi_valid & 65535, W.bi_valid += xt);
        }
        function Rt(W, st, xt) {
          St(W, xt[2 * st], xt[2 * st + 1]);
        }
        function ei(W, st) {
          for (var xt = 0; xt |= 1 & W, W >>>= 1, xt <<= 1, 0 < --st; ) ;
          return xt >>> 1;
        }
        function ai(W, st, xt) {
          var It, nt, kt = new Array(I + 1), Lt = 0;
          for (It = 1; It <= I; It++) kt[It] = Lt = Lt + xt[It - 1] << 1;
          for (nt = 0; nt <= st; nt++) {
            var Tt = W[2 * nt + 1];
            Tt !== 0 && (W[2 * nt] = ei(kt[Tt]++, Tt));
          }
        }
        function re(W) {
          var st;
          for (st = 0; st < y; st++) W.dyn_ltree[2 * st] = 0;
          for (st = 0; st < _; st++) W.dyn_dtree[2 * st] = 0;
          for (st = 0; st < x; st++) W.bl_tree[2 * st] = 0;
          W.dyn_ltree[2 * P] = 1, W.opt_len = W.static_len = 0, W.last_lit = W.matches = 0;
        }
        function Se(W) {
          8 < W.bi_valid ? Ht(W, W.bi_buf) : 0 < W.bi_valid && (W.pending_buf[W.pending++] = W.bi_buf), W.bi_buf = 0, W.bi_valid = 0;
        }
        function Be(W, st, xt, It) {
          var nt = 2 * st, kt = 2 * xt;
          return W[nt] < W[kt] || W[nt] === W[kt] && It[st] <= It[xt];
        }
        function pe(W, st, xt) {
          for (var It = W.heap[xt], nt = xt << 1; nt <= W.heap_len && (nt < W.heap_len && Be(st, W.heap[nt + 1], W.heap[nt], W.depth) && nt++, !Be(st, It, W.heap[nt], W.depth)); ) W.heap[xt] = W.heap[nt], xt = nt, nt <<= 1;
          W.heap[xt] = It;
        }
        function ki(W, st, xt) {
          var It, nt, kt, Lt, Tt = 0;
          if (W.last_lit !== 0) for (; It = W.pending_buf[W.d_buf + 2 * Tt] << 8 | W.pending_buf[W.d_buf + 2 * Tt + 1], nt = W.pending_buf[W.l_buf + Tt], Tt++, It === 0 ? Rt(W, nt, st) : (Rt(W, (kt = D[nt]) + g + 1, st), (Lt = F[kt]) !== 0 && St(W, nt -= R[kt], Lt), Rt(W, kt = ot(--It), xt), (Lt = K[kt]) !== 0 && St(W, It -= mt[kt], Lt)), Tt < W.last_lit; ) ;
          Rt(W, P, st);
        }
        function ii(W, st) {
          var xt, It, nt, kt = st.dyn_tree, Lt = st.stat_desc.static_tree, Tt = st.stat_desc.has_stree, Yt = st.stat_desc.elems, Ve = -1;
          for (W.heap_len = 0, W.heap_max = b, xt = 0; xt < Yt; xt++) kt[2 * xt] !== 0 ? (W.heap[++W.heap_len] = Ve = xt, W.depth[xt] = 0) : kt[2 * xt + 1] = 0;
          for (; W.heap_len < 2; ) kt[2 * (nt = W.heap[++W.heap_len] = Ve < 2 ? ++Ve : 0)] = 1, W.depth[nt] = 0, W.opt_len--, Tt && (W.static_len -= Lt[2 * nt + 1]);
          for (st.max_code = Ve, xt = W.heap_len >> 1; 1 <= xt; xt--) pe(W, kt, xt);
          for (nt = Yt; xt = W.heap[1], W.heap[1] = W.heap[W.heap_len--], pe(W, kt, 1), It = W.heap[1], W.heap[--W.heap_max] = xt, W.heap[--W.heap_max] = It, kt[2 * nt] = kt[2 * xt] + kt[2 * It], W.depth[nt] = (W.depth[xt] >= W.depth[It] ? W.depth[xt] : W.depth[It]) + 1, kt[2 * xt + 1] = kt[2 * It + 1] = nt, W.heap[1] = nt++, pe(W, kt, 1), 2 <= W.heap_len; ) ;
          W.heap[--W.heap_max] = W.heap[1], function(xe, Ri) {
            var Fn, cn, ns, di, Vs, zs, te = Ri.dyn_tree, Ki = Ri.max_code, vn = Ri.stat_desc.static_tree, qn = Ri.stat_desc.has_stree, Bn = Ri.stat_desc.extra_bits, kn = Ri.stat_desc.extra_base, Je = Ri.stat_desc.max_length, xr = 0;
            for (di = 0; di <= I; di++) xe.bl_count[di] = 0;
            for (te[2 * xe.heap[xe.heap_max] + 1] = 0, Fn = xe.heap_max + 1; Fn < b; Fn++) Je < (di = te[2 * te[2 * (cn = xe.heap[Fn]) + 1] + 1] + 1) && (di = Je, xr++), te[2 * cn + 1] = di, Ki < cn || (xe.bl_count[di]++, Vs = 0, kn <= cn && (Vs = Bn[cn - kn]), zs = te[2 * cn], xe.opt_len += zs * (di + Vs), qn && (xe.static_len += zs * (vn[2 * cn + 1] + Vs)));
            if (xr !== 0) {
              do {
                for (di = Je - 1; xe.bl_count[di] === 0; ) di--;
                xe.bl_count[di]--, xe.bl_count[di + 1] += 2, xe.bl_count[Je]--, xr -= 2;
              } while (0 < xr);
              for (di = Je; di !== 0; di--) for (cn = xe.bl_count[di]; cn !== 0; ) Ki < (ns = xe.heap[--Fn]) || (te[2 * ns + 1] !== di && (xe.opt_len += (di - te[2 * ns + 1]) * te[2 * ns], te[2 * ns + 1] = di), cn--);
            }
          }(W, st), ai(kt, Ve, W.bl_count);
        }
        function T(W, st, xt) {
          var It, nt, kt = -1, Lt = st[1], Tt = 0, Yt = 7, Ve = 4;
          for (Lt === 0 && (Yt = 138, Ve = 3), st[2 * (xt + 1) + 1] = 65535, It = 0; It <= xt; It++) nt = Lt, Lt = st[2 * (It + 1) + 1], ++Tt < Yt && nt === Lt || (Tt < Ve ? W.bl_tree[2 * nt] += Tt : nt !== 0 ? (nt !== kt && W.bl_tree[2 * nt]++, W.bl_tree[2 * O]++) : Tt <= 10 ? W.bl_tree[2 * B]++ : W.bl_tree[2 * j]++, kt = nt, Ve = (Tt = 0) === Lt ? (Yt = 138, 3) : nt === Lt ? (Yt = 6, 3) : (Yt = 7, 4));
        }
        function vt(W, st, xt) {
          var It, nt, kt = -1, Lt = st[1], Tt = 0, Yt = 7, Ve = 4;
          for (Lt === 0 && (Yt = 138, Ve = 3), It = 0; It <= xt; It++) if (nt = Lt, Lt = st[2 * (It + 1) + 1], !(++Tt < Yt && nt === Lt)) {
            if (Tt < Ve) for (; Rt(W, nt, W.bl_tree), --Tt != 0; ) ;
            else nt !== 0 ? (nt !== kt && (Rt(W, nt, W.bl_tree), Tt--), Rt(W, O, W.bl_tree), St(W, Tt - 3, 2)) : Tt <= 10 ? (Rt(W, B, W.bl_tree), St(W, Tt - 3, 3)) : (Rt(W, j, W.bl_tree), St(W, Tt - 11, 7));
            kt = nt, Ve = (Tt = 0) === Lt ? (Yt = 138, 3) : nt === Lt ? (Yt = 6, 3) : (Yt = 7, 4);
          }
        }
        h(mt);
        var pt = !1;
        function q(W, st, xt, It) {
          St(W, (u << 1) + (It ? 1 : 0), 3), function(nt, kt, Lt, Tt) {
            Se(nt), Ht(nt, Lt), Ht(nt, ~Lt), r.arraySet(nt.pending_buf, nt.window, kt, Lt, nt.pending), nt.pending += Lt;
          }(W, st, xt);
        }
        n._tr_init = function(W) {
          pt || (function() {
            var st, xt, It, nt, kt, Lt = new Array(I + 1);
            for (nt = It = 0; nt < f - 1; nt++) for (R[nt] = It, st = 0; st < 1 << F[nt]; st++) D[It++] = nt;
            for (D[It - 1] = nt, nt = kt = 0; nt < 16; nt++) for (mt[nt] = kt, st = 0; st < 1 << K[nt]; st++) $[kt++] = nt;
            for (kt >>= 7; nt < _; nt++) for (mt[nt] = kt << 7, st = 0; st < 1 << K[nt] - 7; st++) $[256 + kt++] = nt;
            for (xt = 0; xt <= I; xt++) Lt[xt] = 0;
            for (st = 0; st <= 143; ) ft[2 * st + 1] = 8, st++, Lt[8]++;
            for (; st <= 255; ) ft[2 * st + 1] = 9, st++, Lt[9]++;
            for (; st <= 279; ) ft[2 * st + 1] = 7, st++, Lt[7]++;
            for (; st <= 287; ) ft[2 * st + 1] = 8, st++, Lt[8]++;
            for (ai(ft, y + 1, Lt), st = 0; st < _; st++) H[2 * st + 1] = 5, H[2 * st] = ei(st, 5);
            U = new Nt(ft, F, g + 1, y, I), it = new Nt(H, K, 0, _, I), at = new Nt(new Array(0), J, 0, x, M);
          }(), pt = !0), W.l_desc = new lt(W.dyn_ltree, U), W.d_desc = new lt(W.dyn_dtree, it), W.bl_desc = new lt(W.bl_tree, at), W.bi_buf = 0, W.bi_valid = 0, re(W);
        }, n._tr_stored_block = q, n._tr_flush_block = function(W, st, xt, It) {
          var nt, kt, Lt = 0;
          0 < W.level ? (W.strm.data_type === 2 && (W.strm.data_type = function(Tt) {
            var Yt, Ve = 4093624447;
            for (Yt = 0; Yt <= 31; Yt++, Ve >>>= 1) if (1 & Ve && Tt.dyn_ltree[2 * Yt] !== 0) return o;
            if (Tt.dyn_ltree[18] !== 0 || Tt.dyn_ltree[20] !== 0 || Tt.dyn_ltree[26] !== 0) return l;
            for (Yt = 32; Yt < g; Yt++) if (Tt.dyn_ltree[2 * Yt] !== 0) return l;
            return o;
          }(W)), ii(W, W.l_desc), ii(W, W.d_desc), Lt = function(Tt) {
            var Yt;
            for (T(Tt, Tt.dyn_ltree, Tt.l_desc.max_code), T(Tt, Tt.dyn_dtree, Tt.d_desc.max_code), ii(Tt, Tt.bl_desc), Yt = x - 1; 3 <= Yt && Tt.bl_tree[2 * rt[Yt] + 1] === 0; Yt--) ;
            return Tt.opt_len += 3 * (Yt + 1) + 5 + 5 + 4, Yt;
          }(W), nt = W.opt_len + 3 + 7 >>> 3, (kt = W.static_len + 3 + 7 >>> 3) <= nt && (nt = kt)) : nt = kt = xt + 5, xt + 4 <= nt && st !== -1 ? q(W, st, xt, It) : W.strategy === 4 || kt === nt ? (St(W, 2 + (It ? 1 : 0), 3), ki(W, ft, H)) : (St(W, 4 + (It ? 1 : 0), 3), function(Tt, Yt, Ve, xe) {
            var Ri;
            for (St(Tt, Yt - 257, 5), St(Tt, Ve - 1, 5), St(Tt, xe - 4, 4), Ri = 0; Ri < xe; Ri++) St(Tt, Tt.bl_tree[2 * rt[Ri] + 1], 3);
            vt(Tt, Tt.dyn_ltree, Yt - 1), vt(Tt, Tt.dyn_dtree, Ve - 1);
          }(W, W.l_desc.max_code + 1, W.d_desc.max_code + 1, Lt + 1), ki(W, W.dyn_ltree, W.dyn_dtree)), re(W), It && Se(W);
        }, n._tr_tally = function(W, st, xt) {
          return W.pending_buf[W.d_buf + 2 * W.last_lit] = st >>> 8 & 255, W.pending_buf[W.d_buf + 2 * W.last_lit + 1] = 255 & st, W.pending_buf[W.l_buf + W.last_lit] = 255 & xt, W.last_lit++, st === 0 ? W.dyn_ltree[2 * xt]++ : (W.matches++, st--, W.dyn_ltree[2 * (D[xt] + g + 1)]++, W.dyn_dtree[2 * ot(st)]++), W.last_lit === W.lit_bufsize - 1;
        }, n._tr_align = function(W) {
          St(W, 2, 3), Rt(W, P, ft), function(st) {
            st.bi_valid === 16 ? (Ht(st, st.bi_buf), st.bi_buf = 0, st.bi_valid = 0) : 8 <= st.bi_valid && (st.pending_buf[st.pending++] = 255 & st.bi_buf, st.bi_buf >>= 8, st.bi_valid -= 8);
          }(W);
        };
      }, { "../utils/common": 41 }], 53: [function(e, i, n) {
        i.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, i, n) {
        (function(r) {
          (function(o, l) {
            if (!o.setImmediate) {
              var h, u, f, g, y = 1, _ = {}, x = !1, b = o.document, I = Object.getPrototypeOf && Object.getPrototypeOf(o);
              I = I && I.setTimeout ? I : o, h = {}.toString.call(o.process) === "[object process]" ? function(O) {
                process.nextTick(function() {
                  M(O);
                });
              } : function() {
                if (o.postMessage && !o.importScripts) {
                  var O = !0, B = o.onmessage;
                  return o.onmessage = function() {
                    O = !1;
                  }, o.postMessage("", "*"), o.onmessage = B, O;
                }
              }() ? (g = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", P, !1) : o.attachEvent("onmessage", P), function(O) {
                o.postMessage(g + O, "*");
              }) : o.MessageChannel ? ((f = new MessageChannel()).port1.onmessage = function(O) {
                M(O.data);
              }, function(O) {
                f.port2.postMessage(O);
              }) : b && "onreadystatechange" in b.createElement("script") ? (u = b.documentElement, function(O) {
                var B = b.createElement("script");
                B.onreadystatechange = function() {
                  M(O), B.onreadystatechange = null, u.removeChild(B), B = null;
                }, u.appendChild(B);
              }) : function(O) {
                setTimeout(M, 0, O);
              }, I.setImmediate = function(O) {
                typeof O != "function" && (O = new Function("" + O));
                for (var B = new Array(arguments.length - 1), j = 0; j < B.length; j++) B[j] = arguments[j + 1];
                var F = { callback: O, args: B };
                return _[y] = F, h(y), y++;
              }, I.clearImmediate = C;
            }
            function C(O) {
              delete _[O];
            }
            function M(O) {
              if (x) setTimeout(M, 0, O);
              else {
                var B = _[O];
                if (B) {
                  x = !0;
                  try {
                    (function(j) {
                      var F = j.callback, K = j.args;
                      switch (K.length) {
                        case 0:
                          F();
                          break;
                        case 1:
                          F(K[0]);
                          break;
                        case 2:
                          F(K[0], K[1]);
                          break;
                        case 3:
                          F(K[0], K[1], K[2]);
                          break;
                        default:
                          F.apply(l, K);
                      }
                    })(B);
                  } finally {
                    C(O), x = !1;
                  }
                }
              }
            }
            function P(O) {
              O.source === o && typeof O.data == "string" && O.data.indexOf(g) === 0 && M(+O.data.slice(g.length));
            }
          })(typeof self > "u" ? r === void 0 ? this : r : self);
        }).call(this, typeof ac < "u" ? ac : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }(af)), af.exports;
}
var _g = Hb();
const A_ = /* @__PURE__ */ ld(_g), Ub = new A_();
class Eu {
  constructor(t, e) {
    this._version = Js.Unknown, this._topicsMap = /* @__PURE__ */ new Map(), this._bcfFileName = t, this._id = e;
  }
  /**
   * Exports BCF data to a file. Prompts the user to save it on their device.
   * @param filename Filename BCF data will be exported as
   */
  async exportBCF(t) {
    await this.toBcfZipBlob().then((e) => {
      const i = document.createElement("a"), n = URL.createObjectURL(e);
      i.href = n, i.download = `${t}.bcf`, document.body.appendChild(i), i.click(), setTimeout(() => {
        document.body.removeChild(i), URL.revokeObjectURL(n);
      }, 0);
    });
  }
  /**
   * Creates a BCFZIP blob. The resulting blob is importable using `BcfManager.addBCFFromBuffer`.
   */
  toBcfZipBlob() {
    const t = new XMLSerializer(), i = Ub.file("bcf.version", '<?xml version="1.0" encoding="UTF-8"?><Version VersionId="2.1" xsi:noNamespaceSchemaLocation="version.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><DetailedVersion>2.1</DetailedVersion></Version>');
    return this._topicsMap.forEach((n, r) => {
      const o = i.folder(r);
      if (o === null) {
        console.error("Failed to create folder for BCF topic");
        return;
      }
      const l = t.serializeToString(n.getMarkup().export());
      o.file("markup.bcf", l), n.getViewpointMap().forEach((f, g) => {
        const y = t.serializeToString(f.export());
        o.file(g, y);
      }), n.getSnapshotMap().forEach((f, g) => {
        o.file(g, f.getData());
      });
    }), i.generateAsync({ type: "blob" });
  }
  /**
   * Adds a BCF topic.
   * @param topicId
   * @param topic
   */
  addTopic(t, e) {
    this._topicsMap.set(t, e);
  }
  /**
   * @returns A map associating BCF topic ids to BCF topic data.
   */
  getTopics() {
    return this._topicsMap;
  }
  /**
   * Gets a BCF topic.
   * @param topicId
   */
  getTopic(t) {
    return this._topicsMap.get(t) || null;
  }
  /**
   * Gets the BCF version.
   */
  getVersion() {
    return this._version;
  }
  /**
   * Sets the BCF version.
   * @param version
   */
  setVersion(t) {
    this._version = t;
  }
  /**
   * Gets the BCF filename.
   */
  getFilename() {
    return this._bcfFileName;
  }
  /**
   * Identifier used to keep track of loaded BCF data.
   */
  getId() {
    return this._id;
  }
}
function Ms() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(s) {
    const t = new Uint32Array(1);
    xv().getRandomValues(t);
    const e = t[0] / 4294967295 * 16 | 0;
    return (s === "x" ? e : e & 3 | 8).toString(16);
  });
}
class T_ {
  constructor(t, e, i, n, r, o) {
    this._ifcProject = t, this._ifcSpatialStructureElement = e, this._isExternal = i, this._filename = n, this._date = r, this._reference = o;
  }
  /**
   * [[GenericId]] Reference to the project to which this topic is related in the IFC file
   */
  getIfcProject() {
    return this._ifcProject || null;
  }
  /**
   * [[GenericId]] Reference to the spatial structure element, e.g. IfcBuildingStorey, to which this topic is related.
   */
  getIfcSpacialStructureElement() {
    return this._ifcSpatialStructureElement || null;
  }
  /**
   * Is the IFC file external or within the bcfzip
   */
  getIsExternal() {
    return this._isExternal || null;
  }
  /**
   * The BIM file related to this topic.
   */
  getBimFilename() {
    return this._filename || null;
  }
  /**
   * Date of the BIM file.
   */
  getBimDate() {
    return this._date || null;
  }
  /**
   * URI to IfcFile.
   * IsExternal=false "..\example.ifc" (within bcfzip)
   * IsExternal=true "https://.../example.ifc"
   */
  getReference() {
    return this._reference || null;
  }
}
class D_ {
  constructor(t, e, i, n) {
    this._viewpointFilename = void 0, this._snapshotFilename = void 0, this._index = void 0, this._guid = t, this._viewpointFilename = e, this._snapshotFilename = i, n !== void 0 && (this._index = parseInt(n, 10));
  }
  getGuid() {
    return this._guid;
  }
  getViewpointFilename() {
    return this._viewpointFilename || null;
  }
  getSnapshotFilename() {
    return this._snapshotFilename || null;
  }
  getIndex() {
    return this._index || null;
  }
}
class Nf {
  constructor(t, e, i, n, r, o, l) {
    this._guid = t, this._date = e, this._author = i, this._text = n, this._viewpointGuid = r, this._modifiedDate = o, this._modifiedAuthor = l;
  }
  getId() {
    return this._guid;
  }
  getDate() {
    return this._date;
  }
  setDate(t) {
    this._date = t;
  }
  getAuthor() {
    return this._author;
  }
  setAuthor(t) {
    this._author = t;
  }
  getText() {
    return this._text;
  }
  setText(t) {
    this._text = t;
  }
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  setViewpointGuid(t) {
    this._viewpointGuid = t !== null ? t : void 0;
  }
  getModifiedDate() {
    return this._modifiedDate || null;
  }
  setModifiedDate(t) {
    this._modifiedDate = t !== null ? t : void 0;
  }
  getModifiedAuthor() {
    return this._modifiedAuthor || null;
  }
  setModifiedAuthor(t) {
    this._modifiedAuthor = t !== null ? t : void 0;
  }
}
class N_ {
  constructor(t, e, i) {
    this._markupHeaderFiles = [], this._topic = {
      guid: "",
      title: "",
      creationDate: /* @__PURE__ */ new Date(),
      creationAuthor: ""
    }, this._comments = /* @__PURE__ */ new Map(), this._viewpoints = /* @__PURE__ */ new Map(), this._filename = t, this._bcfTopic = i, this._parseDocument(e);
  }
  _parseDocument(t) {
    if (t === null)
      return;
    let i = t.documentElement.firstElementChild;
    for (; i !== null; ) {
      const n = i.localName;
      if (n === null) break;
      switch (n) {
        case "Header":
          this._parseHeader(i);
          break;
        case "Topic":
          this._parseTopic(i);
          break;
        case "Comment":
          this._parseComment(i);
          break;
        case "Viewpoints":
          this._parseViewpoint(i);
          break;
      }
      i = i.nextElementSibling;
    }
  }
  _exportHeader(t) {
    const e = t.createElement("Header");
    return Or(e, "ProjectGuid", this._projectGuid), this._markupHeaderFiles.forEach((i) => {
      const n = t.createElement("File");
      Or(n, "IfcProject", i.getIfcProject()), Or(
        n,
        "IfcSpatialStructureElement",
        i.getIfcSpacialStructureElement()
      ), Or(
        n,
        "isExternal",
        ku(i.getIsExternal())
      ), on(t, n, "Filename", i.getBimFilename()), on(t, n, "Date", _c(i.getBimDate())), on(t, n, "Reference", i.getReference()), e.appendChild(n);
    }), e;
  }
  _exportTopicData(t) {
    const e = t.createElement("Topic");
    if (e.setAttribute("Guid", this._topic.guid), Or(e, "TopicType", this._topic.topicType), Or(e, "TopicStatus", this._topic.topicStatus), Lr(t, e, "Title", this._topic.title), Lr(t, e, "CreationDate", this._topic.creationDate.toISOString()), Lr(t, e, "CreationAuthor", this._topic.creationAuthor), on(t, e, "ReferenceLink", this._topic.referenceLink), on(t, e, "Priority", this._topic.priority), on(t, e, "Index", Df(this._topic.index)), on(
      t,
      e,
      "ModifiedDate",
      _c(this._topic.modifiedDate)
    ), on(t, e, "ModifiedAuthor", this._topic.modifiedAuthor), on(t, e, "DueDate", _c(this._topic.dueDate)), on(t, e, "AssignedTo", this._topic.assignedTo), on(t, e, "Description", this._topic.description), on(t, e, "Stage", this._topic.stage), this._topic.labels) {
      const i = t.createElement("Labels");
      this._topic.labels.forEach((n) => {
        Lr(t, i, "Label", n);
      }), e.appendChild(i);
    }
    return e;
  }
  _exportBimSnippet(t, e) {
    const i = t.createElement("BimSnippet");
    return i.setAttribute("SnippetType", e.snippetType), Or(
      i,
      "isExternal",
      ku(e.isExternal)
    ), Lr(t, i, "Reference", e.reference), on(t, i, "ReferenceSchema", e.referenceSchema), i;
  }
  _exportDocumentReference(t, e) {
    const i = t.createElement("DocumentReference");
    return Or(i, "Guid", e.guid), Or(
      i,
      "isExternal",
      ku(e.isExternal)
    ), on(
      t,
      i,
      "ReferencedDocument",
      e.referencedDocument
    ), on(t, i, "Description", e.description), i;
  }
  _exportRelatedTopic(t, e) {
    const i = t.createElement("RelatedTopic");
    return i.setAttribute("Guid", e.guid), i;
  }
  _exportTopic(t) {
    const e = this._exportTopicData(t);
    return this._topic.bimSnippets && this._topic.bimSnippets.forEach((i) => {
      e.appendChild(this._exportBimSnippet(t, i));
    }), this._topic.documentReferences && this._topic.documentReferences.forEach((i) => {
      e.appendChild(this._exportDocumentReference(t, i));
    }), this._topic.relatedTopics && this._topic.relatedTopics.forEach((i) => {
      e.appendChild(this._exportRelatedTopic(t, i));
    }), e;
  }
  _exportComment(t, e) {
    const i = t.createElement("Comment");
    i.setAttribute("Guid", e.getId()), Lr(t, i, "Date", e.getDate().toISOString()), Lr(t, i, "Author", e.getAuthor()), Lr(t, i, "Comment", e.getText()), on(
      t,
      i,
      "ModifiedDate",
      _c(e.getModifiedDate())
    ), on(t, i, "ModifiedAuthor", e.getModifiedAuthor());
    const n = e.getViewpointGuid();
    if (n) {
      const r = t.createElement("Viewpoint");
      r.setAttribute("Guid", n), i.appendChild(r);
    }
    return i;
  }
  _exportViewpoint(t, e) {
    const i = t.createElement("Viewpoints");
    return i.setAttribute("Guid", e.getGuid()), on(t, i, "Viewpoint", e.getViewpointFilename()), on(t, i, "Snapshot", e.getSnapshotFilename()), on(
      t,
      i,
      "Index",
      Df(e.getIndex())
    ), i;
  }
  /**
   * @returns XML document containing the markup data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("Markup");
    return e.appendChild(this._exportHeader(t)), e.appendChild(this._exportTopic(t)), this._comments.forEach((i) => {
      e.appendChild(this._exportComment(t, i));
    }), this._viewpoints.forEach((i) => {
      e.appendChild(this._exportViewpoint(t, i));
    }), t.appendChild(e), t;
  }
  /**
   * @returns the project GUID.
   */
  getProjectGuid() {
    return this._projectGuid || null;
  }
  /**
   * @returns a list of [[BCFMarkupHeaderFile]] containing data related to IFC files.
   */
  getMarkupHeaderFiles() {
    return this._markupHeaderFiles;
  }
  /**
   * Gets the Markup filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the topic id.
   */
  getTopicId() {
    return this._topic.guid;
  }
  /**
   * Sets the topic id.
   * @param guid
   */
  setTopicId(t) {
    this._topic.guid = t;
  }
  /**
   * Gets the topic type.
   */
  getTopicType() {
    return this._topic.topicType || null;
  }
  /**
   * Sets the topic type.
   * @param topicType
   */
  setTopicType(t) {
    this._topic.topicType = t !== null ? t : void 0;
  }
  /**
   * Gets the topic status.
   */
  getTopicStatus() {
    return this._topic.topicStatus || null;
  }
  /**
   * Sets the topic status.
   * @param topicStatus
   */
  setTopicStatus(t) {
    this._topic.topicStatus = t !== null ? t : void 0;
  }
  /**
   * Gets the title of the markup topic.
   */
  getTopicTitle() {
    return this._topic.title;
  }
  /**
   * Sets the title of the markup topic.
   * @param title
   */
  setTopicTitle(t) {
    this._topic.title = t;
  }
  /**
   * Gets the creation date of the markup topic.
   */
  getTopicCreationDate() {
    return this._topic.creationDate;
  }
  /**
   * Sets the creation date of the markup topic;
   * @param date
   */
  setTopicCreationDate(t) {
    this._topic.creationDate = t;
  }
  /**
   * Gets the name of the user that created the markup topic.
   */
  getTopicCreationAuthor() {
    return this._topic.creationAuthor;
  }
  /**
   * Sets the name of the user that created the markup topic.
   * @param author
   */
  setTopicCreationAuthor(t) {
    this._topic.creationAuthor = t;
  }
  /**
   * List of references to the topic, for example, a work request management system or an URI to a model.
   */
  getTopicReferenceLink() {
    return this._topic.referenceLink || null;
  }
  /**
   * Sets the ReferenceLink.
   * @param referenceLink
   */
  setTopicReferenceLink(t) {
    this._topic.referenceLink = t === null ? void 0 : t;
  }
  /**
   * Gets the topic priority.
   */
  getTopicPriority() {
    return this._topic.priority || null;
  }
  /**
   * Sets the topic priority.
   * @param priority
   */
  setTopicPriority(t) {
    this._topic.priority = t === null ? void 0 : t;
  }
  /**
   * Number to maintain the order of the topics.
   */
  getTopicIndex() {
    return this._topic.index || null;
  }
  /**
   * Sets the topic index.
   * @param index
   */
  setTopicIndex(t) {
    this._topic.index = t === null ? void 0 : t;
  }
  /**
   * Tags for grouping Topics.
   */
  getTopicLabels() {
    return this._topic.labels === void 0 ? [] : this._topic.labels.slice();
  }
  /**
   * Sets the topic labels.
   * @param labels
   */
  setTopicLabels(t) {
    this._topic.labels = t.slice();
  }
  /**
   * Date when the topic was last modified. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedDate() {
    return this._topic.modifiedDate || null;
  }
  /**
   * Sets the topic modified date.
   * @param date
   */
  setTopicModifiedDate(t) {
    this._topic.modifiedDate = t === null ? void 0 : t;
  }
  /**
   * User who modified the topic. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedAuthor() {
    return this._topic.modifiedAuthor || null;
  }
  /**
   * Sets the author that last modified the topic.
   * @param modifiedAuthor
   */
  setTopicModifiedAuthor(t) {
    this._topic.modifiedAuthor = t === null ? void 0 : t;
  }
  /**
   * Date when the issue needs to be resolved by.
   */
  getTopicDueDate() {
    return this._topic.dueDate || null;
  }
  /**
   * Sets the topic due date.
   * @param date
   */
  setTopicDueDate(t) {
    this._topic.dueDate = t === null ? void 0 : t;
  }
  /**
   * The user to whom this topic is assigned to. Recommended to be in email format. The list of possible values are defined in the extension schema.
   */
  getTopicAssignedTo() {
    return this._topic.assignedTo || null;
  }
  /**
   * Sets the user that the topic is assigned to.
   */
  setTopicAssignedTo(t) {
    this._topic.assignedTo = t === null ? void 0 : t;
  }
  /**
   * Description of the topic.
   */
  getTopicDescription() {
    return this._topic.description || null;
  }
  /**
   * Sets the topic description;
   * @param description
   */
  setTopicDescription(t) {
    this._topic.description = t === null ? void 0 : t;
  }
  /**
   * Stage this topic is part of.
   */
  getTopicStage() {
    return this._topic.stage || null;
  }
  /**
   * Sets the topic stage;
   * @param stage
   */
  setTopicState(t) {
    this._topic.stage = t === null ? void 0 : t;
  }
  /**
   * Gets a map of GUIDs and corresponding comments.
   */
  getComments() {
    return this._comments;
  }
  /**
   * Adds a comment to the topic.
   * @param date
   * @param author
   * @param text
   * @param viewpointGuid
   * @param modifiedDate
   * @param modifiedAuthor
   */
  addComment(t, e, i, n, r, o) {
    const l = Ms(), h = new Nf(
      l,
      t,
      e,
      i,
      n,
      r,
      o
    );
    return this._comments.set(l, h), h;
  }
  /**
   * Updates a topic comment.
   * @param comment
   */
  updateComment(t) {
    const e = t.getId();
    this._comments.set(e, t);
  }
  /**
   * Deletes a comment from the topic..
   * @param guid
   */
  deleteComment(t) {
    this._comments.delete(t);
  }
  /**
   * Gets a map of GUIDs and corresponding viewpoints.
   */
  getViewpoints() {
    return this._viewpoints;
  }
  _addFile(t) {
    const e = this._getElementAttributes(t), i = this._getChildData(t), n = i.get("Date"), r = {
      date: n === void 0 ? void 0 : new Date(n),
      filename: i.get("Filename"),
      reference: i.get("Reference"),
      ifcProject: e.get("IfcProject"),
      ifcSpatialStructureElement: e.get("IfcSpatialStructureElement"),
      isExternal: e.get("isExternal") === "true"
    };
    this._markupHeaderFiles.push(
      new T_(
        r.ifcProject,
        r.ifcSpatialStructureElement,
        r.isExternal,
        r.filename,
        r.date,
        r.reference
      )
    );
  }
  _parseHeader(t) {
    const i = this._getElementAttributes(t).get("ProjectGuid");
    i !== void 0 && (this._projectGuid = i);
    let n = t.firstElementChild;
    n !== null && (this._addFile(n), n = n.nextElementSibling);
  }
  _parseTopic(t) {
    const e = this._getElementAttributes(t), i = e.get("Guid");
    if (i === void 0)
      return;
    this._topic.guid = i, this._topic.topicType = e.get("TopicType") || e.get("Status"), this._topic.topicStatus = e.get("TopicStatus") || e.get("VerbalStatus");
    let n = t.firstElementChild;
    if (n !== null)
      for (; n !== null; ) {
        const r = n.localName;
        if (r === null) break;
        const o = this._getChildData(n), l = this._getElementAttributes(n);
        switch (r) {
          case "BimSnippet":
            {
              this._topic.bimSnippets === void 0 && (this._topic.bimSnippets = []);
              const h = o.get("Reference"), u = l.get("SnippetType");
              if (h !== void 0 && u !== void 0) {
                const f = {
                  snippetType: u,
                  reference: h
                };
                l.get("isExternal") && (f.isExternal = l.get("isExternal") === "true"), o.get("ReferenceSchema") && (f.referenceSchema = o.get("ReferenceSchema")), this._topic.bimSnippets.push(f);
              }
            }
            break;
          case "DocumentReference":
            {
              this._topic.documentReferences === void 0 && (this._topic.documentReferences = []);
              const h = {};
              o.get("Guid") && (h.guid = o.get("Guid")), o.get("isExternal") && (h.isExternal = o.get("isExternal") === "true"), o.get("Description") && (h.description = o.get("Description")), o.get("ReferencedDocument") && (h.referencedDocument = o.get("ReferencedDocument")), this._topic.documentReferences.push(h);
            }
            break;
          case "RelatedTopic":
            {
              this._topic.relatedTopics === void 0 && (this._topic.relatedTopics = []);
              const h = o.get("Guid");
              if (h !== void 0) {
                const u = {
                  guid: h
                };
                this._topic.relatedTopics.push(u);
              }
            }
            break;
          case "ReferenceLink":
            n.textContent && (this._topic.referenceLink = n.textContent);
            break;
          case "Title":
            n.textContent && (this._topic.title = n.textContent);
            break;
          case "Priority":
            n.textContent && (this._topic.priority = n.textContent);
            break;
          case "Index":
            n.textContent && (this._topic.index = parseInt(n.textContent, 10));
            break;
          case "Labels":
            {
              let h = n.firstChild;
              if (!h) break;
              for (this._topic.labels === void 0 && (this._topic.labels = []); h; )
                h.textContent && this._topic.labels.push(h.textContent), h = h.nextSibling;
            }
            break;
          case "CreationDate":
            n.textContent && (this._topic.creationDate = new Date(n.textContent));
            break;
          case "CreationAuthor":
            n.textContent && (this._topic.creationAuthor = n.textContent);
            break;
          case "ModifiedDate":
            n.textContent && (this._topic.modifiedDate = new Date(n.textContent));
            break;
          case "ModifiedAuthor":
            n.textContent && (this._topic.modifiedAuthor = n.textContent);
            break;
          case "DueDate":
            n.textContent && (this._topic.dueDate = new Date(n.textContent));
            break;
          case "AssignedTo":
            n.textContent && (this._topic.assignedTo = n.textContent);
            break;
          case "Description":
            n.textContent && (this._topic.description = n.textContent);
            break;
          case "Stage":
            n.textContent && (this._topic.stage = n.textContent);
            break;
        }
        n = n.nextElementSibling;
      }
  }
  _parseComment(t) {
    let e = "", i = /* @__PURE__ */ new Date(), n = "", r = "", o, l, h;
    const f = this._getElementAttributes(t).get("Guid");
    if (f)
      e = f;
    else
      return;
    let g = t.firstElementChild;
    if (g !== null)
      for (; g !== null; ) {
        const _ = g.localName;
        if (_ === null) break;
        switch (_) {
          case "Date":
            g.textContent && (i = new Date(g.textContent));
            break;
          case "Author":
            g.textContent && (n = g.textContent);
            break;
          case "Comment":
            g.textContent && (r = g.textContent);
            break;
          case "Viewpoint":
            o = this._getElementAttributes(g).get("Guid");
            break;
          case "ModifiedDate":
            g.textContent && (l = new Date(g.textContent));
            break;
          case "ModifiedAuthor":
            g.textContent && (h = g.textContent);
            break;
        }
        g = g.nextElementSibling;
      }
    const y = new Nf(
      e,
      i,
      n,
      r,
      o,
      l,
      h
    );
    this._comments.set(e, y);
  }
  _parseViewpoint(t) {
    const i = this._getElementAttributes(t).get("Guid");
    if (i !== void 0) {
      const n = this._getChildData(t), r = n.get("Viewpoint"), o = n.get("Snapshot"), l = n.get("Index");
      this.addViewpoint(i, r, o, l);
    }
  }
  addViewpoint(t, e, i, n) {
    this._viewpoints.set(
      t,
      new D_(t, e, i, n)
    );
  }
  _getChildData(t) {
    const e = /* @__PURE__ */ new Map();
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const n = i.localName;
      let r = null;
      i.firstElementChild === null && (r = i.textContent), n !== null && r !== null && e.set(n, r), i = i.nextElementSibling;
    }
    return e;
  }
  _getElementAttributes(t) {
    const e = t.attributes, i = /* @__PURE__ */ new Map();
    for (let n = 0; n < e.length; ++n) {
      const r = e[n], o = r.name, l = r.value;
      i.set(o, l);
    }
    return i;
  }
}
class va {
  constructor(t, e) {
    this._filename = t, this._data = e;
  }
  /**
   * Creates a BCF Snapshot from an HTMLImageElement.
   * @param filename
   * @param image
   */
  static createFromImage(t, e) {
    const i = va.snapshotDataFromImage(e);
    return new va(t, i);
  }
  /**
   * Gets the filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets png data.
   */
  getData() {
    return this._data;
  }
  /**
   * Gets a url for images corresponding to viewpoints.
   */
  getUrl() {
    const t = new Blob([this._data], { type: "image/png" });
    return URL.createObjectURL(t, { oneTimeOnly: !0 });
  }
  /**
   * Gets image data as a Uint8Array from an HTMLImageElement.
   * @param img
   */
  static snapshotDataFromImage(t) {
    const e = t.src;
    return va._convertDataURIToBinary(e);
  }
  static _convertDataURIToBinary(t) {
    const e = ";base64,", i = t.indexOf(e) + e.length, n = window.atob(t.substring(i)), r = new Uint8Array(n.length);
    for (let o = 0; o < n.length; o++) {
      const l = n[o].charCodeAt(0);
      r[o] = l;
    }
    return r;
  }
}
class go {
  constructor() {
    this._behindView = !1;
  }
  /**
   * Called when the MarkupItem is removed from a view from the system.
   * Any cleanup that needs to be done should be performed in this method.
   * @param view the view to remove from, null if removed from everywhere.
   */
  remove(t) {
  }
  // XXX: This should probably have a `Promise<void>` return type. See `NoteText.prototype.remove` for an example.
  /**
   * Called when the markup item should be redrawn on a specific view. This most typically happens when the scene is rendered.
   * @param renderer renderer engine to draw.
   * @param view the view to draw on.
   */
  draw(t, e) {
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @returns boolean value indicating whether this item was picked
   */
  hit(t, e) {
    return !1;
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @param pickTolerance amount of tolerance allowed for a hit in pixels.
   * @returns boolean value indicating whether this item was picked
   */
  hitWithTolerance(t, e, i) {
    return !1;
  }
  /**
   * Called when this markup item is selected by the system from a given view.
   * @param view the view where the selection occured
   */
  onSelect(t) {
  }
  /**
   * Called when this markup item is deselected by the system
   */
  onDeselect() {
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Gets the fully qualified class name for this markup item. E.g. "Communicator.Markup.Redline.RedlineCircle"
   * @returns fully qualified class name
   */
  getClassName() {
    return "Communicator.Markup.MarkupItem";
  }
}
class Al extends go {
  constructor(t) {
    super(), this._viewer = t;
  }
  onDragStart(t, e) {
    return !1;
  }
  onDragMove(t, e) {
    return !1;
  }
  onDragEnd(t, e) {
    return !1;
  }
  remove(t) {
    this._viewer.trigger("redlineDeleted", this);
  }
}
class yg {
  constructor() {
    this._strokeWidth = 1, this._strokeColor = yt.black();
  }
  /** @hidden */
  _assign(t) {
    this._strokeWidth = t._strokeWidth, this._strokeColor.assign(t._strokeColor);
  }
  /**
   * Sets the stroke color for this shape
   * @param color the stroke color
   */
  setStrokeColor(t) {
    this._strokeColor.assign(t);
  }
  /**
   * Gets the stroke color for this shape
   * @returns the stroke color
   */
  getStrokeColor() {
    return this._strokeColor.copy();
  }
  /**
   * Sets the stroke width for this shape in pixels
   * @param strokeWidth the stroke width in pixels
   */
  setStrokeWidth(t) {
    this._strokeWidth = t;
  }
  /**
   * Gets the stroke width for this shape in pixels
   * @returns the stroke width in pixels
   */
  getStrokeWidth() {
    return this._strokeWidth;
  }
}
class Ra extends yg {
  constructor() {
    super(...arguments), this._fillColor = yt.black(), this._fillOpacity = 1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fillColor.assign(t._fillColor), this._fillOpacity = t._fillOpacity;
  }
  /**
   * Gets the fill opacity for this shape
   * @returns the fill opacity
   */
  getFillOpacity() {
    return this._fillOpacity;
  }
  /**
   * Sets the fill opacity for this shape
   * @param fillOpacity the fill opacity
   */
  setFillOpacity(t) {
    this._fillOpacity = t;
  }
  /**
   * Sets the fill color for this shape
   * @param color the fill color
   */
  setFillColor(t) {
    this._fillColor.assign(t);
  }
  /**
   * Gets the fill color for this shape
   * @returns the fill color
   */
  getFillColor() {
    return this._fillColor.copy();
  }
}
var yn = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Arrowhead = 1] = "Arrowhead", s[s.Circle = 2] = "Circle", s))(yn || {});
const Up = 9;
class kh extends yg {
  constructor() {
    super(...arguments), this._startEndcapType = 0, this._startEndcapColor = yt.black(), this._startEndcapSize = Up, this._endEndcapType = 0, this._endEndcapColor = yt.black(), this._endEndcapSize = Up, this._endcapsInverted = !1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._startEndcapType = t._startEndcapType, this._startEndcapColor.assign(t._startEndcapColor), this._startEndcapSize = t._startEndcapSize, this._endEndcapType = t._endEndcapType, this._endEndcapColor.assign(t._endEndcapColor), this._endEndcapSize = t._endEndcapSize, this._endcapsInverted = t._endcapsInverted;
  }
  /**
   * Gets the start endcap type for this shape. The default Value is none.
   * @returns the start endcap type
   */
  getStartEndcapType() {
    return this._startEndcapType;
  }
  /**
   * Sets the start endcap type for this shape
   * @param endcapType the new endcap type
   */
  setStartEndcapType(t) {
    this._startEndcapType = t;
  }
  /**
   * Gets the color of the start endcap. Default value is black.
   * @returns color for the start endcap.
   */
  getStartEndcapColor() {
    return this._startEndcapColor.copy();
  }
  /**
   * Sets the color for the start endcap.
   * @param color the start endcap color value.
   */
  setStartEndcapColor(t) {
    this._startEndcapColor.assign(t);
  }
  /**
   * Gets the size of the start endcap in pixels. Default value is 9.
   * @returns size of the start endcap.
   */
  getStartEndcapSize() {
    return this._startEndcapSize;
  }
  /**
   * Sets the size of the start endcap in pixels.
   * @param size the start endcap.
   */
  setStartEndcapSize(t) {
    this._startEndcapSize = t;
  }
  /**
   * Gets the end endcap type for this shape. The default value is none.
   * @returns the end endcap type
   */
  getEndEndcapType() {
    return this._endEndcapType;
  }
  /**
   * Sets the end endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndEndcapType(t) {
    this._endEndcapType = t;
  }
  /**
   * Convenience for setting the start and eend endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndcapType(t) {
    this._startEndcapType = t, this._endEndcapType = t;
  }
  /**
   * Gets the size of the end endcap in pixels. Default value is 9.
   * @returns size of the end endcap.
   */
  getEndEndcapSize() {
    return this._endEndcapSize;
  }
  /**
   * Sets the size of the end endcap in pixels.
   * @param size the end endcap.
   */
  setEndEndcapSize(t) {
    this._endEndcapSize = t;
  }
  /**
   * Gets the color of the end endcap. Default value is black.
   * @returns color for the end endcap.
   */
  getEndEndcapColor() {
    return this._endEndcapColor.copy();
  }
  /**
   * Sets the color for the end endcap.
   * @param color the end endcap color value.
   */
  setEndEndcapColor(t) {
    this._endEndcapColor.assign(t);
  }
  /**
   * Gets whether endcaps are inverted for this shape. The default value is false.
   * @returns value indicating whether endcaps are inverted
   */
  getEndcapsInverted() {
    return this._endcapsInverted;
  }
  /**
   * Sets whether endcapsare inverted for this shape.
   * @param inverted value indicated whether endcaps should be inverted
   */
  setEndcapsInverted(t) {
    this._endcapsInverted = t;
  }
}
class $r extends Ra {
  constructor() {
    super(...arguments), this._center = X.zero(), this._radius = 1;
  }
  /**
   * Sets the values for the circle
   * @param center the center point of the circle.
   * @radius the circle radius.
   */
  set(t, e) {
    this._center.assign(t), this.setRadius(e);
  }
  /**
   * Gets the center of the circle
   * @returns the circle center
   */
  getCenter() {
    return this._center.copy();
  }
  /**
   * Sets the center of the circle
   * @param the circle center
   */
  setCenter(t) {
    this._center.assign(t);
  }
  /**
   * Gets the radius of the circle
   * @returns the circle radius
   */
  getRadius() {
    return this._radius;
  }
  /**
   * Sets the radius of the circle
   * @param radius the circle radius
   */
  setRadius(t) {
    this._radius = t;
  }
}
class O_ {
  constructor(t, e) {
    this.center = t.copy(), this.radius = e;
  }
}
class wg extends Ra {
  constructor() {
    super(...arguments), this._circles = [];
  }
  /**
   * Removes all circles from this collection
   */
  clear() {
    this._circles = [];
  }
  /**
   * Adds a circle to the collection
   * @param center circle center
   * @param radius the circle radius
   */
  addCircle(t, e) {
    this._circles.push(new O_(t, e));
  }
  /**
   * Updates a circle in the collection
   * @param index the index of the circle to update
   * @param center circle center
   * @param radius the circle radius
   */
  setCircle(t, e, i) {
    const n = this._circles[t];
    n.center.assign(e), n.radius = i;
  }
  /**
   * Gets the circles in the collection
   */
  getCircles() {
    return this._circles;
  }
}
const ha = class ha extends Al {
  constructor(t) {
    super(t), this._uniqueId = Ms(), this._centerPt = m.zero(), this._radiusPt = m.zero(), this._circleShape = new $r(), this._previousDragPlanePosition = m.zero(), this._circleShape.setFillOpacity(0), this._circleShape.setStrokeColor(yt.red()), this._circleShape.setStrokeWidth(2);
  }
  setCenter(t) {
    this._centerPt.assign(t);
  }
  getCenter() {
    return this._centerPt.copy();
  }
  setRadiusPoint(t) {
    this._radiusPt.assign(t);
  }
  getRadiusPoint() {
    return this._radiusPt.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update(t) {
    const e = X.fromPoint3(t.projectPoint(this._centerPt)), i = X.fromPoint3(t.projectPoint(this._radiusPt)), n = X.distance(e, i);
    this._circleShape.set(e, n);
  }
  draw(t, e) {
    this._update(e), t.drawCircle(this._circleShape);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    this._update(e);
    const n = this._circleShape.getStrokeWidth() + i, r = X.distance(this._circleShape.getCenter(), t) - this._circleShape.getRadius();
    return Math.abs(r) <= n;
  }
  onSelect() {
    this._circleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._circleShape.setStrokeWidth(2);
  }
  isValid() {
    return this._circleShape.getRadius() > ha._validRadiusTolerance;
  }
  // dragging methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = m.subtract(i, this._previousDragPlanePosition);
      this._centerPt.add(n), this._radiusPt.add(n), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      centerPoint: this._centerPt.toJson(),
      radiusPoint: this._radiusPt.toJson(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[RedlineCircle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new ha(e);
    return n._uniqueId = i.uniqueId, n.setCenter(m.fromJson(i.centerPoint)), n.setRadiusPoint(m.fromJson(i.radiusPoint)), n;
  }
  getClassName() {
    return ha.className;
  }
};
ha.className = "Communicator.Markup.Redline.RedlineCircle", ha._validRadiusTolerance = 1;
let ka = ha;
us(ka.className, ka.fromJson);
class La extends kh {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polyline
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polyline
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polyline
   * @param point the point to add to the line
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class jb extends kh {
  constructor() {
    super(...arguments), this._polylines = [];
  }
  /**
   * Removes all polylines from the collection
   */
  clear() {
    this._polylines = [];
  }
  /**
   * Creates a new array of points that represent a polyline. Add Point2 objects to the array to construct the polyline
   * @returns new array which represents a polyline.
   */
  createPolyline() {
    const t = [];
    return this._polylines.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolylines() {
    return this._polylines;
  }
}
const Ac = class Ac extends Al {
  constructor(t) {
    super(t), this._uniqueId = Ms(), this._points = [], this._polylineShape = new La(), this._previousDragPlanePosition = m.zero(), this._polylineShape.setStrokeWidth(2), this._polylineShape.setStrokeColor(yt.red());
  }
  addPoint(t) {
    this._points.push(t.copy());
  }
  getPoints() {
    const t = [];
    return this._points.forEach((e) => {
      t.push(e.copy());
    }), t;
  }
  _update(t) {
    this._polylineShape.clearPoints();
    for (const e of this._points) {
      const i = X.fromPoint3(t.projectPoint(e));
      this._polylineShape.pushPoint(i);
    }
  }
  draw(t, e) {
    this._update(e), this.isValid() && t.drawPolyline(this._polylineShape);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    this._update(e);
    const n = this._polylineShape.getStrokeWidth() + i, r = this._polylineShape.getPoints();
    if (r.length > 1) {
      for (let o = 1; o < r.length; o++)
        if (oc(t, r[o - 1], r[o], n)) return !0;
    }
    return !1;
  }
  onSelect() {
    this._polylineShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._polylineShape.setStrokeWidth(2);
  }
  getClassName() {
    return Ac.className;
  }
  isValid() {
    return this._points.length > 1;
  }
  // dragging methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = m.subtract(i, this._previousDragPlanePosition);
      for (const r of this._points) r.add(n);
      this._polylineShape.clearPoints(), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._points) t.push(e.toJson());
    return {
      uniqueId: this._uniqueId,
      points: t
    };
  }
  /**
   * Creates a new [[RedlinePolyline]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Ac(e);
    n._uniqueId = i.uniqueId;
    for (const r of i.points)
      n.addPoint(m.fromJson(r));
    return n;
  }
};
Ac.className = "Communicator.Markup.Redline.RedlinePolyline";
let Ea = Ac;
us(Ea.className, Ea.fromJson);
class gd extends Ra {
  constructor() {
    super(...arguments), this._borderRadius = 0;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._borderRadius = t._borderRadius;
  }
  /**
   * Gets the border radius for this shape
   * @returns the border radius
   */
  getBorderRadius() {
    return this._borderRadius;
  }
  /**
   * Sets the border radius for this shape
   * @param borderRadius the border radius in pixels
   */
  setBorderRadius(t) {
    this._borderRadius = t;
  }
}
class pd extends gd {
  /**
   * Creates a new rectangle markup item
   * @param position the screen space position of the top left of the rectangle.
   * @param size the point object representing the width and height of the rectangle in pixels.
   */
  constructor(t, e) {
    super(), this._position = X.zero(), this._size = X.zero(), t && this._position.assign(t), e && this._size.assign(e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position), this._size.assign(t._size);
  }
  /**
   * Sets the rectanlge position
   * @param position the top left corner of the rectangle
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets rectangle position
   * @returns the rectangle position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the rectanlge size
   * @param size indicating the rectangle width and height
   */
  setSize(t) {
    this._size.assign(t);
  }
  /**
   * Gets rectangle size
   * @returns the rectangle size
   */
  getSize() {
    return this._size.copy();
  }
}
class R_ {
  constructor(t, e) {
    this.position = t.copy(), this.size = e.copy();
  }
}
class Wb extends gd {
  constructor() {
    super(...arguments), this._rectangles = [];
  }
  /**
   * Removes all rectangles from this collection
   */
  clear() {
    this._rectangles = [];
  }
  /**
   * Adds a rectangle to the collection
   * @param position the top left corner of the rectangle
   * @param size indicating the rectangle width and height
   */
  addRectangle(t, e) {
    this._rectangles.push(new R_(t, e));
  }
  /**
   * Gets the rectangles in the collection
   */
  getRectangles() {
    return this._rectangles;
  }
}
const Ao = class Ao extends Al {
  constructor(t) {
    super(t), this._uniqueId = Ms(), this._point1 = m.zero(), this._point2 = m.zero(), this._rectangleShape = new pd(), this._previousDragPlanePosition = m.zero(), this._rectangleShape.setFillOpacity(0), this._rectangleShape.setStrokeColor(yt.red()), this._rectangleShape.setStrokeWidth(2);
  }
  setPoint1(t) {
    this._point1.assign(t);
  }
  getPoint1() {
    return this._point1.copy();
  }
  setPoint2(t) {
    this._point2.assign(t);
  }
  getPoint2() {
    return this._point2.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update(t) {
    const e = t.projectPoint(this._point1), i = t.projectPoint(this._point2), n = new X(
      Math.min(e.x, i.x),
      Math.min(e.y, i.y)
    ), r = new X(
      Math.max(e.x, i.x),
      Math.max(e.y, i.y)
    ), o = X.subtract(r, n);
    this._rectangleShape.setPosition(n), this._rectangleShape.setSize(o);
  }
  draw(t, e) {
    this._update(e), t.drawRectangle(this._rectangleShape);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    this._update(e);
    const n = this._rectangleShape.getStrokeWidth() + i, r = this._rectangleShape.getPosition(), o = this._rectangleShape.getSize(), l = r, h = new X(r.x + o.x, l.y), u = new X(r.x, r.y + o.y), f = new X(r.x + o.x, r.y + o.y);
    return oc(t, l, h, n) || oc(t, h, f, n) || oc(t, f, u, n) ? !0 : !!oc(t, u, l, n);
  }
  onSelect() {
    this._rectangleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._rectangleShape.setStrokeWidth(2);
  }
  isValid() {
    const t = this._rectangleShape.getSize();
    return t.x > Ao._validSizeTolerance.x && t.y > Ao._validSizeTolerance.y;
  }
  // dragging methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = m.subtract(i, this._previousDragPlanePosition);
      this._point1.add(n), this._point2.add(n), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      point1: this._point1.toJson(),
      point2: this._point2.toJson()
    };
  }
  /**
   * Creates a new [[RedlineRectangle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Ao(e);
    return n._uniqueId = i.uniqueId, n.setPoint1(m.fromJson(i.point1)), n.setPoint2(m.fromJson(i.point2)), n;
  }
  getClassName() {
    return Ao.className;
  }
};
Ao.className = "Communicator.Markup.Redline.RedlineRectangle", Ao._validSizeTolerance = new X(5, 5);
let Aa = Ao;
us(Aa.className, Aa.fromJson);
const cl = class cl {
  constructor(t, e) {
    this._sizeChanged = !1, this._sizeUpdateCallback = t, this._textUpdateCallback = e, this._createTextBox();
  }
  _createTextBox() {
    this._currentSize = cl._defaultSize.copy(), this._textArea = document.createElement("textarea"), this._textArea.style.position = "absolute", this._textArea.style.width = `${cl._defaultSize.x}px`, this._textArea.style.height = `${cl._defaultSize.y}px`, this._textArea.style.zIndex = "1", this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none", this._textArea.style.letterSpacing = "1px", this.setBorderWidth(2), this._textArea.onmousemove = (e) => {
      e.stopPropagation();
      const i = new X(
        parseInt(this._textArea.style.width, 10),
        parseInt(this._textArea.style.height, 10)
      );
      this.setSize(i);
    }, this._textArea.onmouseup = (e) => {
      e.stopPropagation(), this._sizeChanged && (this._sizeChanged = !1, this._sizeUpdateCallback(this._currentSize));
    };
    const t = () => {
      this._textUpdateCallback(this._textArea.value);
    };
    this._textArea.oninput = t;
  }
  setPosition(t) {
    this._textArea.style.left = `${t.x}px`, this._textArea.style.top = `${t.y}px`;
  }
  setBorderWidth(t) {
    this._textArea.style.outline = `${t}px solid red`;
  }
  setText(t) {
    this._textArea.textContent = t;
  }
  setSize(t) {
    this._currentSize.equals(t) || (this._sizeChanged = !0, this._currentSize.assign(t), this._textArea.style.width = `${t.x}px`, this._textArea.style.height = `${t.y}px`);
  }
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto", this._textArea.style.resize = "both";
  }
  blur() {
    this._textArea.blur(), this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none";
  }
  getTextArea() {
    return this._textArea;
  }
};
cl._defaultSize = new X(100, 100);
let Ju = cl;
const ua = class ua extends Al {
  constructor(t, e = ua.defaultText) {
    super(t), this._uniqueId = Ms(), this._position = m.zero(), this._size = new X(100, 100), this._redlineTextElements = /* @__PURE__ */ new Map(), this._previousDragPlanePosition = m.zero(), this._callbacks = null, this._text = e;
  }
  setPosition(t) {
    this._position.assign(t);
  }
  getPosition() {
    return this._position.copy();
  }
  setSize(t) {
    this._size.assign(t), this._redlineTextElements.forEach((e) => {
      e.element.setSize(t);
    }), this._viewer.trigger("redlineUpdated", this);
  }
  getSize() {
    return this._size.copy();
  }
  setText(t) {
    this._text = t, this._redlineTextElements.forEach((e) => {
      e.element.setText(t);
    }), this._viewer.trigger("redlineUpdated", this);
  }
  getText() {
    return this._text;
  }
  registerCallback() {
    this._callbacks === null && (this._callbacks = {
      selectionArray: () => {
        this.onDeselect();
      }
    }, this._viewer.setCallbacks(this._callbacks));
  }
  unregisterCallback() {
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null);
  }
  createTextElement() {
    const t = (n) => {
      this.setSize(n);
    }, e = (n) => {
      this.setText(n);
    }, i = new Ju(t, e);
    return i.setText(this._text), this.registerCallback(), i;
  }
  draw(t, e) {
    const i = X.fromPoint3(e.projectPoint(this._position));
    let n = this._redlineTextElements.get(e);
    if (!n) {
      const r = this.createTextElement(), o = this._viewer.markupManager.addMarkupElement(r.getTextArea(), e);
      n = { id: o, element: r }, this._redlineTextElements.set(e, { id: o, element: r });
    }
    n.element.setPosition(i);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    const n = this._redlineTextElements.get(e);
    if (!n)
      return !1;
    const r = n.element.getTextArea(), o = new X(
      parseFloat(r.style.left || "0"),
      parseFloat(r.style.top || "0")
    ), l = new X(
      parseFloat(r.style.width || "0"),
      parseFloat(r.style.height || "0")
    );
    return Mm(t, o, l, i);
  }
  getClassName() {
    return ua.className;
  }
  onSelect(t) {
    const e = this._redlineTextElements.get(t);
    e && (e.element.setBorderWidth(4), e.element.focus());
  }
  onDeselect() {
    this._redlineTextElements.forEach((t) => {
      t.element.setBorderWidth(2), t.element.blur();
    });
  }
  isValid() {
    return this._text.length > 0;
  }
  remove(t) {
    const e = [];
    t ? e.push(t) : e.push(...this._redlineTextElements.keys());
    for (const i of e) {
      const n = this._redlineTextElements.get(i);
      n && (this._viewer.markupManager.removeMarkupElement(n.id, i), this._redlineTextElements.delete(i), this._redlineTextElements.size === 0 && this.unregisterCallback());
    }
    super.remove(t);
  }
  // drag methods and drop methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = m.subtract(i, this._previousDragPlanePosition), r = this.getPosition();
      r.add(n), this.setPosition(r), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      position: this._position.toJson(),
      size: this._size.toJson(),
      text: this._text
    };
  }
  /**
   * Creates a new [[RedlineText]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new ua(e, i.text);
    return n._uniqueId = i.uniqueId, n.setPosition(m.fromJson(i.position)), n.setSize(X.fromJson(i.size)), n;
  }
};
ua.className = "Communicator.Markup.Redline.RedlineText", ua.defaultText = "Type Here...";
let jo = ua;
us(jo.className, jo.fromJson);
const Gb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircle: ka,
  RedlinePolyline: Ea,
  RedlineRectangle: Aa,
  RedlineText: jo,
  RedlineTextElement: Ju
}, Symbol.toStringTag, { value: "Module" })), Tc = class Tc extends go {
  constructor(t, e = null, i = null, n = null, r = null) {
    super(), this._uniqueId = Ms(), this._lineMeshId = null, this._lineMeshInstanceId = null, this._lineColor = yt.red(), this._lineOpacity = 1, this._linePattern = null, this._linePatternLength = null, this._linePatternLengthUnit = null, this._viewer = t, this._firstPoint = e, this._secondPoint = i, this._firstNodeId = n, this._secondNodeId = r;
  }
  /**
   * Sets the line color.
   * @param color
   */
  setLineColor(t) {
    this._lineColor = t;
  }
  /**
   * Gets the line color.
   */
  getLineColor() {
    return this._lineColor;
  }
  /**
   * Sets the line opacity.
   * @param opacity
   */
  setLineOpacity(t) {
    this._lineOpacity = t;
  }
  /**
   * Gets the line opacity.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the line pattern.
   * @param pattern The line pattern.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the pattern length is measured.
   */
  setLinePattern(t, e, i) {
    this._linePattern = t, this._linePatternLength = e, this._linePatternLengthUnit = i;
  }
  /**
   * Gets the line pattern.
   */
  getLinePattern() {
    return this._linePattern !== void 0 ? this._linePattern : null;
  }
  /**
   * Gets the length of a single repetition of the line pattern.
   */
  getLinePatternLength() {
    return this._linePatternLength !== void 0 ? this._linePatternLength : null;
  }
  /**
   * Gets the unit in which the line pattern length is measured.
   */
  getLinePatternLengthUnit() {
    return this._linePatternLengthUnit !== void 0 ? this._linePatternLengthUnit : null;
  }
  /**
   * Sets the first point on the line.
   * @param firstPoint
   */
  setFirstPoint(t) {
    this._firstPoint = t;
  }
  /**
   * Gets the first point on the line.
   * @returns the first point, or null if none is set.
   */
  getFirstPoint() {
    return this._firstPoint;
  }
  /**
   * Sets the second point on the line.
   * @param secondPoint
   */
  setSecondPoint(t) {
    this._secondPoint = t;
  }
  /**
   * Gets the second point on the line.
   * @returns the second point, or null if none is set.
   */
  getSecondPoint() {
    return this._secondPoint;
  }
  /**
   * Sets the NodeId of the part associated with the first line point
   * @param nodeId
   */
  setFirstNodeId(t) {
    this._firstNodeId = t;
  }
  /**
   * Gets the NodeId of the part associated with the first line point
   */
  getFirstNodeId() {
    return this._firstNodeId;
  }
  /**
   * Sets the NodeId of the part associated with the second line point
   * @param nodeId
   */
  setSecondNodeId(t) {
    this._secondNodeId = t;
  }
  /**
   * Gets the NodeId of the part associated with the second line point
   */
  getSecondNodeId() {
    return this._secondNodeId;
  }
  /**
   * Gets the node id associated with the line markup.
   */
  getNodeId() {
    return this._lineMeshInstanceId;
  }
  /**
   * Removes the line geometry from the scene.
   */
  async removeLine() {
    const t = this._viewer.model;
    this._lineMeshInstanceId !== null && (await t.deleteMeshInstances([this._lineMeshInstanceId]), this._lineMeshInstanceId = null, this._lineMeshId !== null && (await t.deleteMeshes([this._lineMeshId]), this._lineMeshId = null));
  }
  /**
   * Draws updated line geometry in the scene.
   */
  async updateLine() {
    if (await this.removeLine(), this._firstPoint !== null && this._secondPoint !== null) {
      const t = new Ss();
      t.addPolyline([
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z,
        this._secondPoint.x,
        this._secondPoint.y,
        this._secondPoint.z
      ]);
      const e = this._viewer.model, i = await e.createMesh(t);
      this._lineMeshId = i;
      const n = new tr(i);
      n.setLineColor(this._lineColor), n.setLineOpacity(this._lineOpacity), n.setCreationFlags(ee.ExcludeBounding);
      const r = await e.createMeshInstance(n);
      this._linePattern !== null && e.setNodesLinePattern(
        [r],
        this._linePattern,
        this._linePatternLength,
        this._linePatternLengthUnit
      ), this._lineMeshInstanceId = r;
    }
  }
  /**
   * Returns a unique markup id for this line.
   */
  getId() {
    return this._uniqueId;
  }
  /**
   * Sets a markup id for this line.
   * @param id
   */
  setId(t) {
    this._uniqueId = t;
  }
  /**
   * Returns the class name for this markup item.
   */
  getClassName() {
    return Tc.className;
  }
  _toJson() {
    return {
      className: this.getClassName(),
      uniqueId: this._uniqueId,
      firstPoint: this.getFirstPoint(),
      secondPoint: this.getSecondPoint(),
      firstNodeId: this.getFirstNodeId(),
      secondNodeId: this.getSecondNodeId(),
      lineColor: this.getLineColor(),
      lineOpacity: this.getLineOpacity(),
      linePattern: this.getLinePattern(),
      linePatternLength: this.getLinePatternLength(),
      linePatternLengthUnit: this.getLinePatternLengthUnit()
    };
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  /**
   * Creates a new [[LineMarkup]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(t, e) {
    const i = t, n = new Tc(
      e,
      m.fromJson(i.firstPoint),
      m.fromJson(i.secondPoint),
      i.firstNodeId,
      i.secondNodeId
    );
    return n.setId(i.uniqueId), n.setLineColor(yt.fromJson(i.lineColor)), n.setLineOpacity(i.lineOpacity), i.linePattern != null && i.linePatternLength != null && i.linePatternLengthUnit != null && n.setLinePattern(i.linePattern, i.linePatternLength, i.linePatternLengthUnit), n;
  }
};
Tc.className = "Communicator.Markup.Line.LineMarkup";
let Ta = Tc;
us(Ta.className, Ta.fromJson);
const $b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LineMarkup: Ta
}, Symbol.toStringTag, { value: "Module" }));
class ml {
  constructor(t, e, i, n, r, o) {
    this._version = Js.Unknown, this._components = {}, this._lines = [], this._clippingPlanes = [], this._viewer = o, this._filename = t, this._version = i, this._modelBounding = n, this._unitScale = 1e3 / r, this._parseDocument(e);
  }
  static async createViewpoint(t, e, i = null) {
    const n = (j) => {
      const F = [];
      return j.forEach((K) => {
        let J = null;
        for (; K !== null && J === null; )
          J = r.getNodeGenericId(K), K = r.getNodeParent(K);
        F.push(J);
      }), console.assert(j.length === F.length), F;
    }, r = t.model, o = r.getAbsoluteRootNode(), l = await r.getVisibilityState(o), h = await r.getNodeColorMap(o, an.Faces), u = await r.getModelBounding(!0, !1), f = r.getNodeUnitMultiplier(o), g = new ml(
      e,
      null,
      Js.v2_1,
      u,
      f,
      t
    ), y = l.defaultVisibility;
    g.setDefaultVisibility(y);
    const _ = l.visibilityExceptions, x = [];
    _.forEach((j) => {
      x.push(j);
    });
    const b = [], I = n(x);
    for (let j = 0; j < I.length; j++) {
      const F = I[j];
      let K;
      F !== null ? K = r.getNodeIdsByGenericIds([F]) : K = [x[j]];
      for (const J of K) {
        const rt = await r.getVisibilityState(J), ft = { genericId: F, nodeId: J };
        y ? rt.visibilityExceptions.size === 0 && b.push(ft) : (rt.visibilityExceptions.size !== 0 || rt.defaultVisibility) && b.push(ft);
      }
    }
    g.setVisibilityExceptionNodes(b);
    const M = t.selectionManager.getResults().map((j) => j.getNodeId()), P = n(M), O = [];
    for (let j = 0; j < M.length; j++) {
      const F = {
        genericId: P[j],
        nodeId: M[j]
      };
      O.push(F);
    }
    g.setSelectionNodes(O);
    const B = /* @__PURE__ */ new Map();
    if (h.size > 0 && h.forEach((j, F) => {
      const K = r.getNodeParent(F);
      if (K === null)
        return;
      const J = r.getNodeGenericId(K);
      let rt = B.get(j);
      rt === void 0 && (rt = /* @__PURE__ */ new Set(), B.set(j, rt)), rt.add({ genericId: J, nodeId: F });
    }), g.setColorNodes(B), g.setCamera(t.view.getCamera()), i !== null) {
      const j = ml._markupRedlineToBcf(i.getMarkup(), t.view);
      g.setLines(j);
    }
    return g;
  }
  static _markupRedlineToBcf(t, e) {
    const r = (f) => {
      const g = e.projectPoint(f);
      return e.unprojectPoint(X.fromPoint3(g), 0);
    }, o = (f, g, y) => {
      const _ = Math.PI * 2 / y, x = [];
      for (let b = 0; b <= y; b++) {
        const I = b * _;
        x.push(
          new X(f.x + Math.cos(I) * g, f.y + Math.sin(I) * g)
        );
      }
      return x;
    }, l = (f) => {
      for (let g = 0; g < f.length - 1; ++g) {
        const y = f[g], _ = f[g + 1];
        if (y !== null && _ !== null) {
          const x = [y.copy().scale(1e-3), _.copy().scale(1e-3)];
          u.push(x);
        }
      }
    }, h = (f) => {
      for (let g = 0; g < f.length; ++g) {
        const y = f[g], _ = f[(g + 1) % f.length];
        if (y !== null && _ !== null) {
          const x = [y.copy().scale(1e-3), _.copy().scale(1e-3)];
          u.push(x);
        }
      }
    }, u = [];
    return t.forEach((f) => {
      if (f instanceof Ea) {
        const y = f.getPoints().map(r);
        l(y);
      } else if (f instanceof ka) {
        const g = f.getCenter(), y = f.getRadiusPoint(), _ = X.fromPoint3(e.projectPoint(g)), x = X.fromPoint3(e.projectPoint(y)), b = X.subtract(x, _).length(), C = o(_, b, 40).map((M) => e.unprojectPoint(M, 0));
        h(C);
      } else if (f instanceof Aa) {
        const g = f.getPoint1(), y = f.getPoint2(), _ = X.fromPoint3(e.projectPoint(g)), x = X.fromPoint3(e.projectPoint(y)), b = [];
        b.push(e.unprojectPoint(_, 0)), b.push(
          e.unprojectPoint(new X(_.x, x.y), 0)
        ), b.push(e.unprojectPoint(x, 0)), b.push(
          e.unprojectPoint(new X(x.x, _.y), 0)
        ), h(b);
      }
    }), u;
  }
  _parseDocument(t) {
    if (t === null)
      return;
    const e = t.documentElement, i = e.attributes.getNamedItem("Guid");
    i !== null && (this._viewpointGuid = i.value);
    let n = e.firstElementChild;
    for (; n !== null; ) {
      const r = n.localName;
      if (r === null) break;
      switch (r) {
        case "Components":
          this._version >= Js.v2_1 ? this._parseComponents(n) : this._parseComponentsV2_0(n);
          break;
        case "OrthogonalCamera":
          this._parseOrthogonalCamera(n);
          break;
        case "PerspectiveCamera":
          this._parsePerspectiveCamera(n);
          break;
        case "Lines":
          this._parseLines(n);
          break;
        case "ClippingPlanes":
          this._parseClippingPlanes(n);
          break;
      }
      n = n.nextElementSibling;
    }
  }
  _exportComponents(t) {
    const e = t.createElement("Components"), i = t.createElement("ViewSetupHints"), n = this._components.viewSetupHints;
    n && (e.setAttribute("SpacesVisible", mc(n.spacesVisible)), e.setAttribute(
      "SpaceBoundariesVisible",
      mc(n.spaceBoundariesVisible)
    ), e.setAttribute("OpeningsVisible", mc(n.openingsVisible))), e.appendChild(i);
    const r = t.createElement("Selection"), o = this._components.selection;
    o && o.forEach((y) => {
      r.appendChild(Pu(t, y));
    }), e.appendChild(r);
    const l = t.createElement("Visibility"), h = this._components.defaultVisibility, u = this._components.visibilityExceptions;
    if (h !== void 0 && u !== void 0) {
      l.setAttribute("DefaultVisibility", mc(h));
      const y = t.createElement("Exceptions");
      u.forEach((_) => {
        y.appendChild(Pu(t, _));
      }), l.appendChild(y);
    }
    e.appendChild(l);
    const f = t.createElement("Coloring"), g = this._components.coloring;
    return g && g.forEach((y) => {
      const _ = t.createElement("Color");
      _.setAttribute("Color", E_(y.color, y.alpha)), y.components.forEach((x) => {
        _.appendChild(Pu(t, x));
      }), f.appendChild(_);
    }), e.appendChild(f), e;
  }
  _exportOrthogonalCamera(t, e) {
    const i = t.createElement("OrthogonalCamera"), n = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    hr(t, n, e.cameraViewPoint), hr(t, r, e.cameraDirection), hr(t, o, e.cameraUpVector);
    const l = t.createElement("ViewToWorldScale");
    return l.innerHTML = e.viewToWorldScale.toString(), i.appendChild(n), i.appendChild(r), i.appendChild(o), i.appendChild(l), i;
  }
  _exportPerspectiveCamera(t, e) {
    const i = t.createElement("PerspectiveCamera"), n = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    hr(t, n, e.cameraViewPoint), hr(t, r, e.cameraDirection), hr(t, o, e.cameraUpVector);
    const l = t.createElement("FieldOfView");
    return l.innerHTML = e.fieldOfView.toString(), i.appendChild(n), i.appendChild(r), i.appendChild(o), i.appendChild(l), i;
  }
  _exportLines(t) {
    const e = t.createElement("Lines");
    return this._lines.forEach((i) => {
      const n = t.createElement("Line"), r = t.createElement("StartPoint"), o = t.createElement("EndPoint");
      hr(t, r, i.startPoint), hr(t, o, i.endPoint), n.appendChild(r), n.appendChild(o), e.appendChild(n);
    }), e;
  }
  _exportClippingPlanes(t) {
    const e = t.createElement("ClippingPlanes");
    return this._clippingPlanes.forEach((i) => {
      const n = t.createElement("ClippingPlane"), r = t.createElement("Location"), o = t.createElement("Direction");
      hr(t, r, i.location), hr(t, o, i.direction), n.appendChild(r), n.appendChild(o), e.appendChild(n);
    }), e;
  }
  /**
   * @returns XML document containing the viewpoint data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("VisualizationInfo");
    return e.appendChild(this._exportComponents(t)), this._viewpointGuid !== void 0 && e.setAttribute("Guid", this._viewpointGuid), this._orthogonalCamera ? e.appendChild(this._exportOrthogonalCamera(t, this._orthogonalCamera)) : this._perspectiveCamera && e.appendChild(this._exportPerspectiveCamera(t, this._perspectiveCamera)), this._lines.length > 0 && e.appendChild(this._exportLines(t)), this._clippingPlanes.length > 0 && e.appendChild(this._exportClippingPlanes(t)), t.appendChild(e), t;
  }
  /**
   * Activates viewpoint.
   * Sets the camera, visibility, cutting planes, colors, and markup.
   */
  async activate() {
    await this._activateCamera(), await this._activateComponentsVisibility(), await this._activateMarkup(), await this._activateCuttingPlanes(), this._activateSelected(), await this._activateColors();
  }
  async _activateCamera() {
    const t = this.getCamera();
    t !== null && await this._viewer.view._setCameraPromise(t, 800);
  }
  async _activateComponentsVisibility() {
    const t = this._viewer.model, e = this._getDefaultVisibility(), i = this.getVisibilityExceptionNodes();
    i.length ? (await t.setNodesVisibility([-2], e), await t.setNodesVisibility(i, !e)) : await t.reset();
  }
  async _activateMarkup() {
    const t = this._viewer.lineManager;
    await t.removeAllLines();
    const e = [];
    for (let i = 0; i < this._lines.length; ++i) {
      const n = this._lines[i], r = new Ta(
        this._viewer,
        n.startPoint.copy().scale(1e3),
        n.endPoint.copy().scale(1e3)
      );
      e.push(t.addLine(r));
    }
    await Promise.all(e);
  }
  async _activateCuttingPlanes() {
    const e = await this._viewer.model.getModelBounding(!0, !1), i = this._viewer.cuttingManager;
    await i.clearAllCuttingSections();
    for (let n = 0; n < this._clippingPlanes.length; ++n) {
      const r = i.getCuttingSection(n);
      await r.clear();
      const o = this._clippingPlanes[n], l = o.location.copy().scale(1e3), h = o.direction.normalize(), u = ln.createFromPointAndNormal(l, h), f = i.createReferenceGeometryFromFaceNormal(
        h,
        l,
        e
      );
      await r.addPlane(u, f);
    }
    await i.activateCuttingSections();
  }
  _activateSelected() {
    const t = this._getNodeIdsFromComponents(this._components.selection);
    this._viewer.selectionManager.clear(), t.forEach((e) => {
      this._viewer.selectionManager.selectNode(e, In.Add);
    });
  }
  async _activateColors() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode();
    if (t.unsetNodesFaceColor([e]), t.unsetNodesLineColor([e]), this._components.coloring !== void 0) {
      const i = /* @__PURE__ */ new Map();
      for (let n = 0; n < this._components.coloring.length; ++n) {
        const r = this._components.coloring[n];
        this._getNodeIdsFromComponents(r.components).forEach((l) => {
          i.set(l, r.color);
        });
      }
      await this._viewer.model.setNodesColors(i);
    }
  }
  /**
   * Gets the viewpoint filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the GUID associated with the viewpoint.
   */
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  _fromBCFPerspectiveCamera(t, e) {
    const i = new Sn();
    i.setProjection(ri.Perspective);
    const n = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = m.add(n, r), l = t.cameraUpVector.copy().normalize();
    i.setPosition(n), i.setTarget(o), i.setUp(l);
    const h = Lo(t.fieldOfView), u = Math.tan(h / 2), g = 2 * m.subtract(i.getTarget(), i.getPosition()).length() * u;
    return i.setWidth(g), i.setHeight(g), i;
  }
  _fromBCFOrthogonalCamera(t, e) {
    const i = new Sn();
    i.setProjection(ri.Orthographic);
    const n = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = m.add(n, r), l = t.cameraUpVector.copy().normalize();
    i.setPosition(n), i.setTarget(o), i.setUp(l);
    const h = t.viewToWorldScale * this._unitScale * 2;
    return i.setWidth(h), i.setHeight(h), i;
  }
  /**
   * Gets the viewpoint camera, or null if none is set.
   */
  getCamera() {
    const t = this._modelBounding.extents().length();
    return this._perspectiveCamera ? this._fromBCFPerspectiveCamera(this._perspectiveCamera, t / 40) : this._orthogonalCamera ? this._fromBCFOrthogonalCamera(this._orthogonalCamera, t) : null;
  }
  /**
   * Sets the viewpoint camera.
   * @param camera
   */
  setCamera(t) {
    t.getProjection() === ri.Perspective ? (this._perspectiveCamera = this._toBCFPerspectiveCamera(t), this._orthogonalCamera = void 0) : (this._orthogonalCamera = this._toBCFOrthogonalCamera(t), this._perspectiveCamera = void 0);
  }
  _toBCFOrthogonalCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), n = m.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), h = t.getWidth() / (this._unitScale * 2);
    return {
      cameraDirection: n,
      cameraUpVector: r,
      cameraViewPoint: o,
      viewToWorldScale: h
    };
  }
  _toBCFPerspectiveCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), n = m.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), l = t.getWidth(), h = m.subtract(t.getTarget(), t.getPosition()).length(), u = l / (2 * h), f = Math.atan(u) * 2, g = Qf(f);
    return {
      cameraDirection: n,
      cameraUpVector: r,
      cameraViewPoint: o,
      fieldOfView: g
    };
  }
  /**
   * Sets the default visibility.
   * If true, visibility exceptions are hidden.
   * If false, visibility exceptions are shown.
   * @param defaultVisibility
   */
  setDefaultVisibility(t) {
    this._components.defaultVisibility = t;
  }
  _getDefaultVisibility() {
    return this._components.defaultVisibility !== void 0 ? this._components.defaultVisibility : !0;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of GenericIds corresponding to components.
   */
  setVisibilityExceptions(t) {
    const e = t.map(
      (i) => {
        const n = this._viewer.model.getNodeIdsByGenericIds([i]), r = n.length !== 0 ? n[0] : void 0;
        return {
          ifcGuid: i,
          authoringToolId: r,
          originatingSystem: Nr
        };
      }
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of BcfNodes corresponding to components.
   */
  setVisibilityExceptionNodes(t) {
    const e = t.map(
      (i) => ({
        ifcGuid: i.genericId !== null ? i.genericId : void 0,
        authoringToolId: i.nodeId,
        originatingSystem: Nr
      })
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Gets the visibility exception generic ids.
   * @returns Array of GenericIds corresponding to components.
   */
  getVisibilityExceptions() {
    return this._getGenericIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Gets the visibility exception node ids.
   * @returns Array of NodeIds corresponding to components.
   */
  getVisibilityExceptionNodes() {
    return this._getNodeIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Sets the colors.
   * @param colorGenericIdMap Map correlating color to GenericIds.
   */
  setColors(t) {
    const e = [];
    t.forEach((i, n) => {
      const r = [];
      i.forEach((l) => {
        const h = this._viewer.model.getNodeIdsByGenericIds([l]), u = h.length !== 0 ? h[0] : void 0;
        r.push({
          ifcGuid: l,
          authoringToolId: u,
          originatingSystem: Nr
        });
      });
      const o = {
        color: n,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * Sets the colors.
   * @param colorNodeMap Map correlating color to BfcNodes.
   */
  setColorNodes(t) {
    const e = [];
    t.forEach((i, n) => {
      const r = [];
      i.forEach((l) => {
        const h = l.genericId !== null ? l.genericId : void 0;
        r.push({
          ifcGuid: h,
          authoringToolId: l.nodeId,
          originatingSystem: Nr
        });
      });
      const o = {
        color: n,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * @returns Map correlating color to components.
   */
  getColors() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const n = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.ifcGuid !== void 0 && r.add(o.ifcGuid);
      }), t.set(n, r);
    }), t;
  }
  /**
   * @returns Map correlating color to nodes.
   */
  getColorsToNodes() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const n = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.authoringToolId !== void 0 && o.originatingSystem === Nr && r.add(o.authoringToolId);
      }), t.set(n, r);
    }), t;
  }
  /**
   * Sets the markup lines.
   * @param lines array of start point and end point line pairs.
   */
  setLines(t) {
    this._lines = [], t.forEach((e) => {
      const i = {
        startPoint: e[0].copy(),
        endPoint: e[1].copy()
      };
      this._lines.push(i);
    });
  }
  /**
   * Gets markup lines.
   * @returns Array containing start point and end point line pairs.
   */
  getLines() {
    const t = [];
    return this._lines.forEach((e) => {
      t.push([e.startPoint.copy(), e.endPoint.copy()]);
    }), t;
  }
  /**
   * Sets the clipping planes.
   * @param planes array containing position and direction pairs.
   */
  setClippingPlanes(t) {
    this._clippingPlanes = [], t.forEach((e) => {
      const i = {
        location: e[0].copy(),
        direction: e[1].copy()
      };
      this._clippingPlanes.push(i);
    });
  }
  /**
   * Gets the clipping planes.
   * @returns Array containing position and direction pairs.
   */
  getClippingPlanes() {
    const t = [];
    return this._clippingPlanes.forEach((e) => {
      t.push([e.location.copy(), e.direction.copy()]);
    }), t;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelection(t) {
    const e = t.map((i) => {
      const n = this._viewer.model.getNodeIdsByGenericIds([i]), r = n.length !== 0 ? n[0] : void 0;
      return {
        ifcGuid: i,
        authoringToolId: r,
        originatingSystem: Nr
      };
    });
    this._components.selection = e;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelectionNodes(t) {
    const e = t.map((i) => ({
      ifcGuid: i.genericId !== null ? i.genericId : void 0,
      authoringToolId: i.nodeId,
      originatingSystem: Nr
    }));
    this._components.selection = e;
  }
  /**
   * Gets a list of generic IDs that are in the selection set.
   */
  getSelection() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.ifcGuid && t.push(i.ifcGuid);
    }), t;
  }
  /**
   * Gets a list of node IDs that are in the selection set.
   */
  getSelectionNodes() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.authoringToolId !== void 0 && i.originatingSystem === Nr && t.push(i.authoringToolId);
    }), t;
  }
  _getGenericIdsFromComponents(t) {
    if (!t) return [];
    const e = [];
    for (let i = 0; i < t.length; ++i) {
      const n = t[i];
      n.ifcGuid !== void 0 && e.push(n.ifcGuid);
    }
    return e;
  }
  _getNodeIdsFromComponents(t) {
    if (!t) return [];
    const e = /* @__PURE__ */ new Set(), i = [];
    for (let r = 0; r < t.length; ++r) {
      const o = t[r];
      o.authoringToolId !== void 0 && o.originatingSystem === Nr ? e.add(o.authoringToolId) : o.ifcGuid !== void 0 && i.push(o.ifcGuid);
    }
    const n = this._viewer.model.getNodeIdsByGenericIds(i);
    for (const r of n)
      e.add(r);
    return Array.from(e);
  }
  _parseComponentsV2_0(t) {
    console.assert(this._version <= Js.v2_0);
    const e = [], i = [], n = [];
    let r = !0, o = t.firstElementChild;
    for (; o !== null; ) {
      const l = o.localName;
      if (l === null) break;
      switch (l) {
        case "Component":
          {
            const h = o.attributes, u = h.getNamedItem("IfcGuid"), f = h.getNamedItem("Selected"), g = h.getNamedItem("Visible"), y = h.getNamedItem("Color");
            if (u !== null && u.value) {
              const x = {
                ifcGuid: u.value
              };
              if (f !== null && f.value === "true" && e.push(x), r = !1, g !== null && g.value === "false" || i.push(x), y !== null && y.value) {
                const b = y.value;
                n.push(this._colorFromArgb(b, [x]));
              }
            }
          }
          break;
      }
      o = o.nextElementSibling;
    }
    this._components = {
      defaultVisibility: r,
      selection: e,
      visibilityExceptions: i,
      coloring: n
    };
  }
  _parseComponents(t) {
    console.assert(this._version >= Js.v2_1);
    let e = t.firstElementChild;
    const i = {
      spacesVisible: !1,
      spaceBoundariesVisible: !1,
      openingsVisible: !1
    };
    let n = [], r = !0, o = [], l = [];
    for (; e !== null; ) {
      const h = e.localName;
      if (h === null) break;
      const u = e.attributes;
      switch (h) {
        case "ViewSetupHints":
          {
            const f = u.getNamedItem("SpacesVisible"), g = u.getNamedItem("SpaceBoundariesVisible"), y = u.getNamedItem("OpeningsVisible");
            f !== null && (i.spacesVisible = f.value === "true"), g !== null && (i.spaceBoundariesVisible = g.value === "true"), y !== null && (i.openingsVisible = y.value === "true");
          }
          break;
        case "Selection":
          n = this._getComponents(e);
          break;
        case "Visibility":
          {
            const f = u.getNamedItem("DefaultVisibility");
            f && (r = f.value === "true");
            const g = e.firstElementChild;
            g !== null && (o = this._getComponents(g));
          }
          break;
        case "Coloring":
          l = this._getColoring(e);
          break;
      }
      e = e.nextElementSibling;
    }
    this._components = {
      viewSetupHints: i,
      selection: n,
      defaultVisibility: r,
      visibilityExceptions: o,
      coloring: l
    };
  }
  _getCameraData(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; )
      switch (i.nodeName) {
        case "FieldOfView":
        case "ViewToWorldScale":
          {
            const n = i.textContent;
            n !== null && e.push(parseFloat(n)), i = null;
          }
          break;
        default:
          e.push(this._getPoint(i)), i = i.nextElementSibling;
      }
    return e;
  }
  _parseOrthogonalCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._orthogonalCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      viewToWorldScale: e[3]
    });
  }
  _parsePerspectiveCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._perspectiveCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      fieldOfView: e[3]
    });
  }
  _parseLines(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._lines.push(this._getLine(e)), e = e.nextElementSibling;
  }
  _parseClippingPlanes(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._clippingPlanes.push(this._getClippingPlane(e)), e = e.nextElementSibling;
  }
  _getClippingPlane(t) {
    let e = t.firstElementChild, i = m.zero(), n = m.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (n = this._getPoint(e))), {
      location: i,
      direction: n
    };
  }
  _getLine(t) {
    let e = t.firstElementChild, i = m.zero(), n = m.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (n = this._getPoint(e))), {
      startPoint: i,
      endPoint: n
    };
  }
  _getPoint(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const n = i.firstChild;
      n !== null && e.push(parseFloat(n.wholeText)), i = i.nextElementSibling;
    }
    return console.assert(e.length === 3), new m(e[0], e[1], e[2]);
  }
  _colorFromArgb(t, e) {
    const i = {
      color: yt.black(),
      components: e
    }, n = [];
    for (let r = 0; r < t.length; r += 2) {
      const o = t.substr(r, 2);
      n.push(parseInt(o, 16));
    }
    return n.length === 3 ? i.color.set(n[0], n[1], n[2]) : n.length === 4 && (i.alpha = n[0], i.color.set(n[1], n[2], n[3])), i;
  }
  _getColoring(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const r = i.attributes.getNamedItem("Color"), o = this._getComponents(i);
      r && o.length && e.push(this._colorFromArgb(r.value, o)), i = i.nextElementSibling;
    }
    return e;
  }
  _getComponents(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const n = i.attributes, r = n.getNamedItem("IfcGuid"), o = n.getNamedItem("OriginatingSystem"), l = n.getNamedItem("AuthoringToolId");
      if (r !== null) {
        const h = {
          ifcGuid: r.value
        };
        o !== null && (h.originatingSystem = o.value), l !== null && (h.authoringToolId = parseInt(l.value, 10)), e.push(h);
      }
      i = i.nextElementSibling;
    }
    return e;
  }
}
class md {
  constructor(t, e, i, n) {
    this._viewpointMap = /* @__PURE__ */ new Map(), this._snapshotMap = /* @__PURE__ */ new Map(), this._viewer = n, this._topicId = i, this._bcfDataId = t, this._bcfFilename = e;
  }
  /**
   * Takes a MarkupView and creates a BCF Topic from it.
   * @param bcfDataId
   * @param bcfFilename
   * @param viewer
   * @param markupView
   * @param topicTitle
   */
  static async createTopic(t, e, i, n, r = null) {
    const o = Ms(), l = new md(e, i, o, t), u = l.addMarkup("markup.bcf", null);
    u.setTopicTitle(n), u.setTopicId(o);
    const f = "viewpoint.bcfv", g = await ml.createViewpoint(t, f, r);
    l.setViewpoint(f, g);
    const y = "snapshot.png", _ = (r !== null ? r.getSnapshotImage() : null) || await t.takeSnapshot(), x = va.createFromImage(y, _);
    return l.setSnapshot(y, x), l;
  }
  /**
   * Gets the topic id corresponding to the BCF topic folder.
   */
  getTopicId() {
    return this._topicId;
  }
  /**
   * Adds a BCF markup.
   * @param markup BCF markup data.
   */
  addMarkup(t, e) {
    return this._markup = new N_(t, e, this), this._markup;
  }
  /**
   * @returns BCF markup data.
   */
  getMarkup() {
    return this._markup;
  }
  /**
   * Creates and adds BCF viewpoint.
   * @param fileName viewpoint filename.
   * @param viewpoint BCF viewpoint data.
   */
  addViewpoint(t, e, i, n, r) {
    const o = new ml(
      t,
      e,
      i,
      n,
      r,
      this._viewer
    );
    return this.setViewpoint(t, o), o;
  }
  /**
   * Adds a BCF Viewpoint. If there is a already a viewpoint with the same filename, it will be replaced.
   * @param filename
   * @param viewpoint
   */
  setViewpoint(t, e) {
    this._viewpointMap.set(t, e);
  }
  /**
   * @returns A map associating viewpoint filenames with viewpoint data.
   */
  getViewpointMap() {
    return this._viewpointMap;
  }
  /**
   * Gets viewpoint data.
   * @param filename viewpoint filename.
   */
  getViewpoint(t) {
    return this._viewpointMap.get(t) || null;
  }
  /**
   * Creates and adds a Snapshot.
   * @param fileName Snapshot filename.
   * @param png Image data.
   */
  addSnapshot(t, e) {
    const i = new va(t, e);
    this.setSnapshot(t, i);
  }
  /**
   * Adds a BCF Snapshot. If there is already a snapshot with the smae filename, it will be replaced.
   * @param filename
   * @param snapshot
   */
  setSnapshot(t, e) {
    this._snapshotMap.set(t, e);
  }
  /**
   * @returns A map associating snapshot filenames with snapshot data.
   */
  getSnapshotMap() {
    return this._snapshotMap;
  }
  /**
   * Gets snapshot data.
   * @param filename snapshot or corresponding viewpoint filename
   */
  getSnapshot(t) {
    return this._snapshotMap.get(this._massageSnapshotFilename(t)) || null;
  }
  _massageSnapshotFilename(t) {
    if (t === "viewpoint.bcfv")
      return "snapshot.png";
    const e = t.split(".");
    return e[1] === "bcfv" ? `${e[0]}.png` : t;
  }
}
const eS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BCFComment: Nf,
  BCFData: Eu,
  BCFFileType: Yn,
  BCFMarkup: N_,
  BCFMarkupHeaderFile: T_,
  BCFMarkupViewpoint: D_,
  BCFSnapshot: va,
  BCFTopic: md,
  BCFVersion: Js,
  BCFViewpoint: ml,
  addElem: Lr,
  appendPoint3: hr,
  argbStringFromColor: E_,
  boolToString: mc,
  conditionalAddElem: on,
  conditionalBoolToString: ku,
  conditionalDateToString: _c,
  conditionalNumberToString: Df,
  conditionalSetAttribute: Or,
  defaultOriginatingSystem: Nr,
  exportComponent: Pu
}, Symbol.toStringTag, { value: "Module" }));
var Yu = /* @__PURE__ */ ((s) => (s[s.avatarOffset = 1500] = "avatarOffset", s[s.maxClimbHeight = 600] = "maxClimbHeight", s[s.negligibleClimbHeight = 20] = "negligibleClimbHeight", s[s.maxFallDistance = 5e3] = "maxFallDistance", s))(Yu || {}), Zu = /* @__PURE__ */ ((s) => (s[s.avatarOffset = 150] = "avatarOffset", s))(Zu || {}), Qu = /* @__PURE__ */ ((s) => (s[s.transparencyRange = 4e3] = "transparencyRange", s))(Qu || {});
const iS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DefaultDoorConfig: Qu,
  DefaultFloorConfig: Yu,
  DefaultWallConfig: Zu
}, Symbol.toStringTag, { value: "Module" }));
var Wo = /* @__PURE__ */ ((s) => (s[s.Never = 0] = "Never", s[s.Bim = 1] = "Bim", s[s.BimWalk = 2] = "BimWalk", s))(Wo || {}), xn = /* @__PURE__ */ ((s) => (s.Inactive = "inactive", s.Activating = "activating", s.Active = "active", s))(xn || {});
function Of(s) {
  if (s.length === 0)
    return new wt();
  if (s.length === 1)
    return s[0];
  let t = wt.multiply(s[1], s[0]);
  for (let e = 2; e < s.length; ++e)
    t = wt.multiply(s[e], t);
  return t;
}
function Za(s, t, e) {
  return Math.max(t, Math.min(e, s));
}
function L_(s, t) {
  return s.x >= t.min.x && s.x <= t.max.x && s.y >= t.min.y && s.y <= t.max.y && s.z >= t.min.z && s.z <= t.max.z;
}
function Rf(s, t) {
  return s.z >= t.min.z && s.z <= t.max.z;
}
class F_ {
  constructor(t, e, i, n, r) {
    this.floorplanNode = null, this.floorNode = t, this.bounds = e, this.slabNodes = i, this.spaceNodes = n, this.floorplanMeshCreationNodes = r;
  }
}
class Eh {
  constructor() {
    this.overlayAnchor = qe.LowerRightCorner, this.overlaySize = new X(0.25, 1), this.overlayWidthUnit = Fe.ProportionOfCanvas, this.overlayHeightUnit = Fe.ProportionOfOtherDimension, this.overlayOffset = new X(0, 0), this.overlayOffsetXUnit = Fe.Pixels, this.overlayOffsetYUnit = Fe.Pixels, this.backgroundColor = yt.white(), this.backgroundOpacity = 0.25, this.borderColor = yt.black(), this.borderOpacity = 1, this.avatarColor = yt.createFromFloat(1, 0, 1), this.avatarOutlineColor = yt.black(), this.avatarOpacity = 1, this.avatarScale = 1, this.fixedAvatarScale = !0, this.overlayFeetPerPixel = 0.1, this.zoomLevel = 1, this.autoActivate = Wo.BimWalk, this.floorplanOrientation = ol.NorthUp, this.customAvatar = null, this.trackCameraEnabled = !1;
  }
  /**
   * Per-floor information.
   * @returns Copy of this configuration object.
   */
  copy() {
    const t = new Eh();
    return t.overlayAnchor = this.overlayAnchor, t.overlaySize = this.overlaySize.copy(), t.overlayWidthUnit = this.overlayWidthUnit, t.overlayHeightUnit = this.overlayHeightUnit, t.overlayOffset = this.overlayOffset.copy(), t.overlayOffsetXUnit = this.overlayOffsetXUnit, t.overlayOffsetYUnit = this.overlayOffsetYUnit, t.backgroundColor = this.backgroundColor.copy(), t.backgroundOpacity = this.backgroundOpacity, t.borderColor = this.borderColor.copy(), t.borderOpacity = this.borderOpacity, t.avatarColor = this.avatarColor.copy(), t.avatarOutlineColor = this.avatarOutlineColor.copy(), t.avatarOpacity = this.avatarOpacity, t.avatarScale = this.avatarScale, t.fixedAvatarScale = this.fixedAvatarScale, t.customAvatar = this.customAvatar, t.overlayFeetPerPixel = this.overlayFeetPerPixel, t.zoomLevel = this.zoomLevel, t.trackCameraEnabled = this.trackCameraEnabled, t.autoActivate = this.autoActivate, t.floorplanOrientation = this.floorplanOrientation, t;
  }
}
class Pi {
  constructor(t = Pe.Face) {
    this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Pe.None, this.forceEffectiveSceneVisibilityMask = Pe.None, this.respectDepthRange = !0, this.oneEntityPerTypePerInstance = !0, this.restrictLinesAndPointsToSelectedFaceInstances = !0, this.enableProximityFaces = !1, this.ignoreCappingGeometry = !1, this.ignoreOverlays = !1, this.restrictToOverlays = !1, this.selectionMask = t;
  }
  /** Returns a copy of this [[PickConfig]]. */
  copy() {
    const t = new Pi();
    return bv(this, t), t;
  }
  get allowFaces() {
    return (this.selectionMask & Pe.Face) !== 0;
  }
  set allowFaces(t) {
    this.selectionMask = fa(this.selectionMask, Pe.Face, t);
  }
  get allowLines() {
    return (this.selectionMask & Pe.Line) !== 0;
  }
  set allowLines(t) {
    this.selectionMask = fa(this.selectionMask, Pe.Line, t);
  }
  get allowPoints() {
    return (this.selectionMask & Pe.Point) !== 0;
  }
  set allowPoints(t) {
    this.selectionMask = fa(this.selectionMask, Pe.Point, t);
  }
}
class _d {
  constructor(t = Pe.All) {
    this.mustBeFullyContained = !1, this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Pe.None, this.forceEffectiveSceneVisibilityMask = Pe.None, this.allowFaces = !0, this.allowLines = !0, this.allowPoints = !0, this.ignoreCuttingSections = !0, this.onlyStreamedInstances = !1, this.ignoreUnrequestedInstances = !1, this.allowFaces = (t & Pe.Face) !== 0, this.allowLines = (t & Pe.Line) !== 0, this.allowPoints = (t & Pe.Point) !== 0;
  }
}
class Go {
  constructor(t, e, i, n) {
    this.x = t, this.xUnit = e, this.y = i, this.yUnit = n;
  }
}
class B_ {
  constructor(t, e, i) {
    this._anchor = t, this._position = e, this._size = i;
  }
  getAnchor() {
    return this._anchor;
  }
  getPosition() {
    return this._position;
  }
  getSize() {
    return this._size;
  }
}
class V_ {
  /** @hidden */
  constructor(t, e, i, n) {
    this._view = t, this._model = e, this._callbackManager = i, this._engine = n, this._viewports = [];
    for (let r = 0; r <= this.maxIndex(); r++)
      this._viewports.push(null);
  }
  /**
   * Gets the maximum index value that can be used for indexing overlays.
   * @returns the maximum index value.
   */
  maxIndex() {
    return be.First - 1;
  }
  /**
   * Creates an overlay or updates an existing one.
   * @param index the index of the overlay. This value may be any number between 1 and maxIndex(). If No overlay exists for this index one will be created.
   * @param anchor the anchor point for the viewport.
   * @param x the x value of the viewport location.
   * @param xUnit the unit type of the x parameter.
   * @param y the y value of the viewport location.
   * @param yUnit the unit type of the y parameter.
   * @param width the width of the viewport.
   * @param widthUnit the unit type of the width parameter.
   * @param height the height of the viewport.
   * @param heightUnit the unit type of the height parameter.
   */
  setViewport(t, e, i, n, r, o, l, h, u, f) {
    if (t === 0)
      throw new oe("Index 0 is reserved and may not be used to specify an overlay.");
    if (t < 0)
      throw new oe(`Invalid index ${t} specified when setting viewport.`);
    if (n === Fe.ProportionOfOtherDimension && o === Fe.ProportionOfOtherDimension)
      throw new oe("Both x and y may not be set proportional to each other");
    if (h === Fe.ProportionOfOtherDimension && f === Fe.ProportionOfOtherDimension)
      throw new oe(
        "Both width and height may not be set proportional to each other"
      );
    this._validateUnit(i, n, "x"), this._validateUnit(r, o, "y"), this._validateUnit(l, h, "width"), this._validateUnit(u, f, "height");
    const g = new Go(i, n, r, o), y = new Go(l, h, u, f), _ = new B_(e, g, y);
    return this._viewports[t] = _, this._engine.setOverlayViewport(
      t,
      e,
      i,
      n,
      r,
      o,
      l,
      h,
      u,
      f,
      this._view.id
    ), this._callbackManager.trigger("overlayViewportSet", t, this._view), Promise.resolve();
  }
  /**
   * @hidden
   * Gets the position of a viewport as it was defined with OverlayUnits
   * @param index Index to get position of
   * @returns OverlayUnitPoint expressing overlay's position
   */
  _getViewportPosition(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getPosition();
  }
  /**
   * Gets position in pixels of the viewport with the supplied index, or `null` if none has been set.
   * Note: This does not take the anchor point into account
   * @param index The index of the overlay to get the position of.
   */
  getViewportPixelPosition(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getPosition();
    return this._toPixelPoint(i);
  }
  /**
   * Gets the calculated position of the upper-left corner of the viewport with the supplied index, or `null`
   * if none has been set.
   * @param index The index of the overlay to get the offset of
   */
  getViewportPixelOffsetInCanvas(t) {
    const e = this.getViewportPixelPosition(t);
    if (e === null)
      return null;
    const i = this.getViewportPixelSize(t);
    if (i === null)
      return null;
    const n = this.getViewportAnchor(t);
    if (n === null)
      return null;
    const r = this._getOverlayOffset(n, i), o = X.add(r, e);
    switch (n) {
      case qe.UpperRightCorner:
      case qe.RightCenter:
      case qe.LowerRightCorner:
        o.x = r.x - e.x;
        break;
    }
    switch (n) {
      case qe.LeftCenter:
      case qe.Center:
      case qe.RightCenter:
      case qe.LowerLeftCorner:
      case qe.BottomCenter:
      case qe.LowerRightCorner:
        o.y = r.y - e.y;
    }
    return o;
  }
  /**
   * @hidden
   * Gets the size of a viewport as it was defined with OverlayUnits
   * @param index Index to get size of
   * @returns OverlayUnitPoint expressing overlay's size
   */
  _getViewportSize(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getSize();
  }
  /**
   * Gets size in pixels of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the size of.
   */
  getViewportPixelSize(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getSize();
    return this._toPixelPoint(i);
  }
  /**
   * Get the anchor point of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the anchor of.
   */
  getViewportAnchor(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getAnchor();
  }
  /**
   * Sets the visibility state for the given viewport.
   * @param index the overlay index.
   * @param visibility boolean value indicating whether the overlay should be rendered.
   */
  setVisibility(t, e) {
    return this._engine.setOverlayVisibility(t, e, this._view.id), Promise.resolve();
  }
  /**
   * Removes an overlay from the system. All nodes that have been assigned to this overlay will be returned to the default view.
   * @param index the index of the overlay to destroy.
   */
  destroy(t) {
    return this._engine.destroyOverlay(t, this._view.id), this._viewports[t] = null, Promise.resolve();
  }
  /**
   * Adds nodes into the overlay at the given index. They will no longer be rendered in the main window or any other overlay.
   * This method should not be called before the model structure ready callback has been triggered.
   * @param index the overlay index to add nodes into.
   * @param nodes the nodes to add into the overlay.
   */
  addNodes(t, e) {
    const i = this._model._gatherInstanceIncsFromNodeIds(e);
    return i.length > 0 && this._engine.addNodesToOverlay(i, this._view.id, t), Promise.resolve();
  }
  /**
   * Sets the camera for the given index.
   * @param index
   * @param camera
   */
  setCamera(t, e) {
    return this._engine.setOverlayCamera(t, e, this._view.id), Promise.resolve();
  }
  /** @hidden */
  _getOverlayOffset(t, e) {
    const i = this._view.getCanvasSize(), n = X.zero();
    return t === qe.LowerRightCorner || t === qe.UpperRightCorner || t === qe.RightCenter ? n.x = i.x - e.x : (t === qe.Center || t === qe.TopCenter || t === qe.BottomCenter) && (n.x = 0.5 * (i.x - e.x)), t === qe.LowerLeftCorner || t === qe.LowerRightCorner || t === qe.BottomCenter ? n.y = i.y - e.y : (t === qe.Center || t === qe.LeftCenter || t === qe.RightCenter) && (n.y = 0.5 * (i.y - e.y)), n;
  }
  /**
   * @hidden
   * Converts an OverlayUnitPoint to a pixel defined Point2 using the viewer's current dimensions
   * @param unitPoint Point defined with [[OverlayUnit]]s to convert
   * @returns point expressed in pixels based on viewer's current size
   */
  _toPixelPoint(t) {
    const e = this._view.getCanvasSize(), i = X.zero();
    let n = !1;
    switch (t.xUnit) {
      case Fe.Pixels:
        i.x = t.x;
        break;
      case Fe.ProportionOfCanvas:
        i.x = e.x * t.x;
        break;
      case Fe.MinimumProportionOfCanvas:
        i.x = t.x * Math.min(e.x, e.y);
        break;
      case Fe.ProportionOfOtherDimension:
        n = !0;
        break;
    }
    switch (t.yUnit) {
      case Fe.Pixels:
        i.y = t.y;
        break;
      case Fe.ProportionOfCanvas:
        i.y = e.y * t.y;
        break;
      case Fe.MinimumProportionOfCanvas:
        i.y = t.y * Math.min(e.x, e.y);
        break;
      case Fe.ProportionOfOtherDimension:
        i.y = i.x * t.y;
        break;
    }
    return n && (i.x = t.x * i.y), i;
  }
  _validateUnit(t, e, i) {
    if (e !== Fe.Pixels && (t < 0 || t > 1))
      throw new Rs(
        `value for ${i} should be between 0.0 and 1.0 when specifying non pixel value`
      );
  }
}
const nS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OverlayManager: V_,
  OverlayUnitPoint: Go,
  OverlayViewport: B_
}, Symbol.toStringTag, { value: "Module" })), Tn = class Tn {
  /** @hidden */
  constructor(t, e, i, n, r) {
    this._active = xn.Inactive, this._isSceneReady = !1, this._isModelLoaded = !1, this._isOverlayVisible = !1, this._isCallbacksSet = !1, this._onCameraUpdateFunc = this._doCameraUpdate.bind(this), this._onFrameDrawnFunc = this._onFrameDrawn.bind(this), this._floorplanNode = null, this._currentFloorInfo = null, this._config = new Eh(), this._floorLock = !1, this._tightBoundings = !1, this._genericStoreyType = "IFCBUILDINGSTOREY", this._floorInfos = /* @__PURE__ */ new Map(), this._floorInfosArray = new Array(), this._avatarNode = null, this._avatarDirty = !0, this._borderNode = null, this._borderDirty = !0, this._backgroundNode = null, this._backgroundDirty = !0, this._canvasSize = new X(1, 1), this._sync = new Uo(1, !0), this._setFloorplanSync = new P0(!1), this._viewer = t, this._model = e, this._engine = n, this._overlayManager = i, this._config = r.copy(), this._viewer.setCallbacks({
      sceneReady: () => {
        console.assert(
          this._active !== xn.Active,
          "Got sceneReady while Floorplan is Active"
        ), this._isSceneReady = !0, this._active === xn.Activating && this._sync.push(() => this._doUpdateActivation());
      },
      modelSwitchStart: () => {
        this._isModelLoaded = !1, this._sync.push(async () => this._deactivate());
      },
      firstModelLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      },
      subtreeLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      }
    });
  }
  /** Sets a custom avatar. See [[FloorplanConfig.customAvatar]] for detailed information. */
  async setCustomAvatar(t) {
    if (this._config.customAvatar !== t)
      return await this._doSetCustomAvatar(t), this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the size of the floorplan overlay window. See [[FloorplanConfig.overlaySize]] for detailed information. */
  async setOverlaySize(t, e, i) {
    return this._config.overlaySize = t.copy(), this._config.overlayWidthUnit = e, this._config.overlayHeightUnit = i, this._onConfigurationChanged();
  }
  /** Sets the anchor position of the floorplan overlay window. See [[FloorplanConfig.overlayAnchor]] for detailed information. */
  async setOverlayAnchor(t) {
    return this._config.overlayAnchor = t, this._onConfigurationChanged();
  }
  /** Sets the offset position of the floorplan overlay window. See [[FloorplanConfig.overlayOffset]] for detailed information. */
  async setOverlayOffset(t) {
    return this._config.overlayOffset = t.copy(), this._onConfigurationChanged();
  }
  /** Sets the overlay scaling. See [[FloorplanConfig.overlayFeetPerPixel]] for detailed information. */
  async setOverlayFeetPerPixel(t) {
    return this._config.overlayFeetPerPixel = t, this._onConfigurationChanged();
  }
  /** Sets the overlay zoom level. See [[FloorplanConfig.zoomLevel]] for detailed information. */
  async setZoomLevel(t) {
    return this._config.zoomLevel = t, this._onConfigurationChanged();
  }
  /** Sets the overlay background color. See [[FloorplanConfig.backgroundColor]] for detailed information. */
  async setBackgroundColor(t) {
    return this._config.backgroundColor = t, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay background opacity. See [[FloorplanConfig.backgroundOpacity]] for detailed information. */
  async setBackgroundOpacity(t) {
    return this._config.backgroundOpacity = t, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border color. See [[FloorplanConfig.borderColor]] for detailed information. */
  async setBorderColor(t) {
    return this._config.borderColor = t, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border opacity. See [[FloorplanConfig.borderOpacity]] for detailed information. */
  async setBorderOpacity(t) {
    return this._config.borderOpacity = t, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar primary color. See [[FloorplanConfig.avatarColor]] for detailed information. */
  async setAvatarColor(t) {
    return this._config.avatarColor = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar outline color. See [[FloorplanConfig.avatarOutlineColor]] for detailed information. */
  async setAvatarOutlineColor(t) {
    return this._config.avatarOutlineColor = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar opacity. See [[FloorplanConfig.avatarOpacity]] for detailed information. */
  async setAvatarOpacity(t) {
    return this._config.avatarOpacity = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar scale. See [[FloorplanConfig.avatarScale]] for detailed information. */
  async setAvatarScale(t) {
    return this._config.avatarScale = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar size to fixed scale. See [[FloorplanConfig.fixedAvatarScale]] for detailed information. */
  async setFixedAvatarScale(t) {
    if (this._config.fixedAvatarScale !== t)
      return await this._deleteAvatarNode(), this._config.fixedAvatarScale = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the floorplan tracking mode. See [[FloorplanConfig.trackCameraEnabled]] for detailed information. */
  async setTrackCameraEnabled(t) {
    return this._config.trackCameraEnabled = t, this._onConfigurationChanged();
  }
  /** Sets the floorplan display orientation. See [[FloorplanConfig.floorplanOrientation]] for detailed information. */
  async setFloorplanOrientation(t) {
    return this._config.floorplanOrientation = t, this._onConfigurationChanged();
  }
  /** Sets the auto-activate capability for any models loaded after this call. See [[FloorplanConfig.autoActivate]] for detailed information. */
  async setAutoActivate(t) {
    return this._config.autoActivate = t, this._onConfigurationChanged();
  }
  /** Locks floorplan to current floor such that changing floors will not change the displayed floorplan. */
  async setFloorLock(t) {
    if (this._floorLock = t, this.isActive() && !t) {
      const e = this._viewer.view.getCamera().getPosition();
      await this._setFloorplanFromPosition(e);
    }
  }
  /** Returns `true` if displayed floor has been locked with [[setFloorLock]]. */
  getFloorLock() {
    return this._floorLock;
  }
  /**
   * Makes floorplans use tight boundings during creation which can result in a better fit for the overlay.
   * This involves recreating any already existing floorplans.
   * This can be significantly more time consuming than using loose boundings if your floors are complex.
   * Defaults to `false`.
   */
  async setUseTightBoundings(t) {
    t !== this._tightBoundings && (await this._deleteAllFloorplans(), this._tightBoundings = t, this.isActive() && await this._onProcessIfc());
  }
  /**
   * Updates the floorplan to use the given configuration. This function allows
   * the user to set all configuration values with a single operation. There are
   * also `set<config-value>()` functions for easily setting individual configuration
   * values.
   *
   * Note that when using this function, all settings in the given configuration are
   * used and thus overwrite any individual settings changed with a prior
   * `set<config-value>()` call.
   *
   * All values from the passed configuration will be copied as part of this operation.
   */
  async setConfiguration(t) {
    const e = this._config.customAvatar;
    return this._config = t.copy(), e !== this._config.customAvatar && await this._doSetCustomAvatar(this._config.customAvatar), this._borderDirty = !0, this._backgroundDirty = !0, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Returns a copy of the current floorplan configuration. */
  getConfiguration() {
    return this._config.copy();
  }
  /** Gets the [[NodeId]] of the current storey. */
  getCurrentFloorNodeId() {
    return this._currentFloorInfo !== null ? this._currentFloorInfo.floorNode : null;
  }
  /** Gets the [[NodeId]] of the floorplan avatar. */
  getAvatarNodeId() {
    return this._avatarNode;
  }
  /** Returns `true` if the given point is inside the floorplan overlay and `false` otherwise. */
  insideOverlay(t) {
    const e = this._getOverlaySizeInPixels(), i = this._getOverlayOffsetInPixels();
    return t.x >= i.x && t.y >= i.y && t.x <= i.x + e.x && t.y <= i.y + e.y;
  }
  /**
   *  Activate the floorplan overlay.
   */
  async activate() {
    await this._sync.push(() => this._activate());
  }
  /**
   *  Deactivate the floorplan overlay. Once explicitly deactivated via this call, auto-activation
   *  will be suppressed for any new model that is loaded. Auto-activation can be reenabled by
   *  calling [[setAutoActivate]].
   */
  async deactivate() {
    await this._sync.push(() => this._deactivate());
  }
  /**
   * The avatar node needs to be deleted any time we are making changes to the mesh,
   * such as switching to a custom avatar or fixed avatar scale.
   */
  async _deleteAvatarNode() {
    if (this._avatarNode !== null) {
      try {
        this._model._getModelStructure().allowNodeDeletion(this._avatarNode), await this._model.deleteNode(this._avatarNode);
      } catch (t) {
        console.log(`Problem deleting existing avatar: ${t.message}`);
      }
      this._avatarNode = null;
    }
  }
  /** Perform the steps needed to set a custom avatar. */
  async _doSetCustomAvatar(t) {
    await this._deleteAvatarNode(), this._config.customAvatar = t;
  }
  /** Call after something in the configuration has changed. Will update all visuals accordingly */
  async _onConfigurationChanged() {
    return this._config.zoomLevel = Za(this._config.zoomLevel, 0.1, 10), this._config.avatarScale = Za(this._config.avatarScale, 0.1, 10), this._config.backgroundOpacity = Za(this._config.backgroundOpacity, 0, 1), this._config.borderOpacity = Za(this._config.borderOpacity, 0, 1), this._config.avatarOpacity = Za(this._config.avatarOpacity, 0, 1), this._isModelLoaded && this._active === xn.Inactive && this._config.autoActivate === Wo.Bim ? this._onModelLoaded() : (this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()), this._doCameraUpdate());
  }
  /** Sets the best floorplan for the given world position */
  async _setFloorplanFromPosition(t) {
    return this._setFloorplanSync.push(() => this._doSetFloorplanFromPosition(t));
  }
  /** Sets what floor the floorplan displays based on position */
  async _doSetFloorplanFromPosition(t) {
    let e = null;
    const i = [];
    for (const r of this._floorInfosArray)
      L_(t, r.bounds) && i.push(r);
    if (e = await (async (r) => {
      const o = await this._performDownwardSelection(t);
      for (const l of o) {
        const h = l.getNodeId(), u = this._model.getNodeParent(h);
        if (u === null)
          continue;
        const f = this._viewer.model.getNodeGenericType(u);
        if (f !== null) {
          if (Tn._ifcSpaceTypes.has(f)) {
            const g = await this._viewer.model.getNodesBounding([u]);
            if (!Rf(t, g))
              continue;
            for (const _ of r)
              if (_.spaceNodes.indexOf(u) !== -1)
                return _;
          } else if (Tn._ifcFloorTypes.has(f)) {
            for (const g of r)
              if (g.slabNodes.indexOf(u) !== -1)
                return g;
          }
        }
      }
      return null;
    })(i), e === null) {
      for (const r of this._floorInfosArray)
        if (Rf(t, r.bounds)) {
          e = r;
          break;
        }
    }
    if (e !== null && (this._currentFloorInfo = e, this._floorplanNode === null || this._floorplanNode !== e.floorplanNode))
      return this._setFloorplanFromFloorNode(e.floorNode);
  }
  /** This function performs a downward selection and sorts the results by the top of their boundings */
  async _performDownwardSelection(t) {
    const e = new Pi();
    e.respectVisibility = !1, e.oneEntityPerTypePerInstance = !0;
    const i = new vr(t, new m(0, 0, -1)), n = await this._viewer.view.pickAllFromRay(i, e), r = /* @__PURE__ */ new Map();
    for (const l of n) {
      const h = l.getNodeId(), u = await this._model.getNodesBounding([h]);
      r.set(h, u.max.z);
    }
    const o = (l, h) => {
      const u = r.get(l.getNodeId()), f = r.get(h.getNodeId());
      return u === void 0 || f === void 0 ? -1 : f - u;
    };
    return n.sort(o);
  }
  /**
   *  Will set the active state appropriately and kick off activation processing
   */
  async _activate() {
    this._active === xn.Inactive && (this._active = xn.Activating, await this._doUpdateActivation());
  }
  /**
   *  Deactivation will remove camera callbacks, hide the overlay, delete floornodes, and any other necessary cleanup
   */
  async _deactivate() {
    this._active !== xn.Inactive && (this._active = xn.Inactive, this._isCallbacksSet && (this._isCallbacksSet = !1, this._viewer.unsetCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })), this._isOverlayVisible = !1, await this._overlayManager.setVisibility(be.Floorplan, this._isOverlayVisible), this._borderNode && (await this._model.deleteNode(this._borderNode), this._borderNode = null), this._backgroundNode && (await this._model.deleteNode(this._backgroundNode), this._backgroundNode = null), await this._deleteAllFloorplans());
  }
  /**  This will be called anytime a model has loaded... first model, second model, etc. */
  async _onModelLoaded() {
    await this._sync.push(() => this._doOnModelLoaded());
  }
  /**
   * When a model is loaded, the active state will be examined and possibly modified here based on the incoming model.
   */
  async _doOnModelLoaded() {
    console.assert(this._isModelLoaded, "Model not loaded as expected");
    const t = this._model.getNodesByGenericType(this._genericStoreyType), e = t && t.size > 0;
    if (!e) {
      await this._deactivate();
      return;
    }
    this._active === xn.Inactive ? e && this._config.autoActivate === Wo.Bim && (this._active = xn.Activating) : this._active === xn.Active && (this._active = xn.Activating), this._active === xn.Activating && await this._doUpdateActivation();
  }
  /**
   *  This will activate the floorplan visuals if conditions allow.
   */
  async _doUpdateActivation() {
    this._active !== xn.Activating || !this._isSceneReady || !this._isModelLoaded || (this._active = xn.Active, this._isOverlayVisible || await this._setupOverlay(), await this._onProcessIfc(), this._isCallbacksSet || (this._isCallbacksSet = !0, this._viewer.setCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })));
  }
  /**
   *  Deletes all floorplan infos including generated nodes
   */
  async _deleteAllFloorplans() {
    const t = this._floorInfosArray.slice();
    this._floorInfos.clear(), this._floorInfosArray.length = 0, this._floorplanNode = null, this._currentFloorInfo = null;
    for (const e of t)
      e.floorplanNode && await this._model.deleteNode(e.floorplanNode);
  }
  /** Hides the currently active floorplan */
  async _hideActiveFloorplan() {
    this._floorplanNode !== null && (await this._hideOverlayNode(this._floorplanNode), this._floorplanNode = null, this._currentFloorInfo = null);
  }
  /**
   *  Call when IFC information is available from the model tree. Note that this call can happen multiple
   *  times within a session, thus it must be tolerant of existing data vs new data.
   */
  async _onProcessIfc() {
    console.assert(this._active === xn.Active), await this._gatherFloorInfos(), await this._doCameraUpdate();
  }
  /**
   */
  _hasFloorInfo(t) {
    return this._floorInfos.has(t);
  }
  /**
   */
  _getFloorInfo(t) {
    const e = this._floorInfos.get(t);
    return e === void 0 ? null : e;
  }
  /**
   * Creates floorplan related information from a floor node
   */
  async _createFloorInfo(t) {
    const e = new Array();
    this._gatherDescendentIfcNodes(t, Tn._ifcFloorTypes, e);
    const i = new Array();
    this._gatherDescendentIfcNodes(t, Tn._ifcSpaceTypes, i);
    const n = new Array();
    if (this._gatherDescendentIfcNodes(
      t,
      Tn._ifcFloorplanCreationTypes,
      n
    ), n.length === 0)
      return null;
    const r = await this._model.getNodesBounding(n, {
      bodyInstance: !0,
      pmiBody: !1,
      viewFrame: !1,
      tightBounding: this._tightBoundings
    }), o = new F_(
      t,
      r,
      e,
      i,
      n
    );
    return this._floorInfos.set(t, o), this._floorInfosArray.push(o), o;
  }
  /**
   *  Find the root floor nodes within the model.
   */
  async _gatherFloorInfos() {
    const t = this._model.getNodesByGenericType(Tn._genericStoreyType);
    if (t === null || t.size === 0) {
      await this._deactivate();
      return;
    }
    for (const e of lo(t))
      this._hasFloorInfo(e) || await this._createFloorInfo(e);
    this._floorInfos.size === 0 && await this._deactivate();
  }
  /**
   * Gathers all descendent nodes that have IFC types matching the given IFC types
   */
  _gatherDescendentIfcNodes(t, e, i) {
    const n = this._model.getNodeChildren(t);
    for (const r of n) {
      const o = this._model.getNodeGenericType(r);
      o !== null && e.has(o) && i.push(r), this._gatherDescendentIfcNodes(r, e, i);
    }
  }
  /**
   * Creates a floorplan mesh from a FloorInfo object and returns the NodeId of the resulting mesh.
   * Note: This does not attach the created floorplan mesh to the FloorInfo param. That must be done after.
   */
  async _createFloorplanFromFloorInfo(t) {
    const e = this._model._gatherInstanceIncsFromNodeIds(
      t.floorplanMeshCreationNodes
    ), i = await this._engine.createFloorplanMesh(e), n = i[0], r = i[1];
    return this._model._getModelStructure().createMeshInstance(n, r, "floorplan", null, !0, !0, !1);
  }
  /** We need to handle a canvas size updates, so use the frame-drawn callback */
  async _onFrameDrawn() {
    const t = this._viewer.view.getCanvasSize();
    t.equals(this._canvasSize) || (this._canvasSize = t.copy(), this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()));
  }
  /** Updates the overlay camera based on current state */
  async _doCameraUpdate() {
    if (this.isActive()) {
      this._floorLock || await this._setFloorplanFromPosition(this._viewer.view.getCamera().getPosition());
      try {
        this._viewer.pauseRendering(), await this._updateOverlay();
      } finally {
        this._viewer.resumeRendering();
      }
    }
  }
  /**
   * Returns `true` if the [[FloorplanManager]] is fully active.
   */
  isActive() {
    return this._active === xn.Active;
  }
  /** Call anytime something in the floorplan overlay might need to change. */
  async _updateOverlay() {
    if (!this.isActive())
      return;
    const t = this._viewer.view.getCamera(), e = t.getPosition();
    let i = m.subtract(t.getTarget(), e);
    i.z = 0, i.normalize(), (isNaN(i.x) || i.length() === 0) && (i = new m(0, 1, 0)), await this._updateOverlayCamera(e, i), await this._updateOverlayNodes(e, i);
  }
  /**
   * Call anytime something in the floorplan overlay might need to change.
   */
  async _updateOverlayNodes(t, e) {
    const i = this._model, n = this._config, r = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8, o = this._getOverlaySizeInPixels(), l = o.x / o.y, h = r * n.overlayFeetPerPixel / n.zoomLevel, u = h / l;
    let f = h * o.x, g = f / l;
    if (!n.trackCameraEnabled) {
      const B = this._getFixedCameraSize(l);
      B !== null && (f = B.x, g = B.y);
    }
    const y = new wt().setTranslationComponent(
      t.x,
      t.y,
      Tn._avatarZ
    ), _ = r * n.avatarScale, x = new wt().setScaleComponent(_, _, _), b = new wt();
    b.m[0] = e.y, b.m[1] = -e.x, b.m[2] = 0, b.m[4] = e.x, b.m[5] = e.y, b.m[6] = 0, b.m[8] = 0, b.m[9] = 0, b.m[10] = 1, await this._viewer.model.setNodeMatrix(
      this._avatarNode,
      Of([y, b, x])
    ), this._avatarDirty && (n.customAvatar === null && (i.setNodesFaceColor([this._avatarNode], n.avatarColor), i.setNodesLineColor([this._avatarNode], n.avatarOutlineColor), i.setNodesOpacity([this._avatarNode], n.avatarOpacity)), this._avatarDirty = !1), this._borderDirty && (i.setNodesLineColor([this._borderNode], n.borderColor), i.setNodesOpacity([this._borderNode], n.borderOpacity), this._borderDirty = !1), this._backgroundDirty && (i.setNodesFaceColor([this._backgroundNode], n.backgroundColor), i.setNodesOpacity([this._backgroundNode], n.backgroundOpacity), this._backgroundDirty = !1);
    const I = f - h, C = g - u, M = new wt().setScaleComponent(I, C, 1), P = new wt();
    if (!this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const B = this._currentFloorInfo.bounds.center();
      P.setTranslationComponent(B.x, B.y, 0);
    } else
      P.setTranslationComponent(t.x, t.y, 0);
    const O = this._config.floorplanOrientation === ol.AvatarUp ? Of([P, b, M]) : wt.multiply(M, P);
    await this._viewer.model.setNodeMatrix(this._borderNode, O), await this._viewer.model.setNodeMatrix(this._backgroundNode, O);
  }
  /**
   * Moves the camera such that the avatar will appear at the provided point on the overlay.
   * This is only available when the floorplan is not tracking the camera.
   * @param point Point in canvas within overlay
   */
  snapAvatarToPoint(t) {
    if (this._currentFloorInfo === null || !this.insideOverlay(t))
      return;
    if (this._config.trackCameraEnabled) {
      console.log(
        "FP: snapAvatarToPoint: currently only supported when trackCameraEnabled is false"
      );
      return;
    }
    const e = this._getOverlaySizeInPixels(), i = this._getOverlayOffsetInPixels(), n = new X(t.x - i.x, t.y - i.y), r = this._currentFloorInfo.bounds, o = r.extents(), l = o.x / o.y, h = e.x / e.y, u = this._viewer.view.getCamera(), f = u.getPosition(), g = u.getTarget();
    let y = new wt();
    if (this._config.floorplanOrientation !== ol.NorthUp) {
      const M = m.subtract(g, f), P = new m(M.x, M.y, 0).normalize(), O = new m(0, 1, 0), B = new m(-1, 0, 0), j = wr(B, P) > 90 ? new m(0, 0, -1) : new m(0, 0, 1), F = wr(O, P);
      y = wt.createFromOffAxisRotation(j, F);
    }
    let _, x;
    h > l ? (_ = o.y / e.y, x = new X(
      r.center().x - o.y / 2 * h,
      r.center().y + o.y / 2
    )) : (_ = o.x / e.x, x = new X(
      r.center().x - o.x / 2,
      r.center().y + o.x / 2 / h
    ));
    let b = new m(
      n.x * _ + x.x,
      x.y - n.y * _,
      f.z
    );
    b = y.transform(b);
    const I = m.subtract(g, f), C = m.add(b, I);
    u.setPosition(b), u.setTarget(C), u.setProjection(ri.Perspective), this._viewer.view.setCamera(u);
  }
  /** Figure out the pixel size of the overlay window */
  _getOverlaySizeInPixels() {
    const t = new Go(
      this._config.overlaySize.x,
      this._config.overlayWidthUnit,
      this._config.overlaySize.y,
      this._config.overlayHeightUnit
    );
    return this._viewer.overlayManager._toPixelPoint(t);
  }
  /** Get overlay offset in pixels */
  _getOverlayOffsetInPixels() {
    const t = this._overlayManager.getViewportPixelOffsetInCanvas(
      be.Floorplan
    );
    return t === null ? X.zero() : t;
  }
  _getFixedCameraSize(t) {
    if (this._currentFloorInfo !== null) {
      const e = this._currentFloorInfo.bounds.extents();
      return e.x / e.y > t ? new X(e.x, e.x / t) : new X(e.y * t, e.y);
    }
    return null;
  }
  /** Updates the camera settings for the overlay. Only update if the floorplan has changed?  */
  async _updateOverlayCamera(t, e) {
    const i = this._config, n = this._getOverlaySizeInPixels(), r = n.x / n.y;
    let h = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8 * i.overlayFeetPerPixel / i.zoomLevel * n.x, u = h / r;
    if (!i.trackCameraEnabled) {
      const g = this._getFixedCameraSize(r);
      g !== null && (h = g.x, u = g.y);
    }
    const f = new Sn();
    if (f.setWidth(h), f.setHeight(u), !this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const g = this._currentFloorInfo.bounds.center();
      f.setTarget(new m(g.x, g.y, 0)), f.setPosition(new m(g.x, g.y, 10));
    } else
      f.setTarget(new m(t.x, t.y, 0)), f.setPosition(new m(t.x, t.y, 10));
    i.floorplanOrientation === ol.AvatarUp ? f.setUp(e) : i.floorplanOrientation === ol.NorthUp && f.setUp(new m(0, 1, 0)), await this._overlayManager.setCamera(be.Floorplan, f);
  }
  /**
   * Sets the current floorplan based on the floorNode.
   *
   * @param floorNode A IFC Story node.
   */
  async _setFloorplanFromFloorNode(t) {
    await this._hideActiveFloorplan();
    const e = this._hasFloorInfo(t) ? this._getFloorInfo(t) : await this._createFloorInfo(t);
    if (e !== null) {
      if (e.floorplanNode === null) {
        const i = await this._createFloorplanFromFloorInfo(e), n = new wt();
        await this._model.setNodeMatrix(i, n, !0), await this._overlayManager.addNodes(be.Floorplan, [i]), e.floorplanNode = i, this._floorplanNode = i, this._currentFloorInfo = e, await this._showOverlayNode(i);
      } else
        this._floorplanNode = e.floorplanNode, this._currentFloorInfo = e, await this._showOverlayNode(e.floorplanNode);
      await this._updateOverlay();
    }
  }
  /**
   *  Creates the floorplan overlay
   */
  async _setupOverlay() {
    const t = this._config;
    console.assert(this.isActive());
    const e = this._overlayManager;
    this._isOverlayVisible = !0, await e.setViewport(
      be.Floorplan,
      t.overlayAnchor,
      t.overlayOffset.x,
      t.overlayOffsetXUnit,
      t.overlayOffset.y,
      t.overlayOffsetYUnit,
      t.overlaySize.x,
      t.overlayWidthUnit,
      t.overlaySize.y,
      t.overlayHeightUnit
    ), await e.setVisibility(be.Floorplan, this._isOverlayVisible), this._avatarNode || (this._avatarNode = this._config.customAvatar = this._config.customAvatar ?? await this._createAvatar(), this._model._getModelStructure().preventNodeDeletion(this._avatarNode), await this._overlayManager.addNodes(be.Floorplan, [this._avatarNode])), this._borderNode || (this._borderNode = await this._create2dBox(!0, !1, Tn._borderZ), await this._overlayManager.addNodes(be.Floorplan, [this._borderNode]), this._borderDirty = !0), this._backgroundNode || (this._backgroundNode = await this._create2dBox(!1, !0, Tn._backgroundZ), await this._overlayManager.addNodes(be.Floorplan, [this._backgroundNode]), this._backgroundDirty = !0), await this._updateOverlay();
  }
  /** Nodes within the the overlay displays aren't honoring their visibility settings. This is a workaround
   *  until that problem is fixed. Since the floorplan is a top-down view, we can just move "hidden" nodes
   *  far enough out of the camera view so they aren't rendered.
   */
  async _hideOverlayNode(t) {
    const e = new wt();
    e.setTranslationComponent(1e30, 0, 0), await this._model.setNodeMatrix(t, e, !0);
  }
  /** See _hideOverlayNode for workaround description */
  async _showOverlayNode(t) {
    await this._model.setNodeMatrix(t, new wt(), !0);
  }
  /** Creates a simple node to show the camera-position as an avatar on the overlay */
  async _createAvatar() {
    const t = this._config.fixedAvatarScale ? 1e4 : 1, e = 1.2 / t, i = 1.5 / t, n = -1.1 / t, r = [
      0,
      i,
      0,
      -e,
      -i,
      0,
      0,
      n,
      0,
      0,
      i,
      0,
      0,
      n,
      0,
      e,
      -i,
      0
    ], o = [
      -e,
      -i,
      0,
      0,
      i,
      0,
      e,
      -i,
      0,
      0,
      n,
      0,
      -e,
      -i,
      0
    ], l = new Ss();
    l.setBackfacesEnabled(!1), l.addFaces(r, void 0, void 0, void 0), l.addPolyline(o, void 0);
    const h = await this._viewer.model.createMesh(l), u = new tr(h), f = (this._config.fixedAvatarScale ? ee.SuppressCameraScale : ee.None) | ee.ExcludeBounding;
    return u.setCreationFlags(f), await this._viewer.model.createMeshInstance(
      u,
      null,
      !0,
      !0
    );
  }
  /** Create a 2d line based box. Used for the overlay border & background */
  async _create2dBox(t, e, i) {
    const h = new Ss();
    if (t) {
      const y = [
        -0.5,
        -0.5,
        i,
        -0.5,
        0.5,
        i,
        0.5,
        0.5,
        i,
        0.5,
        -0.5,
        i,
        -0.5,
        -0.5,
        i
      ];
      h.addPolyline(y, void 0);
    }
    if (e) {
      const y = [
        0.5,
        -0.5,
        i,
        0.5,
        0.5,
        i,
        -0.5,
        0.5,
        i,
        -0.5,
        0.5,
        i,
        -0.5,
        -0.5,
        i,
        0.5,
        -0.5,
        i
      ], _ = [
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1
      ];
      h.addFaces(y, _), h.setBackfacesEnabled(!1);
    }
    const u = await this._viewer.model.createMesh(h), f = new tr(u);
    return f.setCreationFlags(
      ee.ExcludeBounding | ee.DoNotReset
    ), await this._viewer.model.createMeshInstance(f, null, !0, !0);
  }
};
Tn._genericStoreyType = "IFCBUILDINGSTOREY", Tn._ifcFloorTypes = /* @__PURE__ */ new Set(["IFCSLAB"]), Tn._ifcSpaceTypes = /* @__PURE__ */ new Set(["IFCSPACE"]), Tn._ifcFloorplanCreationTypes = /* @__PURE__ */ new Set([
  "IFCWALL",
  "IFCWALLSTANDARDCASE",
  "IFCCURTAINWALL",
  "IFCSLAB",
  "IFCCOLUMN"
]), Tn._backgroundZ = -1, Tn._avatarZ = 1, Tn._borderZ = 2;
let td = Tn;
const sS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActiveState: xn,
  FloorInfo: F_,
  FloorplanAutoActivation: Wo,
  FloorplanConfig: Eh,
  FloorplanManager: td,
  clamp: Za,
  isPointInBox: L_,
  isPointInBoxOnlyZ: Rf,
  multiplyMatrices: Of
}, Symbol.toStringTag, { value: "Module" }));
class yd {
  /**
   * @param viewKey key for the View the event is occurring in
   */
  constructor(t = Ae.Default) {
    this._date = /* @__PURE__ */ new Date(), this._handled = !1, this._viewKey = t;
  }
  /**
   * Get the ViewKey this event is associated with.
   */
  get viewKey() {
    return this._viewKey;
  }
  /**
   * Gets the handled state of the event
   * @returns whether the event has been handled
   */
  getHandled() {
    return this._handled;
  }
  /**
   * Sets the handled state of the event. When an event has been handled it will not propagate any further
   * @param handled Indicates whether this event has been handled.
   */
  setHandled(t) {
    this._handled = t;
  }
  /**
   * Gets the Date this event occurred
   * @returns the event Date
   */
  getDate() {
    return this._date;
  }
}
class Lf extends yd {
  /** @hidden */
  constructor(t, e, i, n) {
    super(n), this._keyCode = t, this._eventType = i;
  }
  /**
   * gets the key code
   * @returns the key code of the event
   */
  getKeyCode() {
    return this._keyCode;
  }
  /**
   * gets the event type
   * @returns the type of key event
   */
  getEventType() {
    return this._eventType;
  }
}
class vg extends yd {
  /** @hidden */
  constructor(t, e, i, n, r) {
    super(r), this._position = new X(t, e), this._modifiers = i, this._inputType = n;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * gets the state of the shift key
   * @returns whether the shift key was down when this event was generated
   */
  shiftDown() {
    return (this._modifiers & Mi.Shift) === Mi.Shift;
  }
  /**
   * gets the state of the alt key
   * @returns whether the alt key was down when this event was generated
   */
  altDown() {
    return (this._modifiers & Mi.Alt) === Mi.Alt;
  }
  /**
   * gets the state of the control key
   * @returns whether the control key was down when this event was generated
   */
  controlDown() {
    return (this._modifiers & Mi.Control) === Mi.Control;
  }
  /**
   * gets the state of the command key
   * @returns whether the command key was down when this event was generated
   */
  commandDown() {
    return (this._modifiers & Mi.Command) === Mi.Command;
  }
  /**
   * gets the event type
   * @returns the type of mouse event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the event modifiers
   * @returns bitwise combination of KeyModifiers
   */
  getModifiers() {
    return this._modifiers;
  }
}
class Gr extends vg {
  /**
   * Mouse Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param button mouse button associated with this event
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   */
  constructor(t, e, i, n, r, o, l) {
    super(t, e, r, o, l), this._button = i, this._buttons = n;
  }
  /**
   * gets the mouse button associated with this event
   * @returns the mouse button for this event
   */
  getButton() {
    return this._button;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
class z_ extends vg {
  /**
   * Mousewheel Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param wheelDelta the direction the mouse wheel moved
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   * @hidden
   */
  constructor(t, e, i, n, r, o, l) {
    super(t, e, r, o, l), this._wheelDelta = i, this._buttons = n;
  }
  /**
   * Gets the wheel delta for this event. A positive value indicates that the wheel was scrolled Up, while a negative value indicated the wheel was scrolled down.
   * @returns Wheel dela value
   */
  getWheelDelta() {
    return this._wheelDelta;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
var ro = /* @__PURE__ */ ((s) => (s[s.Dec = 0] = "Dec", s[s.Inc = 1] = "Inc", s))(ro || {});
function Ff(s, t) {
  if (t.getNodeType(s) === Le.BodyInstance) {
    let e = s;
    for (; e !== null; ) {
      if (t.getNodeGenericId(e) !== null)
        return e;
      e = t.getNodeParent(e);
    }
  }
  return s;
}
class ed {
  constructor(t, e, i) {
    this.faceItem = t, this.lineItem = e, this.pointItem = i;
  }
  /**
   * Returns the most relevant selection item for the provided selection mask.
   * The priority used by this method is points -> lines -> faces.
   * For example, if your selection mask was Faces | Lines and this item contained and all fields were populated, this method would return its lineItem.
   * @param mask a selection mask used to indicate the relevancy of the item to retrieve.
   * @returns the most relevant selection item if one exists.  If no relevant item is found, null is returned.
   */
  fetchMostRelevant(t) {
    return this.pointItem !== null && (t & Pe.Point) !== 0 ? this.pointItem : this.lineItem !== null && (t & Pe.Line) !== 0 ? this.lineItem : this.faceItem !== null && (t & Pe.Face) !== 0 ? this.faceItem : null;
  }
}
class Ah {
  /** @hidden */
  constructor(t, e, i, n, r, o, l) {
    this._position = t.copy(), this._normal = e.copy(), this._elementIndex = i, this._elementBits = r, this._bounding = o.copy(), this._overlayIndex = n, this._isProximityFace = l;
  }
  /**
   * Returns whether or not this face entity was selected by proximity or was instead selected dead-on.
   * @returns True if this face entity was selected by proximity and false otherwise.
   */
  isProximityFace() {
    return this._isProximityFace;
  }
  /**
   * Returns whether or not this face entity is capping geometry or not.
   * @returns True if this face entity is capping geometry and false otherwise.
   */
  isCappingGeometry() {
    return this._elementIndex === -1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      normal: this._normal.toJson(),
      cadFaceIndex: this._elementIndex,
      cadFaceBits: this._elementBits,
      bounding: this._bounding.toJson(),
      overlayIndex: this._overlayIndex,
      isProximityFace: this._isProximityFace
    };
  }
  /**
   * Creates a new [[FaceEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = m.fromJson(e.position), n = m.fromJson(e.normal), r = wn.fromJson(e.bounding), o = e.overlayIndex, l = e.isProximityFace === !0;
    return new Ah(
      i,
      n,
      e.cadFaceIndex,
      o,
      e.cadFaceBits,
      r,
      l
    );
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the face normal for the selection Point.
   * @returns Face normal for the selection position if it can be determined.
   */
  getNormal() {
    return this._normal.copy();
  }
  /**
   * Gets the cad face index for the selection Point.
   * @returns The index for the cad face.
   */
  getCadFaceIndex() {
    return this._elementIndex;
  }
  /**
   * Gets the cad face bits for the selection Point.
   * @returns The bits set on the cad face.
   */
  getCadFaceBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the face entity
   * @returns Bounding box for the face entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class yc {
  constructor(t) {
    this._handle = t;
  }
}
class Th {
  /** @hidden */
  constructor(t, e, i, n, r, o, l) {
    if (this._lineSegmentVertices = [], this._elementIndex = t, this._elementBits = l, this._position = e.copy(), this._bounding = r.copy(), this._overlayIndex = o, i) {
      if (n >= 0) {
        const h = 3 * n;
        this._bestLineSegmentVertexIndex = new m(
          i[h],
          i[h + 1],
          i[h + 2]
        );
      }
      this._lineSegmentVertices.push(
        new m(i[0], i[1], i[2])
      );
      for (let h = 3; h < i.length; h += 6)
        this._lineSegmentVertices.push(
          new m(i[h], i[h + 1], i[h + 2])
        );
    }
  }
  isCappingGeometry() {
    return this._elementIndex < 0;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._lineSegmentVertices) t.push(e.toJson());
    return {
      lineId: this._elementIndex,
      lineBits: this._elementBits,
      position: this._position.toJson(),
      linePoints: t,
      bounding: this._bounding.copy(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Creates a new [[LineEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = m.fromJson(e.position), n = wn.fromJson(e.bounding), r = e.overlayIndex, o = new Th(e.lineId, i, null, -1, n, r, 0);
    for (const l of e.linePoints) {
      const h = m.fromJson(l);
      o._lineSegmentVertices.push(h);
    }
    return o;
  }
  /**
   * Gets the line identifier
   * @returns the identifier of the line that was selected
   */
  getLineId() {
    return this._elementIndex;
  }
  /**
   * Gets the closest point on the selected line
   * @returns the closest point on the line
   */
  getPosition() {
    return this._position.copy();
  }
  getPoints() {
    return this._lineSegmentVertices;
  }
  /**
   * Returns the vertex of the line that is closest to the selection
   * point.
   *
   * Clipped vertices are skipped. If the vertex is occluded, then
   * `null` is returned.
   */
  getBestVertex() {
    return this._bestLineSegmentVertexIndex ? this._bestLineSegmentVertexIndex.copy() : null;
  }
  /**
   * Gets the kine bits for the selection Point.
   * @returns The bits set on the line/edge.
   */
  getLineBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the line entity
   * @returns Bounding box for the line entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class H_ {
  constructor() {
    this.none = 0, this.face = 0, this.line = 0, this.point = 0, this.part = 0;
  }
  update(t, e) {
    switch (t.getSelectionType()) {
      case On.None:
        e === ro.Dec ? --this.none : ++this.none;
        break;
      case On.Face:
        e === ro.Dec ? --this.face : ++this.face;
        break;
      case On.Line:
        e === ro.Dec ? --this.line : ++this.line;
        break;
      case On.Point:
        e === ro.Dec ? --this.point : ++this.point;
        break;
      case On.Part:
        e === ro.Dec ? --this.part : ++this.part;
        break;
    }
  }
  sum() {
    return this.none + this.face + this.line + this.point + this.part;
  }
}
class Dh {
  /** @hidden */
  constructor(t, e, i, n) {
    this._position = t.copy(), this._elementIndex = e, this._overlayIndex = i, this._elementBits = n;
  }
  /**
   * Creates a new [[PointEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = m.fromJson(e.position), n = e.overlayIndex;
    return new Dh(i, e.pointId, e.pointBits, n);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      pointId: this._elementIndex,
      pointBits: this._elementBits,
      position: this._position.toJson(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the cad bits for the selection Point.
   * @returns The bits set on the point.
   */
  getPointBits() {
    return this._elementBits;
  }
  /**
   * Gets the point identifier
   * @returns the identifier of the point that was selected
   */
  getPointId() {
    return this._elementIndex;
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class yi {
  /** @hidden */
  constructor(t = null, e = null, i = null, n = null, r = null) {
    this._nodeId = t, this._inclusionKey = e, this._faceEntity = i, this._lineEntity = n, this._pointEntity = r;
  }
  static create(t, e, i, n, r) {
    return new yi(t, e, i, n, r);
  }
  getSelectionType() {
    return this._nodeId === null ? On.None : this._faceEntity !== null ? On.Face : this._lineEntity !== null ? On.Line : this._pointEntity !== null ? On.Point : On.Part;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      nodeId: this._nodeId,
      includeId: this._inclusionKey,
      faceEntity: this._faceEntity ? this._faceEntity.toJson() : null,
      lineEntity: this._lineEntity ? this._lineEntity.toJson() : null,
      pointEntity: this._pointEntity ? this._pointEntity.toJson() : null
    };
  }
  /** @hidden */
  static _fromJson(t) {
    const e = t;
    return new yi(
      e.nodeId,
      e.includeId,
      e.faceEntity ? Ah.fromJson(e.faceEntity) : null,
      e.lineEntity ? Th.fromJson(e.lineEntity) : null,
      e.pointEntity ? Dh.fromJson(e.pointEntity) : null
    );
  }
  /**
   * Gets the face entity for this selection.
   * @returns the face entity if one was selected, otherwise null
   */
  getFaceEntity() {
    return this._faceEntity;
  }
  /**
   * Gets the line entity for this selection.
   * @returns the line entity if one was selected, otherwise null
   */
  getLineEntity() {
    return this._lineEntity;
  }
  /**
   * Gets the point entity for this selection.
   * @returns the point entity if one was selected, otherwise null
   */
  getPointEntity() {
    return this._pointEntity;
  }
  /**
   * Gets the part id for this selection.
   * @returns the part id associated with this selection item
   */
  getNodeId() {
    return this._nodeId ?? gg;
  }
  /**
   * Gets the include id for this selection.
   * @returns the inclusion key associated with this selection item
   */
  getInclusionKey() {
    return this._inclusionKey;
  }
  /**
   * Convenience method for getting the world space position of the selection point.
   * [[SelectionItem]]s with a type of [[SelectionType.Part]] will not have a position and null will be returned.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._faceEntity !== null ? this._faceEntity.getPosition() : this._lineEntity !== null ? this._lineEntity.getPosition() : this._pointEntity !== null ? this._pointEntity.getPosition() : null;
  }
  /**
   * Gets the overlay index for this selection.
   * @returns the overlay index associated with this selection item
   */
  overlayIndex() {
    return this._faceEntity ? this._faceEntity.overlayIndex() : this._lineEntity ? this._lineEntity.overlayIndex() : this._pointEntity ? this._pointEntity.overlayIndex() : null;
  }
  /** @hidden */
  _setNodeId(t) {
    this._nodeId = t;
  }
  /**
   * Determines if two selection items are equal.
   * @param selectionItem The selection item to test against.
   * @returns whether or not the two items are equal.
   */
  equals(t) {
    return this._nodeId !== t._nodeId || this.getSelectionType() !== t.getSelectionType() ? !1 : this._faceEntity && t._faceEntity ? this._faceEntity.getCadFaceIndex() === t._faceEntity.getCadFaceIndex() : this._lineEntity && t._lineEntity ? this._lineEntity.getLineId() === t._lineEntity.getLineId() : this._pointEntity && t._pointEntity ? this._pointEntity.getPointId() === t._pointEntity.getPointId() : !0;
  }
  /** @hidden */
  _hash(t) {
    let e = this._nodeId !== null ? this._nodeId.toString(36) : "";
    return t || (e += `;${this.getSelectionType()};`, this._faceEntity && (e += this._faceEntity.getCadFaceIndex().toString(36)), e += ";", this._lineEntity && (e += this._lineEntity.getLineId().toString(36)), e += ";", this._pointEntity && (e += this._pointEntity.getPointId().toString(36))), e;
  }
  /**
   * @returns true if the object has the fields required for an [[EntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isEntitySelection() {
    return this._faceEntity !== null || this._lineEntity !== null || this._pointEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeSelection() {
    return this._nodeId !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeEntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeEntitySelection() {
    return this._nodeId !== null && this.isEntitySelection();
  }
  /**
   * @returns true if the object has the fields required for a [[FaceSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isFaceSelection() {
    return this._nodeId !== null && this._faceEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[LineSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isLineSelection() {
    return this._nodeId !== null && this._lineEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[PointSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isPointSelection() {
    return this._nodeId !== null && this._pointEntity !== null;
  }
}
class U_ {
  constructor(t) {
    this.futureItemHash = null, this.pastItemHash = t;
  }
}
class wd {
  /** @hidden */
  constructor(t, e, i, n, r) {
    this._selectedItemsPruned = /* @__PURE__ */ new Map(), this._selectedItemsFull = /* @__PURE__ */ new Map(), this._selectedNodeCounts = /* @__PURE__ */ new Map(), this._temporalLinks = /* @__PURE__ */ new Map(), this._oldestItemHash = null, this._newestItemHash = null, this._selectedLayers = /* @__PURE__ */ new Set(), this._selectedTypes = /* @__PURE__ */ new Set(), this._nodeSelectionColor = new yt(255, 255, 0), this._nodeSelectionOutlineColor = new yt(255, 255, 0), this._elementSelectionColor = yt.red(), this._elementSelectionOutlineColor = yt.red(), this._nodeHighlightMode = Dr.HighlightAndOutline, this._nodeElementHighlightMode = Dr.HighlightAndOutline, this._highlightNodeSelection = !0, this._highlightFaceElementSelection = !0, this._highlightLineElementSelection = !0, this._highlightPointElementSelection = !0, this._selectParentIfSelected = !0, this._pruneSelectionDescendants = !0, this._ignoreEntityWhenTogglingChildSelection = !0, this._singleEntityToggleMode = !1, this._suppressImplicitRemovalCallback = !1, this._selectionFilter = null, this._incrementalBlacklistedInstanceNodes = /* @__PURE__ */ new Set(), this._viewer = t, this._engine = i, this._model = n, this._modelStructure = r, this._callbackManager = e, this._callbackManager.bind({
      _subtreeLoaded: (o) => {
        for (const l of o)
          this._onSubtreeLoaded(l);
        return Promise.resolve();
      },
      _drawContextCreated: (o) => {
        this._updateHighlightingMode();
      }
    });
  }
  /** * @hidden */
  _init() {
    this._updateHighlightingMode();
    for (const t of this._viewer.views)
      this._engine.setHighlightColorizeCompression(t.id, 0.7);
    this._callbackManager.bind({
      _drawContextCreated: (t) => {
        this._engine.setHighlightColorizeCompression(t, 0.7);
      }
    });
  }
  /**
   * This allows manipulating the selected NodeId.
   * To reset the filter, set it to null.
   * @param selectionFilter function that manipulates the selected NodeId.
   */
  setSelectionFilter(t) {
    this._selectionFilter = t;
  }
  /**
   * @returns [[SelectionFilter]] function or null if none is set.
   */
  getSelectionFilter() {
    return this._selectionFilter;
  }
  /**
   * Enables / disables descendant pruning and clears the current selection set.  When enabled, a parent and child will not be present in the same selection set.  This behavior is enabled by default.
   */
  setPruneSelectionDescendants(t) {
    this._pruneSelectionDescendants = t, this.clear();
  }
  /**
   * Gets whether descendant pruning is enabled.
   * See also: [[setPruneSelectionDescendants]]
   */
  getPruneSelectionDescendants() {
    return this._pruneSelectionDescendants;
  }
  /**
   * Enables / disables automatic parent selection.  When enabled, if a selected part is selected again, its parent will be selected.  This behavior is enabled by default.
   */
  setSelectParentIfSelected(t) {
    this._selectParentIfSelected = t;
  }
  /**
   * Gets whether automatic parent selection is enabled.
   * See also: [[setSelectParentIfSelected]]
   */
  getSelectParentIfSelected() {
    return this._selectParentIfSelected;
  }
  /**
   * Enables / disables ignore entity when toggling child selection mode.
   *
   * When enabled, a [[NodeSelectionItem]] that has a selected ancestor may only be toggled if it does not contain an entity selection.
   * A selection item without an entity selection is usually generated from selecting a node via a model tree control.
   * A selection item containing an entity selection is usually generated as a result of a viewport picking operation.
   *
   * This behavior is enabled by default.
   * See Also: [[toggle]]
   */
  setIgnoreEntityWhenTogglingChildSelection(t) {
    this._ignoreEntityWhenTogglingChildSelection = t;
  }
  /**
   * Gets whether ignore entity when toggling child selection mode is enabled.
   * See also: [[setIgnoreEntityWhenTogglingChildSelection]]
   */
  getIgnoreEntityWhenTogglingChildSelection() {
    return this._ignoreEntityWhenTogglingChildSelection;
  }
  /**
   * Enables / disables single entity toggle mode.
   *
   * When enabled, limits the selection set to containing only one entity selection for each node id.
   * Toggling with an entity selection that has the same node id as a [[NodeSelectionItem]]
   * already in the selection set will remove that item from the selection set.
   *
   * This behavior is disabled by default.
   * See Also: [[toggle]]
   */
  setSingleEntityToggleModeEnabled(t) {
    this._singleEntityToggleMode = t, this.clear();
  }
  /**
   * Gets whether single entity toggle mode is enabled.
   * See also: [[setSingleEntityToggleModeEnabled]]
   */
  getSingleEntityToggleModeEnabled() {
    return this._singleEntityToggleMode;
  }
  /**
   * Sets whether to generate selectionArray callbacks with implicitly removed nodes.
   *
   * For example, consider the case where you have a parent node that has a multiple child nodes.
   * Normally, if the parent begins selected and then a child is removed from the selection set
   * there will be two selectionArray callbacks generated. The first will for the removal of the
   * parent node. The second wil be for the addition of all of it's children except the one that was
   * initially removed.
   *
   * When this behavior is enabled only a single selectionArray callback will be generated for the
   * child node that was removed.
   *
   * This behavior is disabled by default.
   */
  setSuppressImplicitRemovalCallback(t) {
    this._suppressImplicitRemovalCallback = t;
  }
  /**
   * Gets whether implicit removal callbacks are being suppressed
   * See also: [[setSuppressImplicitRemovalCallback]]
   */
  getSuppressImplicitRemovalCallback() {
    return this._suppressImplicitRemovalCallback;
  }
  /**
   * Performs a selection operation from the given position on the canvas. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromPoint(t, e, i = In.Set, n = this._viewer.view) {
    const r = await n.pickFromPoint(t, e);
    this._onSelectionItem(r, i);
  }
  /**
   * Performs a selection operation from the given position on the canvas. All candidate entities are selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromPoint(t, e, i = In.Set, n = this._viewer.view) {
    const r = await n.pickAllFromPoint(t, e);
    this._onSelectionItems(r, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromRay(t, e, i = In.Set, n = this._viewer.view) {
    const r = await n.pickFromRay(t, e);
    this._onSelectionItem(r, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromRay(t, e, i = In.Set, n = this._viewer.view) {
    const r = await n.pickAllFromRay(t, e);
    this._onSelectionItems(r, i);
  }
  _onSelectionItem(t, e) {
    t.isNodeEntitySelection() ? this._processSelection(t, e) : this._triggerNullSelection();
  }
  _onSelectionItems(t, e) {
    if (e === In.Set && this.clear(!1), t.length === 0) {
      this._triggerNullSelection();
      return;
    }
    switch (e) {
      case In.Add:
      case In.Set:
        this.add(t);
        break;
      case In.Toggle:
        for (const i of t)
          this.toggle(i);
        break;
      default:
        qr();
    }
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coordinate in css pixel space for the selection window.
   * @param areaCssMax The maximum coordinate in css pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @param view The view to use when projecting the point into the scene.
   * @returns The handle for the selection context.
   */
  beginScreenSelectByArea(t, e, i, n = this._viewer.view) {
    return n.beginScreenSelectByArea(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in css pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in css pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @param view The view to use when projecting the point into the scene.
   * @returns The handle for the selection context.
   */
  beginRayDrillSelection(t, e, i, n = this._viewer.view) {
    return n.beginRayDrillSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for ordering returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginConvexPolyhedronSelection(t, e, i) {
    return this._viewer.view.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginSphereSelection(t, e, i) {
    return this._viewer.view.beginSphereSelection(t, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._callbackManager.trigger("incrementalSelectionEnd"), this._viewer.view.endIncrementalSelection(t), Promise.resolve();
  }
  /**
   * Adds the next batch of instances selected by the supplied selection
   * context to the selection set.
   *
   * @param handle The handle to an active area selection context.
   * @param predicate An optional function that returns `true` if a given
   * [[NodeSelectionItem]] should be added to the selection set. If
   * `false` is returned, the item will not be added.
   *
   * @returns `true` if there are possibly more items to select and
   * `false` if not.
   */
  async advanceIncrementalSelection(t, e = null) {
    let i = await this._viewer.view.advanceIncrementalSelection(t);
    if (i === null)
      return !1;
    if (e !== null) {
      const n = await Promise.all(i.map(e));
      i = i.filter((r, o) => n[o]);
    }
    return this.add(i), !0;
  }
  isSelected(t) {
    return this.contains(t) ? !0 : t.isNodeSelection() ? this._findAncestor(t) !== null : !1;
  }
  /**
   * Checks whether a node, or its parents, appear in the selection set or not.
   * Note: for the purposes of this function element selections on a node
   * are considered the same as node selection.
   * @param nodeId Node to check for
   * @returns `true` if the node or its parents appear in the selection set. `false` otherwise
   */
  isNodeSelected(t) {
    for (const i of this.getResults())
      if (i.getNodeId() === t)
        return !0;
    const e = yi.create(t);
    return this._findAncestor(e) !== null;
  }
  contains(t) {
    return this._selectedItemsPruned.has(t._hash(this._singleEntityToggleMode));
  }
  /**
   * Checks if the parent of a selection item is in the selection set.
   * @param selectionItem
   * @returns parent selection item, or null if not found
   */
  containsParent(t) {
    return this._findAncestor(t);
  }
  _findAncestor(t) {
    if (this._selectedItemsPruned.size > 0)
      for (; ; ) {
        const e = this._model.getNodeParent(t.getNodeId());
        if (e === null)
          return null;
        t = yi.create(e);
        const i = t._hash(this._singleEntityToggleMode);
        if (this._selectedItemsPruned.has(i))
          return t;
      }
    return null;
  }
  /**
   * Adds all items in a layer to the selection set.
   * @param layerName
   * @param selectionMode
   */
  selectLayer(t, e) {
    e === In.Set && this.clear();
    const i = [], n = this._model.getLayerIdsFromName(t);
    if (n !== null)
      for (const o of n) {
        const l = this._model.getNodesFromLayer(o, !0);
        if (l !== null)
          for (const h of l)
            i.push(yi.create(h));
      }
    const r = this._selectedLayers.has(t);
    e === In.Toggle && r ? this.remove(i) : (this.add(i), this._selectedLayers.add(t));
  }
  /**
   * Gets all selected layers.
   */
  getSelectedLayers() {
    const t = [];
    return this._selectedLayers.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Adds all items with an IFC type to the selection set.
   * @param genericType
   */
  selectType(t, e) {
    e === In.Set && this.clear();
    const i = [], n = this._model.getNodesByGenericType(t);
    n !== null && n.forEach((o) => {
      i.push(yi.create(o));
    });
    const r = this._selectedTypes.has(t);
    if (e === In.Toggle && r)
      for (const o of i)
        this.remove(o);
    else
      this.add(i), this._selectedTypes.add(t);
  }
  /**
   * Gets all selected IFC types.
   */
  getSelectedTypes() {
    const t = [];
    return this._selectedTypes.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Selects a node with the given Id.
   * @param nodeId nodeId of the node to select. Pass null to clear the selection.
   * @returns the selection type of this operation.
   */
  selectNode(t, e = In.Set) {
    if (t !== null && this._modelStructure.isIdValid(t)) {
      const i = yi.create(t);
      return this._processSelection(i, e), i.getSelectionType();
    } else
      return this._processSelection(null, e), On.None;
  }
  _triggerNullSelection() {
    this._callbackManager.trigger("selectionArray", [], !1);
  }
  _isInAxisOverlay(t) {
    const i = t.getFaceEntity();
    if (i)
      return i.overlayIndex() === 1;
    const n = t.getLineEntity();
    if (n)
      return n.overlayIndex() === 1;
    const r = t.getPointEntity();
    return r ? r.overlayIndex() === 1 : !1;
  }
  _getNodeCounts(t) {
    const e = t.getNodeId();
    let i = this._selectedNodeCounts.get(e);
    return i || (i = new H_(), this._selectedNodeCounts.set(e, i)), i;
  }
  _addToFull(t, e) {
    for (; this._selectedItemsFull.set(e, t); ) {
      const i = this._model.getNodeParent(t.getNodeId());
      if (i === null)
        return;
      t = yi.create(i), e = t._hash(this._singleEntityToggleMode);
    }
  }
  _addItems(t, e) {
    const i = t.length;
    if (i === 0)
      return;
    this._callbackManager.trigger("incrementalSelectionBatchBegin");
    const n = [];
    for (let r = 0; r < i; ++r) {
      const o = this._filterItem(t[r]);
      if (o !== null && this._addImpl(o, o._hash(this._singleEntityToggleMode))) {
        const l = new Br(o);
        n.push(l);
      }
    }
    n.length === 0 && !e ? this._triggerNullSelection() : e || this._callbackManager.trigger("selectionArray", n, !1), this._callbackManager.trigger("incrementalSelectionBatchEnd");
  }
  _addItem(t, e) {
    const i = this._filterItem(t);
    if (i !== null && this._addImpl(i, i._hash(this._singleEntityToggleMode))) {
      const n = new Br(i);
      e || this._callbackManager.trigger("selectionArray", [n], !1);
    } else
      this._triggerNullSelection();
  }
  /**
   * Manually adds an item or array of items to the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or selectionItem array that will be added to the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  add(t, e = !1) {
    if (t === null) {
      e || this._triggerNullSelection();
      return;
    }
    Array.isArray(t) ? this._addItems(t, e) : this._addItem(t, e);
  }
  _filterItem(t) {
    if (this._selectionFilter === null)
      return t;
    const e = t.getNodeId(), i = this._selectionFilter(e, this._model);
    return i === e ? t : i === null ? null : yi.create(i);
  }
  _addImpl(t, e) {
    if (t.getSelectionType() === On.None)
      return !1;
    if (this._isInAxisOverlay(t))
      return !0;
    if (this._selectedItemsPruned.has(e))
      return !1;
    if (this._pruneSelectionDescendants) {
      if (this._findAncestor(t) !== null)
        return !1;
      this._removeDescendants(t);
    }
    this._selectedItemsPruned.set(e, t), this._addToFull(t, e), this._getNodeCounts(t).update(t, ro.Inc);
    const i = this._newestItemHash;
    if (this._newestItemHash = e, this._oldestItemHash || (this._oldestItemHash = e), i !== null) {
      const r = this._temporalLinks.get(i);
      r && (r.futureItemHash = e);
    }
    const n = new U_(i);
    if (this._temporalLinks.set(e, n), this._updateItemHighlight(t, !0, !0), this._modelStructure.getType(t.getNodeId()) === Le.Pmi) {
      const r = this._modelStructure.getPmiTopologyReferences(t.getNodeId());
      if (r !== null)
        for (const o of r) {
          const l = o.body.getRuntimeId(), h = o.faceIds;
          for (const f of h) this._model.setNodeFaceHighlighted(l, f, !0);
          const u = o.edgeIds;
          for (const f of u) this._model.setNodeLineHighlighted(l, f, !0);
        }
    }
    return !0;
  }
  _removeUpdateLayers(t) {
    if (this._selectedLayers.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeLayerId(e);
        if (i !== null) {
          const n = this._model.getLayerName(i);
          n !== null && this._selectedLayers.delete(n);
        }
      }
    }
  }
  _removeUpdateTypes(t) {
    if (this._selectedTypes.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeGenericType(e);
        i !== null && this._selectedTypes.delete(i);
      }
    }
  }
  _removeFromFull(t, e) {
    if (this._removeUpdateLayers(t), this._removeUpdateTypes(t), this._selectedItemsFull.delete(e)) {
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const n of i) {
        const r = yi.create(n);
        this._removeFromFull(r, r._hash(this._singleEntityToggleMode));
      }
    }
  }
  _removeItems(t, e) {
    const i = [];
    t.forEach((n) => {
      this._removeImpl(n, n._hash(this._singleEntityToggleMode)) && i.push(new Br(n));
    }), e || this._callbackManager.trigger("selectionArray", i, !0);
  }
  _removeItem(t, e) {
    if (this._removeImpl(t, t._hash(this._singleEntityToggleMode))) {
      const i = new Br(t);
      e || this._callbackManager.trigger("selectionArray", [i], !0);
    }
  }
  /**
   * Manually removes an item or an array of items from the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or an array of selection items that will be removed from the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  remove(t, e = !1) {
    Array.isArray(t) ? this._removeItems(t, e) : this._removeItem(t, e);
  }
  /** hidden */
  _removeImpl(t, e) {
    if (this._singleEntityToggleMode) {
      const l = this._selectedItemsPruned.get(e);
      l && (t = l);
    }
    if (!this._selectedItemsPruned.delete(e))
      return !1;
    this._removeFromFull(t, e);
    const i = this._getNodeCounts(t);
    i.update(t, ro.Dec);
    const n = this._temporalLinks.get(e);
    if (n !== void 0) {
      if (this._temporalLinks.delete(e), n.pastItemHash !== null) {
        const l = this._temporalLinks.get(n.pastItemHash);
        l && (l.futureItemHash = n.futureItemHash);
      }
      if (n.futureItemHash !== null) {
        const l = this._temporalLinks.get(n.futureItemHash);
        l && (l.pastItemHash = n.pastItemHash);
      }
      this._oldestItemHash === e && (this._oldestItemHash = n.futureItemHash), this._newestItemHash === e && (this._newestItemHash = n.pastItemHash);
    }
    let r = !0;
    const o = !1;
    if (i.sum() === 0) {
      r = !1;
      const l = t.getNodeId();
      this._selectedNodeCounts.delete(l);
    }
    return this._updateItemHighlight(t, r, o), !0;
  }
  static _selectionItemIsFromModelBrowser(t) {
    return t.getFaceEntity() === null && t.getLineEntity() === null && t.getPointEntity() === null;
  }
  /**
   * Manually adds or removes an item from the selection set.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will be added or removed from the selection set.
   */
  toggle(t) {
    const e = this._filterItem(t);
    if (e === null)
      return;
    const i = this._findAncestor(e), n = e._hash(this._singleEntityToggleMode);
    if (i !== null) {
      if (wd._selectionItemIsFromModelBrowser(t) ? this._removeImplicit(t, i, this._suppressImplicitRemovalCallback) : this._ignoreEntityWhenTogglingChildSelection || this._removeImplicit(
        yi.create(e.getNodeId()),
        i,
        this._suppressImplicitRemovalCallback
      ), this._suppressImplicitRemovalCallback) {
        const r = new Br(e);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (this._selectedItemsPruned.has(n)) {
      if (this._removeImpl(e, n)) {
        const r = new Br(t);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (e !== null && this._addImpl(e, n)) {
      const r = new Br(e);
      this._callbackManager.trigger("selectionArray", [r], !1);
    }
  }
  /**
   * Manually removes all currently selected items (if any) from the selection set and adds the supplied item.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will become the new selection item.
   */
  set(t) {
    this.clear(!1), this.add(t);
  }
  /**
   * Gets all current selection items.
   * @returns array of all selection items.
   */
  getResults() {
    const t = [];
    return this.each((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Gets a selection at the specified index. The first selected item will be at index 0.
   * @param index index of selection item to get
   * @returns the selection result at the given index.
   */
  getResult(t) {
    const e = this.size();
    if (t < 0 || t >= e)
      return null;
    const i = e - t - 1;
    return t <= i ? this._getItemFromOldest(t) : this._getItemFromNewest(i);
  }
  _getItemFromOldest(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).futureItemHash;
    }
    return null;
  }
  _getItemFromNewest(t) {
    let e = this._newestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).pastItemHash;
    }
    return null;
  }
  /**
   * Gets the least recent selection item.
   * @returns the least recently selected item (if any).
   */
  getFirst() {
    return this._oldestItemHash !== null && this._selectedItemsPruned.get(this._oldestItemHash) || null;
  }
  /**
   * Gets the most recent selection item.
   * @returns the most recently selected item (if any).
   */
  getLast() {
    return this._newestItemHash !== null && this._selectedItemsPruned.get(this._newestItemHash) || null;
  }
  /**
   * Gets the number of selection items.
   * @returns the number of selected items.
   */
  size() {
    return this._selectedItemsPruned.size;
  }
  /**
   * Iterates over all selection items.
   * The function passed in will be called once for every selection item and will receive the item as its parameter.
   * @param func a function to be called for every selection item.
   */
  each(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      const i = this._selectedItemsPruned.get(e);
      t(i), e = this._temporalLinks.get(e).futureItemHash;
    }
  }
  /**
   * Removes all items from the selection set.
   * @param triggerCallback triggers a null selection callback when true.
   */
  clear(t = !0) {
    this._selectedLayers.clear(), this._selectedTypes.clear(), this._clearHighlight(), this._selectedItemsPruned.clear(), this._selectedItemsFull.clear(), this._selectedNodeCounts.clear(), this._temporalLinks.clear(), this._oldestItemHash = null, this._newestItemHash = null, t && this._triggerNullSelection();
  }
  /**
   * Sets the color to be used when selecting nodes.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the selected node.
   */
  setNodeSelectionColor(t) {
    return this._setNodeSelectionColor(t), Promise.resolve();
  }
  _setNodeSelectionColor(t) {
    this._nodeSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used when selecting nodes.
   * @returns the color that is applied to a selected node.
   */
  getNodeSelectionColor() {
    return this._nodeSelectionColor.copy();
  }
  /**
   * Sets color for the node selection outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the node selection outline.
   */
  setNodeSelectionOutlineColor(t) {
    return this._setNodeSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeSelectionOutlineColor(t) {
    this._nodeSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used for outlining the node selection.
   * @returns the color for node selection outline.
   */
  getNodeSelectionOutlineColor() {
    return this._nodeSelectionOutlineColor.copy();
  }
  /**
   * Sets the color to use for node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to selected node elements.
   */
  setNodeElementSelectionColor(t) {
    return this._setNodeElementSelectionColor(t), Promise.resolve();
  }
  _setNodeElementSelectionColor(t) {
    this._elementSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for face and line selection.
   * @returns the color used for face and line selection.
   */
  getNodeElementSelectionColor() {
    return this._elementSelectionColor.copy();
  }
  /**
   * Gets the color to use for outlining node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color used for outlining face and line selection.
   */
  setNodeElementSelectionOutlineColor(t) {
    return this._setNodeElementSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeElementSelectionOutlineColor(t) {
    this._elementSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for outlining face and line selection.
   * @returns color the color used for outlining face and line selection.
   */
  getNodeElementSelectionOutlineColor() {
    return this._elementSelectionOutlineColor.copy();
  }
  /**
   * Gets whether face elements will be highlighted on selection.
   * @returns boolean the current value for face element selection highlighting.
   */
  getHighlightFaceElementSelection() {
    return this._highlightFaceElementSelection;
  }
  /**
   * Sets whether face elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight face elements associated with a selection item.
   * @param highlightFaceElementSelection value indicating whether selected face elements should be highlighted.
   */
  setHighlightFaceElementSelection(t) {
    return this._highlightFaceElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the highlighting mode for selected nodes. The default behavior is to highlight the node and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeSelectionHighlightMode(t) {
    return this._setNodeSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeSelectionHighlightMode(t) {
    this._nodeHighlightMode = t, this._updateHighlightingMode();
  }
  /**
   * Gets the highlighting mode for selected nodes.
   * @returns the current
   */
  getNodeSelectionHighlightMode() {
    return this._nodeHighlightMode;
  }
  /**
   * Sets the highlighting mode for selected node elements.
   * The default behavior is to highlight the node element and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeElementSelectionHighlightMode(t) {
    return this._setNodeElementSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeElementSelectionHighlightMode(t) {
    this._nodeElementHighlightMode = t, this._updateHighlightingMode();
  }
  getNodeElementSelectionHighlightMode() {
    return this._nodeElementHighlightMode;
  }
  /**
   * Sets whether nodes should be highlighted when a selection occurs.
   * By default, the system will automatically highlight the node associated with a selection item.
   * @param highlightNodeSelection value indicating whether selected nodes should be highlighted.
   */
  setHighlightNodeSelection(t) {
    return this._highlightNodeSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Gets whether nodes will be highlighted on selection.
   * @returns the current value for node selection highlighting.
   */
  getHighlightNodeSelection() {
    return this._highlightNodeSelection;
  }
  /**
   * Gets whether line elements will be highlighted on selection.
   * @returns boolean the current value for line element selection highlighting.
   */
  getHighlightLineElementSelection() {
    return this._highlightLineElementSelection;
  }
  /**
   * Gets whether point elements will be highlighted on selection.
   * @returns boolean the current value for point element selection highlighting.
   */
  getHighlightPointElementSelection() {
    return this._highlightPointElementSelection;
  }
  /**
   * Sets whether line elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight line elements associated with a selection item.
   * @param highlightLineElementSelection value indicating whether selected line elements should be highlighted.
   */
  setHighlightLineElementSelection(t) {
    return this._highlightLineElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets whether point elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight point elements associated with a selection item.
   * @param highlightPointElementSelection value indicating whether selected point elements should be highlighted.
   */
  setHighlightPointElementSelection(t) {
    return this._highlightPointElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the pick tolerance in pixels for line and point picking.
   * If a line or point is within this pixel tolerance of the click point,
   * it will be prioritized over the face at the click position.
   *
   * The default value is 20.
   * @param Pick Tolerance value in pixels
   */
  setPickTolerance(t) {
    this._engine.setPickTolerance(t);
  }
  /**
   * Gets the pick tolerance in pixels for line and point picking.
   *
   * The default value is 20.
   * @returns number Pick tolerance value in pixels
   */
  getPickTolerance() {
    return this._engine.getPickTolerance();
  }
  /**
   * Exports selection objects so that they may be loaded back into the the system at a later time using loadSelectionData.
   * @returns exported selection data.
   */
  exportSelectionData() {
    const t = [], e = this.getResults();
    for (const i of e)
      t.push(i.toJson());
    return t;
  }
  /**
   * Loads serialized selection items exported using [[exportSelectionData]] back into the [[SelectionManager]].
   * The current selection will be cleared. A selection event will be triggered for each loaded item.
   * This method should not be called before the [[CallbackMap.modelStructureReady]] callback has been triggered.
   * @param data data to be imported in the form of a JavaScript object or JSON string
   */
  loadSelectionData(t) {
    if (this.clear(!1), typeof t == "string" && (t = JSON.parse(t), !Array.isArray(t)))
      throw new Rs("Expected JSON depicting an Array.");
    const e = [];
    for (const i of t) {
      const n = yi._fromJson(i);
      n.isNodeSelection() && e.push(n);
    }
    this.add(e);
  }
  _pathToParent(t, e) {
    const i = [];
    for (; !t.equals(e); ) {
      i.push(t);
      const n = this._model.getNodeParent(t.getNodeId());
      if (n === null)
        break;
      t = yi.create(n);
    }
    return i;
  }
  _removeImplicit(t, e, i) {
    const n = this._pathToParent(t, e), r = (u) => {
      for (const f of n)
        if (u.equals(f))
          return !0;
      return !1;
    };
    let o = e;
    const l = [t], h = [];
    for (; n.length > 0; ) {
      l.push(o);
      const u = this._model.getNodeChildren(o.getNodeId());
      for (const f of u) {
        const g = yi.create(f);
        r(g) || h.push(g);
      }
      o = n.pop();
    }
    console.assert(t === o), this.remove(l, i), this.add(h, i);
  }
  _removeDescendants(t) {
    const e = this._model.getNodeChildren(t.getNodeId());
    for (const i of e) {
      const n = yi.create(i);
      this._removeDescendantsRecursive(n);
    }
  }
  _removeDescendantsRecursive(t) {
    const e = t._hash(this._singleEntityToggleMode);
    if (this._selectedItemsFull.delete(e)) {
      this._removeImpl(t, e);
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const n of i) {
        const r = yi.create(n);
        this._removeDescendantsRecursive(r);
      }
    }
  }
  _processSelection(t, e) {
    switch (e) {
      case In.Add:
        this.add(t);
        break;
      case In.Set:
        this.set(t);
        break;
      case In.Toggle:
        t !== null && this.toggle(t);
        break;
    }
  }
  _clearHighlight() {
    this._selectedItemsPruned.size > 0 && this._engine.clearHighlight();
  }
  _updateHighlight() {
    this._clearHighlight(), this._selectedItemsPruned.forEach((t) => {
      t && this._updateItemHighlight(t, !0, !0);
    }), this._highlightNodeSelection && this._model.setNodesHighlighted([], !0);
  }
  _updateItemHighlight(t, e, i) {
    const n = t.getNodeId();
    if (this._highlightNodeSelection && this._model.setNodesHighlighted([n], e), this._model.getNodeType(n) !== Le.Pmi) {
      const r = t.getFaceEntity();
      this._highlightFaceElementSelection && r !== null && !r.isCappingGeometry() && this._model.setNodeFaceHighlighted(n, r.getCadFaceIndex(), i);
      const o = t.getLineEntity();
      this._highlightLineElementSelection && o !== null && !o.isCappingGeometry() && this._model.setNodeLineHighlighted(n, o.getLineId(), i);
      const l = t.getPointEntity();
      this._highlightPointElementSelection && l !== null && this._model.setNodePointHighlighted(n, l.getPointId(), i);
    }
  }
  _updateHighlightingMode() {
    for (const t of this._viewer.views) {
      switch (this._nodeHighlightMode) {
        case Dr.HighlightOnly:
          this._engine.setNodeHighlightColor(t.id, this._nodeSelectionColor, null);
          break;
        case Dr.OutlineOnly:
          this._engine.setNodeHighlightColor(t.id, null, this._nodeSelectionOutlineColor);
          break;
        case Dr.HighlightAndOutline:
          this._engine.setNodeHighlightColor(
            t.id,
            this._nodeSelectionColor,
            this._nodeSelectionOutlineColor
          );
          break;
      }
      switch (this._nodeElementHighlightMode) {
        case Dr.HighlightOnly:
          this._engine.setElementHighlightColor(t.id, this._elementSelectionColor, null);
          break;
        case Dr.OutlineOnly: {
          this._nodeHighlightMode === Dr.OutlineOnly ? this._engine.setElementHighlightColor(
            t.id,
            null,
            this._elementSelectionOutlineColor
          ) : this._engine.setElementHighlightColor(
            t.id,
            this._nodeSelectionColor,
            this._elementSelectionOutlineColor
          );
          break;
        }
        case Dr.HighlightAndOutline:
          this._engine.setElementHighlightColor(
            t.id,
            this._elementSelectionColor,
            this._elementSelectionOutlineColor
          );
          break;
      }
    }
  }
  _onSubtreeLoaded(t) {
    const e = yi.create(t);
    if (this.isSelected(e))
      return this._updateItemHighlight(e, !0, !0);
  }
}
const rS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompositeSelectionItem: ed,
  FaceEntity: Ah,
  IncrementalSelectionId: yc,
  LineEntity: Th,
  NodeCounts: H_,
  Op: ro,
  PointEntity: Dh,
  SelectionItem: yi,
  SelectionManager: wd,
  TemporalLink: U_,
  ifcSelectionFilter: Ff
}, Symbol.toStringTag, { value: "Module" }));
class Br {
  /**
   * Creates a new NodeSelectionEvent
   * @hidden
   */
  constructor(t) {
    this._selection = t;
  }
  /**
   * Gets the result of the selection operator.
   * @returns the result of the selection
   */
  getType() {
    return this._selection ? this._selection.getSelectionType() : On.None;
  }
  /**
   * Gets the selection object.
   * @returns Selection object containing detailed information about the selection
   */
  getSelection() {
    return this._selection;
  }
  /**
   * Creates a no-selection event.
   * @returns Selection event with result set to none.
   * @hidden
   */
  static _createNull() {
    return new Br(yi.create());
  }
}
class Au extends yd {
  /**
   * Touch Event class
   * @param id unique identifier for this touch
   * @param positionX X window position of the touch
   * @param positionY Y window position of the touch
   * @hidden
   */
  constructor(t, e, i, n, r, o) {
    super(o), this._id = t, this._position = new X(e, i), this._buttons = n, this._inputType = r;
  }
  /**
   * gets the id this event
   * @returns the unique identifier for this touch
   */
  getId() {
    return this._id;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position;
  }
  /**
   * gets the event type
   * @returns the type of touch event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
function qb(s) {
  switch (s) {
    case le.MouseDown:
      return !0;
    case le.MouseMove:
      return !0;
    case le.MouseUp:
      return !0;
    case le.Mousewheel:
      return !0;
    case le.TouchStart:
      return !1;
    case le.TouchMove:
      return !1;
    case le.TouchEnd:
      return !1;
    case le.KeyDown:
      return !1;
    case le.KeyUp:
      return !1;
    case le.ViewOrientationChange:
      return !1;
    default:
      return !1;
  }
}
const oS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InputEvent: yd,
  KeyInputEvent: Lf,
  MouseInputEvent: Gr,
  MouseInputEventBase: vg,
  MouseWheelInputEvent: z_,
  NodeSelectionEvent: Br,
  TouchInputEvent: Au,
  isMouseEventType: qb
}, Symbol.toStringTag, { value: "Module" }));
class j_ {
  constructor(t, e) {
    this._markupItems = /* @__PURE__ */ new Map(), this._activeViews = /* @__PURE__ */ new Map(), this._selectedMarkup = null, this._pendingUpdateHandleTimer = new Ko(), this._viewToUpdate = /* @__PURE__ */ new Set(), this._pickTolerance = 0, this._callbackManager = t, this._markupRenderer = e;
  }
  shutdown() {
    this._activeViews.forEach((t, e) => {
      this.setActiveView(e, t);
    }), this._markupItems.forEach((t, e) => {
      t.forEach((i) => {
        i.remove(e);
      });
    }), this._markupItems.clear();
  }
  _updateLater(t, e) {
    this._viewToUpdate.add(t), this._pendingUpdateHandleTimer.isIdle(Nn.BeforeAction) && this._pendingUpdateHandleTimer.set(0, () => {
      this.update();
    }), e !== null && this._pendingUpdateHandleTimer.waitForIdle(Nn.AfterAction).then(() => {
      e.resolve();
    });
  }
  updateLater(t) {
    this._updateLater(t, null);
  }
  _updateAllViews() {
    this._activeViews.forEach((t, e) => {
      this._viewToUpdate.add(e);
    }), this._markupItems.forEach((t, e) => {
      this._viewToUpdate.add(e);
    }), this.update();
  }
  update() {
    this._pendingUpdateHandleTimer.clear(), this._viewToUpdate.forEach((t) => {
      this.renderMarkup(t), this.renderActiveViewMarkup(t);
    }), this._viewToUpdate.clear();
  }
  registerMarkupItem(t, e) {
    let i = this._markupItems.get(e);
    i || (i = /* @__PURE__ */ new Map(), this._markupItems.set(e, i));
    const n = Ms();
    return i.set(n, t), n;
  }
  unregisterMarkupItem(t, e) {
    const i = this._markupItems.get(e);
    if (!i)
      throw new Error("Unable to remove markup from unknown view");
    const n = i.get(t);
    n && (n.remove && n.remove(e), i.delete(t));
  }
  getActiveView(t) {
    const e = this._activeViews.get(t);
    return e !== void 0 ? e : null;
  }
  getViews(t) {
    const e = [];
    return this._activeViews.forEach((i, n) => {
      t === i && e.push(n);
    }), e;
  }
  async setActiveView(t, e) {
    this._selectedMarkup && (this._selectedMarkup.onDeselect(), this._selectedMarkup = null, this._updateAllViews());
    const i = this.getActiveView(t);
    e ? this._activeViews.set(t, e) : this._activeViews.delete(t);
    const n = vi();
    if (this._updateLater(t, n), i !== null && i !== e) {
      const r = i.getMarkup();
      for (const o of r) o.remove(t);
      await n, this._callbackManager.trigger("viewDeactivated", i);
    } else
      await this._pendingUpdateHandleTimer.waitForIdle(Nn.AfterAction);
  }
  markupViewDeleted(t) {
    const e = this.getViews(t);
    for (const i of e)
      this.setActiveView(i, null);
  }
  viewDeleted(t) {
    this._activeViews.delete(t);
    const e = this._markupItems.get(t);
    e && (e.forEach((i) => {
      i.remove(t);
    }), this._markupItems.delete(t));
  }
  renderMarkup(t) {
    this._markupRenderer._setCanvas(t.domElements.getMarkupSvgElement()), this._markupRenderer._clear();
    const e = this._markupItems.get(t);
    e && (e.forEach((i) => {
      i.draw(this._markupRenderer, t);
    }), this._markupRenderer._finalize());
  }
  renderActiveViewMarkup(t) {
    this._markupRenderer._setCanvas(t.domElements.getRedlineSvgElement()), this._markupRenderer._clear();
    const e = this.getActiveView(t);
    if (!e) return;
    const i = e.getMarkup();
    for (const n of i)
      n.draw(this._markupRenderer, t);
    this._markupRenderer._finalize();
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  pick(t, e) {
    const i = this.getActiveView(e);
    if (i) {
      const o = i.getMarkup();
      for (const l of o)
        if (l.hitWithTolerance(t, e, this._pickTolerance) || l.hit(t, e))
          return l;
    }
    const n = this._markupItems.get(e);
    if (!n)
      return null;
    let r = null;
    return n.forEach((o) => {
      r === null && (o.hitWithTolerance(t, e, this._pickTolerance) || o.hit(t, e)) && (r = o);
    }), r;
  }
  select(t, e) {
    this._selectedMarkup && t !== this._selectedMarkup && this._selectedMarkup.onDeselect(), this._selectedMarkup = t, this._selectedMarkup && this._selectedMarkup.onSelect(e), this._updateAllViews();
  }
  getSelected() {
    return this._selectedMarkup;
  }
}
class W_ {
  constructor(t, e) {
    this.markupView = t, this.itemResults = e;
  }
}
class oh {
  /** @hidden */
  constructor(t, e, i, n, r, o = null) {
    this._lineVisibility = !0, this._faceVisibility = !0, this._markupItems = /* @__PURE__ */ new Set(), this._sheetId = null, this._colorMap = /* @__PURE__ */ new Map(), this._snapshotImage = null, this._defaultVisibility = !0, this._visibilityExceptions = /* @__PURE__ */ new Set(), this._uniqueId = t, this._camera = i, this._name = e, this._explodeMagnitude = n, this._cuttingPlaneData = r, this._sheetId = o;
  }
  /**
   * Gets the camera of this view
   * @returns the camera of this view
   */
  getCamera() {
    return this._camera;
  }
  /**
   * Gets the sheet id for this view
   * @returns the id of the sheet for this view. If no view was active at the time of creation this function will return null.
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Gets the unique identifier of this view
   * @returns unique identifier of this view
   */
  getUniqueId() {
    return this._uniqueId;
  }
  /**
   * Gets the name of this view
   * @returns name of this view
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name for this view
   * @param name name to set
   */
  setName(t) {
    this._name = t;
  }
  /**
   * Gets line visibility setting for this view
   * @returns line visibility setting for this view
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets line visibility for this view
   * @param lineVisibility line visibility setting for this view
   */
  setLineVisibility(t) {
    this._lineVisibility = t;
  }
  /**
   * Gets face visibility setting for this view
   * @returns face visibility setting for this view
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets face visibility for this view
   * @param faceVisibility face visibility setting for this view
   */
  setFaceVisibility(t) {
    this._faceVisibility = t;
  }
  /**
   * Adds a markup item to this view
   * @param markupItem the markup to be added to this view.
   */
  addMarkupItem(t) {
    this._markupItems.add(t);
  }
  /**
   * Gets an array of markup items associated with this view
   * @returns {boolean} face visibility setting for this view
   */
  getMarkup() {
    return lo(this._markupItems);
  }
  /**
   * Removes a markup item from the view
   * @param markupItem the markup to be removed from this view.
   * @returns result of the removal operation
   */
  removeMarkup(t) {
    return t.remove(null), this._markupItems.delete(t);
  }
  /**
   * @returns a JSON object with the cutting plane data associated with this view
   */
  getCuttingPlaneData() {
    return this._cuttingPlaneData;
  }
  /**
   * Takes a JSON cutting plane data object and associates it with this view
   * @param cuttingPlaneData
   */
  setCuttingPlaneData(t) {
    this._cuttingPlaneData = t;
  }
  /**
   * @returns the explode value associated with this view
   */
  getExplodeMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Takes an explode magnitude and associates it with this view
   */
  setExplodeMagnitude(t) {
    this._explodeMagnitude = t;
  }
  /**
   * @returns A color map associating NodeIds to Colors.
   */
  getColorMap() {
    return this._colorMap;
  }
  /**
   * Takes a color map associating NodeIds to Colors and associates it with this view.
   * @param colorMap
   */
  setColorMap(t) {
    this._colorMap = t;
  }
  getDefaultVisibility() {
    return this._defaultVisibility;
  }
  setDefaultVisibility(t) {
    this._defaultVisibility = t;
  }
  getVisibilityExceptions() {
    return this._visibilityExceptions;
  }
  setVisibilityExceptions(t) {
    this._visibilityExceptions = t;
  }
  getSnapshotImage() {
    return this._snapshotImage;
  }
  setSnapshotImage(t) {
    this._snapshotImage = t;
  }
  _handleLoadMarkupItem(t) {
    return t instanceof go ? (this.addMarkupItem(t), !0) : !1;
  }
  /** @hidden */
  static async _fromJson(t, e) {
    const i = t, n = Sn.fromJson(i.camera);
    let r;
    if (i.hasOwnProperty("sheetId") && i.sheetId) {
      const y = parseInt(t.sheetId, 10);
      isNaN(y) || (r = y);
    }
    const o = new oh(
      i.uniqueId,
      i.name,
      n,
      i.explodeMagnitude,
      i.cuttingData,
      r
    );
    if (o.setLineVisibility(i.lineVisibility), o.setFaceVisibility(i.faceVisibility), i.defaultVisibility !== void 0 && i.visibilityExceptions !== void 0) {
      o.setDefaultVisibility(i.defaultVisibility);
      const y = /* @__PURE__ */ new Set();
      i.visibilityExceptions.forEach((_) => {
        y.add(_);
      }), o.setVisibilityExceptions(y);
    }
    const l = /* @__PURE__ */ new Map(), h = i.colors;
    if (Array.isArray(h))
      for (const y of h) {
        const _ = y[0], x = yt.fromJson(y[1]);
        l.set(_, x);
      }
    o.setColorMap(l);
    const u = [];
    console.assert(Array.isArray(i.markup));
    for (const y of i.markup) {
      const _ = sg(y.className);
      if (_) {
        const x = _(y, e);
        x instanceof Promise ? u.push(
          x.then((b) => o._handleLoadMarkupItem(b))
        ) : u.push(Promise.resolve(o._handleLoadMarkupItem(x)));
      }
    }
    const f = i.imageSrc;
    if (f !== void 0 && f.length > 0) {
      const y = new Image();
      y.src = f, o.setSnapshotImage(y);
    }
    const g = await Promise.all(u);
    return new W_(o, g);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = {
      uniqueId: this._uniqueId,
      name: this._name,
      camera: this._camera.toJson(),
      cuttingData: this._cuttingPlaneData,
      explodeMagnitude: this._explodeMagnitude,
      lineVisibility: this._lineVisibility,
      faceVisibility: this._faceVisibility,
      markup: [],
      sheetId: this._sheetId,
      defaultVisibility: this._defaultVisibility,
      visibilityExceptions: [],
      colors: [],
      imageSrc: ""
    };
    return this._markupItems.forEach((e) => {
      const i = e.toJson();
      i.className = e.getClassName(), t.markup.push(i);
    }), this._visibilityExceptions.forEach((e) => {
      t.visibilityExceptions.push(e);
    }), this._colorMap.forEach((e, i) => {
      t.colors.push([i, e.toJson()]);
    }), this._snapshotImage !== null && (t.imageSrc = this._snapshotImage.src), t;
  }
}
const Kb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineItem: Al
}, Symbol.toStringTag, { value: "Module" }));
class es extends kh {
  /**
   * Creates a new Line Shape
   * @param p1 Optional first point on the line. If omitted, default value of (0,0) is used.
   * @param p2 Optional second point on the line. If omitted, default value of (0,0) is used.
   * @returns new Line object.
   */
  constructor(t, e) {
    super(), t ? this._p1 = t.copy() : this._p1 = X.zero(), e ? this._p2 = e.copy() : this._p2 = X.zero();
  }
  /**
   * Sets the points that define the line segment
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  set(t, e) {
    this._p1.assign(t), this._p2.assign(e);
  }
  /**
   * Gets the first point of the line segment
   * @returns the first point of the line segment
   */
  getP1() {
    return this._p1.copy();
  }
  /**
   * Sets the first point of the line segment
   * @param p1 first point of the line segment
   */
  setP1(t) {
    this._p1.assign(t);
  }
  /**
   * Gets the second point of the line segment
   * @returns the second point of the line segment
   */
  getP2() {
    return this._p2;
  }
  /**
   * sets the first point of the line segment
   * @param p2 second point of the line segment
   */
  setP2(t) {
    this._p2.assign(t);
  }
}
class G_ {
  constructor(t, e) {
    this.p1 = t.copy(), this.p2 = e.copy();
  }
}
class Xb extends kh {
  constructor() {
    super(...arguments), this._lines = [];
  }
  /**
   * Adds a line segment to the collection
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  addLine(t, e) {
    this._lines.push(new G_(t, e));
  }
  /**
   * Gets the lines in the collection
   */
  getLines() {
    return this._lines;
  }
  /**
   * Removes all line segments from this collection
   */
  clear() {
    this._lines = [];
  }
}
class $_ extends Ra {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polygon
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polygon
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polygon
   * @param point the point to add to the polygon
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class Jb extends Ra {
  constructor() {
    super(...arguments), this._polygons = [];
  }
  /**
   * Removes all polygons from the collection
   */
  clear() {
    this._polygons = [];
  }
  /**
   * Creates a new array of points that represent a polygon. Add Point2 objects to the array to construct the polygon
   * @returns new array which represents a polygon.
   */
  createPolygon() {
    const t = [];
    return this._polygons.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolygons() {
    return this._polygons;
  }
}
class vd extends Ra {
  /** @hidden */
  constructor() {
    super(), this._fontFamily = null, this._fontSize = 12, this.setStrokeWidth(0);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fontFamily = t._fontFamily, this._fontSize = t._fontSize;
  }
  /**
   * Gets the font family for this text
   * @returns the font family
   */
  getFontFamily() {
    return this._fontFamily;
  }
  /**
   * Sets the font family this shape
   * @param fontFamily font family to use for this text
   */
  setFontFamily(t) {
    this._fontFamily = t;
  }
  /**
   * Sets the font size for this text
   * @param fontSize size to use for this text
   */
  setFontSize(t) {
    this._fontSize = t;
  }
  /**
   * Gets the font size for this text
   * @returns the font size
   */
  getFontSize() {
    return this._fontSize;
  }
}
class Yb extends vd {
  /**
   * Creates a new markup text item.
   * @param text the text associated with this item.
   * @param position the screen space point of the top left of the text string.
   */
  constructor(t, e) {
    super(), this._position = X.zero(), this._text = "", e && (this._position = e.copy()), t && this.setText(t);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._text = t._text, this._position.assign(t._position);
  }
  /**
   * Sets the text position
   * @returns the top left position to render text from
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text position
   * @returns the text position
   */
  getPosition() {
    return this._position;
  }
  /**
   * Sets the text content
   * @param text the text to render
   */
  setText(t) {
    this._text = t;
  }
  /**
   * Gets the text content
   * @returns the text content
   */
  getText() {
    return this._text;
  }
}
class bg {
  constructor(t, e) {
    this.text = t, this.position = e.copy();
  }
}
class q_ extends vd {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new bg(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
class xg {
  /** @hidden */
  constructor() {
    this._padding = 5, this._text = new vd(), this._box = new gd(), this._box.setFillOpacity(0), this._box.setFillColor(yt.white());
  }
  /** @hidden */
  _assign(t) {
    this._text._assign(t._text), this._box._assign(t._box), this._padding = t._padding;
  }
  /**
   * Gets the Text portion of the TextBox. Use the methods on this object to modify the appearance of the text string
   * @returns the text markup object
   */
  getTextPortion() {
    return this._text;
  }
  /**
   * Gets the Box portion of the TextBox. Use the methods on this object to modify the appearance of the rectangle around the text string
   * @returns the rectangle markup object.
   */
  getBoxPortion() {
    return this._box;
  }
  /**
   * Gets the Pixel distance between the text and outer rectangle
   * @returns the padding value.
   */
  getPadding() {
    return this._padding;
  }
  /**
   * Sets the Pixel distance between the text and outer rectangle
   * @param padding the padding value.
   */
  setPadding(t) {
    this._padding = t;
  }
}
class Tl extends xg {
  /**
   * Creates a new TextBox Markup Shape.
   * @param position the screen space point of the top left of the box. Default value is (0,0).
   * @param text the text string for the box. Default value is empty string.
   */
  constructor(t, e) {
    super(), this._position = X.zero(), this._textStr = "", t && this._position.assign(t), e && (this._textStr = e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position);
  }
  /**
   * Gets the position in screen space of the top-left corner of the TextBox rectangle
   * @returns the TextBox position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the position in screen space of the top-left corner of the TextBox rectangle
   * @param position the TextBox position
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text string for this box
   * @returns the text string
   */
  getTextString() {
    return this._textStr;
  }
  /**
   * Sets the text string for this box
   * @param text the text string
   */
  setTextString(t) {
    this._textStr = t;
  }
}
class Zb extends xg {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new bg(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
const Qb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: $r,
  CircleCollection: wg,
  EndcapShape: kh,
  EndcapType: yn,
  FilledShape: Ra,
  Line: es,
  LineCollection: Xb,
  Polygon: $_,
  PolygonCollection: Jb,
  Polyline: La,
  PolylineCollection: jb,
  Rectangle: pd,
  RectangleBase: gd,
  RectangleCollection: Wb,
  StrokedShape: yg,
  Text: Yb,
  TextBox: Tl,
  TextBoxBase: xg,
  TextBoxCollection: Zb,
  TextCollection: q_,
  TextMarkupBase: vd,
  _MarkupCircleData: O_,
  _MarkupLineData: G_,
  _MarkupRectangleData: R_,
  _MarkupTextData: bg
}, Symbol.toStringTag, { value: "Module" })), xs = "http://www.w3.org/2000/svg";
function _l(s) {
  return `rgb(${s.r}, ${s.g}, ${s.b})`;
}
function Bf(s) {
  let t = "";
  for (let e = 0; e < s.length; e++)
    e && (t += " "), t += `${s[e].x},${s[e].y}`;
  return t;
}
function Vf(s, t) {
  const e = s * 1.1, i = new X(e, 0), n = new X(e, s), r = new X(0, s / 2), o = document.createElementNS(xs, "marker");
  o.id = Ms(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = s, o.setOrientToAuto(), o.refY.baseVal.value = s / 2;
  const l = `M${i.x},${i.y} L${n.x},${n.y} L${r.x},${r.y} Z`, h = document.createElementNS(xs, "path");
  return h.setAttribute("d", l), h.setAttributeNS(null, "fill", _l(t)), o.appendChild(h), o;
}
function zf(s, t) {
  const e = s * 1.1, i = X.zero(), n = new X(0, s), r = new X(e, s / 2), o = document.createElementNS(xs, "marker");
  o.id = Ms(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = s, o.setOrientToAuto(), o.refY.baseVal.value = s / 2, o.refX.baseVal.value = s;
  const l = `M${i.x},${i.y} L${n.x},${n.y} L${r.x},${r.y} Z`, h = document.createElementNS(xs, "path");
  return h.setAttribute("d", l), h.setAttributeNS(null, "fill", _l(t)), o.appendChild(h), o;
}
function Hf(s, t, e, i) {
  const n = e / 2, r = _l(i), o = document.createElementNS(xs, "circle");
  return o.setAttributeNS(null, "cx", s.x.toString()), o.setAttributeNS(null, "cy", s.y.toString()), o.setAttributeNS(null, "r", n.toString()), o.setAttributeNS(null, "fill", r), t > 0 && (o.setAttributeNS(null, "stroke-width", t.toString()), o.setAttributeNS(null, "stroke", r)), o;
}
class K_ {
  constructor() {
    this._svgCanvas = null, this._svgDefsElement = null, this._svgElements = [], this._svgTextElements = [];
  }
  _setCanvas(t) {
    this._svgCanvas = t, this._svgDefsElement = document.createElementNS(xs, "defs"), this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _clear() {
    if (this._svgCanvas === null || this._svgDefsElement === null)
      throw new oe("canvas not set");
    for (; this._svgCanvas.firstChild; )
      this._svgCanvas.removeChild(this._svgCanvas.firstChild);
    for (this._svgElements = [], this._svgTextElements = []; this._svgDefsElement.firstChild; )
      this._svgDefsElement.removeChild(this._svgDefsElement.firstChild);
    this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _finalize() {
    if (this._svgCanvas === null)
      throw new oe("canvas not set");
    for (const t of this._svgElements)
      this._svgCanvas.appendChild(t);
    for (const t of this._svgTextElements)
      this._svgCanvas.appendChild(t);
  }
  drawCircle(t) {
    return this._addCircleNode(t.getCenter(), t.getRadius(), t);
  }
  drawCircles(t) {
    const e = t.getCircles(), i = [];
    for (const n of e) {
      const r = this._addCircleNode(n.center, n.radius, t);
      i.push(r);
    }
    return i;
  }
  drawLine(t) {
    return this._addLineElement(t.getP1(), t.getP2(), t);
  }
  drawLines(t) {
    const e = t.getLines(), i = [];
    for (const n of e) {
      const r = this._addLineElement(n.p1, n.p2, t);
      i.push(r);
    }
    return i;
  }
  drawText(t) {
    return this._addTextElement(t.getText(), t.getPosition(), t);
  }
  drawTexts(t) {
    const e = t.getStrings(), i = [];
    for (const n of e) {
      const r = this._addTextElement(n.text, n.position, t);
      i.push(r);
    }
    return i;
  }
  measureText(t, e) {
    if (this._svgCanvas === null)
      throw new oe("canvas not set");
    const i = this._createTextElement(t, X.zero(), e);
    this._svgCanvas.appendChild(i);
    const n = i.getBoundingClientRect(), r = new X(n.width, n.height);
    return this._svgCanvas.removeChild(i), r;
  }
  measureTextBox(t) {
    const e = this.measureText(t.getTextString(), t.getTextPortion());
    return e.x += 2 * t.getBoxPortion().getStrokeWidth(), e.y += 2 * t.getBoxPortion().getStrokeWidth(), e.x += 2 * t.getPadding(), e.y += 2 * t.getPadding(), e;
  }
  drawPolyline(t) {
    return this._addPolylineElement(t.getPoints(), t);
  }
  drawPolylines(t) {
    const e = t.getPolylines(), i = [];
    for (const n of e) {
      const r = this._addPolylineElement(n, t);
      i.push(r);
    }
    return i;
  }
  drawPolygon(t) {
    return this._addPolygonElement(t.getPoints(), t);
  }
  drawPolygons(t) {
    const e = t.getPolygons(), i = [];
    for (const n of e) {
      const r = this._addPolygonElement(n, t);
      i.push(r);
    }
    return i;
  }
  drawRectangle(t) {
    return this._addRectangleElement(t.getPosition(), t.getSize(), t);
  }
  drawRectangles(t) {
    const e = t.getRectangles(), i = [];
    for (const n of e) {
      const r = this._addRectangleElement(n.position, n.size, t);
      i.push(r);
    }
    return i;
  }
  drawTextBox(t) {
    return this._addTextBoxElement(t.getTextString(), t.getPosition(), t);
  }
  drawTextBoxes(t) {
    const e = t.getStrings(), i = [];
    for (const n of e) {
      const r = this._addTextBoxElement(n.text, n.position, t);
      i.push(r);
    }
    return i;
  }
  _addTextBoxElement(t, e, i) {
    const n = this.measureText(t, i.getTextPortion());
    n.x += 2 * i.getPadding(), n.y += 2 * i.getPadding();
    const r = [], o = this._addRectangleElement(
      e,
      n,
      i.getBoxPortion(),
      !0
    );
    r.push(o);
    const l = e.copy();
    l.x += i.getPadding(), l.y += i.getPadding() / 2 + i.getBoxPortion().getStrokeWidth();
    const h = this._addTextElement(t, l, i.getTextPortion());
    return r.push(h), r;
  }
  _renderEndcaps(t, e, i, n) {
    if (this._svgDefsElement === null)
      throw new oe("canvas not set");
    if (i.getStartEndcapType() === yn.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? (r = zf(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), r.refX.baseVal.value = i.getStartEndcapSize()) : r = Vf(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), n.style.markerStart = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getStartEndcapType() === yn.Circle) {
      const r = Hf(
        t,
        i.getStrokeWidth(),
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      );
      this._addSVGElement(r);
    }
    if (i.getEndEndcapType() === yn.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? r = Vf(i.getEndEndcapSize(), i.getEndEndcapColor()) : r = zf(i.getEndEndcapSize(), i.getEndEndcapColor()), n.style.markerEnd = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getEndEndcapType() === yn.Circle) {
      const r = Hf(
        e,
        i.getStrokeWidth(),
        i.getEndEndcapSize(),
        i.getEndEndcapColor()
      );
      this._addSVGElement(r);
    }
  }
  _createTextElement(t, e, i) {
    const n = document.createElementNS(xs, "text"), r = t.split(`
`);
    for (const l of r) {
      const h = document.createElementNS(xs, "tspan");
      h.textContent = l, h.setAttributeNS(null, "x", `${e.x}`), h.setAttributeNS(null, "dy", "1.2em"), n.appendChild(h);
    }
    const o = i.getFontFamily();
    return o && n.setAttributeNS(null, "font-family", o), n.setAttributeNS(null, "font-size", i.getFontSize().toString()), n.setAttributeNS(null, "x", `${e.x}`), n.setAttributeNS(null, "y", `${e.y}`), this._setGenericFillAttributes(n, i), this._setGenericStrokeAttributes(n, i), n;
  }
  _addTextElement(t, e, i) {
    const n = this._createTextElement(t, e, i);
    return this._addSVGTextItemElement(n), n;
  }
  _addRectangleElement(t, e, i, n = !1) {
    const r = document.createElementNS(xs, "rect");
    r.setAttributeNS(null, "x", t.x.toString()), r.setAttributeNS(null, "y", t.y.toString()), r.setAttributeNS(null, "width", e.x.toString()), r.setAttributeNS(null, "height", e.y.toString());
    const o = i.getBorderRadius();
    return o > 0 && (r.setAttributeNS(null, "rx", o.toString()), r.setAttributeNS(null, "ry", o.toString())), this._setGenericFillAttributes(r, i), this._setGenericStrokeAttributes(r, i), n ? this._addSVGTextItemElement(r) : this._addSVGElement(r), r;
  }
  _addLineElement(t, e, i) {
    const n = document.createElementNS(xs, "line");
    return n.setAttributeNS(null, "x1", t.x.toString()), n.setAttributeNS(null, "y1", t.y.toString()), n.setAttributeNS(null, "x2", e.x.toString()), n.setAttributeNS(null, "y2", e.y.toString()), this._setGenericStrokeAttributes(n, i), this._addSVGElement(n), this._renderEndcaps(t, e, i, n), n;
  }
  _addPolygonElement(t, e) {
    const i = Bf(t), n = document.createElementNS(xs, "polygon");
    return n.setAttributeNS(null, "points", i), this._setGenericStrokeAttributes(n, e), this._setGenericFillAttributes(n, e), this._addSVGElement(n), n;
  }
  _addPolylineElement(t, e) {
    const i = Bf(t), n = document.createElementNS(xs, "polyline");
    return n.setAttributeNS(null, "points", i), n.setAttributeNS(null, "fill", "none"), this._renderEndcaps(t[0], t[t.length - 1], e, n), this._setGenericStrokeAttributes(n, e), this._addSVGElement(n), n;
  }
  _addCircleNode(t, e, i) {
    const n = document.createElementNS(xs, "circle");
    return n.setAttributeNS(null, "cx", t.x.toString()), n.setAttributeNS(null, "cy", t.y.toString()), n.setAttributeNS(null, "r", e.toString()), this._setGenericFillAttributes(n, i), this._setGenericStrokeAttributes(n, i), this._addSVGElement(n), n;
  }
  _setGenericFillAttributes(t, e) {
    t.setAttributeNS(null, "fill", _l(e.getFillColor())), t.setAttributeNS(null, "fill-opacity", e.getFillOpacity().toString());
  }
  _setGenericStrokeAttributes(t, e) {
    t.setAttributeNS(null, "stroke", _l(e.getStrokeColor())), t.setAttributeNS(null, "stroke-width", e.getStrokeWidth().toString());
  }
  _addSVGTextItemElement(t) {
    this._svgTextElements.push(t);
  }
  _addSVGElement(t) {
    this._svgElements.push(t);
  }
}
const tx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SVGMarkupRenderer: K_,
  createCircleMarker: Hf,
  createEndArrowMarker: zf,
  createStartArrowMarker: Vf,
  svgColorRgbString: _l,
  svgNamespace: xs,
  svgPointString: Bf
}, Symbol.toStringTag, { value: "Module" })), aS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Line: $b,
  MarkupItem: go,
  MarkupItemManager: j_,
  MarkupView: oh,
  Redline: Kb,
  Shapes: Qb,
  Svg: tx,
  _MarkupViewConstruction: W_
}, Symbol.toStringTag, { value: "Module" })), X_ = 45, J_ = -45, Y_ = 150, Z_ = 30;
function Q_(s) {
  Qa(s, Re.Forward, Re.Backward), Qa(s, Re.Left, Re.Right), Qa(s, Re.Up, Re.Down), Qa(s, Re.RotateLeft, Re.RotateRight), Qa(s, Re.TiltUp, Re.TiltDown);
}
function Qa(s, t, e) {
  s.has(t) && s.has(e) && (s.delete(t), s.delete(e));
}
function Uf(s, t, e) {
  return Math.max(Math.min(s, e), t);
}
function ty(s) {
  const t = s.getViewAxes().upVector;
  return console.assert(t.isAxis()), m.scale(t, -1);
}
function Ig(s, t) {
  const e = new Pi(Pe.Face);
  return e.bimMask = s, e.ignoreOverlays = !0, t !== null && (e.maxWorldDistance = t), e;
}
async function jf(s, t, e, i) {
  const n = new vr(t, e), r = Ig(_n.Floor, i), o = await s.pickFromRay(n, r);
  return o.isFaceSelection() ? o.getPosition() : null;
}
async function ey(s, t, e, i) {
  const n = new vr(t, e.copy().normalize()), r = Ig(_n.Wall, i), o = await s.pickFromRay(n, r);
  return o.isFaceSelection() ? o : null;
}
class ex {
  constructor() {
    this._action = new fo(!0), this._latestPromise = null, this._timestamp = 0;
  }
  isIdle() {
    return this._latestPromise === null && this._action.isIdle();
  }
  /**
   * Returned promise can reject if future calls are made. This is by design.
   */
  set(t) {
    const e = ++this._timestamp;
    this._latestPromise !== null && this._latestPromise.reject(void 0);
    const i = vi();
    return this._latestPromise = i, this._action.clear(), this._action.waitForIdle().then(() => {
      e === this._timestamp && this._action.set(() => {
        if (e !== this._timestamp)
          return;
        i === this._latestPromise && (this._latestPromise = null), typeof t == "function" && (t = Cs.create(t));
        let n;
        try {
          n = t.get();
        } catch (r) {
          return this._advance(i, !0, r);
        }
        return n === void 0 ? this._advance(i, !1, null) : n.then(
          () => this._advance(i, !1, null),
          (r) => this._advance(i, !0, r)
        );
      });
    }), i;
  }
  _advance(t, e, i) {
    t === this._latestPromise && (this._latestPromise = null), e ? t.reject(i) : t.resolve();
  }
}
class Wf {
  constructor(t, e) {
    this._button = t, this._modifier = e;
  }
  getButton() {
    return this._button;
  }
  getModifier() {
    return this._modifier;
  }
}
class Oi {
  /** @hidden */
  constructor(t, e) {
    this._ptFirst = X.zero(), this._ptPrevious = X.zero(), this._ptCurrent = X.zero(), this._dragging = !1, this._dragCount = 0, this._primaryTouchId = null, this._mapping = [], this._buttonModifierActive = !1, this._doubleClickInterval = 200, this._firstMouseDownTime = null, this._isDoubleClick = !1, this._viewer = t, this._view = e;
  }
  /** @hidden */
  onDoubleClick(t) {
  }
  /** @hidden */
  onMouseDown(t) {
    if (this._firstMouseDownTime ? Date.now() - this._firstMouseDownTime < this._doubleClickInterval ? (this._isDoubleClick = !0, this._firstMouseDownTime = null) : this._firstMouseDownTime = Date.now() : (this._firstMouseDownTime = Date.now(), this._isDoubleClick = !1), this._isDoubleClick)
      this.onDoubleClick(t);
    else {
      if (this._buttonModifierActive = this.checkMapping(t), this._buttonModifierActive) {
        const e = t.getPosition();
        this._ptFirst.assign(e), this._ptPrevious.assign(e), this._ptCurrent.assign(e);
      }
      this._dragging = !0;
    }
  }
  /** @hidden */
  onMouseMove(t) {
    this.isActive() && (this._ptPrevious.assign(this._ptCurrent), this._ptCurrent.assign(t.getPosition()), this._dragging && (this._ptCurrent.equals(this._ptPrevious) || (++this._dragCount, this._dragCount === 1 && this._viewer.trigger("beginInteraction"))));
  }
  /** @hidden */
  onMouseUp(t) {
    this._buttonModifierActive && this.stopInteraction(), this._dragging = !1, this._dragCount = 0;
  }
  /** @hidden */
  stopInteraction() {
    this._viewer.trigger("endInteraction"), this._dragging = !1, this._dragCount = 0, this._buttonModifierActive = !1;
  }
  /** @hidden */
  isDragging() {
    return this._dragging;
  }
  /** @hidden */
  isActive() {
    return (this._buttonModifierActive || this._primaryTouchId !== null) && !this._isDoubleClick && !this._viewer.getContextMenuStatus();
  }
  /** @hidden */
  onTouchStart(t) {
    if (this._primaryTouchId === null) {
      this._primaryTouchId = t.getId();
      const e = t.getPosition(), i = new Gr(
        e.x,
        e.y,
        Te.None,
        t.getButtons(),
        Mi.None,
        _r.Down,
        t.viewKey
      );
      this.onMouseDown(i);
    }
    t.setHandled(this.setHandled());
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Gr(
        e.x,
        e.y,
        Te.None,
        t.getButtons(),
        Mi.None,
        _r.Move,
        t.viewKey
      );
      await this.onMouseMove(i);
    }
    return t.setHandled(this.setHandled()), Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Gr(
        e.x,
        e.y,
        Te.None,
        t.getButtons(),
        Mi.None,
        _r.Up,
        t.viewKey
      );
      this.onMouseUp(i), this._primaryTouchId = null;
    }
    t.setHandled(this.setHandled());
  }
  /**
   * Adds a button and key modifier mapping for the operator. If no mapping is provided, all combinations are considered valid.
   * All mappings require a mouse button, but a key modifier is optional.
   * @param button
   * @param modifier
   */
  addMapping(t, e = Mi.None) {
    this._mapping.push(new Wf(t, e));
  }
  /**
   * Clears any button and key modifier mappings for the operator.
   */
  clearMapping() {
    this._mapping = [];
  }
  /**
   * Sets the button and key modifier mapping for the operator.
   * @param button
   * @param modifier
   */
  setMapping(t, e = Mi.None) {
    this._mapping = [], this._mapping.push(new Wf(t, e));
  }
  /** @hidden */
  checkMapping(t) {
    if (this._mapping.length === 0)
      return !0;
    for (const e of this._mapping)
      if (e.getButton() === t.getButton() && e.getModifier() === t.getModifiers())
        return !0;
    return !1;
  }
  /** @hidden */
  setHandled() {
    return !1;
  }
  /** @hidden */
  onDeactivate() {
    const t = this.stopInteraction();
    return this._primaryTouchId = null, t;
  }
}
class Nh {
  constructor(t, e) {
    this._mode = t, this._impl = new ox(e);
  }
  /**
   * Creates a new `IncrementalSelection` object that can be used to perform incremental selections.
   *
   * @param mode Controls whether or not selections are performed using the [[View]] or the [[SelectionManager]].
   * @param viewer The `IWebViewer` of the scene.
   * @param createSelectionPredicate This callback is used to create a selection predicate. Return null to not filter selection results.
   * @returns The created `IncrementalSelection` object.
   */
  static create(t, e) {
    return new Nh(t, e);
  }
  performSelection(t, e, i) {
    const n = this._impl.viewer;
    let r;
    return this._mode === "View" ? (r = n.view, i === void 0 && (i = [])) : (this._mode, r = n.selectionManager), e === void 0 && (e = null), this._impl.performSelection(r, t, e, i);
  }
  /**
   * Returns whether or not this object has an active selection in progress.
   * @returns `true` if active and `false` if idle.
   */
  isIdle() {
    return this._impl.isIdle();
  }
  /**
   * Used to wait for this object to become idle.
   * @returns A promise that resolves when this becomes idle.
   */
  waitForIdle() {
    return this._impl.waitForIdle();
  }
  /**
   * Stops the selection.
   * @returns A `Promise` that resolves when completed.
   */
  stopSelection() {
    return this._impl.stopSelection();
  }
  /**
   * Stops and clears the selection.
   * @returns A `Promise` that resolves when completed.
   */
  clearSelection() {
    return this._impl.clearSelection();
  }
}
function ix(s) {
  return "areaCssMin" in s;
}
function nx(s) {
  return "rayCssBoxRadius" in s;
}
function sx(s) {
  return "volumePlanes" in s;
}
function rx(s) {
  return "sphereRadius" in s;
}
class ox {
  constructor(t) {
    this._killHandles = [], this._activeSelectionCount = 0, this._inactivityPromise = null, this.viewer = t;
  }
  isIdle() {
    return this._activeSelectionCount === 0;
  }
  async waitForIdle() {
    return this._activeSelectionCount === 0 ? (console.assert(this._inactivityPromise === null), Promise.resolve()) : (this._inactivityPromise === null && (this._inactivityPromise = vi()), this._inactivityPromise);
  }
  async stopSelection() {
    console.assert(this._killHandles.length === this._activeSelectionCount);
    const t = [];
    for (const e of this._killHandles)
      t.push(e());
    return We(t);
  }
  async clearSelection() {
    const t = this.viewer.selectionManager;
    t.clear(), await this.stopSelection(), t.clear();
  }
  async _advanceBySelectionManager(t, e) {
    return this.viewer.selectionManager.advanceIncrementalSelection(t, e);
  }
  async _advanceByView(t, e, i) {
    let r = await this.viewer.view.advanceIncrementalSelection(t);
    if (r === null)
      return !1;
    if (e) {
      const o = await Promise.all(r.map(e));
      r = r.filter((l, h) => o[h]);
    }
    for (const o of r)
      i.push(o);
    return !0;
  }
  _wrapBeginSelection(t, e) {
    return ix(e) ? t.beginScreenSelectByArea(
      e.areaCssMin,
      e.areaCssMax,
      e.pickConfig
    ) : nx(e) ? t.beginRayDrillSelection(
      e.rayCssOrigin,
      e.rayCssBoxRadius,
      e.pickConfig
    ) : sx(e) ? t.beginConvexPolyhedronSelection(
      e.volumePlanes,
      e.heuristicOrigin,
      e.pickConfig
    ) : rx(e) ? t.beginSphereSelection(
      e.sphereCenter,
      e.sphereRadius,
      e.pickConfig
    ) : qr();
  }
  async performSelection(t, e, i, n) {
    return n === void 0 ? this._performSelection(t, e, i, null) : (await this._performSelection(t, e, i, n), n);
  }
  async _performSelection(t, e, i, n) {
    const r = this._wrapBeginSelection(t, e);
    if (r === null)
      return;
    ++this._activeSelectionCount;
    const o = this.viewer.selectionManager, l = n === null;
    let h = !1;
    const u = Cs.create(async () => {
      h = !0;
      try {
        const g = await r;
        l ? await o.endIncrementalSelection(g) : await this.viewer.view.endIncrementalSelection(g);
      } finally {
        const g = this._killHandles.indexOf(f);
        console.assert(g >= 0), this._killHandles.splice(g, 1), --this._activeSelectionCount, this._activeSelectionCount === 0 && this._inactivityPromise !== null && (this._inactivityPromise.resolve(), this._inactivityPromise = null);
      }
    }), f = () => u.get();
    this._killHandles.push(f);
    try {
      const g = await r;
      let y = !0;
      for (; y && !h; )
        l ? y = await this._advanceBySelectionManager(g, i) : y = await this._advanceByView(g, i, n), y && !h && await ud(1);
    } finally {
      await f();
    }
  }
}
class iy {
  constructor(t) {
    this._nearbyDoors = /* @__PURE__ */ new Set(), this._viewer = t;
  }
  _performSphereSelection(t, e, i) {
    const n = Nh.create("View", this._viewer), r = new _d(Pe.Face);
    return r.bimMask = i, r.onlyStreamedInstances = !0, r.ignoreUnrequestedInstances = !0, n.performSelection({
      pickConfig: r,
      sphereCenter: t,
      sphereRadius: e
    });
  }
  async updateNearbyDoors(t, e, i) {
    const n = await this._performSphereSelection(
      t,
      e,
      _n.Door
    ), r = /* @__PURE__ */ new Set();
    for (const g of n) {
      const y = g.getNodeId();
      r.add(y);
    }
    const o = wf(r, this._nearbyDoors), l = wf(this._nearbyDoors, r), h = lo(o), u = lo(l), f = this._viewer.model;
    f.setNodesOpacity(h, i), f.resetNodesOpacity(u), this._nearbyDoors = r;
  }
  forgetNearbyDoors() {
    const t = lo(this._nearbyDoors);
    this._nearbyDoors.clear(), this._viewer.model.resetNodesOpacity(t);
  }
}
class Cg extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._elevationSpeed = 0, this._rotationSpeed = 0, this._viewAngle = 90, this._zoomDistance = 0, this._walkDistance = 0, this._tilt = 0, this._majorAxis = Ze.X, this._maxExtents = 0, this._walkActive = !1, this._activeWalk = new fo(!0), this._bimModeEnabled = !1, this._synchronizedToggleBimMode = new ex(), this._initialInteractiveDrawLimitIncreaseStatus = !0, this._logical = {
      floor: {
        ...Yu
      },
      wall: {
        ...Zu
      },
      door: {
        ...Qu
      }
    }, this._effective = {
      floor: {
        ...Yu
      },
      wall: {
        ...Zu
      },
      door: {
        ...Qu
      }
    }, this._doorCache = new iy(t), this._downAxis = new m(0, -1, 0), t.setCallbacks({
      subtreeLoaded: (i, n) => {
        n === uo.LoadModel && this._updateSceneFloor();
      }
    });
  }
  _updateSceneFloor() {
    this._downAxis = ty(this._viewer.model);
  }
  isBimModeEnabled() {
    return this._bimModeEnabled;
  }
  async _enableBimMode() {
    this._bimModeEnabled = !0, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor), this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall), this._effective.door = this._scaleAgainstModelUnit(this._logical.door), this._updateSceneFloor(), await this._applyGravity(), await this._updateNearbyDoors();
  }
  _disableBimMode() {
    this._bimModeEnabled = !1, this._doorCache.forgetNearbyDoors();
  }
  /**
   * Enables BIM mode, which includes collision detection
   */
  enableBimMode() {
    return this._synchronizedToggleBimMode.set(async () => {
      await this._enableBimMode();
    });
  }
  /**
   * Disables BIM mode, which includes collision detection
   */
  disableBimMode() {
    return this._synchronizedToggleBimMode.set(() => {
      this._disableBimMode();
    });
  }
  /**
   * Toggles BIM mode, deactivating it if it's activated and activating it if it's deactivated
   */
  toggleBimMode() {
    return this._synchronizedToggleBimMode.set(() => this._bimModeEnabled ? this._disableBimMode() : this._enableBimMode());
  }
  /** @hidden */
  async onActivate() {
    this._view.setProjectionMode(ri.Perspective);
    const t = this._view;
    if (this._initialInteractiveDrawLimitIncreaseStatus = await t.getInteractiveDrawLimitIncreaseEnabled(), t.setInteractiveDrawLimitIncreaseEnabled(!1), this._calculateInitialPosition(), this._maxExtents === 0 && await this.resetDefaultWalkSpeeds(), this._bimModeEnabled && await this._updateNearbyDoors(), this._view.floorplanManager.getConfiguration().autoActivate === Wo.BimWalk) {
      const i = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      i && i.size > 0 && await this._view.floorplanManager.activate();
    }
  }
  /** @hidden */
  async onDeactivate() {
    if (this._view.setInteractiveDrawLimitIncreaseEnabled(
      this._initialInteractiveDrawLimitIncreaseStatus
    ), this._doorCache.forgetNearbyDoors(), this._view.floorplanManager.getConfiguration().autoActivate === Wo.BimWalk) {
      const e = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      e && e.size > 0 && await this._view.floorplanManager.deactivate();
    }
    super.onDeactivate();
  }
  /**
   * Sets the walk, rotate, and mouse look speeds to the default values.
   */
  async resetDefaultWalkSpeeds() {
    this._rotationSpeed = 40, this._viewAngle = 90;
    const e = (await this._viewer.model.getLooseBounding()).extents();
    this._maxExtents = Math.max(e.x, e.y, e.z), this._walkDistance = this._maxExtents / 15, this._elevationSpeed = this._maxExtents / 10, this._zoomDistance = this._maxExtents / 30;
  }
  /**
   * Gets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimFloorConfig() {
    return { ...this._logical.floor };
  }
  /**
   * Sets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimFloorConfig(t) {
    this._logical.floor = { ...t }, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor);
  }
  /**
   * Gets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimWallConfig() {
    return { ...this._logical.wall };
  }
  /**
   * Sets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimWallConfig(t) {
    this._logical.wall = { ...t }, this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall);
  }
  /**
   * Gets the door distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimDoorConfig() {
    return { ...this._logical.door };
  }
  /**
   * Sets the door distance config used by BIM mode.
   */
  setBimDoorConfig(t) {
    this._logical.door = { ...t }, this._effective.door = this._scaleAgainstModelUnit(this._logical.door);
  }
  _scaleAgainstModelUnit(t) {
    const e = this._viewer.model, i = 1 / e.getNodeUnitMultiplier(e.getAbsoluteRootNode());
    t = { ...t };
    const n = Object.keys(t);
    for (const r of n)
      typeof t[r] == "number" && (t[r] *= i);
    return t;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t);
  }
  /** @hidden */
  async _applyGravity() {
    const t = this._view, e = t.getCamera();
    let i = e.getPosition(), n = await jf(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    );
    if (n === null && (i = m.subtract(
      i,
      m.scale(this._downAxis, this._effective.floor.avatarOffset)
    ), n = await jf(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    ), n === null))
      return;
    const r = new m(0, 0, this._effective.floor.avatarOffset), o = m.add(n, r), l = m.subtract(o, i), h = l.length();
    h > this._effective.floor.negligibleClimbHeight && wr(l, this._downAxis) > 90 && h > this._effective.floor.maxClimbHeight || this._applyWalkDelta(e, l);
  }
  /** @hidden */
  _updateNearbyDoors() {
    const e = this._view.getCamera().getPosition();
    return this._doorCache.updateNearbyDoors(
      e,
      this._effective.door.transparencyRange,
      0.5
    );
  }
  _updateCamera(t) {
    this._resetPosition(t), this._updateCameraTilt(t), this._updateCameraViewAngle(t), this._view.setCamera(t);
  }
  /** @hidden */
  _applyWalkDelta(t, e) {
    t.dolly(m.scale(e, -1)), this._updateCamera(t);
  }
  /** @hidden */
  async _applyWalkDeltaWithCollisionCheck(t, e, i) {
    const n = t.getPosition(), o = wt.createFromOffAxisRotation(i, 90).transform(e), h = wt.createFromOffAxisRotation(i, -90).transform(e), u = this._testWallCollision(
      n,
      o,
      this._effective.wall.avatarOffset
    ), f = this._testWallCollision(
      n,
      h,
      this._effective.wall.avatarOffset
    ), g = this._testWallCollision(
      n,
      e,
      e.length() + this._effective.wall.avatarOffset
    ), [y, _] = await Promise.all([
      u,
      f
    ]);
    if (y !== null || _ !== null) {
      const b = (I) => {
        if (I !== null) {
          const C = I.getFaceEntity().getNormal();
          return wr(C, e) > 90;
        }
        return !1;
      };
      if (b(y) || b(_))
        return;
    }
    const x = await g;
    if (x !== null) {
      const b = e.length(), I = m.scale(e, 1 / b), M = m.subtract(x.getPosition(), n).length() - this._effective.wall.avatarOffset, P = Math.min(b, M);
      e = m.scale(I, P);
    }
    this._applyWalkDelta(t, e);
  }
  _testWallCollision(t, e, i) {
    return ey(this._view, t, e, i);
  }
  _walkBackward(t, e) {
    const n = this._view.getCamera();
    this._resetPosition(n);
    const r = n.getTarget(), o = n.getPosition(), l = n.getUp(), u = m.subtract(o, r).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(n, u, l) : this._applyWalkDelta(n, u);
  }
  _walkForward(t, e) {
    return this._walkBackward(-t, e);
  }
  _walkLeft(t, e) {
    const n = this._view.getCamera();
    this._resetPosition(n);
    const r = n.getTarget(), o = n.getPosition(), l = n.getUp(), h = m.subtract(r, o).normalize(), f = m.cross(l, h).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(n, f, l) : this._applyWalkDelta(n, f);
  }
  _walkRight(t, e) {
    return this._walkLeft(-t, e);
  }
  walkBackward(t) {
    return this._walkBackward(t, !1);
  }
  walkForward(t) {
    return this._walkForward(t, !1);
  }
  walkLeft(t) {
    return this._walkLeft(t, !1);
  }
  walkRight(t) {
    return this._walkRight(t, !1);
  }
  walkBackwardWithCollision(t) {
    return this._walkBackward(t, !0);
  }
  walkForwardWithCollision(t) {
    return this._walkForward(t, !0);
  }
  walkLeftWithCollision(t) {
    return this._walkLeft(t, !0);
  }
  walkRightWithCollision(t) {
    return this._walkRight(t, !0);
  }
  walkDown(t) {
    const i = this._view.getCamera();
    this._resetPosition(i);
    const n = i.getUp().normalize().scale(t);
    this._applyWalkDelta(i, n);
  }
  walkUp(t) {
    this.walkDown(-t);
  }
  rotateRight(t) {
    const i = this._view.getCamera();
    this._resetPosition(i);
    const n = i.getTarget(), r = i.getPosition(), l = m.subtract(r, n).length(), h = m.subtract(n, r).normalize(), u = Lo(t), f = Math.tan(u), y = m.subtract(i.getTarget(), i.getPosition()).length() * f, _ = m.cross(h, i.getUp()).scale(y);
    let x = n.copy().add(_);
    const b = m.subtract(x, r).normalize().scale(l);
    x = m.add(r, b), i.setTarget(x), this._updateCamera(i);
  }
  rotateLeft(t) {
    this.rotateRight(-t);
  }
  tiltDown(t) {
    this.setTilt(this._tilt + t);
    const i = this._view.getCamera();
    this._resetPosition(i), this._updateCamera(i);
  }
  tiltUp(t) {
    this.tiltDown(-t);
  }
  /** @hidden */
  _calculateInitialPosition() {
    const e = this._view.getCamera();
    this._calculateMajorAxis(e), this.setTilt(this._calculateInitialTilt(e)), this._resetPosition(e), this._updateCamera(e);
  }
  _updateCameraViewAngle(t) {
    const e = Lo(this._viewAngle), i = Math.tan(e / 2), r = m.subtract(t.getTarget(), t.getPosition()).length() * i;
    t.setWidth(r), t.setHeight(r);
  }
  _updateCameraTilt(t) {
    const e = t.getPosition(), i = t.getTarget(), n = t.getUp().normalize(), r = m.subtract(i, e).normalize(), o = m.cross(n, r).normalize(), l = m.distance(i, e);
    wt.createFromOffAxisRotation(o, this._tilt).transform(r, r), t.setTarget(m.add(e, r.scale(l)));
  }
  _calculateInitialTilt(t) {
    const e = t.getTarget(), i = t.getPosition(), n = m.subtract(e, i), r = n.length();
    this._majorAxis === Ze.X ? n.x = 0 : this._majorAxis === Ze.Y ? n.y = 0 : this._majorAxis === Ze.Z && (n.z = 0);
    const o = n.length();
    return Math.acos(o / r) * (180 / Math.PI);
  }
  /** @hidden */
  _resetPosition(t) {
    this._calculateMajorAxis(t);
    const e = t.getPosition(), i = t.getTarget(), n = m.subtract(i, e);
    let r = n.length();
    switch (this.getWalkSpeed() > 0 && (r = this.getWalkSpeed()), this._majorAxis) {
      case Ze.X:
        n.set(0, n.y, n.z), t.setUp(new m(1, 0, 0));
        break;
      case Ze.Y:
        n.set(n.x, 0, n.z), t.setUp(new m(0, 1, 0));
        break;
      case Ze.Z:
        n.set(n.x, n.y, 0), t.setUp(new m(0, 0, 1));
        break;
    }
    n.normalize().scale(r), t.setTarget(m.add(e, n));
  }
  /** @hidden */
  _calculateMajorAxis(t) {
    const e = t.getUp(), i = Math.abs(e.x), n = Math.abs(e.y), r = Math.abs(e.z);
    r >= i && r >= n ? this._majorAxis = Ze.Z : n >= i && n >= r ? this._majorAxis = Ze.Y : this._majorAxis = Ze.X;
  }
  /**
   * Sets the speed to walk when using the mouse scroll wheel.
   * @param zoomSpeed distance for walking with the mouse scroll wheel.
   */
  setZoomSpeed(t) {
    this._zoomDistance = t;
  }
  /**
   * Gets the speed used when walking with the mouse scroll wheel.
   */
  getZoomSpeed() {
    return this._zoomDistance;
  }
  /**
   * Sets the tilt value. Values must be between -45 and 45 degrees.
   * @param tilt
   */
  setTilt(t) {
    this._tilt = Uf(t, J_, X_);
    const e = this._view.getCamera();
    this._updateCamera(e);
  }
  /**
   * Gets the tilt value.
   */
  getTilt() {
    return this._tilt;
  }
  /**
   * Sets the view angle. Values must be between 30 and 150 degrees.
   * @param viewAngle
   */
  setViewAngle(t) {
    const e = Uf(t, Z_, Y_);
    this._viewAngle !== e && (this._viewAngle = e, this._updateCamera(this._view.getCamera()));
  }
  /**
   * Gets the view angle.
   */
  getViewAngle() {
    return this._viewAngle;
  }
  /**
   * Sets the walkSpeed for walking forward, backwards, left, and right.
   * @param walkSpeed The camera will move by walkSpeed per second.
   */
  setWalkSpeed(t) {
    this._walkDistance = t;
  }
  /**
   * Gets the walkSpeed for walking forward, backwards, left, and right.
   */
  getWalkSpeed() {
    return this._walkDistance;
  }
  /**
   * Sets the elevation speed for moving the camera up and down.
   * @param elevationSpeed The camera will move by elevationSpeed per second.
   */
  setElevationSpeed(t) {
    this._elevationSpeed = t;
  }
  /**
   * Gets the elevation speed for moving the camera up and down.
   */
  getElevationSpeed() {
    return this._elevationSpeed;
  }
  /**
   * Sets the rotation speed for tilt and rotate.
   * @param rotationSpeed The camera will rotate by rotationSpeed degrees per second.
   */
  setRotationSpeed(t) {
    this._rotationSpeed = t;
  }
  /**
   * Gets the rotation speed for tilt and rotate.
   */
  getRotationSpeed() {
    return this._rotationSpeed;
  }
  /** @hidden */
  setWalkActive(t) {
    this._walkActive = t;
  }
  /**
   * Returns true if walking is currently active
   */
  getWalkActive() {
    return this._walkActive;
  }
  /**
   * Returns true if BIM mode is currently active
   */
  getBimModeEnabled() {
    return this._bimModeEnabled;
  }
  /**
   * Get major axis
   */
  getMajorAxis() {
    return this._majorAxis;
  }
  /** @hidden */
  getActiveWalk() {
    return this._activeWalk;
  }
}
class id extends Cg {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._keyWalkMapping = /* @__PURE__ */ new Map(), this._keyUpMap = /* @__PURE__ */ new Map(), this._keyDownMap = /* @__PURE__ */ new Map(), this._mouseLookSpeed = 0, this._mouseLookEnabled = !0, this._previousWalkTime = 0, this._tickTimerId = null, t.setCallbacks({
      camera: (i) => {
        i.getProjection() !== ri.Perspective && this._keyDownMap.clear();
      }
    }), this.addKeyMapping(Qe.a, Re.Left), this.addKeyMapping(Qe.d, Re.Right), this.addKeyMapping(Qe.w, Re.Forward), this.addKeyMapping(Qe.s, Re.Backward), this.addKeyMapping(Qe.q, Re.RotateLeft), this.addKeyMapping(Qe.e, Re.RotateRight), this.addKeyMapping(Qe.r, Re.TiltUp), this.addKeyMapping(Qe.f, Re.TiltDown), this.addKeyMapping(Qe.x, Re.Up), this.addKeyMapping(Qe.c, Re.Down), this.addKeyMapping(Qe.LeftArrow, Re.Left), this.addKeyMapping(Qe.RightArrow, Re.Right), this.addKeyMapping(Qe.UpArrow, Re.Forward), this.addKeyMapping(Qe.DownArrow, Re.Backward);
  }
  /**
   * Adds a key mapping for a walk direction.
   * @param key
   * @param walkDirection
   */
  addKeyMapping(t, e) {
    this._keyWalkMapping.set(t, e);
  }
  /**
   * Gets the walk direction key mapping.
   */
  getKeyMapping() {
    return cd(this._keyWalkMapping);
  }
  /**
   * Clears all key mappings.
   */
  clearKeyMappings() {
    this._keyWalkMapping.clear();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._viewer.focusInput(!0);
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._dragging && this._mouseLookEnabled) {
      this._view.setProjectionMode(ri.Perspective);
      const e = window.screen.width, i = window.screen.height;
      t.setHandled(!0);
      const n = X.subtract(this._ptPrevious, this._ptCurrent);
      this.rotateLeft(n.x / e * this._mouseLookSpeed), this.tiltUp(n.y / i * this._mouseLookSpeed);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    this._dragCount > 5 && t.setHandled(!0), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._view.setProjectionMode(ri.Perspective);
    const e = this._view.getCamera(), i = t.getPosition(), n = t.getWheelDelta();
    this._view.pickFromPoint(i, new Pi(Pe.Face)).then((r) => {
      const o = r.getPosition();
      if (r !== null && o !== null) {
        const h = m.subtract(
          e.getPosition(),
          o
        ).normalize().scale(this.getZoomSpeed() * n);
        this._applyWalkDelta(e, h);
      } else
        this.walkBackward(n * this.getWalkSpeed());
    });
  }
  /** @hidden */
  onKeyDown(t) {
    this._view.setProjectionMode(ri.Perspective);
    const e = t.getKeyCode();
    e === Qe.v && this.toggleBimMode(), this._keyCodeActive(e) || (this._keyDownMap.set(e, t.getDate().getTime()), this._onKeyChange(e));
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    this._keyUpMap.set(e, t.getDate().getTime()), this._onKeyChange(e);
  }
  _keyCodeActive(t) {
    const e = this._keyDownMap.get(t);
    if (e !== void 0) {
      const i = this._keyUpMap.get(t);
      if (i === void 0 || e > i)
        return !0;
    }
    return !1;
  }
  _onKeyChange(t) {
    this._keyCodeActive(t) && this._keyWalkMapping.has(t) && (this.getWalkActive() || (this._previousWalkTime = Date.now()), this._onTick());
  }
  /**
   * Sets the speed for mouse look.
   * @param mouseLookSpeed
   */
  setMouseLookSpeed(t) {
    this._mouseLookSpeed = t;
  }
  /**
   * Gets the mouse look speed.
   */
  getMouseLookSpeed() {
    return this._mouseLookSpeed;
  }
  /**
   * Sets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   * @param mouseLookEnabled
   */
  setMouseLookEnabled(t) {
    this._mouseLookEnabled = t;
  }
  /**
   * Gets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   */
  getMouseLookEnabled() {
    return this._mouseLookEnabled;
  }
  async resetDefaultWalkSpeeds() {
    return super.resetDefaultWalkSpeeds().then(() => {
      this._mouseLookSpeed = 300;
    });
  }
  _execWalkDirection(t, e, i) {
    const n = this.getWalkSpeed() * e;
    switch (t) {
      case Re.Forward:
        return i ? this.walkForwardWithCollision(n) : this.walkForward(n);
      case Re.Backward:
        return i ? this.walkBackwardWithCollision(n) : this.walkBackward(n);
      case Re.Left:
        return i ? this.walkLeftWithCollision(n) : this.walkLeft(n);
      case Re.Right:
        return i ? this.walkRightWithCollision(n) : this.walkRight(n);
      case Re.Up:
        return this.walkUp(this.getElevationSpeed() * e);
      case Re.Down:
        return this.walkDown(this.getElevationSpeed() * e);
      case Re.RotateLeft:
        return this.rotateLeft(this.getRotationSpeed() * e);
      case Re.RotateRight:
        return this.rotateRight(this.getRotationSpeed() * e);
      case Re.TiltUp:
        return this.tiltUp(this.getRotationSpeed() * e);
      case Re.TiltDown:
        return this.tiltDown(this.getRotationSpeed() * e);
      default:
        qr();
    }
  }
  _queueWalkDirections(t) {
    const e = /* @__PURE__ */ new Set();
    this._keyWalkMapping.forEach((n, r) => {
      this._keyCodeActive(r) && e.add(n);
    }), Q_(e);
    const i = lo(e);
    if (i.sort(), i.length > 0) {
      this.setWalkActive(!0);
      const n = this.getBimModeEnabled();
      this.getActiveWalk().set(async () => {
        const r = new Sc(1, !0);
        if (t > 0)
          for (const o of i)
            r.push(() => this._execWalkDirection(o, t, n));
        if (n && (!e.has(Re.Up) && !e.has(Re.Down) && r.push(async () => {
          await this._applyGravity();
        }), r.push(async () => {
          await this._updateNearbyDoors();
        })), !r.isIdle())
          return r.waitForIdle();
      });
    }
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousWalkTime) / 1e3;
    this._previousWalkTime = t;
    const i = !this.getActiveWalk().isIdle();
    this.setWalkActive(i), this._queueWalkDirections(e), this._tickTimerId !== null && (cancelAnimationFrame(this._tickTimerId), this._tickTimerId = null), this.getWalkActive() && (this._tickTimerId = requestAnimationFrame(() => {
      this._onTick();
    }));
  }
}
class ny {
  /**
   * Caches a stream of points generated in time by storing them in a wrapped array, from oldest to newest. When the wrap occurs, the oldest, earliest entries are overwritten
   * @param {number} maxPoints the maximum point stream size
   */
  constructor(t = 10) {
    this._count = 0, this._points = new Array(t), this._times = new Array(t);
  }
  /**
   * Clears the array of points
   */
  clear() {
    this._count = 0;
  }
  /**
   * Adds a point to the array of points, possibly overwriting the oldest one
   */
  add(t, e = Date.now()) {
    const i = this._count % this._points.length;
    this._points[i] === void 0 ? this._points[i] = t.copy() : this._points[i].assign(t), this._times[i] = e, this._count++;
  }
  /**
   * Gets the average offset from the first point specified between (now - offset) and now
   */
  getAverageOffsetWithinMilliseconds(t, e = Date.now()) {
    let i = -1;
    const n = X.zero(), r = Math.min(this._points.length, this._count);
    if (r > 0) {
      let o = 0;
      for (let l = 0; l < r; l++) {
        const h = (this._count - 1 - l) % this._points.length;
        if (e - this._times[h] > t) break;
        i = h, n.add(this._points[h]), o++;
      }
      o > 1 ? (n.subtract(this._points[i]), o--, n.scale(1 / o)) : (i = -1, n.set(0, 0));
    }
    return i >= 0 ? X.subtract(n, this._points[i]) : n;
  }
}
class Sg extends Oi {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._cameraRotationMomentumEnabled = !1, this._isDown = !1, this._mouseDragged = !1, this._averagedMousePoints = new ny(), this._averageTimeIntervalMilliseconds = 150, this._previousMouseMovePoint = X.zero(), this._mouseMovePoint = X.zero(), this._mouseMoveOffset = X.zero(), this._previousMouseMoveTime = null, this._mouseMoveTime = null, this._mouseMoveElapsedTimeSeconds = 0, this._rotationDegreesPerSecond = [0, 0], this._animationLastTickTime = 0, this._animationElapsedTimeSeconds = 0, this._animationIntervalResult = null, this._preferredAnimationIntervalMilliseconds = 16, this._momentum = 0, this._momentumLossPerSecond = 0, this._degreesPerPixel = 0.5, this._maxRotationMagnitudeScale = 8, this._initialSelectionPosition = null, this._cameraRotateFunction = i;
  }
  getCameraRotationMomentumEnabled() {
    return this._cameraRotationMomentumEnabled;
  }
  setCameraRotationMomentumEnabled(t) {
    t !== this._cameraRotationMomentumEnabled && (this._cameraRotationMomentumEnabled = t, t || this.stopAnimation());
  }
  isCurrentlyAnimating() {
    return this._cameraRotationMomentumEnabled && this.getMomentum() > 0;
  }
  /** @hidden */
  onDeactivate() {
    return super.onDeactivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this.stopAnimation();
  }
  supportsAnimation() {
    return !0;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._initialSelectionPosition = t.getPosition(), this._isDown = !0, this.stopAnimation(), this._mouseDragged = !1, this._previousMouseMoveTime = Date.now(), this._mouseMoveTime = this._previousMouseMoveTime, this._mouseMovePoint.assign(this._initialSelectionPosition), this._previousMouseMovePoint.assign(this._mouseMovePoint), this._averagedMousePoints.clear(), this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive()) {
      if (!this._isDown) return;
      this._mouseDragged = !0, this._previousMouseMovePoint.assign(this._mouseMovePoint), this._mouseMovePoint.assign(t.getPosition()), this._mouseMoveOffset = X.subtract(this._mouseMovePoint, this._previousMouseMovePoint), this._previousMouseMoveTime = this._mouseMoveTime, this._mouseMoveTime = Date.now(), this._mouseMoveElapsedTimeSeconds = this._previousMouseMoveTime === null ? 0 : (this._mouseMoveTime - this._previousMouseMoveTime) / 1e3, this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime);
      const e = this._getMouseMoveOffsetForRotation();
      this._rotateCamera(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && (this._isDown = !1, this._mouseDragged && this.getCameraRotationMomentumEnabled())) {
      this._mouseMoveOffset = this._averagedMousePoints.getAverageOffsetWithinMilliseconds(
        this._averageTimeIntervalMilliseconds
      );
      const e = this._getMouseMoveOffsetForRotation();
      if (e[0] !== 0 || e[1] !== 0) {
        for (let i = 0; i < 2; i++) {
          const n = Math.abs(e[i]) * this._maxRotationMagnitudeScale;
          this._rotationDegreesPerSecond[i] = e[i] / this._mouseMoveElapsedTimeSeconds, this._rotationDegreesPerSecond[i] < -n ? this._rotationDegreesPerSecond[i] = -n : this._rotationDegreesPerSecond[i] > n && (this._rotationDegreesPerSecond[i] = n);
        }
        this._momentum = 1, this._startAnimation();
      } else
        this._momentum = 0;
    }
    super.onMouseUp(t);
  }
  _rotateCamera(t) {
    this._cameraRotateFunction(t);
  }
  stopAnimation() {
    this._animationIntervalResult !== null && (clearInterval(this._animationIntervalResult), this._animationIntervalResult = null);
  }
  getMomentum() {
    return this._momentum;
  }
  /**
   * Sets proportion of momentum lost per second if camera rotation momentum is enabled. At 0
   * no momentum is lost and the camera will orbit indefinitely. Above 1 the camera will stop
   * orbiting within a second of release. Only values greater than or equal to 0 are accepted.
   * @param amountLost Proportion of momentum lost per second
   */
  setMomentumLossPerSecond(t) {
    t >= 0 && (this._momentumLossPerSecond = t);
  }
  getMomentumLossPerSecond() {
    return this._momentumLossPerSecond;
  }
  isAnimating() {
    return this._animationIntervalResult !== null;
  }
  _startAnimation() {
    this._animationIntervalResult === null && (this._animationLastTickTime = Date.now(), this._animationIntervalResult = window.setInterval(() => {
      this._onTick();
    }, this._preferredAnimationIntervalMilliseconds));
  }
  _getMouseMoveOffsetForRotation() {
    return [
      -this._mouseMoveOffset.x * this._degreesPerPixel,
      this._mouseMoveOffset.y * this._degreesPerPixel
    ];
  }
  _onTick() {
    const t = Date.now();
    this._animationElapsedTimeSeconds = (t - this._animationLastTickTime) / 1e3, this._animationLastTickTime = t;
    const e = [
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[0],
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[1]
    ];
    if (this._rotateCamera(e), this._momentumLossPerSecond > 0)
      if (this._momentum = Math.max(
        0,
        this._momentum - this._animationElapsedTimeSeconds * this._momentumLossPerSecond
      ), this._momentum > 0)
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] *= this._momentum;
      else {
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] = 0;
        this._rotateCamera(this._rotationDegreesPerSecond), this.stopAnimation();
      }
  }
}
class sy extends go {
  constructor(t, e, i, n) {
    super(), this._circle = new $r(), this._viewer = t, this._view = e, this._position = i, this._circle.setRadius(n);
  }
  draw() {
    if (this._circle) {
      const t = this._view.projectPoint(this._position);
      this._circle.setCenter(X.fromPoint3(t)), this._viewer.markupManager.getRenderer().drawCircle(this._circle);
    }
  }
}
class Mg extends Sg {
  /** @hidden */
  constructor(t, e) {
    super(t, e, (i) => {
      if (!this._viewer.sheetManager.isDrawingSheetActive())
        if (this._pickPosition !== null) {
          if (this._circleMarkupHandler === null) {
            const n = new sy(
              this._viewer,
              this._view,
              this._pickPosition,
              this._circleRadius
            );
            this._circleMarkupHandler = this._viewer.markupManager.registerMarkup(
              n,
              this._view
            );
          }
          this._orbitByTurnTiltWithTarget(i, this._pickPosition);
        } else {
          const n = this._view.getCamera();
          switch (this._orbitFallbackMode) {
            default:
            case gc.CameraTarget:
              this._orbitByTurnTiltWithTarget(i, n.getTarget());
              break;
            case gc.ModelCenter:
              this._modelCenter && this._orbitByTurnTiltWithTarget(i, this._modelCenter);
              break;
            case gc.OrbitTarget:
              this._orbitByTurnTiltWithTarget(i, this._orbitTarget);
              break;
          }
        }
    }), this._orbitTarget = m.zero(), this._orbitFallbackMode = gc.ModelCenter, this._modelCenter = m.zero(), this._circleMarkupHandler = null, this._circleRadius = 3, this._updateCameraCenterAction = new fo(!1), this._updateCameraCenterTimer = new Ko(), this._primaryButton = Te.Middle, this._pickPosition = null, this._bimOrbitEnabled = !1, this._viewer.setCallbacks({
      sceneReady: () => {
        this._updateModelCenter();
      },
      modelSwitched: () => {
        this._updateModelCenter();
      },
      visibilityChanged: () => {
        this._updateModelCenter();
      },
      _updateTransform: (i) => {
        i || this._updateModelCenter();
      },
      _geometryCreated: () => {
        this._updateModelCenter();
      },
      hwfParseComplete: () => {
        this._updateModelCenter();
      }
    }), this._viewer.getSceneReady() && this._updateModelCenter(0);
  }
  _updateModelCenter(t = 50) {
    this._updateCameraCenterTimer.clear(), this._updateCameraCenterAction.set(async () => {
      const e = await this._viewer.model.getModelBounding(!0, !1);
      if (e.isDegenerate() && t > 0) {
        this._updateCameraCenterTimer.set(500, () => {
          this._updateModelCenter(t - 1);
        });
        return;
      }
      this._modelCenter = e.center();
    });
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() && t.getButton() === this._primaryButton) {
      const e = await this._view.pickFromPoint(
        t.getPosition(),
        new Pi(Pe.Face)
      );
      e !== null && e.overlayIndex() === 0 ? (this._pickPosition = e.getPosition(), t.setHandled(!0)) : this._pickPosition = null;
    }
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t), t.getButton() === this._primaryButton && (this._pickPosition = null), this._removeMarkup();
  }
  /** @hidden */
  onDeactivate() {
    const t = super.onDeactivate();
    return this._updateCameraCenterTimer.clear(), t;
  }
  /**
   * BIM orbit is intended to make orbiting building models easier.
   * It slows the rotation speed, clamps vertical rotation to 180 degrees, and restricts horizontal rotation to rotate around the vertical axis.
   * @param bimOrbitEnabled
   */
  setBimOrbitEnabled(t) {
    this._bimOrbitEnabled = t;
  }
  /**
   * Returns true if BIM orbit is enabled.
   */
  getBimOrbitEnabled() {
    return this._bimOrbitEnabled;
  }
  /** @hidden */
  _removeMarkup() {
    this._circleMarkupHandler !== null && (this._viewer.markupManager.unregisterMarkup(this._circleMarkupHandler, this._view), this._circleMarkupHandler = null);
  }
  _getClampedRotationMatrix(t, e, i, n) {
    const r = wt.createFromOffAxisRotation(t, e), o = m.zero();
    return r.transform(i, o), Qf(Math.asin(m.dot(n, o))) <= 0 ? new wt() : r;
  }
  async _orbitByTurnTiltWithTarget(t, e) {
    const i = this._view, n = i.getCamera();
    let r = n.getPosition().subtract(e), o = n.getTarget().subtract(e), l = n.getUp().normalize();
    const h = m.subtract(o, r).normalize(), u = m.cross(l, h).normalize(), f = t[0], g = t[1];
    let y = new wt(), _ = new wt();
    if (this._bimOrbitEnabled) {
      const I = this._viewer.model.getViewAxes().upVector.copy();
      y = this._getClampedRotationMatrix(u, g, l, I), _ = wt.createFromOffAxisRotation(I, f / 4);
      const C = _.transform(y.transform(r)), M = _.transform(y.transform(o)), P = _.transform(y.transform(m.add(r, l)));
      P.subtract(C), r = C, o = M, l = P;
    } else {
      y = wt.createFromOffAxisRotation(u, g), _ = wt.createFromOffAxisRotation(l, f);
      const b = wt.multiply(_, y), I = b.transform(r), C = b.transform(o), M = b.transform(m.add(r, l));
      M.subtract(I), r = I, o = C, l = M;
    }
    r.add(e), o.add(e), n.setPosition(r), n.setTarget(o), n.setUp(l), i.setCamera(n), (await this._viewer.model.getModelBounding(!1, !1)).isDegenerate() && this._viewer.view.unsetDefaultCamera();
  }
  /**
   * Sets the fallback mode. This is used to specify whether to orbit
   * around a set target, the model center, or camera target.
   */
  setOrbitFallbackMode(t) {
    this._orbitFallbackMode = t;
  }
  /**
   * Gets the orbit fallback mode.
   * @returns orbit fallback mode
   */
  getOrbitFallbackMode() {
    return this._orbitFallbackMode;
  }
  /**
   * Sets the orbit target for the orbit fallback mode OrbitTarget.
   * @param orbitTarget
   */
  setOrbitTarget(t) {
    this._orbitTarget = t;
  }
  /**
   * Gets the orbit target point.
   * @returns orbit target
   */
  getOrbitTarget() {
    return this._orbitTarget;
  }
  /**
   * Sets the primary mouse button. When this button is pressed, we will orbit around the selected point on the model.
   * If there is no selected point, the orbit fallback mode will be used for orbit.
   * @param button
   */
  setPrimaryButton(t) {
    this._primaryButton = t;
  }
  /**
   * @returns the primary orbit button
   */
  getPrimaryButton() {
    return this._primaryButton;
  }
}
class ry extends Oi {
  /** @hidden */
  constructor(t, e, i, n, r) {
    super(t, e), this._activeOperator = null, this._activeTouchCount = 0, this._touchMoveCount = 0, this._returnToOrbit = !1, this._bimNavigationEnabled = !1, this._orbitOperator = i, this._panOperator = n, this._zoomOperator = r;
  }
  /**
   * When BIM navigation is enabled, the following controls for orbit, pan, and zoom are set:
   * Left mouse button: orbit
   * Middle mouse wheel: zoom
   * Middle mouse button: pan
   * Right mouse button: zoom
   * @param bimNavigation
   */
  setBimNavigationEnabled(t) {
    this._bimNavigationEnabled = t;
    const e = this._orbitOperator, i = this._zoomOperator, n = this._panOperator;
    e.clearMapping(), i.clearMapping(), n.clearMapping(), e.setMapping(Te.Left), e.setBimOrbitEnabled(t), i.setDollyZoomEnabled(t), t ? (e.setPrimaryButton(Te.Left), i.setMapping(Te.Right), n.setMapping(Te.Middle), this._setBimCamera()) : (e.addMapping(Te.Middle), e.setPrimaryButton(Te.Middle), i.addMapping(Te.Left, Mi.Shift), n.addMapping(Te.Right), n.addMapping(Te.Left, Mi.Control));
  }
  _setBimCamera() {
    const t = this._view.getCamera(), e = m.subtract(t.getPosition(), t.getTarget()).normalize(), n = this._viewer.model.getViewAxes().upVector.copy(), r = m.cross(e, n), o = m.cross(r, e);
    t.setUp(o), t.setProjection(ri.Perspective), this._view.setCamera(t);
  }
  /**
   * Returns true if BIM navigation is enabled.
   */
  getBimNavigationEnabled() {
    return this._bimNavigationEnabled;
  }
  /** @hidden */
  onViewOrientationChange() {
    this._activeTouchCount = 0, this._returnToOrbit = !1;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._setActiveOperatorForMouseInput(t), this._activeOperator && (this._bimNavigationEnabled && this._setBimCamera(), this._activeOperator.onMouseDown(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this._activeOperator && this._dragging && this._dragCount > 3 && this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator && this._activeOperator.onMouseUp(t), this._activeOperator instanceof Mg || this._orbitOperator._removeMarkup(), super.onMouseUp(t);
  }
  /** @hidden */
  async onMousewheel(t) {
    await this._zoomOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    ++this._activeTouchCount, this._orbitOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t), this._viewer.sheetManager.isDrawingSheetActive() && (this._panOperator.onTouchStart(t), this._orbitOperator.onDeactivate()), this._activeTouchCount === 1 && (this._primaryTouchId = t.getId()), this._activeTouchCount === 2 && (this._orbitOperator.onDeactivate(), this._panOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t));
  }
  /** @hidden */
  async onTouchMove(t) {
    ++this._touchMoveCount, this._touchMoveCount > 5 && (this._returnToOrbit ? (this._orbitOperator.onTouchStart(t), this._returnToOrbit = !1) : this._activeTouchCount === 1 ? (await this._orbitOperator.onTouchMove(t), await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)) : this._activeTouchCount === 2 && (await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)));
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeTouchCount === 2 && (this._returnToOrbit = !0), this._zoomOperator.onTouchEnd(t), this._panOperator.onTouchEnd(t), this._orbitOperator.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount, this._activeTouchCount === 0 && (this._touchMoveCount = 0);
  }
  /** @hidden */
  stopInteraction() {
    const t = [];
    let e;
    return e = super.stopInteraction(), e !== void 0 && t.push(e), this._activeTouchCount = 0, this._touchMoveCount = 0, e = this._zoomOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._panOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._orbitOperator.onDeactivate(), e !== void 0 && t.push(e), We(t);
  }
  _setActiveOperatorForMouseInput(t) {
    const e = this._orbitOperator, i = this._panOperator, n = this._zoomOperator;
    this._activeOperator = null, this._viewer.sheetManager.isDrawingSheetActive() ? this._activeOperator = i : e.checkMapping(t) ? this._activeOperator = e : n.checkMapping(t) ? this._activeOperator = n : i.checkMapping(t) && (this._activeOperator = i);
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._orbitOperator.onDeactivate(), this._panOperator.onDeactivate(), this._zoomOperator.onDeactivate();
  }
}
class oy extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._cameraPtPrevious = m.zero();
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._view, n = e.getCamera().getCameraPlaneIntersectionPoint(t.getPosition(), e);
      n && this._cameraPtPrevious.assign(n);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._view, i = e.getCamera(), n = i.getCameraPlaneIntersectionPoint(t.getPosition(), e);
      if (n) {
        const r = m.subtract(n, this._cameraPtPrevious);
        i.dolly(r), e.setCamera(i);
      }
    }
  }
}
class ay extends Sg {
  /** @hidden */
  constructor(t, e) {
    super(t, e, (i) => {
      this._rotateAroundAxis(this._rotationAxis, i[0]);
    }), this._rotationAxis = new m(0, 0, 1), this._tiltAmount = 12;
  }
  async _rotateAroundAxis(t, e) {
    const i = this._view, n = i.getCamera(), r = n.getPosition(), o = n.getUp().normalize(), l = n.getTarget(), h = wt.createFromOffAxisRotation(t, e), u = new wt().setTranslationComponent(-l.x, -l.y, -l.z), f = wt.multiply(u, h), g = new wt().setTranslationComponent(l.x, l.y, l.z);
    wt.multiply(f, g).transform(r, r), h.transform(o, o), o.normalize(), n.setPosition(r), n.setUp(o), i.setCamera(n), (await this._viewer.model.getModelBounding(!1, !1)).isDegenerate() && this._viewer.view.unsetDefaultCamera();
  }
  /** @hidden */
  onMousewheel(t) {
    const e = t.getWheelDelta(), i = this._view.getCamera(), n = i.getUp().normalize(), r = m.subtract(i.getTarget(), i.getPosition()).normalize(), o = m.cross(n, r).normalize();
    e > 0 ? this._rotateAroundAxis(o, this._tiltAmount) : this._rotateAroundAxis(o, -this._tiltAmount);
  }
  _axisToPoint3(t) {
    let e = null;
    switch (t) {
      case Ze.X:
        e = new m(1, 0, 0);
        break;
      case Ze.Y:
        e = new m(0, 1, 0);
        break;
      case Ze.Z:
        e = new m(0, 0, 1);
        break;
    }
    return e;
  }
  /**
   * Sets the rotation axis.
   * @param axis [[Axis]] or [[Point3]] used to set the rotation axis.
   */
  setRotationAxis(t) {
    let e = null;
    return t instanceof m ? e = t : e = this._axisToPoint3(t), e !== null ? (this._rotationAxis.assign(e), !0) : !1;
  }
}
class ly {
  /** @hidden */
  constructor(t, e, i) {
    this._keyboardWalkOperator = i, this._walkOperator = e, this._activeOperator = e, this._walkMode = pc.Mouse, this._active = !1;
  }
  /**
   * Sets the walk mode to Mouse or Keyboard.
   * @param walkMode
   */
  async setWalkMode(t) {
    this._walkMode !== t && (this._walkMode = t, t === pc.Keyboard ? (this._activeOperator = this._keyboardWalkOperator, this._active && (await this._walkOperator.onDeactivate(), await this._keyboardWalkOperator.onActivate())) : (this._activeOperator = this._walkOperator, this._active && (await this._keyboardWalkOperator.onDeactivate(), await this._walkOperator.onActivate())));
  }
  /**
   * Gets the walk mode.
   * @returns Keyboard or Mouse
   */
  getWalkMode() {
    return this._activeOperator instanceof id ? pc.Keyboard : pc.Mouse;
  }
  /** @hidden */
  onMouseDown(t) {
    this._activeOperator.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._activeOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    this._activeOperator.onTouchStart(t);
  }
  /** @hidden */
  async onTouchMove(t) {
    await this._activeOperator.onTouchMove(t);
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeOperator.onTouchEnd(t);
  }
  /** @hidden */
  onKeyDown(t) {
    this._activeOperator.onKeyDown(t);
  }
  /** @hidden */
  onKeyUp(t) {
    this._activeOperator instanceof id && this._activeOperator.onKeyUp(t);
  }
  /** @hidden */
  onDeactivate() {
    return this._activeOperator.onDeactivate();
  }
  /** @hidden */
  onActivate() {
    return this._active = !0, this._activeOperator.onActivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this._active = !1;
  }
  /** @hidden */
  stopInteraction() {
    return this._activeOperator.stopInteraction();
  }
  /**
   * Sets BIM mode enables/disabled on both mouse and keyboard walk
   */
  async setBimModeEnabled(t) {
    const e = [];
    return t ? (e.push(this._keyboardWalkOperator.enableBimMode()), e.push(this._walkOperator.enableBimMode())) : (e.push(this._keyboardWalkOperator.disableBimMode()), e.push(this._walkOperator.disableBimMode())), Promise.all(e).then(() => {
    });
  }
  /**
   * Resets speeds to defaults on both mouse and keyboard walk
   */
  async resetDefaultWalkSpeeds() {
    return Promise.all([
      this._walkOperator.resetDefaultWalkSpeeds(),
      this._keyboardWalkOperator.resetDefaultWalkSpeeds()
    ]).then(() => {
    });
  }
  /**
   * Sets BIM floor config on both mouse and keyboard walk
   */
  setBimFloorConfig(t) {
    this._walkOperator.setBimFloorConfig(t), this._keyboardWalkOperator.setBimFloorConfig(t);
  }
  /**
   * Sets BIM wall config on both mouse and keyboard walk
   */
  setBimWallConfig(t) {
    this._walkOperator.setBimWallConfig(t), this._keyboardWalkOperator.setBimWallConfig(t);
  }
  /**
   * Sets BIM door config on both mouse and keyboard walk
   */
  setBimDoorConfig(t) {
    this._walkOperator.setBimDoorConfig(t), this._keyboardWalkOperator.setBimDoorConfig(t);
  }
  /**
   * Sets zoom speed on both mouse and keyboard walk
   */
  setZoomSpeed(t) {
    this._walkOperator.setZoomSpeed(t), this._keyboardWalkOperator.setZoomSpeed(t);
  }
  /**
   * Sets walk speed for both mouse and keyboard walk
   */
  setWalkSpeed(t) {
    this._walkOperator.setWalkSpeed(t), this._keyboardWalkOperator.setWalkSpeed(t);
  }
  /**
   * Sets elevation speed for both mouse and keyboard walk
   */
  setElevationSpeed(t) {
    this._walkOperator.setElevationSpeed(t), this._keyboardWalkOperator.setElevationSpeed(t);
  }
  /**
   * Sets rotation speed for both mouse and keyboard walk
   */
  setRotationSpeed(t) {
    this._walkOperator.setRotationSpeed(t), this._keyboardWalkOperator.setRotationSpeed(t);
  }
  /**
   * Sets view angle (FOV) for both mouse and keyboard walk operators
   */
  setViewAngle(t) {
    this._walkOperator.setViewAngle(t), this._keyboardWalkOperator.setViewAngle(t);
  }
}
class cy extends Cg {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._timerId = null, this._walkButton = Te.None, this._previousTimestamp = 0, this._activeTouchCount = 0, this._maxDistance = 200;
  }
  /** @hidden */
  async onActivate() {
    await super.onActivate(), this._viewer.trigger("walkOperatorActivated");
  }
  /** @hidden */
  onKeyDown(t) {
    const e = t.getKeyCode(), i = this.getWalkSpeed();
    e === Qe.PgUp && this.setWalkSpeed(i * 1.2), e === Qe.PgDown && this.setWalkSpeed(i * 0.8), e === Qe.v && this.toggleBimMode();
  }
  /** @hidden */
  async onDeactivate() {
    const t = this._resetCameraTarget();
    return this.stopWalking(), await super.onDeactivate(), this._viewer.trigger("walkOperatorDeactivated"), t;
  }
  // This can resolve issues that arise if the user activates a CAD view while walking that may change the projection mode.
  _checkProjection() {
    const t = this._view;
    t.getProjectionMode() !== ri.Perspective && (t.setProjectionMode(ri.Perspective), this._calculateInitialPosition());
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._checkProjection(), this.isActive() && (this.stopWalking(), this.setWalkActive(!0), this._walkButton = t.getButton());
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.getWalkActive() && this._timerId === null && this.isActive() && (this._previousTimestamp = Date.now(), this._onTick());
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && this.stopWalking(), super.onMouseUp(t);
  }
  /** @hidden */
  onTouchStart(t) {
    super.onTouchStart(t), ++this._activeTouchCount, this._activeTouchCount === 1 ? this._walkButton = Te.Left : this._activeTouchCount === 2 ? this._walkButton = Te.Right : this._activeTouchCount === 3 && (this._walkButton = Te.None);
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._activeTouchCount === 3 && this._primaryTouchId === t.getId()) {
      this._ptCurrent.assign(t.getPosition());
      const e = X.subtract(this._ptCurrent, this._ptPrevious);
      this._adjustTilt(e.y / 100 * 1.5);
    } else this._activeTouchCount < 3 && await super.onTouchMove(t);
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    super.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount;
  }
  /** @hidden */
  onMousewheel(t) {
    this._checkProjection(), t.getWheelDelta() > 0 ? this._adjustTilt(3) : this._adjustTilt(-3);
  }
  /** @hidden */
  stopWalking() {
    this._timerId !== null && (cancelAnimationFrame(this._timerId), this._timerId = null), this.setWalkActive(!1);
  }
  /** @hidden */
  async _testWalk(t, e, i, n = Ae.Default) {
    const r = new Gr(
      0,
      0,
      i,
      ws.None,
      Mi.None,
      _r.Down,
      n
    ), o = new Gr(
      0,
      t,
      i,
      ws.None,
      Mi.None,
      _r.Move,
      n
    ), l = new Gr(
      0,
      t,
      i,
      ws.None,
      Mi.None,
      _r.Up,
      n
    );
    this.onMouseDown(r), this.onMouseMove(o), await ud(e), this.onMouseUp(l);
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousTimestamp) / 1e3;
    this._previousTimestamp = t;
    const i = this._view, n = X.subtract(this._ptCurrent, this._ptFirst), r = new X(
      Math.abs(n.x) / this._maxDistance,
      Math.abs(n.y) / this._maxDistance
    ), o = this.getRotationSpeed() * e * r.x, l = this.getWalkSpeed() * e * r.y, h = this.getElevationSpeed() * e * r.x, u = this.getElevationSpeed() * e * r.y;
    if (this._walkButton === Te.Left) {
      if (n.x !== 0 && (n.x > 0 ? this.rotateRight(o) : n.x < 0 && this.rotateLeft(o)), n.y !== 0) {
        const f = i.getCamera();
        this._resetPosition(f);
        const g = f.getTarget(), y = f.getPosition(), _ = m.subtract(g, y).normalize(), x = f.getUp();
        let b = m.scale(_, l);
        n.y > 0 && (b = b.negate()), this.setWalkActive(!0);
        const I = this.getBimModeEnabled();
        this.getActiveWalk().set(async () => {
          if (I)
            await this._applyWalkDeltaWithCollisionCheck(f, b, x), await this._applyGravity(), await this._updateNearbyDoors();
          else
            return this._applyWalkDelta(f, b);
        });
      }
    } else (this._walkButton === Te.Right || this._walkButton === Te.Middle) && (Math.abs(n.y) > 0 && (n.y > 0 ? this.walkUp(u) : this.walkDown(u)), Math.abs(n.x) > 0 && (n.x > 0 ? this.walkRight(h) : this.walkLeft(h)));
    this._timerId = requestAnimationFrame(() => {
      this._onTick();
    });
  }
  _adjustTilt(t) {
    const e = this._view;
    this.setTilt(this.getTilt() + t);
    const i = e.getCamera();
    this._resetPosition(i);
    const n = i.getTarget(), r = i.getPosition(), o = m.distance(n, r), l = i.getUp().normalize(), h = m.subtract(n, r).normalize(), u = m.cross(l, h).normalize();
    wt.createFromOffAxisRotation(u, this.getTilt()).transform(h, h), h.normalize().scale(o), i.setTarget(m.add(r, h)), e.setCamera(i);
  }
  async _resetCameraTarget() {
    const t = this._view, e = t.getCanvasSize(), i = new X(Math.round(e.x / 2), Math.round(e.y / 2)), n = new Pi(), r = await t.pickFromPoint(i, n);
    if (r.isEntitySelection()) {
      const o = t.getCamera();
      o.setTarget(r.getPosition()), t.updateCamera(o);
    }
  }
}
class Rn extends go {
  /** @hidden */
  constructor(t) {
    super(), this._stage = 0, this._finalized = !1, this._uniqueId = "", this._positions = [], this._name = "", this._measurementValue = 0, this._unitMultiplier = 1, this._textShape = new Tl(), this._visibility = !0, this._positions = [], this._lineShapes = [], this._viewer = t;
  }
  /**
   * Gets the name of this measurement.
   * @returns the measurement name
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name of this measurement
   * @param name the name to set
   */
  setName(t) {
    this._name = t;
  }
  /** @hidden */
  _getStage() {
    return this._stage;
  }
  /** @hidden */
  _nextStage() {
    this._stage++;
  }
  /** @hidden */
  _setId(t) {
    this._uniqueId = t;
  }
  /** @hidden */
  _getId() {
    return this._uniqueId;
  }
  /** @hidden */
  adjust(t) {
  }
  /** @hidden */
  _isFinalized() {
    return this._finalized;
  }
  /** @hidden */
  update() {
  }
  /** @hidden */
  draw() {
    this.update();
  }
  setVisibility(t) {
    this._visibility = t, this.draw(), t ? this._viewer.trigger("measurementShown", this) : this._viewer.trigger("measurementHidden", this);
  }
  getVisibility() {
    return this._visibility;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Returns the unit agnostic value for this measurement.
   * In the case where this value represents distance, use [[getUnitMultiplier]] to determine the measurement units.
   * In other cases, this value will be the angle measurement in degrees.
   * @returns the measurement value
   */
  getMeasurementValue() {
    return this._measurementValue;
  }
  /**
   * Returns the unit multiplier incorporated into the measurement value.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   */
  getUnitMultiplier() {
    return this._unitMultiplier;
  }
  /**
   * Sets the measurement text that is rendered with this measurement.
   * @param measurementText the text to render with this measurement
   */
  setMeasurementText(t) {
    this._textShape.setTextString(t);
  }
  /**
   * Gets the text for this measurement. By default this will contain the measurement value and units for the model in the cases where the measurement is a distance.
   * In other cases it will contain the angle in degrees.
   */
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /**
   * Returns whether the measurement markup is valid. Override in subclasses when needed.
   */
  isMarkupValid() {
    return !0;
  }
  /** @hidden */
  _setMeasurementValue(t) {
    this._measurementValue = t / this._unitMultiplier, this.setMeasurementText(Hc(this._measurementValue, this._unitMultiplier)), this._viewer.trigger("measurementValueSet", this);
  }
  /** @hidden */
  static _serializePointArray(t) {
    const e = [];
    for (const i of t)
      e.push(i.toJson());
    return e;
  }
  /** @hidden */
  static _constructPointArray(t) {
    const e = [];
    for (const i of t) {
      const n = m.fromJson(i);
      e.push(n);
    }
    return e;
  }
}
class Pg extends Rn {
  constructor(t, e) {
    super(t), this._rectangle = new pd(), this._markupHandle = null, this._dim = new X(0, 0), this.initialPosition = new X(0, 0), this.currentPosition = new X(0, 0), this.min = new X(0, 0), this.max = new X(0, 0), this._name = "_RectangleMarkup", this._rectangle.setFillOpacity(0), this._rectangle.setStrokeColor(yt.red()), this._constantStrokeColor = e;
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawRectangle(this._rectangle);
  }
  updateCurrentPosition(t) {
    if (this.currentPosition.assign(t), this._constantStrokeColor || this._rectangle.setStrokeColor(
      this.initialPosition.x < this.currentPosition.x ? yt.red() : yt.blue()
    ), this.min.assign(this.initialPosition), this.max.assign(this.currentPosition), this.max.x < this.min.x) {
      const e = this.max.x;
      this.max.x = this.min.x, this.min.x = e;
    }
    if (this.max.y < this.min.y) {
      const e = this.max.y;
      this.max.y = this.min.y, this.min.y = e;
    }
    this._dim.assign(this.max), this._dim.subtract(this.min), this._updateRectangleVertices();
  }
  _updateRectangleVertices() {
    this._rectangle.setPosition(this.min), this._rectangle.setSize(this._dim);
  }
  activate(t) {
    this.initialPosition.assign(t), this.currentPosition.assign(t), this.min.assign(t), this.max.assign(t), this._dim.set(0, 0), this._rectangle.setStrokeWidth(1), this._updateRectangleVertices();
    const e = this._viewer.markupManager;
    this._markupHandle = e.registerMarkup(this, this._viewer.view);
  }
  deactivate() {
    this.initialPosition.set(0, 0), this.currentPosition.set(0, 0), this.min.set(0, 0), this.max.set(0, 0), this._dim.set(0, 0), this._rectangle.setStrokeWidth(0), this._updateRectangleVertices();
    const t = this._viewer.markupManager;
    this._markupHandle !== null && (t.unregisterMarkup(this._markupHandle, this._viewer.view), this._markupHandle = null), t.refreshMarkup(this._viewer.view);
  }
  isActive() {
    return this._markupHandle !== null;
  }
}
class hy extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._rectangleMarkup = new Pg(t, !0), this._computeTarget = !1, this._preserveViewAngle = !0;
  }
  /**
   * When enabled, the camera target will be computed using selection while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each zoom operation,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setComputeTarget(t) {
    this._computeTarget = t;
  }
  /**
   * Returns whether a new camera target will be computed using selection.
   * See [[setComputeTarget]]
   */
  getComputeTarget() {
    return this._computeTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If window zoom is being using in conjunction with mouse wheel zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  adjustPositionToPlane(t, e) {
    const n = this._view.getCamera().getViewMatrix(this._viewer), r = n.transform(e), o = n.transform(t);
    r.z = o.z;
    const l = wt.inverse(n);
    return l === null ? null : l.transform(r);
  }
  computeNewField(t, e, i) {
    const n = X.add(t, X.scale(X.subtract(e, t), 0.5)), r = new X(e.x, n.y), o = new X(n.x, e.y), l = new X(t.x, n.y), h = new X(n.x, t.y), u = this._view.getCamera(), f = u.getCameraPlaneIntersectionPoint(r, this._view), g = u.getCameraPlaneIntersectionPoint(o, this._view), y = u.getCameraPlaneIntersectionPoint(l, this._view), _ = u.getCameraPlaneIntersectionPoint(h, this._view);
    if (f === null || g === null || y === null || _ === null)
      return null;
    const x = this.adjustPositionToPlane(i, f), b = this.adjustPositionToPlane(i, g), I = this.adjustPositionToPlane(i, y), C = this.adjustPositionToPlane(i, _);
    if (x === null || b === null || I === null || C === null)
      return null;
    const M = m.subtract(x, I), P = m.subtract(b, C);
    return [M.length(), P.length()];
  }
  async computeReasonableTarget(t, e) {
    const i = X.add(t, X.scale(X.subtract(e, t), 0.5)), n = await this._view.pickFromPoint(i, new Pi());
    if (n.getNodeId() !== null)
      return n.getPosition();
    {
      let r = 0;
      const o = m.zero(), l = await this._view.beginScreenSelectByArea(
        t,
        e,
        new _d()
      );
      for (; ; ) {
        const f = await this._view.advanceIncrementalSelection(l);
        if (f === null)
          break;
        for (const g of f) {
          const y = g.getPosition();
          y !== null && (o.add(y), r++);
        }
      }
      let u = this._view.getCamera().getCameraPlaneIntersectionPoint(i, this._view);
      if (u === null)
        return null;
      if (r !== 0) {
        const f = m.scale(o, 1 / r);
        u = this.adjustPositionToPlane(f, u);
      }
      return u;
    }
  }
  async getCameraTarget(t, e) {
    if (this._computeTarget)
      return this.computeReasonableTarget(t, e);
    const i = this._view.getCamera(), n = X.add(t, X.scale(X.subtract(e, t), 0.5));
    return i.getCameraPlaneIntersectionPoint(n, this._view);
  }
  async doZoom(t, e) {
    const i = this._view.getCamera(), n = i.copy(), r = i.getTarget(), o = await this.getCameraTarget(t, e);
    if (o === null)
      return;
    const l = this.computeNewField(t, e, o);
    if (l === null)
      return;
    const [h, u] = l, f = this._view.getCanvasSize(), g = new X(0, 0), y = m.distance(
      i.getCameraPlaneIntersectionPoint(f, this._view),
      i.getCameraPlaneIntersectionPoint(g, this._view)
    );
    n.setWidth(h), n.setHeight(u), n.setTarget(o), this._viewer.pauseRendering(() => {
      this._view.setCamera(n);
      const _ = m.subtract(r, i.getPosition());
      let x;
      if (this._preserveViewAngle) {
        const b = m.distance(
          n.getCameraPlaneIntersectionPoint(f, this._view),
          n.getCameraPlaneIntersectionPoint(g, this._view)
        ), I = _.length() / y;
        x = m.add(
          o,
          m.scale(_.negate().normalize(), I * b)
        );
      } else
        x = m.subtract(o, _);
      n.setPosition(x), this._view.setCamera(n);
    });
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup(this._view));
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      const e = this._rectangleMarkup;
      if (e.updateCurrentPosition(t.getPosition()), X.subtract(e.max, e.min).length() <= 3) {
        e.deactivate();
        return;
      }
      t.setHandled(!0), await this.doZoom(e.min, e.max);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class uy extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._mouseMoveZoomDelta = 3, this._mouseWheelZoomDelta = 0.25, this._pinchZoomModifier = 2.5, this._zoomToMousePosition = !0, this._dollyZoomEnabled = !1, this._adjustCameraTarget = !1, this._preserveViewAngle = !0, this._mouseMoveZoomFactor = 1, this._mouseWheelZoomFactor = -1, this._secondaryTouchId = null, this._lastTouch1 = X.zero(), this._lastTouch2 = X.zero(), this._prevLen = 0;
  }
  /**
   * When true, scrolling up will zoom towards the model.
   * @param inverted
   */
  setMouseWheelZoomInverted(t) {
    t ? this._mouseWheelZoomFactor = -1 : this._mouseWheelZoomFactor = 1;
  }
  getMouseWheelZoomInverted() {
    return this._mouseWheelZoomFactor === -1;
  }
  /**
   * When true, moving the mouse up will zoom towards the model.
   * @param inverted
   */
  setMouseMoveZoomInverted(t) {
    t ? this._mouseMoveZoomFactor = -1 : this._mouseMoveZoomFactor = 1;
  }
  getMouseMoveZoomInverted() {
    return this._mouseMoveZoomFactor === -1;
  }
  /**
   * Sets the delta to zoom when moving the mouse
   * @param delta
   */
  setMouseMoveZoomDelta(t) {
    this._mouseMoveZoomDelta = t;
  }
  /**
   * Gets the mouse move zoom delta
   * @returns number
   */
  getMouseMoveZoomDelta() {
    return this._mouseMoveZoomDelta;
  }
  /**
   * Sets the delta to zoom when scrolling
   * @param delta
   */
  setMouseWheelZoomDelta(t) {
    this._mouseWheelZoomDelta = t;
  }
  /**
   * Gets the scrollwheel zoom delta
   * @returns number
   */
  getMouseWheelZoomDelta() {
    return this._mouseWheelZoomDelta;
  }
  /**
   * When set, the zoom will be towards the mouse position. When not set, the zoom will be from the center of the screen.
   * @param zoom
   */
  setZoomToMousePosition(t) {
    this._zoomToMousePosition = t;
  }
  /**
   * @returns boolean When true, the zoom will be towards the mouse position. When false, the zoom will be towards the center of the screen.
   */
  getZoomToMousePosition() {
    return this._zoomToMousePosition;
  }
  /**
   * When dolly zoom is enabled, the camera position will move towards the camera target when zooming.
   * @moveCameraPositon
   */
  setDollyZoomEnabled(t) {
    this._dollyZoomEnabled = t;
  }
  /**
   * Returns true if dolly zoom is enabled.
   */
  getDollyZoomEnabled() {
    return this._dollyZoomEnabled;
  }
  /**
   * When enabled, the camera target will be updated to the selection position while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each mouse scroll,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setMouseWheelAdjustCameraTarget(t) {
    this._adjustCameraTarget = t;
  }
  /**
   * Returns whether the camera target will be updated to the selection
   * position while zooming. See [[setMouseWheelAdjustCameraTarget]].
   */
  getMouseWheelAdjustCameraTarget() {
    return this._adjustCameraTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If mouse wheel zoom is being using in conjunction with window zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this.isDragging() && this.isActive()) {
      const e = this._view, i = e.pointToWindowPosition(this._ptCurrent), n = e.pointToWindowPosition(this._ptPrevious), r = i.y - n.y, o = i.x - n.x, l = this._mouseMoveZoomDelta * this._mouseMoveZoomFactor * (r - o);
      this._dollyZoomEnabled ? await this._dollyZoom(l, void 0, void 0, !0) : await this._doZoom(l);
    }
  }
  /** @hidden */
  async onMousewheel(t) {
    const e = this._mouseWheelZoomDelta * this._mouseWheelZoomFactor * t.getWheelDelta();
    this._dollyZoomEnabled ? await this._dollyZoom(-e, void 0, t.getPosition()) : await this._doZoom(e, void 0, t.getPosition());
  }
  /** @hidden */
  onTouchStart(t) {
    const e = this._view;
    this._primaryTouchId === null ? (this._primaryTouchId = t.getId(), this._lastTouch1.assign(e.pointToWindowPosition(t.getPosition()))) : this._secondaryTouchId === null && (this._secondaryTouchId = t.getId(), this._lastTouch2.assign(e.pointToWindowPosition(t.getPosition()))), this._primaryTouchId !== null && this._secondaryTouchId !== null && (this._prevLen = X.subtract(this._lastTouch2, this._lastTouch1).length(), this._dragging = !0);
  }
  /** @hidden */
  onTouchMove(t) {
    const e = this._view, i = t.getId(), n = t.getPosition();
    if (i === this._primaryTouchId ? this._lastTouch1.assign(e.pointToWindowPosition(n)) : i === this._secondaryTouchId && this._lastTouch2.assign(e.pointToWindowPosition(n)), this._dragging && (i === this._primaryTouchId || i === this._secondaryTouchId)) {
      const r = X.subtract(this._lastTouch2, this._lastTouch1).length(), l = 1 / (1 - (this._prevLen - r) * this._pinchZoomModifier);
      this._zoomHelper(l, this._view.getCamera()), this._prevLen = r;
    }
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    const e = t.getId();
    this._primaryTouchId === e ? this._primaryTouchId = null : this._secondaryTouchId === e && (this._secondaryTouchId = null), this._dragging = !1;
  }
  /** @hidden */
  onDeactivate() {
    this._primaryTouchId = null, this._secondaryTouchId = null;
  }
  _updateCameraViewAngle(t) {
    const e = Lo(90), i = Math.tan(e / 2), r = m.subtract(t.getTarget(), t.getPosition()).length() * i;
    return t.setWidth(r), t.setHeight(r), t;
  }
  async _dollyZoom(t, e = this._view.getCamera(), i, n = !1) {
    const r = this._view;
    e.setProjection(ri.Perspective);
    const o = e.getPosition(), l = e.getTarget();
    if (i) {
      const f = (await this._viewer.model.getModelBounding(!1, !1, !1)).extents().length() / 100, y = (await this._view.pickFromPoint(i, new Pi())).getPosition();
      if (y !== null) {
        const x = m.subtract(l, o), b = m.subtract(y, o), I = m.add(o, x.scale(m.dot(x, b) / m.dot(x, x)));
        e.setTarget(I);
      }
      let _ = m.subtract(e.getTarget(), o);
      t > 0 && _.length() < f && e.setTarget(
        m.add(
          l,
          _.copy().normalize().scale(f * 2)
        )
      ), _ = m.subtract(e.getTarget(), o), e.setPosition(m.add(o, _.copy().scale(t / 10)));
    } else {
      const h = m.subtract(l, o).scale(t / 10);
      e.setPosition(m.add(o, h)), n && e.setTarget(m.add(l, h));
    }
    e = this._updateCameraViewAngle(e), this._viewer.pauseRendering(() => {
      if (i) {
        const h = e.getCameraPlaneIntersectionPoint(i, this._view);
        r.setCamera(e);
        const u = e.getCameraPlaneIntersectionPoint(
          i,
          this._view
        );
        h !== null && u !== null && e.dolly(m.subtract(u, h));
      }
      r.setCamera(e);
    });
  }
  async _doZoom(t, e = this._view.getCamera(), i) {
    const n = this._view, r = Math.max(1 / (1 - t), 1e-3);
    if (i && this._zoomToMousePosition) {
      if (this._adjustCameraTarget) {
        const o = await this._view.pickFromPoint(i, new Pi());
        if (o !== void 0 && o.isEntitySelection()) {
          const l = e.getPosition().subtract(e.getTarget()), h = m.subtract(e.getTarget(), e.getPosition()), u = m.subtract(o.getPosition(), e.getPosition()), f = e.getPosition().add(h.scale(m.dot(h, u) / m.dot(h, h)));
          e.setTarget(f), e.setPosition(m.add(f, l));
        }
      }
      this._viewer.pauseRendering(() => {
        const o = e.getCameraPlaneIntersectionPoint(i, this._view);
        this._zoomHelper(r, e);
        const l = e.getCameraPlaneIntersectionPoint(
          i,
          this._view
        );
        o !== null && l !== null && e.dolly(m.subtract(l, o)), n.setCamera(e);
      });
    } else
      this._zoomHelper(r, e);
  }
  _zoomHelper(t, e) {
    const i = this._view;
    if (e.setWidth(e.getWidth() * t), e.setHeight(e.getHeight() * t), this._preserveViewAngle && !this._viewer.sheetManager.isDrawingSheetActive()) {
      const n = e.getPosition(), r = e.getTarget(), o = m.subtract(r, n).scale(t), l = m.subtract(r, o);
      e.setPosition(l);
    }
    i.setCamera(e);
  }
}
const ax = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CameraKeyboardWalkOperator: id,
  CameraNavigationOperator: ry,
  CameraOrbitBaseOperator: Sg,
  CameraOrbitOperator: Mg,
  CameraPanOperator: oy,
  CameraTurntableOperator: ay,
  CameraWalkBaseOperator: Cg,
  CameraWalkModeOperator: ly,
  CameraWalkOperator: cy,
  CameraWindowZoomOperator: hy,
  CameraZoomOperator: uy,
  DoorCache: iy,
  MAX_ANGLE: Y_,
  MAX_TILT: X_,
  MIN_ANGLE: Z_,
  MIN_TILT: J_,
  OrbitMarkup: sy,
  TimedPoints: ny,
  applyGravity: jf,
  buildCollisionRayConfig: Ig,
  clamp: Uf,
  getDownAxis: ty,
  normalizeDirections: Q_,
  removeOpposing: Qa,
  testWallCollision: ey
}, Symbol.toStringTag, { value: "Module" }));
var As = /* @__PURE__ */ ((s) => (s[s.NoPointsSelected = 0] = "NoPointsSelected", s[s.OnePointSelected = 1] = "OnePointSelected", s[s.TwoPointsSelected = 2] = "TwoPointsSelected", s))(As || {}), al = /* @__PURE__ */ ((s) => (s[s.First = 0] = "First", s[s.Last = 1] = "Last", s[s.Midpoint = 2] = "Midpoint", s))(al || {}), ll = /* @__PURE__ */ ((s) => (s[s.First = 0] = "First", s[s.Last = 1] = "Last", s[s.Midpoint = 2] = "Midpoint", s))(ll || {});
function Tu(s, t) {
  const e = new Ur(t.x, t.y, t.z, 1), i = new Ur(0, 0, 0, 0);
  s.getFullCameraMatrix().transform4(e, i);
  const n = 1 / i.w, r = new X(i.x * n, i.y * n), { x: o, y: l } = s.getCanvasSize();
  return r.x = 0.5 * o * (r.x + 1), r.y = 0.5 * l * (r.y + 1), r.x = Math.max(0, Math.min(r.x, o)), r.y = l - Math.max(0, Math.min(r.y, l)), r;
}
const Dc = class Dc extends Rn {
  constructor(t) {
    super(t), this._firstNode = null, this._firstPointShape = new $r(), this._secondPointShape = new $r(), this._arrowsInvert = !1, this._measurePoint1 = null, this._measurePoint2 = null, this._leaderPoint1 = null, this._leaderPoint2 = null, this._textPoint = null, this._name = "MeasureBodyBodyDistance", this._lineShapes = [];
    for (let e = 0; e < 6; e++)
      this._lineShapes.push(new es()), this._lineShapes[e].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = t, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new Tl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new yt(255, 255, 255));
  }
  initCircle(t) {
    t.setRadius(2.5), t.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  setFirstNode(t) {
    this._stage = 1, this._firstNode = t;
  }
  getFirstNode() {
    return this._firstNode;
  }
  async setSecondNode(t) {
    if (this._firstNode === null)
      return;
    this._stage = 2;
    const e = await this._viewer.model.computeMinimumBodyBodyDistance(
      this._firstNode,
      t
    );
    this._measurePoint1 = e.pos1.copy(), this._measurePoint2 = e.pos2.copy(), this._textPoint = e.pos2.copy(), this._setMeasurementValue(e.distance);
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  // adjusts the position of the measurement just before it's finalized
  adjust(t) {
    if (super.adjust(t), this._stage < 2)
      return;
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null || this._measurePoint1 === null || this._measurePoint2 === null || this._textPoint == null)
      return;
    let i = new m(1, 0, 0);
    this._measurePoint2.equals(this._measurePoint1) || (i = m.subtract(this._measurePoint2, this._measurePoint1));
    const r = this._viewer.view.getCamera().getUp(), o = m.cross(e.direction, r).normalize(), l = new m(
      (this._measurePoint1.x + this._measurePoint2.x) / 2,
      (this._measurePoint1.y + this._measurePoint2.y) / 2,
      (this._measurePoint1.z + this._measurePoint2.z) / 2
    ), h = new m(l.x + r.x, l.y + r.y, l.z + r.z), u = new m(
      l.x + o.x,
      l.y + o.y,
      l.z + o.z
    ), f = new m(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    );
    let g = new m(0, 0, 0);
    Vo(
      e.origin,
      f,
      l,
      h,
      u,
      g
    ), this._textPoint.assign(g);
    let y = new m(0, 0, 0);
    Math.abs(i.x) <= Math.abs(i.y) && Math.abs(i.x) <= Math.abs(i.z) ? y = new m(1, 0, 0) : Math.abs(i.y) <= Math.abs(i.x) && Math.abs(i.y) <= Math.abs(i.z) ? y = new m(0, 1, 0) : y = new m(0, 0, 1);
    const _ = m.cross(y, i), x = m.cross(_, i);
    _.set(
      this._measurePoint1.x + _.x,
      this._measurePoint1.y + _.y,
      this._measurePoint1.z + _.z
    ), x.set(
      this._measurePoint1.x + x.x,
      this._measurePoint1.y + x.y,
      this._measurePoint1.z + x.z
    );
    const b = new m(
      g.x + i.x * 1e4,
      g.y + i.y * 1e4,
      g.z + i.z * 1e4
    ), I = new m(
      g.x - i.x * 1e4,
      g.y - i.y * 1e4,
      g.z - i.z * 1e4
    ), C = Vo(
      b,
      I,
      this._measurePoint1,
      _,
      x,
      g
    ), M = !isNaN(g.x) && !isNaN(g.y) && !isNaN(g.z);
    (!C || !M) && (g = this._measurePoint2.copy());
    const P = m.subtract(g, this._measurePoint1);
    this._leaderPoint1 = new m(
      this._measurePoint1.x + P.x,
      this._measurePoint1.y + P.y,
      this._measurePoint1.z + P.z
    ), this._leaderPoint2 = new m(
      this._measurePoint2.x + P.x,
      this._measurePoint2.y + P.y,
      this._measurePoint2.z + P.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    if (this._leaderPoint1 === null || this._leaderPoint2 === null || this._textPoint === null)
      return;
    const t = new m(
      (this._leaderPoint1.x + this._leaderPoint2.x) / 2,
      (this._leaderPoint1.y + this._leaderPoint2.y) / 2,
      (this._leaderPoint1.z + this._leaderPoint2.z) / 2
    ), e = m.subtract(this._leaderPoint2, this._leaderPoint1);
    m.subtract(this._textPoint, t).length() * 2 > e.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  // Called as part of drawing the markup. Sets line positions and determines if the markup is in view
  update() {
    if (super.update(), this._stage <= 1)
      return;
    const t = this._viewer.view;
    this._behindView = !1;
    const e = (h) => {
      if (h === null)
        return X.zero();
      const u = t.projectPoint(h);
      return u.z <= 0 && (this._behindView = !0), X.fromPoint3(u);
    }, i = e(this._measurePoint1), n = e(this._measurePoint2), r = e(this._textPoint), o = e(this._leaderPoint1), l = e(this._leaderPoint2);
    this._firstPointShape.setCenter(i), this._textShape && this._textShape.setPosition(r), this._secondPointShape.setCenter(n), this._lineShapes[0].set(i, n), this._lineShapes[1].set(o, l), this._lineShapes[2].set(i, o), this._lineShapes[3].set(n, l), this._lineShapes[4].set(o, r), this._lineShapes[5].set(o, l), this._lineShapes[5].setEndcapType(yn.Arrowhead), this._lineShapes[5].setStartEndcapType(yn.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert);
  }
  draw() {
    if (!this._visibility || this._viewer.explodeManager.getMagnitude() !== 0 || (this.update(), this._behindView))
      return;
    const t = this._viewer.markupManager.getRenderer();
    if (this._stage === 2 || this._stage === 3) {
      t.drawCircle(this._firstPointShape), t.drawCircle(this._secondPointShape);
      for (const e of this._lineShapes) t.drawLine(e);
      t.drawTextBox(this._textShape);
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._measurePoint1,
      measurePoint2: this._measurePoint2,
      leaderPoint1: this._leaderPoint1,
      leaderPoint2: this._leaderPoint2,
      textPoint: this._textPoint,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureBodyBodyDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Dc(e);
    return n._name = i.name, n._measurePoint1 = m.fromJson(i.measurePoint1), n._measurePoint2 = m.fromJson(i.measurePoint2), n._textPoint = m.fromJson(i.textPoint), n._textShape.setTextString(i.text), n._leaderPoint1 = m.fromJson(i.leaderPoint1), n._leaderPoint2 = m.fromJson(i.leaderPoint2), n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._updateArrowsInverted(), n._stage = 2, n;
  }
  getClassName() {
    return Dc.className;
  }
};
Dc.className = "Communicator.Markup.Measure.MeasureBodyBodyDistanceMarkup";
let yl = Dc;
us(
  yl.className,
  yl.fromJson
);
class dy extends Oi {
  constructor(t, e, i) {
    super(t, e), this._moveSelectionAction = new fo(!0), this._currentMoveHighlight = null, this._currentSelectHighlight = null, this._markup = null, this._measureManager = i;
  }
  _unsetCurrentMoveHighlight() {
    this._currentMoveHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentMoveHighlight.getNodeId()], !1), this._currentMoveHighlight = null);
  }
  _unsetCurrentSelectionHighlight() {
    this._currentSelectHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentSelectHighlight.getNodeId()], !1), this._currentSelectHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Pi());
    if (n.overlayIndex() !== 0 || !n.isNodeSelection()) {
      this._unsetCurrentMoveHighlight();
      return;
    }
    const r = n.getNodeId();
    if (!(r === null || i.getNodeType(r) !== Le.BodyInstance)) {
      if (this._markup) {
        const o = this._markup.getFirstNode();
        if (o !== null && r === o)
          return;
      }
      this._currentMoveHighlight !== null ? n.equals(this._currentMoveHighlight) ? n.getSelectionType() === On.None && this._unsetCurrentMoveHighlight() : (this._unsetCurrentMoveHighlight(), this._currentMoveHighlight = n, i.setNodesHighlighted([r], !0)) : (this._currentMoveHighlight = n, i.setNodesHighlighted([r], !0));
    }
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Pi());
    if (n.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() === 1 && this._viewer.trigger("measurementBegin"), this._markup && this._markup._getStage() > 1) {
      const o = this._markup;
      this._markup = null, o.finalize(), this._measureManager.finalizeMeasurement(o);
      return;
    }
    const r = n.getNodeId();
    r !== null && i.getNodeType(r) === Le.BodyInstance && (!this._markup || this._markup._getStage() <= 1) && (this._unsetCurrentMoveHighlight(), this._markup ? (this._unsetCurrentSelectionHighlight(), await this._markup.setSecondNode(r), this._markup.adjust(t)) : (this._markup = new yl(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstNode(r), n.isNodeSelection() && (this._unsetCurrentSelectionHighlight(), this._currentSelectHighlight = n, this._viewer.model.setNodesHighlighted([r], !0)), this._measureManager.addMeasurement(this._markup)));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  async onMouseUp(t) {
    await this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && (this._markup !== null ? (this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentMoveHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup = null);
  }
}
const rd = class rd extends Rn {
  /** @hidden */
  constructor(t) {
    super(t), this._lineEdgeShape = new La(), this._linePositions = [], this._name = "MeasureLength", this._positions = [], this._lineShapes = [], this._lineEdgeShape.setStrokeWidth(4), this._lineEdgeShape.setStrokeColor(t.measureManager.getMeasurementEdgeColor());
  }
  setLineGeometry(t) {
    this._linePositions = t, this._stage = 1;
  }
  setMeasurementEdgeColor(t) {
    this._lineEdgeShape.setStrokeColor(t);
  }
  reset() {
    this._stage = 0;
  }
  adjust(t) {
    super.adjust(t);
  }
  draw() {
  }
  getLineEdgeShape() {
    return this._lineEdgeShape;
  }
  //serialization methods
  getClassName() {
    return rd.className;
  }
};
rd.className = "Communicator.Markup.Measure.MeasureLengthMarkup";
let ah = rd;
const Nc = class Nc extends ah {
  constructor(t, e, i, n) {
    super(t), this._circlePoints = [], this._radius = 0, this._surfaceCenter = m.zero(), this._circlePlane = new ln(), this._arrowsInvert = !1, this._name = "MeasureCircleEdgeLength", this._lineProperties = e, this._matrix = i.copy(), this._unitMultiplier = n, this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new yt(255, 255, 255));
    const o = t.measureManager.getMeasurementColor();
    for (let l = 0; l < 5; l++)
      this._lineShapes.push(new es()), this._lineShapes[l].setStrokeColor(o), this._lineShapes[l].setEndEndcapColor(o), this._lineShapes[l].setStartEndcapColor(o);
  }
  createCircleData() {
    nv(
      this._circlePoints,
      this._lineProperties.origin,
      this._lineProperties.radius,
      32,
      this._lineProperties.normal
    ), this._matrix.transformArray(this._circlePoints, this._circlePoints), this._positions[0] = this._circlePoints[0].copy(), this._positions[1] = this._circlePoints[16].copy();
    const t = new m(this._lineProperties.radius, 0, 0), e = new m(0, 0, 0);
    this._matrix.transform(t, t), this._matrix.transform(e, e);
    let i = m.subtract(e, t);
    this._radius = i.length(), i = m.subtract(this._positions[1], this._positions[0]), this._positions[4] = this._positions[1].copy(), this._surfaceCenter = this._matrix.transform(this._lineProperties.origin);
    const n = new m(
      this._circlePoints[0].x,
      this._circlePoints[0].y,
      this._circlePoints[0].z
    ), r = new m(
      this._circlePoints[1].x,
      this._circlePoints[1].y,
      this._circlePoints[1].z
    );
    this._circlePlane = ln.createFromPoints(n, r, this._surfaceCenter);
  }
  setLineGeometry(t) {
    if (super.setLineGeometry(t), this._positions[0] = this._linePositions[0], this._positions[0].equals(this._positions[this._positions.length - 1])) {
      const e = Math.floor(this._positions.length / 2);
      this._positions[1] = this._positions[e];
    } else
      this._positions[1] = this._linePositions[this._linePositions.length - 1];
    this._positions[1] = this._linePositions[this._linePositions.length - 1], this._positions[2] = this._linePositions[1].copy(), this.createCircleData(), this._setMeasurementValue(this._radius);
  }
  adjust(t) {
    super.adjust(t);
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = this._surfaceCenter, n = this._circlePlane;
    let r = n.rayIntersection(e);
    if (r === null) {
      const u = m.add(i, e.direction.copy().scale(-2 * this._radius)), g = ln.createFromPointAndNormal(u, e.direction).rayIntersection(e);
      console.assert(g !== null);
      const y = new vr(g, n.normal);
      r = n.rayIntersection(y), r === null && (r = n.rayIntersection(y.negate()));
    }
    r === null && (console.assert(!1), r = i.copy());
    const o = m.subtract(r, i).normalize().scale(this._radius), l = m.add(i, o), h = m.subtract(i, o);
    this._positions[0] = l, this._positions[1] = h, this._positions[2] = l.copy(), this._positions[3] = h.copy(), this._positions[4] = r.copy(), this._positions[5] = this._surfaceCenter.copy(), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = new m(
      (this._positions[4].x + this._positions[5].x) / 2,
      (this._positions[4].y + this._positions[5].y) / 2,
      (this._positions[4].z + this._positions[5].z) / 2
    ), e = m.subtract(this._positions[5], this._positions[4]), i = m.subtract(this._positions[2], t);
    this._arrowsInvert = i.length() * 2 > e.length();
  }
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      for (const e of this._linePositions) {
        const i = X.fromPoint3(t.projectPoint(e));
        this._lineEdgeShape.pushPoint(i);
      }
    }
    if (this._stage > 1) {
      const e = new Array(6);
      for (let i = 0; i < this._positions.length; i++)
        e[i] = X.fromPoint3(t.projectPoint(this._positions[i]));
      this._textShape && this._textShape.setPosition(e[4]), this._lineShapes[0].set(e[5], e[2]), this._lineShapes[1].set(e[5], e[4]), this._lineShapes[0].setEndcapType(yn.Arrowhead), this._lineShapes[0].setStartEndcapType(yn.None), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert);
    }
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0) {
      this.update();
      const e = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          e.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (let i = 0; i < 2; i++) e.drawLine(this._lineShapes[i]);
          e.drawTextBox(this._textShape), e.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = Rn._serializePointArray(this._linePositions), e = Rn._serializePointArray(this._positions);
    return {
      matrix: this._matrix.toJson(),
      lineOrigin: this._lineProperties.origin,
      lineRadius: this._lineProperties.radius,
      lineNormal: this._lineProperties.normal,
      linePositions: t,
      positions: e,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureCircleEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = wt.fromJson(i.matrix), r = i.lineRadius, o = m.fromJson(i.lineOrigin), l = m.fromJson(i.lineNormal), h = new kl(r, o, l), u = i.unitMultiplier || 1, f = new Nc(
      e,
      h,
      n,
      u
    ), g = Rn._constructPointArray(i.linePositions), y = Rn._constructPointArray(i.positions);
    return f.setLineGeometry(g), f._positions = y, f._textShape.setTextString(i.text), f._stage = 3, f._measurementValue = i.measurementValue, f;
  }
  getClassName() {
    return Nc.className;
  }
};
Nc.className = "Communicator.Markup.Measure.MeasureCircleEdgeLengthMarkupMeasureMarkup";
let wl = Nc;
us(
  wl.className,
  wl.fromJson
);
const Oc = class Oc extends ah {
  /** @hidden */
  constructor(t, e, i, n) {
    super(t), this._lineProperties = null, this._worldSpaceLength = 0, this._arrowsInvert = !1, this._name = "MeasureStraightEdgeLength", this._lineProperties = e, this._matrix = i.copy(), this._matrix.setTranslationComponent(0, 0, 0), this._unitMultiplier = n;
    const o = this._viewer.measureManager.getMeasurementColor();
    for (let h = 0; h < 5; h++) {
      const u = new es();
      u.setStrokeColor(o), u.setEndEndcapColor(o), u.setStartEndcapColor(o), this._lineShapes.push(u);
    }
    const l = this._textShape.getBoxPortion();
    l.setFillOpacity(1), l.setFillColor(new yt(255, 255, 255));
  }
  /** @hidden */
  setLineGeometry(t) {
    super.setLineGeometry(t), this._positions[0] = this._linePositions[0], this._positions[2] = this._linePositions[0].copy(), this._positions[1] = this._linePositions[this._linePositions.length - 1];
    let e;
    if (this._lineProperties !== null && this._lineProperties.length !== -1) {
      const i = new m(this._lineProperties.length, 0, 0);
      this._matrix.transform(i, i), this._worldSpaceLength = i.length(), e = this._worldSpaceLength;
    } else
      e = m.subtract(this._positions[1], this._positions[0]).length();
    this._setMeasurementValue(e);
  }
  /** @hidden */
  adjust(t) {
    super.adjust(t);
    const e = this._viewer.view, i = e.raycastFromPoint(t);
    if (i === null)
      return;
    const n = this._positions[0], r = this._positions[1];
    let o = new m(1, 0, 0);
    r.equals(n) || (o = m.subtract(r, n));
    const h = e.getCamera().getUp(), u = m.cross(i.direction, h).normalize(), f = m.add(n, r).scale(0.5), g = m.add(f, h), y = m.add(f, u), _ = m.add(m.scale(i.direction, 1e6), i.origin), x = new m(0, 0, 0);
    Vo(i.origin, _, f, g, y, x), this._positions[2].assign(x);
    let b = new m(0, 0, 0);
    Math.abs(o.x) <= Math.abs(o.y) && Math.abs(o.x) <= Math.abs(o.z) ? b = new m(1, 0, 0) : Math.abs(o.y) <= Math.abs(o.x) && Math.abs(o.y) <= Math.abs(o.z) ? b = new m(0, 1, 0) : b = new m(0, 0, 1);
    const I = m.cross(b, o), C = m.cross(I, o);
    I.add(n), C.add(n);
    const M = m.add(m.scale(o, 1e4), x), P = m.add(m.scale(o, -1e4), x);
    Vo(M, P, n, I, C, x);
    const O = m.subtract(x, n);
    this._positions[3] = m.add(n, O), this._positions[4] = m.add(r, O), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = m.add(this._positions[3], this._positions[4]).scale(0.5), e = m.subtract(this._positions[4], this._positions[3]), i = m.subtract(this._positions[2], t);
    this._arrowsInvert = 2 * i.squaredLength() > e.squaredLength();
  }
  /** @hidden */
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._behindView = !1, this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      const e = Array(this._linePositions.length);
      for (let i = 0; i < this._linePositions.length; i++)
        e[i] = t.projectPoint(this._linePositions[i]), e[i].z <= 0 && (this._behindView = !0), this._lineEdgeShape.pushPoint(X.fromPoint3(e[i]));
    }
    if (this._stage > 1) {
      const e = new Array(6), i = Array(6);
      for (let n = 0; n < this._positions.length; n++)
        i[n] = t.projectPoint(this._positions[n]), i[n].z <= 0 && (this._behindView = !0), e[n] = X.fromPoint3(i[n]);
      this._textShape && this._textShape.setPosition(e[2]), this._lineShapes[0].set(e[3], e[4]), this._lineShapes[1].set(e[0], e[3]), this._lineShapes[2].set(e[1], e[4]), this._lineShapes[3].set(e[3], e[2]), this._lineShapes[4].set(e[3], e[4]), this._lineShapes[4].setEndcapType(yn.Arrowhead), this._lineShapes[4].setStartEndcapType(yn.Arrowhead), this._lineShapes[4].setEndcapsInverted(this._arrowsInvert);
    }
  }
  /** @hidden */
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const t = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          t.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (const e of this._lineShapes) t.drawLine(e);
          t.drawTextBox(this._textShape), t.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName(),
      matrix: this._matrix.toJson()
    };
  }
  /**
   * Creates a new [[MeasureStraightEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = wt.fromJson(i.matrix), r = i.unitMultiplier || 1, o = new Oc(e, null, n, r);
    return o._name = i.name, o._positions[0] = m.fromJson(i.measurePoint1), o._positions[1] = m.fromJson(i.measurePoint2), o._positions[2] = m.fromJson(i.textPoint), o._textShape.setTextString(i.text), o._positions[3] = m.fromJson(i.leaderPoint1), o._positions[4] = m.fromJson(i.leaderPoint2), o._measurementValue = i.measurementValue, o._updateArrowsInverted(), o._stage = 2, o;
  }
  getClassName() {
    return Oc.className;
  }
};
Oc.className = "Communicator.Markup.Measure.MeasureStraightEdgeLengthMarkup";
let lh = Oc;
class fy extends Oi {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._pickConfig = new Pi(Pe.Line), this._moveSelectionAction = new fo(!0), this._lengthMarkup = null, this._edgeMarkup = null, this._measureManager = i, this._pickConfig.restrictLinesAndPointsToSelectedFaceInstances = !1;
  }
  /** @hidden */
  onActivate() {
    this._edgeMarkup === null && (this._edgeMarkup = new lh(this._viewer, null, new wt(), 1));
  }
  _unregisterEdgeMarkup() {
    if (this._edgeMarkup === null)
      return;
    const t = this._edgeMarkup._getId();
    t !== "" && (this._viewer.markupManager.unregisterMarkup(t, this._viewer.view), this._edgeMarkup._setId(""));
  }
  _registerEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup._setId(
      this._viewer.markupManager.registerMarkup(this._edgeMarkup, this._viewer.view)
    ));
  }
  _resetEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup.reset());
  }
  async _performMoveSelection(t, e) {
    const n = await this._view.pickFromPoint(t, this._pickConfig), r = n.getNodeId(), o = n.getLineEntity();
    r && o && !o.isCappingGeometry() && n.overlayIndex() === 0 && await this._viewer.model.isLineMeasurable(r, o.getLineId()) ? (e.setLineGeometry(o.getPoints()), this._registerEdgeMarkup()) : this._resetEdgeMarkup();
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, this._pickConfig);
    if (n.overlayIndex())
      return;
    if (this._lengthMarkup && this._lengthMarkup._getStage() === 2) {
      const f = this._lengthMarkup;
      this._lengthMarkup = null, f._nextStage(), this._measureManager.finalizeMeasurement(f);
      return;
    }
    if (this._lengthMarkup || !n.isLineSelection())
      return;
    const r = n.getNodeId();
    if (!r)
      return;
    const o = n.getLineEntity();
    if (!await this._viewer.model.isLineMeasurable(r, o.getLineId()))
      return;
    const h = i.getNodeUnitMultiplier(r), u = await i.getEdgeProperty(r, o.getLineId());
    if (this._viewer.trigger("measurementBegin"), !!u) {
      if (u instanceof fh || u instanceof zo) {
        const f = i.getNodeNetMatrix(r);
        this._lengthMarkup = new lh(
          this._viewer,
          u,
          f,
          h
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      } else if (u instanceof kl) {
        const f = i.getNodeNetMatrix(r);
        this._lengthMarkup = new wl(
          this._viewer,
          u,
          f,
          h
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      }
      this._lengthMarkup._getStage() === 2 && this._viewer.trigger("measurementValueSet", this._lengthMarkup);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._edgeMarkup;
    if (e === null)
      return;
    e.setMeasurementEdgeColor(this._viewer.measureManager.getMeasurementEdgeColor());
    const i = t.getPosition();
    this.isDragging() && this._primaryTouchId === null ? this._resetEdgeMarkup() : (this._lengthMarkup === null && this._moveSelectionAction.set(() => this._performMoveSelection(i, e)), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._lengthMarkup !== null && this._lengthMarkup._getStage() > 0 && this._lengthMarkup.adjust(i));
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._lengthMarkup !== null;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && (this._lengthMarkup !== null ? (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null) : this._measureManager.removeLastMeasurement(), this._edgeMarkup !== null && this._resetEdgeMarkup());
  }
  /** @hidden */
  setHandled() {
    return this._lengthMarkup !== null;
  }
  /** @hidden */
  onDeactivate() {
    this._lengthMarkup !== null && (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null), this._edgeMarkup !== null && this._resetEdgeMarkup();
  }
}
const jp = 30, Rc = class Rc extends Rn {
  constructor(t) {
    super(t), this._faceSelection = [], this._arcArray = [], this._lineGeometryShape = new La(), this.planeIntersectionLine = [], this._pointOnLine = m.zero(), this._clickpointOriginal2 = m.zero(), this._clickpointOriginal1 = m.zero(), this._plane1 = new ln(), this._plane2 = new ln(), this._secondPoint = m.zero(), this._firstPoint = m.zero(), this._textPos = m.zero(), this._intermediatePoint = m.zero(), this._textAnchorPoint = m.zero(), this._angle = 0, this._useAuthoredNormals = !0, this._name = "MeasureFaceFaceAngle";
    const i = this._viewer.measureManager.getMeasurementColor();
    this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(i), this._lineGeometryShape.setEndEndcapColor(i), this._lineGeometryShape.setStartEndcapColor(i), this._textShape = new Tl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new yt(255, 255, 255));
    for (let n = 0; n < 5; n++)
      this._lineShapes.push(new es()), this._lineShapes[n].setStrokeColor(i), this._lineShapes[n].setEndEndcapColor(i), this._lineShapes[n].setStartEndcapColor(i);
  }
  async _getNormalAndPositionFromSelection(t, e, i) {
    const n = t.getNodeId(), r = t.getFaceEntity().getCadFaceIndex();
    i.assign(t.getPosition().copy()), e.assign(t.getFaceEntity().getNormal());
    const o = await this._viewer.model.getFaceProperty(n, r);
    if (this._useAuthoredNormals && o !== null && o instanceof $i) {
      const h = this._viewer.model.getNodeNetMatrix(n).normalMatrix();
      h !== null && h.transform(o.normal, e);
    }
  }
  getFirstSelection() {
    return this._faceSelection[0];
  }
  async setFirstFace(t) {
    const e = t.getNodeId(), i = t.getFaceEntity().getCadFaceIndex();
    this._viewer.model.setNodeFaceColor(e, i, new yt(255, 0, 0)), this._faceSelection.push(t);
    const n = m.zero(), r = m.zero();
    await this._getNormalAndPositionFromSelection(t, n, r), this._firstPoint = r.copy(), this._plane1.setFromPointAndNormal(this._firstPoint, n), this._clickpointOriginal1 = t.getPosition().copy(), this._stage++;
  }
  async setSecondFace(t) {
    const e = t.getNodeId(), i = t.getFaceEntity().getCadFaceIndex();
    this._faceSelection[1] = t, this._viewer.model.setNodeFaceColor(e, i, new yt(255, 0, 0));
    const n = m.zero(), r = m.zero();
    if (await this._getNormalAndPositionFromSelection(t, r, n), this._secondPoint = n.copy(), this._plane2.setFromPointAndNormal(this._secondPoint, r), this.planeIntersectionLine[0] = new m(0, 0, 0), this.planeIntersectionLine[1] = new m(0, 0, 0), ev(
      this._plane1,
      this._firstPoint,
      this._plane2,
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1]
    ) !== 2) return !1;
    const l = m.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    l.normalize(), this.planeIntersectionLine[0].set(
      this.planeIntersectionLine[0].x - l.x * 100,
      this.planeIntersectionLine[0].y - l.y * 100,
      this.planeIntersectionLine[0].z - l.z * 100
    ), this.planeIntersectionLine[1].set(
      this.planeIntersectionLine[1].x + l.x * 100,
      this.planeIntersectionLine[1].y + l.y * 100,
      this.planeIntersectionLine[1].z + l.z * 100
    ), io(
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1],
      this._pointOnLine
    );
    const h = new m(0, 0, 0), u = new m(0, 0, 0);
    h.set(
      this._firstPoint.x + l.x,
      this._firstPoint.y + l.y,
      this._firstPoint.z + l.z
    ), io(this._pointOnLine, this._firstPoint, h, u), this._firstPoint = u.copy(), this._clickpointOriginal2 = t.getPosition().copy();
    const f = new wt(), g = m.subtract(this._secondPoint, this._pointOnLine), y = g.length(), _ = m.subtract(this._firstPoint, this._pointOnLine);
    if (_.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + _.x * y,
      this._pointOnLine.y + _.y * y,
      this._pointOnLine.z + _.z * y
    ), this._angle = wr(g, _), this._angle === 0) return !1;
    this._measurementValue = this._angle, this._textShape.setTextString(`${this._measurementValue.toFixed(2)}°`), this._viewer.trigger("measurementValueSet", this), this._textPos = this._pointOnLine.copy();
    let x = !1, b = new m(0, 0, 0);
    const I = new m(0, 0, 0);
    rc(l, 1, f), f.transform(g, I), b.set(I.x + this._pointOnLine.x, I.y + this._pointOnLine.y, I.z + this._pointOnLine.z), b = m.subtract(b, this._firstPoint);
    const C = b.length();
    return rc(l, -1, f), f.transform(g, I), b.set(I.x + this._pointOnLine.x, I.y + this._pointOnLine.y, I.z + this._pointOnLine.z), m.subtract(b, this._firstPoint), b.length() < C && (x = !0), this._arcArray = mf(
      l,
      x ? -this._angle : this._angle,
      this._pointOnLine,
      g,
      jp
    ), this._stage++, !0;
  }
  adjust(t) {
    if (super.adjust(t), this._stage <= 1) return;
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = new m(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    ), n = new m(0, 0, 0);
    Vo(
      e.origin,
      i,
      this._pointOnLine,
      this._firstPoint,
      this._secondPoint,
      n
    ), this._textPos = n.copy();
    let r = new m(0, 0, 0);
    r = m.subtract(n, this._pointOnLine);
    const o = r.length();
    r = m.subtract(this._secondPoint, this._pointOnLine), r.normalize(), this._secondPoint.set(
      this._pointOnLine.x + r.x * o,
      this._pointOnLine.y + r.y * o,
      this._pointOnLine.z + r.z * o
    );
    const l = m.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    l.normalize();
    const h = new wt(), u = m.subtract(this._secondPoint, this._pointOnLine), f = u.length(), g = m.subtract(this._firstPoint, this._pointOnLine);
    g.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + g.x * f,
      this._pointOnLine.y + g.y * f,
      this._pointOnLine.z + g.z * f
    );
    let y = !1, _ = new m(0, 0, 0);
    const x = new m(0, 0, 0);
    rc(l, 1, h), h.transform(u, x), _.set(x.x + this._pointOnLine.x, x.y + this._pointOnLine.y, x.z + this._pointOnLine.z), _ = m.subtract(_, this._firstPoint);
    const b = _.length();
    rc(l, -1, h), h.transform(u, x), _.set(x.x + this._pointOnLine.x, x.y + this._pointOnLine.y, x.z + this._pointOnLine.z), _ = m.subtract(_, this._firstPoint), _.length() < b && (y = !0), this._arcArray = mf(
      l,
      y ? -this._angle : this._angle,
      this._pointOnLine,
      u,
      jp
    );
    let C;
    const M = this._viewer.view.projectPoint(this._textPos);
    for (const P of this._arcArray) {
      const O = this._viewer.view.projectPoint(P), j = new m(
        M.x - O.x,
        M.y - O.y,
        M.z - O.z
      ).length();
      (C === void 0 || C > j) && (C = j);
    }
    if (C === void 0 || C <= 20)
      this._textAnchorPoint = this._textPos;
    else {
      const P = this._viewer.view.projectPoint(this._intermediatePoint), O = this._viewer.view.projectPoint(this._secondPoint), B = new m(
        P.x - M.x,
        P.y - M.y,
        P.z - M.z
      ), j = new m(
        O.x - M.x,
        O.y - M.y,
        O.z - M.z
      ), F = B.length(), K = j.length();
      F < K ? this._textAnchorPoint = this._intermediatePoint : this._textAnchorPoint = this._secondPoint;
    }
  }
  _nextStage() {
    this._stage++, this._stage > 2 && (this._finalized = !0, this.cleanup());
  }
  cleanup() {
    const t = (e) => {
      const i = this._faceSelection[e];
      this._viewer.model.unsetNodeFaceColor(
        i.getNodeId(),
        i.getFaceEntity().getCadFaceIndex()
      );
    };
    this._stage >= 2 && t(1), this._stage >= 1 && t(0);
  }
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._stage > 1) {
      this._lineGeometryShape.clearPoints();
      for (const n of this._arcArray)
        this._lineGeometryShape.pushPoint(X.fromPoint3(t.projectPoint(n)));
      this._lineGeometryShape.setEndcapType(yn.Arrowhead), this._lineGeometryShape.setStartEndcapType(yn.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5);
      const e = new Array(10);
      e[0] = t.projectPoint(this._textPos), e[1] = t.projectPoint(this._firstPoint), e[2] = t.projectPoint(this._clickpointOriginal1), e[3] = t.projectPoint(this._secondPoint), e[4] = t.projectPoint(this._clickpointOriginal2), e[5] = t.projectPoint(this._intermediatePoint), e[6] = t.projectPoint(this._textAnchorPoint), this._behindView = !1;
      const i = new Array(10);
      for (let n = 0; n <= 6; n++)
        e[n].z <= 0 && (this._behindView = !0), i[n] = X.fromPoint3(e[n]);
      this._textShape && this._textShape.setPosition(i[0]), this._lineShapes[0].set(i[1], i[2]), this._lineShapes[1].set(i[1], i[5]), this._lineShapes[2].set(i[3], i[4]), this._lineShapes[3].set(i[6], i[0]);
    }
  }
  draw() {
    const t = this._viewer.explodeManager.getMagnitude() !== 0;
    if (!(!this._visibility || t) && (this.update(), !this._behindView && this._stage >= 2 && this._stage <= 4)) {
      const e = this._viewer.markupManager.getRenderer();
      for (let i = 0; i < 4; i++)
        e.drawLine(this._lineShapes[i]);
      e.drawTextBox(this._textShape), e.drawPolyline(this._lineGeometryShape);
    }
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(t) {
    this._useAuthoredNormals = t;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
  // selection methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._arcArray) {
      const i = e.toJson();
      t.push(i);
    }
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      arcArray: t,
      firstPoint: this._firstPoint.toJson(),
      clickpointOriginal1: this._clickpointOriginal1.toJson(),
      secondPoint: this._secondPoint.toJson(),
      clickpointOriginal2: this._clickpointOriginal2.toJson(),
      intermediatePoint: this._intermediatePoint.toJson(),
      textAnchorPoint: this._textAnchorPoint.toJson(),
      measurementValue: this._measurementValue,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceAngleMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Rc(e);
    for (const r of i.arcArray) {
      const o = m.fromJson(r);
      n._arcArray.push(o);
    }
    return n._textShape.setTextString(i.text), n._textPos.assign(m.fromJson(i.textPos)), n._firstPoint.assign(m.fromJson(i.firstPoint)), n._clickpointOriginal1 = m.fromJson(i.clickpointOriginal1), n._secondPoint.assign(m.fromJson(i.secondPoint)), n._clickpointOriginal2 = m.fromJson(i.clickpointOriginal2), n._intermediatePoint.assign(m.fromJson(i.intermediatePoint)), n._textAnchorPoint.assign(m.fromJson(i.textAnchorPoint)), n._measurementValue = i.measurementValue, n._stage = 3, n;
  }
  // serialization methods
  getClassName() {
    return Rc.className;
  }
};
Rc.className = "Communicator.Markup.Measure.MeasureFaceFaceAngleMarkup";
let vl = Rc;
us(vl.className, vl.fromJson);
async function lf(s, t) {
  if (t.getSelectionType() !== On.None) {
    const e = t.getNodeId(), i = t.getFaceEntity();
    return await s.isFaceMeasurable(e, i.getCadFaceIndex()) ? (i.getCadFaceBits() & t_.SelectionBitsFacePlanar) !== 0 : !1;
  }
  return !1;
}
class gy extends Oi {
  constructor(t, e, i) {
    super(t, e), this._moveSelectionAction = new fo(!0), this._currentHighlight = null, this._markup = null, this._useAuthoredNormals = !0, this._measureManager = i;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Pi());
    if (n.overlayIndex() !== 0 || !n.isFaceSelection())
      return;
    const r = n.getNodeId(), o = n.getFaceEntity();
    if (i.getNodeType(n.getNodeId()) === Le.BodyInstance) {
      if (this._markup) {
        const l = this._markup.getFirstSelection();
        if (r === l.getNodeId()) {
          const h = l.getFaceEntity().getCadFaceIndex(), u = o.getCadFaceIndex();
          if (h === u)
            return;
        }
      }
      this._currentHighlight !== null ? n.equals(this._currentHighlight) ? n.getSelectionType() === On.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await lf(i, n) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), yt.yellow()))) : this._currentHighlight === null && await lf(i, n) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), yt.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Pi());
    if (n.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const l = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(l);
      }
      return;
    }
    if (!n.isFaceSelection() || !(i.getNodeType(n.getNodeId()) === Le.BodyInstance && (!this._markup || this._markup._getStage() <= 1)) || !await lf(i, n))
      return;
    const r = n.getFaceEntity();
    await i.getFaceProperty(
      n.getNodeId(),
      r.getCadFaceIndex()
    ) instanceof $i && (this._unsetCurrentHighlight(), this._markup === null ? (this._markup = new vl(this._viewer), this._markup.setUseAuthoredNormals(this._useAuthoredNormals), await this._markup.setFirstFace(n), this._measureManager.addMeasurement(this._markup)) : await this._markup.setSecondFace(n) && this._markup.adjust(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._performMoveSelection(e), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    this._moveSelectionAction.set(() => this._performUpSelection(i));
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(t) {
    this._useAuthoredNormals = t;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
}
const da = class da extends Rn {
  constructor(t) {
    super(t), this._faceSelection = [], this._line1PreviewShape1 = new es(), this._line1PreviewShape2 = new es(), this._line2PreviewShape1 = new es(), this._line2PreviewShape2 = new es(), this._matrix1 = new wt(), this._matrix2 = new wt(), this._lineGeometryShape = new La(), this._parallelFaces = !1, this._triangulatedDistance = !0, this._pointsOnSameRay = !1, this._arrowsInvert = !1, this._faceData = [], this._distance = 0, this._surfaceCenter = [m.zero(), m.zero()], this._surfaceAxis1 = [m.zero(), m.zero()], this._surfaceAxis2 = [m.zero(), m.zero()], this._cylinderAxisInfinite1 = [m.zero(), m.zero()], this._cylinderAxisInfinite2 = [m.zero(), m.zero()], this._secondPointInitial = m.zero(), this._firstPointHelper = m.zero(), this._secondPointHelper = m.zero(), this._secondPoint = m.zero(), this._firstPoint = m.zero(), this._textPos = m.zero(), this._name = "MeasureFaceFaceDistance", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._textShape = new Tl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new yt(255, 255, 255));
    const i = this._viewer.measureManager.getMeasurementColor();
    for (let n = 0; n < 5; n++)
      this._lineShapes.push(new es()), this._lineShapes[n].setStrokeColor(i), this._lineShapes[n].setEndEndcapColor(i), this._lineShapes[n].setStartEndcapColor(i);
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  setFirstFace(t, e, i, n) {
    const r = t.getNodeId(), o = t.getFaceEntity(), l = t.getPosition();
    if (this._matrix1 = i.copy(), this._viewer.model.setNodeFaceColor(r, o.getCadFaceIndex(), new yt(255, 0, 0)), this._faceSelection[0] = t, this._firstPoint = l.copy(), this._faceData[0] = e, this._faceData[0] instanceof $i) {
      const h = this._faceData[0], u = new m(
        h.origin.x + h.normal.x,
        h.origin.y + h.normal.y,
        h.origin.z + h.normal.z
      );
      this._matrix1.transform(u, this._surfaceAxis1[0]), this._matrix1.transform(h.origin, this._surfaceCenter[0]);
    } else this._faceData[0] instanceof Bi && this.createCylinderData(this._faceData[0], i, n);
    this._stage++;
  }
  getFirstSelection() {
    return this._faceSelection[0] || null;
  }
  getFirstFaceData() {
    return this._faceData[0] || null;
  }
  cleanup() {
    const t = this._viewer.model;
    this._stage >= 2 && t.unsetNodeFaceColor(
      this._faceSelection[1].getNodeId(),
      this._faceSelection[1].getFaceEntity().getCadFaceIndex()
    ), this._stage >= 1 && t.unsetNodeFaceColor(
      this._faceSelection[0].getNodeId(),
      this._faceSelection[0].getFaceEntity().getCadFaceIndex()
    );
  }
  createCylinderData(t, e, i) {
    const r = m.subtract(i.max, i.min).length() / 4, o = new m(
      t.origin.x + t.normal.x * 1e4,
      t.origin.y + t.normal.y * 1e4,
      t.origin.z + t.normal.z * 1e4
    ), l = new m(
      t.origin.x - t.normal.x * 1e4,
      t.origin.y - t.normal.y * 1e4,
      t.origin.z - t.normal.z * 1e4
    ), h = new m(0, 0, 0);
    io(t.origin, o, l, h), this._surfaceCenter[this._stage] = new m(0, 0, 0), e.transform(h, this._surfaceCenter[this._stage]);
    const u = new m(
      h.x + t.normal.x,
      h.y + t.normal.y,
      h.z + t.normal.z
    );
    this._surfaceAxis1[this._stage] = new m(0, 0, 0), e.transform(u, this._surfaceAxis1[this._stage]), u.set(
      h.x - t.normal.x,
      h.y - t.normal.y,
      h.z - t.normal.z
    ), this._surfaceAxis2[this._stage] = new m(0, 0, 0), e.transform(u, this._surfaceAxis2[this._stage]);
    let f = new m(0, 0, 0);
    f = this._surfaceAxis1[this._stage].copy(), f = m.subtract(f, this._surfaceCenter[this._stage]), f.normalize(), this._surfaceAxis1[this._stage].set(
      this._surfaceCenter[this._stage].x + f.x * r,
      this._surfaceCenter[this._stage].y + f.y * r,
      this._surfaceCenter[this._stage].z + f.z * r
    ), this._surfaceAxis2[this._stage].set(
      this._surfaceCenter[this._stage].x - f.x * r,
      this._surfaceCenter[this._stage].y - f.y * r,
      this._surfaceCenter[this._stage].z - f.z * r
    ), this._cylinderAxisInfinite1[this._stage] = new m(
      this._surfaceCenter[this._stage].x + f.x * r * 1e3,
      this._surfaceCenter[this._stage].y + f.y * r * 1e3,
      this._surfaceCenter[this._stage].z + f.z * r * 1e3
    ), this._cylinderAxisInfinite2[this._stage] = new m(
      this._surfaceCenter[this._stage].x - f.x * r * 1e3,
      this._surfaceCenter[this._stage].y - f.y * r * 1e3,
      this._surfaceCenter[this._stage].z - f.z * r * 1e3
    );
  }
  async setSecondFace(t, e, i, n, r) {
    const o = this._faceSelection[0], l = this._faceData[0];
    if (o === void 0 || l === void 0)
      throw new oe("setSecondFace() called before setFirstFace()");
    if (i instanceof $i) {
      const u = l, f = new m(
        u.origin.x + u.normal.x,
        u.origin.y + u.normal.y,
        u.origin.z + u.normal.z
      );
      this._matrix1.transform(f, this._surfaceAxis1[0]), this._matrix1.transform(u.origin, this._surfaceCenter[0]);
    } else if (i instanceof Bi)
      this.createCylinderData(i, n, r);
    else
      return;
    const h = await this._viewer.model.computeMinimumFaceFaceDistance(
      o.getNodeId(),
      o.getFaceEntity().getCadFaceIndex(),
      e.getNodeId(),
      e.getFaceEntity().getCadFaceIndex()
    );
    if (h.distance !== 0) {
      if (this._matrix2 = n.copy(), this._secondPoint = e.getPosition().copy(), this._secondPointInitial = new m(
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z
      ), l instanceof $i && i instanceof $i) {
        const u = i, f = new m(
          u.origin.x + u.normal.x,
          u.origin.y + u.normal.y,
          u.origin.z + u.normal.z
        );
        this._matrix2.transform(f, this._surfaceAxis1[1]), this._matrix2.transform(u.origin, this._surfaceCenter[1]);
        const g = new m(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), y = new m(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        g.normalize(), y.normalize();
        const _ = new m(-g.x, -g.y, -g.z);
        if (g.equalsWithTolerance(y, 1e-5) || _.equalsWithTolerance(y, 1e-5)) {
          this._secondPointHelper = new m(
            this._secondPoint.x,
            this._secondPoint.y,
            this._secondPoint.z
          ), this._firstPointHelper = new m(
            this._firstPoint.x,
            this._firstPoint.y,
            this._firstPoint.z
          );
          const x = new ln();
          x.setFromPointAndNormal(this._surfaceCenter[0], g);
          const b = new ln();
          b.setFromPointAndNormal(this._surfaceCenter[1], y);
          const I = new m(
            this._firstPoint.x + g.x,
            this._firstPoint.y + g.y,
            this._firstPoint.z + g.z
          );
          if (Im(o.getPosition(), I, b, this._secondPoint), _.equalsWithTolerance(y, 1e-5)) {
            const F = new m(-g.x, -g.y, -g.z);
            x.setFromPointAndNormal(this._surfaceCenter[0], F);
          }
          const C = Math.abs(b.d - x.d) / x.normal.length();
          this._distance = C, this._setMeasurementValue(this._distance), this._parallelFaces = !0, this._triangulatedDistance = !1;
          const M = new m(0, 1, 0), P = m.subtract(this._secondPoint, this._firstPoint);
          let O = new m(0, 0, 0);
          O = m.subtract(this._secondPointHelper, this._firstPoint);
          const B = wr(M, P), j = wr(M, O);
          this._textPos.assign(this._secondPoint), B - j < 0.1 && B - j > -0.1 && (this._pointsOnSameRay = !0);
        } else
          this._firstPoint.assign(h.pos1), this._secondPoint.assign(h.pos2), this._textPos.assign(h.pos2), this._distance = h.distance, this._setMeasurementValue(this._distance);
      } else if (l instanceof Bi && i instanceof Bi) {
        const u = new m(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), f = new m(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        u.normalize(), f.normalize();
        const g = new m(-u.x, -u.y, -u.z);
        if (u.equalsWithTolerance(f, 1e-5) || g.equalsWithTolerance(f, 1e-5)) {
          const y = new m(0, 0, 0);
          io(
            this._firstPoint,
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            y
          ), this._firstPoint = y.copy();
          let _ = new m(this._firstPoint.x, this._firstPoint.y, this._firstPoint.z);
          _ = m.subtract(_, this._surfaceCenter[0]), _.set(0, 0, 0), io(
            this._firstPoint,
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            y
          ), this._secondPoint = y.copy();
          const x = m.subtract(this._secondPoint, this._firstPoint).length();
          if (x < 1e-7) return;
          this._triangulatedDistance = !1, this._textPos.assign(this._secondPoint), this._setMeasurementValue(x);
        } else {
          if (this._distance = sv(
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            this._firstPoint,
            this._secondPoint
          ), this._distance < 1e-7) return;
          this._textPos.assign(this._firstPoint), this._setMeasurementValue(this._distance);
        }
      } else if (l instanceof Bi && i instanceof $i) {
        const u = new m(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ).normalize(), f = await this._viewer.model.computeMinimumFaceLineDistance(
          e.getNodeId(),
          e.getFaceEntity().getCadFaceIndex(),
          new vr(this._surfaceCenter[0], u)
        );
        if (this._distance = f.distance, this._distance < 1e-7) return;
        this._firstPoint.assign(f.pos1), this._secondPoint.assign(f.pos2), this._textPos.assign(f.pos2), this._secondPointHelper = new m(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new m(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          e.getNodeId(),
          e.getFaceEntity().getCadFaceIndex(),
          new yt(255, 0, 0)
        ), this._faceData[1] = i, this._faceSelection[1] = e, this._stage++, this.adjust(t), this._setMeasurementValue(this._distance);
      } else if (l instanceof $i && i instanceof Bi) {
        const u = new m(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        ).normalize(), f = await this._viewer.model.computeMinimumFaceLineDistance(
          o.getNodeId(),
          o.getFaceEntity().getCadFaceIndex(),
          new vr(this._surfaceCenter[1], u)
        );
        if (this._distance = f.distance, this._distance < 1e-7) return;
        this._firstPoint.assign(f.pos1), this._secondPoint.assign(f.pos2), this._textPos.assign(f.pos2), this._secondPointHelper = new m(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new m(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          e.getNodeId(),
          e.getFaceEntity().getCadFaceIndex(),
          new yt(255, 0, 0)
        ), this._faceData[1] = i, this._faceSelection[1] = e, this._stage++, this.adjust(t), this._setMeasurementValue(this._distance);
      } else {
        if (this._firstPoint.assign(h.pos1), this._secondPoint.assign(h.pos2), this._textPos.assign(h.pos2), this._distance = h.distance, this._distance < 1e-7)
          return;
        this._setMeasurementValue(this._distance);
      }
      this._viewer.model.setNodeFaceColor(
        e.getNodeId(),
        e.getFaceEntity().getCadFaceIndex(),
        new yt(255, 0, 0)
      ), this._faceData[1] = i, this._faceSelection[1] = e, this._stage++, this.adjust(t);
    }
  }
  adjust(t) {
    if (super.adjust(t), this._stage <= 1) return;
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = new m(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    ), n = xm(e.direction);
    let r = new m(0, 0, 0);
    r = m.cross(e.direction, n), r.normalize();
    let o = new m(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    );
    o = this._textPos.copy(), n.set(o.x + n.x, o.y + n.y, o.z + n.z), r.set(o.x + r.x, o.y + r.y, o.z + r.z);
    const l = new m(0, 0, 0);
    if (Vo(e.origin, i, o, n, r, l), this._stage === 2)
      io(l, this._firstPoint, this._secondPoint, this._textPos);
    else if (this._parallelFaces || this._triangulatedDistance) {
      const h = new m(0, 0, 0), u = this._faceData[0] instanceof Bi || this._faceData[1] instanceof Bi, f = this._faceData[0] instanceof $i || this._faceData[1] instanceof $i;
      if (!this._pointsOnSameRay) {
        u && f ? io(l, this._secondPoint, this._secondPointInitial, h) : io(l, this._secondPoint, this._secondPointHelper, h);
        let g = new m(0, 0, 0);
        g = m.subtract(h, this._secondPoint), this._secondPoint = h.copy(), this._firstPoint.set(
          this._firstPoint.x + g.x,
          this._firstPoint.y + g.y,
          this._firstPoint.z + g.z
        ), this._textPos.set(
          this._textPos.x + g.x,
          this._textPos.y + g.y,
          this._textPos.z + g.z
        );
      }
    } else {
      const h = new m(0, 0, 0);
      io(
        l,
        this._cylinderAxisInfinite1[1],
        this._cylinderAxisInfinite2[1],
        h
      );
      const u = m.subtract(h, this._secondPoint);
      this._secondPoint = h.copy(), this._firstPoint.set(
        this._firstPoint.x + u.x,
        this._firstPoint.y + u.y,
        this._firstPoint.z + u.z
      ), this._textPos.set(
        this._textPos.x + u.x,
        this._textPos.y + u.y,
        this._textPos.z + u.z
      );
    }
    this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = new m(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    ), e = m.subtract(this._secondPoint, this._firstPoint);
    m.subtract(this._textPos, t).length() * 2 > e.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  _nextStage() {
    this._stage++, (this._stage > 3 || this._stage > 2 && this._triangulatedDistance) && (this._finalized = !0, this.cleanup());
  }
  /** @hidden */
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._behindView = !1, this._stage === 0) return;
    const e = new Array(10), i = [];
    for (let n = 0; n < 10; n++)
      i.push(new m(0, 0, 0));
    this._faceData[0] instanceof Bi && (i[0] = t.projectPoint(this._surfaceCenter[0]), i[1] = t.projectPoint(this._surfaceAxis1[0]), i[2] = t.projectPoint(this._surfaceAxis2[0]), e[0] = X.fromPoint3(i[0]), e[1] = X.fromPoint3(i[1]), e[2] = X.fromPoint3(i[2]), this._line1PreviewShape1.set(e[0], e[1]), this._line1PreviewShape2.set(e[0], e[2])), this._stage > 1 && this._faceData[1] instanceof Bi && (i[0] = t.projectPoint(this._surfaceCenter[1]), i[1] = t.projectPoint(this._surfaceAxis1[1]), i[2] = t.projectPoint(this._surfaceAxis2[1]), e[0] = X.fromPoint3(i[0]), e[1] = X.fromPoint3(i[1]), e[2] = X.fromPoint3(i[2]), this._line2PreviewShape1.set(e[0], e[1]), this._line2PreviewShape2.set(e[0], e[2])), this._stage > 1 && (i[0] = t.projectPoint(this._textPos), i[1] = t.projectPoint(this._firstPoint), i[2] = t.projectPoint(this._secondPoint), e[0] = X.fromPoint3(i[0]), e[1] = X.fromPoint3(i[1]), e[2] = X.fromPoint3(i[2]), this._textShape && this._textShape.setPosition(e[0]), this._lineShapes[0].setEndcapType(yn.Arrowhead), this._lineShapes[0].setStartEndcapType(yn.Arrowhead), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert), this._lineShapes[0].set(e[1], e[2]), i[3] = t.projectPoint(this._firstPointHelper), i[4] = t.projectPoint(this._secondPointHelper), e[3] = X.fromPoint3(i[3]), e[4] = X.fromPoint3(i[4]), this._lineShapes[1].set(e[2], e[4]), this._lineShapes[2].set(e[1], e[3]), this._lineShapes[3].set(e[1], e[0]));
    for (let n = 0; n < 6; n++)
      i[n].z < 0 && (this._behindView = !0);
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const t = this._faceData[0] instanceof Bi || this._faceData[1] instanceof Bi, e = this._faceData[0] instanceof $i || this._faceData[1] instanceof $i, i = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          this._faceData[0] instanceof Bi && (i.drawLine(this._line1PreviewShape1), i.drawLine(this._line1PreviewShape2));
          break;
        case 2:
        case 3:
        case 4:
          this._faceData[0] instanceof Bi && (i.drawLine(this._line1PreviewShape1), i.drawLine(this._line1PreviewShape2)), this._faceData[1] instanceof Bi && (i.drawLine(this._line2PreviewShape1), i.drawLine(this._line2PreviewShape2)), t && e ? (i.drawLine(this._lineShapes[0]), i.drawLine(this._lineShapes[1]), i.drawLine(this._lineShapes[2]), i.drawLine(this._lineShapes[3]), i.drawTextBox(this._textShape)) : (i.drawLine(this._lineShapes[0]), this._parallelFaces && (i.drawLine(this._lineShapes[1]), i.drawLine(this._lineShapes[2])), i.drawLine(this._lineShapes[3]), i.drawTextBox(this._textShape));
          break;
      }
    }
  }
  //serialization methods
  static _serializeFaceProp(t) {
    return t instanceof Bi ? {
      type: "CylinderElement",
      origin: t.origin.toJson(),
      normal: t.normal.toJson(),
      radius: t.radius
    } : t instanceof $i ? {
      type: "PlaneElement",
      origin: t.origin.toJson(),
      normal: t.normal.toJson()
    } : null;
  }
  static _constructFaceProp(t) {
    if (t.type === "CylinderElement") {
      const e = m.fromJson(t.origin), i = m.fromJson(t.normal), n = t.radius;
      return new Bi(n, e, i);
    } else if (t.type === "PlaneElement") {
      const e = m.fromJson(t.origin), i = m.fromJson(t.normal);
      return new $i(e, i);
    } else
      return null;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const r of this._faceData)
      t.push(da._serializeFaceProp(r));
    const e = [];
    for (const r of this._surfaceCenter) e.push(r.toJson());
    const i = [];
    for (const r of this._surfaceAxis1) i.push(r.toJson());
    const n = [];
    for (const r of this._surfaceAxis2) n.push(r.toJson());
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      firstPoint: this._firstPoint.toJson(),
      secondPoint: this._secondPoint.toJson(),
      firstPointHelper: this._firstPointHelper.toJson(),
      secondPointHelper: this._secondPointHelper.toJson(),
      secondPointInitial: this._secondPointInitial.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      parallelFaces: this._parallelFaces,
      faceData: t,
      surfaceCenter: e,
      surfaceAxis1: i,
      surfaceAxis2: n,
      name: this.getName(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new da(e);
    n.setName(i.name), n._textShape.setTextString(i.text), n._textPos.assign(m.fromJson(i.textPos)), n._firstPoint.assign(m.fromJson(i.firstPoint)), n._firstPointHelper.assign(m.fromJson(i.firstPointHelper)), n._secondPoint.assign(m.fromJson(i.secondPoint)), n._secondPointHelper.assign(m.fromJson(i.secondPointHelper)), i.secondPointInitial !== void 0 && n._secondPointInitial.assign(m.fromJson(i.secondPointInitial)), console.assert(Array.isArray(i.faceData));
    for (const r of i.faceData) {
      const o = da._constructFaceProp(r);
      console.assert(o !== null), n._faceData.push(o);
    }
    return n._surfaceCenter[0].assign(i.surfaceCenter[0]), n._surfaceCenter[1].assign(i.surfaceCenter[1]), n._surfaceAxis1[0].assign(i.surfaceAxis1[0]), n._surfaceAxis1[1].assign(i.surfaceAxis1[1]), n._surfaceAxis2[0].assign(i.surfaceAxis2[0]), n._surfaceAxis2[1].assign(i.surfaceAxis2[1]), n._stage = 4, n._parallelFaces = i.parallelFaces, n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n;
  }
  getClassName() {
    return da.className;
  }
};
da.className = "Communicator.Markup.Measure.MeasureFaceFaceDistanceMarkup";
let bl = da;
us(
  bl.className,
  bl.fromJson
);
class py extends Oi {
  constructor(t, e, i) {
    super(t, e), this._moveSelectionAction = new fo(!0), this._currentHighlight = null, this._markup = null, this._measureManager = i;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Pi());
    if (n.overlayIndex() !== 0 || !n.isFaceSelection())
      return;
    const r = n.getNodeId(), o = n.getFaceEntity();
    if (i.getNodeType(r) === Le.BodyInstance) {
      if (this._markup) {
        const l = this._markup.getFirstSelection();
        if (l !== null && r === l.getNodeId() && o.getCadFaceIndex() === l.getFaceEntity().getCadFaceIndex())
          return;
      }
      this._currentHighlight !== null ? n.equals(this._currentHighlight) ? n.getSelectionType() === On.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), yt.yellow()))) : await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), yt.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Pi());
    if (n.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const f = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(f);
      }
      return;
    }
    if (!n.isFaceSelection())
      return;
    const r = n.getNodeId(), o = n.getFaceEntity();
    if (!await i.isFaceMeasurable(r, o.getCadFaceIndex()) || !(i.getNodeType(r) === Le.BodyInstance && (!this._markup || this._markup._getStage() <= 1)))
      return;
    const h = await i.getFaceProperty(r, o.getCadFaceIndex());
    if (!h)
      return;
    const u = i.getNodeNetMatrix(r);
    if (this._unsetCurrentHighlight(), h instanceof $i || h instanceof Bi) {
      const f = await i.getNodesBounding([r]);
      this._markup ? await this._markup.setSecondFace(t, n, h, u, f) : (this._markup = new bl(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstFace(n, h, u, f), this._measureManager.addMeasurement(this._markup));
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
}
const Lc = class Lc extends Rn {
  constructor(t) {
    super(t), this._anchorLinePoint = null, this._firstLinePoint = null, this._secondLinePoint = null, this._selectionPosition = null, this._lineGeometryShape = new La(), this._viewer = t, this._name = "MeasureLineLineAngle", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setEndcapType(yn.Arrowhead), this._lineGeometryShape.setStartEndcapType(yn.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5), this._lineGeometryShape.setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setStartEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(yt.white());
  }
  addPoint(t) {
    if (this._finalized) return !1;
    if (this._anchorLinePoint === null)
      this._anchorLinePoint = t.copy(), this._stage = 1;
    else if (this._firstLinePoint === null) {
      if (t.equals(this._anchorLinePoint))
        return !1;
      this._firstLinePoint = t.copy(), this._stage = 2;
    } else {
      if (t.equals(this._anchorLinePoint) || t.equals(this._firstLinePoint))
        return !1;
      const e = m.subtract(this._firstLinePoint, this._anchorLinePoint), i = m.subtract(t, this._anchorLinePoint), n = wr(e, i);
      if (n === 0 || n === 180) return !1;
      this._secondLinePoint = t.copy(), this.setMeasurementText(`${n.toFixed(2)}°`), this._measurementValue = n, this._finalized = !0, this._stage = 3;
    }
    return this.draw(), !0;
  }
  setSelectionPosition(t) {
    this._selectionPosition = t;
  }
  getLineGeometryShape() {
    return this._lineGeometryShape;
  }
  _drawPreviewLine(t, e) {
    const i = this._viewer.markupManager.getRenderer(), n = this._viewer.view, r = X.fromPoint3(n.projectPoint(t)), o = X.fromPoint3(n.projectPoint(e)), l = new es(r, o);
    i.drawLine(l);
  }
  _drawAngleMarkup(t, e, i) {
    const n = this._viewer.markupManager.getRenderer(), r = this._viewer.view, o = m.subtract(e, t), l = m.subtract(i, t), h = m.cross(o, l).normalize(), u = wr(o, l);
    if (u !== 0 && u !== 180 && !isNaN(u)) {
      const C = mf(h, -u, t, l, 30);
      this._lineGeometryShape.clearPoints();
      for (const M of C)
        this._lineGeometryShape.pushPoint(X.fromPoint3(r.projectPoint(M)));
      n.drawPolyline(this._lineGeometryShape);
    }
    const f = l.length(), g = m.add(
      t,
      o.copy().normalize().scale(f)
    ), y = X.fromPoint3(r.projectPoint(t)), _ = X.fromPoint3(r.projectPoint(g)), x = X.fromPoint3(r.projectPoint(i)), b = new es(y, _);
    n.drawLine(b);
    const I = new es(y, x);
    n.drawLine(I), this._textShape.setPosition(_), this._finalized ? this._textShape.setTextString(this.getMeasurementText()) : isNaN(u) ? this._textShape.setTextString("0°") : this._textShape.setTextString(`${u.toFixed(2)}°`), n.drawTextBox(this._textShape);
  }
  draw() {
    if (!(!this._visibility || this._anchorLinePoint === null || this._viewer.view.projectPoint(this._anchorLinePoint).z <= 0)) {
      if (this._stage === 1) {
        if (this._selectionPosition === null) return;
        this._drawPreviewLine(this._anchorLinePoint, this._selectionPosition);
      } else if (this._stage === 2) {
        if (this._firstLinePoint === null || this._selectionPosition === null) return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._selectionPosition);
      } else if (this._stage === 3) {
        if (this._firstLinePoint == null || this._secondLinePoint == null) return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._secondLinePoint);
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      anchorPoint: this._anchorLinePoint.copy(),
      firstPoint: this._firstLinePoint.copy(),
      secondPoint: this._secondLinePoint.copy(),
      measurementValue: this._measurementValue,
      measurementText: this.getMeasurementText(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Lc(e);
    return n._name = i.name, n._anchorLinePoint = m.fromJson(i.anchorPoint), n._firstLinePoint = m.fromJson(i.firstPoint), n._secondLinePoint = m.fromJson(i.secondPoint), n._measurementValue = i.measurementValue, n.setMeasurementText(i.measurementText), n._finalized = !0, n._stage = 3, n;
  }
  getClassName() {
    return Lc.className;
  }
};
Lc.className = "Communicator.Markup.Measure.MeasureLineLineAngleMarkup";
let xl = Lc;
us(xl.className, xl.fromJson);
class kg extends Rn {
  constructor(t, e) {
    super(t), this._cursorSprite = new $r(), this._removed = !1, this._view = e, this._name = "CursorMarkup";
    const i = t.measureManager.getMeasurementColor();
    this._cursorSprite.setFillColor(i), this._cursorSprite.setStrokeColor(i), this._cursorSprite.setRadius(0), this._markupId = t.markupManager.registerMarkup(this, e);
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawCircle(this._cursorSprite);
  }
  enable(t) {
    this._cursorSprite.setRadius(t ? 2.5 : 0);
  }
  isEnabled() {
    return this._cursorSprite.getRadius() > 0;
  }
  setPosition(t) {
    this._cursorSprite.setCenter(t);
  }
  destroy() {
    this._removed || this._viewer.markupManager.unregisterMarkup(this._markupId, this._view);
  }
  remove(t) {
    this._removed = !0;
  }
}
class my {
  constructor(t, e, i) {
    this.worldPosition = t, this.screenPosition = e, this.selectionItem = i;
  }
}
class Oh {
  constructor(t, e) {
    this._cursorMarkup = null, this._updateCursorSpriteAction = new fo(!0), this._viewer = t, this._view = e, this.snappingConfig = {
      enabled: !0,
      preferVertices: !0
    };
  }
  async getSelectionCursorPoints(t, e, i) {
    const n = new Pi(e ? Pe.All : Pe.Face);
    e && (n.enableProximityFaces = !0);
    const r = await this._view.pickFromPoint(t, n);
    if (r.overlayIndex() !== 0)
      return null;
    let o = r.getPosition(), l = t;
    if (this.snappingConfig.enabled) {
      const h = r.getLineEntity(), u = r.getPointEntity(), f = r.getFaceEntity();
      if (h || u || f) {
        let g = null;
        h !== null ? g = this._getLineSnapPoint(h, e, i) : u !== null ? g = u.getPosition() : f !== null && f.isProximityFace() && (g = f.getPosition()), g !== null && (o = g, l = Tu(this._view, o));
      }
    }
    return new my(o, l, r);
  }
  updateCursorSprite(t, e, i) {
    this._updateCursorSpriteAction.set(() => this._updateCursorSpriteImpl(t, e, i));
  }
  async _updateCursorSpriteImpl(t, e, i) {
    if (this._cursorMarkup !== null)
      if (e) {
        const n = await this.getSelectionCursorPoints(
          t,
          e,
          i
        );
        n !== null ? (this._cursorMarkup.setPosition(n.screenPosition), this.activateCursorSprite(!0)) : this.activateCursorSprite(!1);
      } else
        this._cursorMarkup.setPosition(t);
  }
  draw() {
    this._cursorMarkup !== null && this._cursorMarkup.draw();
  }
  activateCursorSprite(t) {
    this._cursorMarkup !== null && this._cursorMarkup.enable(t);
  }
  /**
   * Finds the best point to use for the given lineEntity given the snapping behavior and settings.
   */
  _getLineSnapPoint(t, e, i) {
    const n = this.snappingConfig.preferVertices ? t.getBestVertex() : null;
    if (n !== null)
      return n;
    const r = t.getPosition();
    if (!e || i == null)
      return r;
    const o = t.getPoints(), l = 1e-10, h = (() => {
      for (let C = 0; C < o.length - 1; C++)
        if (ov(o[C], o[C + 1], r, l))
          return C;
      return 0;
    })(), u = o[h], f = o[h + 1];
    if (u === void 0 || f === void 0)
      return r;
    const g = rv(u, f, i), y = Tu(this._view, g), _ = Tu(this._view, r), x = X.subtract(
      y,
      _
    ).squaredLength(), b = this._viewer.selectionManager.getPickTolerance(), I = b * b;
    return x <= I ? g : r;
  }
  _clearCursorMarkup() {
    this._cursorMarkup !== null && (this._cursorMarkup.destroy(), this._cursorMarkup = null);
  }
  onOperatorActivate() {
    this._clearCursorMarkup(), this._cursorMarkup = new kg(this._viewer, this._view), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!0);
  }
  onOperatorDeactivate() {
    this._clearCursorMarkup(), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!1);
  }
}
class _y extends Oi {
  constructor(t, e, i) {
    super(t, e), this._markupItem = null, this._cameraInteractionActive = !1, this._measureManager = i, this._cursor = new Oh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  /**
   * Determine if the given mouse event should cause snapping.
   * This is influenced by the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  async _addPoint(t, e) {
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    if (!(i === null || i.worldPosition === null) && (this._markupItem === null && (this._markupItem = new xl(this._viewer), this._measureManager.addMeasurement(this._markupItem), this._viewer.trigger("measurementBegin")), this._markupItem.addPoint(i.worldPosition), this._markupItem._isFinalized())) {
      const n = this._markupItem;
      this._markupItem = null, this._measureManager.finalizeMeasurement(n);
    }
  }
  async _updateMarkupSelectionPosition(t, e) {
    if (this._markupItem === null) return;
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    i !== null && this._markupItem.setSelectionPosition(i.worldPosition);
  }
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._cameraInteractionActive) return;
    const e = t.getPosition(), i = this._useSnapping(t);
    this._cursor.updateCursorSprite(e, i, null), await this._updateMarkupSelectionPosition(e, i), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  async onMouseUp(t) {
    if (!this.isActive()) return;
    const e = t.getPosition();
    this._ptFirst.equals(e) && await this._addPoint(e, this._useSnapping(t)), super.onMouseUp(t);
  }
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && this._clearMeasurement();
  }
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  setHandled() {
    return this._markupItem !== null && this._markupItem._getStage() > 1;
  }
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._markupItem !== null && (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null);
  }
}
const Fc = class Fc extends Rn {
  constructor(t) {
    super(t), this._firstPointShape = new $r(), this._secondPointShape = new $r(), this._arrowsInvert = !1, this._name = "MeasurePointPointDistance", this._lineShapes = [];
    for (let e = 0; e < 6; e++)
      this._lineShapes.push(new es()), this._lineShapes[e].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = t, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new Tl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new yt(255, 255, 255));
  }
  initCircle(t) {
    t.setRadius(2.5), t.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  setFirstPointPosition(t) {
    this._stage = 1, this._positions[0] = t.copy();
  }
  setSecondPointPosition(t) {
    this._stage = 2, this._positions[1] = t.copy(), this._positions[2] = t.copy(), this._setMeasurementValue(m.subtract(this._positions[1], this._positions[0]).length());
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  getFirstPointPosition() {
    return this._positions[0];
  }
  getSecondPointPosition() {
    return this._positions[1];
  }
  adjust(t) {
    super.adjust(t);
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = this._positions[0], n = this._positions[1];
    let r = new m(1, 0, 0);
    n.equals(i) || (r = m.subtract(n, i));
    const l = this._viewer.view.getCamera().getUp(), h = m.cross(e.direction, l).normalize(), u = new m(
      (i.x + n.x) / 2,
      (i.y + n.y) / 2,
      (i.z + n.z) / 2
    ), f = new m(u.x + l.x, u.y + l.y, u.z + l.z), g = new m(
      u.x + h.x,
      u.y + h.y,
      u.z + h.z
    ), y = new m(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    );
    let _ = new m(0, 0, 0);
    Vo(
      e.origin,
      y,
      u,
      f,
      g,
      _
    ), this._positions[2].assign(_);
    let x = new m(0, 0, 0);
    Math.abs(r.x) <= Math.abs(r.y) && Math.abs(r.x) <= Math.abs(r.z) ? x = new m(1, 0, 0) : Math.abs(r.y) <= Math.abs(r.x) && Math.abs(r.y) <= Math.abs(r.z) ? x = new m(0, 1, 0) : x = new m(0, 0, 1);
    const b = m.cross(x, r), I = m.cross(b, r);
    b.set(
      i.x + b.x,
      i.y + b.y,
      i.z + b.z
    ), I.set(
      i.x + I.x,
      i.y + I.y,
      i.z + I.z
    );
    const C = new m(
      _.x + r.x * 1e4,
      _.y + r.y * 1e4,
      _.z + r.z * 1e4
    ), M = new m(
      _.x - r.x * 1e4,
      _.y - r.y * 1e4,
      _.z - r.z * 1e4
    ), P = Vo(
      C,
      M,
      i,
      b,
      I,
      _
    ), O = !isNaN(_.x) && !isNaN(_.y) && !isNaN(_.z);
    (!P || !O) && (_ = n.copy());
    const B = m.subtract(_, i);
    this._positions[3] = new m(
      i.x + B.x,
      i.y + B.y,
      i.z + B.z
    ), this._positions[4] = new m(
      n.x + B.x,
      n.y + B.y,
      n.z + B.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = new m(
      (this._positions[3].x + this._positions[4].x) / 2,
      (this._positions[3].y + this._positions[4].y) / 2,
      (this._positions[3].z + this._positions[4].z) / 2
    ), e = m.subtract(this._positions[4], this._positions[3]);
    m.subtract(this._positions[2], t).length() * 2 > e.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  update() {
    super.update();
    const t = this._viewer.view, e = new Array(6);
    if (this._stage > 0) {
      this._behindView = !1;
      for (let i = 0; i < this._positions.length; i++)
        t.projectPoint(this._positions[i]).z <= 0 && (this._behindView = !0), e[i] = X.fromPoint3(t.projectPoint(this._positions[i]));
      this._firstPointShape.setCenter(e[0]);
    }
    this._stage > 1 && (this._textShape && this._textShape.setPosition(e[2]), this._secondPointShape.setCenter(e[1]), this._lineShapes[0].set(e[0], e[1]), this._lineShapes[1].set(e[3], e[4]), this._lineShapes[2].set(e[0], e[3]), this._lineShapes[3].set(e[1], e[4]), this._lineShapes[4].set(e[3], e[2]), this._lineShapes[5].set(e[3], e[4]), this._lineShapes[5].setEndcapType(yn.Arrowhead), this._lineShapes[5].setStartEndcapType(yn.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert));
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const t = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          t.drawCircle(this._firstPointShape);
          break;
        case 2:
        case 3:
          t.drawCircle(this._firstPointShape), t.drawCircle(this._secondPointShape);
          for (const e of this._lineShapes) t.drawLine(e);
          t.drawTextBox(this._textShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Fc(e);
    return n._name = i.name, n._positions[0] = m.fromJson(i.measurePoint1), n._positions[1] = m.fromJson(i.measurePoint2), n._positions[2] = m.fromJson(i.textPoint), n._textShape.setTextString(i.text), n._positions[3] = m.fromJson(i.leaderPoint1), n._positions[4] = m.fromJson(i.leaderPoint2), n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._updateArrowsInverted(), n._stage = 2, n;
  }
  getClassName() {
    return Fc.className;
  }
  /**
   * Returns whether the measurement markup is valid.
   */
  isMarkupValid() {
    return this._positions.length >= 5;
  }
};
Fc.className = "Communicator.Markup.Measure.MeasurePointPointDistanceMarkup";
let Il = Fc;
us(
  Il.className,
  Il.fromJson
);
class yy extends Oi {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._measureMarkup = null, this._cameraInteractionActive = !1, this._viewer = t, this._measureManager = i, this._cursor = new Oh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  _getStage() {
    return this._measureMarkup === null ? As.NoPointsSelected : this._measureMarkup._getStage();
  }
  _draw() {
    let t = !1;
    this._getStage() < As.TwoPointsSelected && (this._cursor.draw(), t = !0), this._measureMarkup !== null && (this._measureMarkup.draw(), t = !0), t && this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  async _finalizeMeasurement(t, e) {
    const i = this._measureMarkup;
    if (i === null) {
      console.assert(!1);
      return;
    }
    const n = new Pi(e ? Pe.All : Pe.Face);
    (await this._view.pickFromPoint(t, n)).overlayIndex() || (i.finalize(), this._measureMarkup = null, this._measureManager.finalizeMeasurement(i));
  }
  // Gets the first picked position or null if one is not selected.  This is used as a hint when updating the cursor for snapping.
  _getFirstPickPosition() {
    let t = null;
    return this._measureMarkup !== null && this._getStage() >= As.OnePointSelected && (t = this._measureMarkup.getFirstPointPosition()), t;
  }
  async _updateMeasurementPoints(t, e) {
    const i = this._getStage();
    console.assert(i < As.TwoPointsSelected), this._viewer.trigger("measurementBegin");
    const n = this._getFirstPickPosition(), r = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      n
    );
    if (r === null || r.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    }
    this._cursor.activateCursorSprite(!0), this._measureMarkup === null && (this._measureMarkup = new Il(this._viewer), this._measureManager.addMeasurement(this._measureMarkup));
    const o = r.worldPosition.copy();
    if (this._viewer.sheetManager.isDrawingSheetActive() && (o.z = 0), i === As.NoPointsSelected)
      this._measureMarkup.setFirstPointPosition(o), this._measureMarkup.setUnitMultiplier(
        r.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(r.selectionItem.getNodeId()) : 1
      );
    else if (i === As.OnePointSelected) {
      const l = this._getFirstPickPosition();
      r.worldPosition.equalsWithTolerance(l, 1e-7) || (this._measureMarkup.setSecondPointPosition(o), this._measureMarkup.adjust(r.screenPosition));
    }
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._getStage();
    if (e < As.TwoPointsSelected) {
      if (!this._cameraInteractionActive) {
        const i = t.getPosition(), n = this._getFirstPickPosition();
        this._cursor.updateCursorSprite(
          i,
          this._useSnapping(t),
          n
        );
      }
    } else e === As.TwoPointsSelected && (this._measureMarkup.adjust(t.getPosition()), t.setHandled(!0));
    this._draw();
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive()) {
      const e = this._getStage(), i = this._primaryTouchId !== null && this._measureMarkup !== null && e > As.OnePointSelected;
      if (this._dragCount < 3 || i) {
        const n = this._useSnapping(t), r = t.getPosition();
        e <= As.OnePointSelected ? await this._updateMeasurementPoints(r, n) : await this._finalizeMeasurement(r, n);
      }
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onKeyUp(t) {
  }
  _clearMeasurement() {
    this._measureMarkup !== null ? (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null) : this._measureManager.removeLastMeasurement();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && this._clearMeasurement();
  }
  /** @hidden */
  setHandled() {
    return this._getStage() > As.OnePointSelected;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._measureMarkup !== null && (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null);
  }
}
const Bc = class Bc extends Rn {
  constructor(t) {
    super(t), this._initialPoint = new $r(), this._leaderLine = new es(), this._endpoints = new wg(), this._textboxCorners = [
      X.zero(),
      X.zero(),
      X.zero(),
      X.zero()
    ], this._polygon = new $_(), this._plane = null, this.textPosition = m.zero(), this.leaderPosition = m.zero(), this.pointRadius = 2.5, this._viewer = t;
    const e = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(e), this._initialPoint.setStrokeColor(e), this._leaderLine.setStrokeColor(e), this._endpoints.setFillColor(e), this._endpoints.setStrokeColor(e), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(yt.white()), this._polygon.setFillColor(e), this._polygon.setFillOpacity(0.4);
  }
  _calculateArea() {
    const t = this._positions.length;
    if (t < 3)
      return 0;
    const e = new Float32Array(t * 3);
    for (let u = 0; u < t; u++) {
      const f = this._positions[u];
      e[3 * u] = f.x, e[3 * u + 1] = f.y, e[3 * u + 2] = f.z;
    }
    const i = m.subtract(this._positions[1], this._positions[0]), n = m.subtract(this._positions[2], this._positions[0]), r = m.cross(i, n), o = this._viewer.model.triangulatePolygon(e, r);
    let l = 0;
    const h = o.length / 3 / 3;
    for (let u = 0; u < h; u++) {
      const f = u * 3 * 3, g = [];
      for (let I = 0; I < 3; I++) {
        const C = o[f + I * 3], M = o[f + I * 3 + 1], P = o[f + I * 3 + 2];
        g[I] = new m(C, M, P);
      }
      const y = m.subtract(g[1], g[0]).length(), _ = m.subtract(g[2], g[0]).length(), x = m.subtract(g[2], g[1]).length(), b = 0.25 * Math.sqrt(
        (y + _ + x) * (-y + _ + x) * (y - _ + x) * (y + _ - x)
      );
      l += b;
    }
    return l;
  }
  /**
   * Adds a point to the point list and updates the calculated polygon area.
   * Only points that are coplanar will be added.
   * Returns a bool representing if the point was accepted or not
   */
  addPoint(t) {
    if (this._positions.length >= 3 && (this._plane === null && (this._plane = ln.createFromPoints(
      this._positions[0],
      this._positions[1],
      this._positions[2]
    )), Math.abs(this._plane.distanceToPoint(t)) > 1e-4))
      return !1;
    this._positions.length === 2 && (this._plane = ln.createFromPoints(this._positions[0], this._positions[1], t)), this._positions.push(t.copy());
    const e = this._calculateArea(), i = this.getUnitMultiplier(), n = `${Hc(e, i)}²`;
    return this._setMeasurementValue(e), this.setMeasurementText(n), !0;
  }
  getPoints() {
    return this._positions;
  }
  getLast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement
  finalize() {
    if (this._positions.length > 2) {
      const t = this._calculateArea(), e = this.getUnitMultiplier(), i = `${Hc(t, e)}²`;
      this._setMeasurementValue(t), this.setMeasurementText(i);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  isValid() {
    return this._positions.length > 2;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polygon */
  _updateProjectedPoints() {
    const t = [];
    this._behindView = !1;
    for (const e of this._positions) {
      const i = this._viewer.view.projectPoint(e);
      i.z <= 0 && (this._behindView = !0), t.push(X.fromPoint3(i));
    }
    return t;
  }
  _updateTextBoxCorners() {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    this._textboxCorners[0].assign(e), this._textboxCorners[1].set(e.x + t.x, e.y), this._textboxCorners[2].set(e.x + t.x, e.y + t.y), this._textboxCorners[3].set(e.x, e.y + t.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(t) {
    this._updateTextBoxCorners();
    const e = X.zero();
    let i = Number.MAX_VALUE;
    for (const n of this._textboxCorners) {
      const r = X.distance(t, n);
      r < i && (e.assign(n), i = r);
    }
    return e;
  }
  draw() {
    if (!this._visibility) return;
    const t = this._updateProjectedPoints();
    if (this._behindView || t.length === 0) return;
    const e = this._viewer.markupManager.getRenderer();
    if (t.length === 1)
      this._initialPoint.set(t[0], this.pointRadius), e.drawCircle(this._initialPoint);
    else {
      this._polygon.clearPoints();
      for (const o of t)
        this._polygon.pushPoint(o);
      this._finalized && this._polygon.pushPoint(t[0]);
      const i = X.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(i), e.drawPolygon(this._polygon);
      const n = X.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), r = this._calculateLeaderEndpoint(n);
      this._leaderLine.setP1(n), this._leaderLine.setP2(r), e.drawLine(this._leaderLine), e.drawTextBox(this._textShape), this._endpoints.clear(), this._endpoints.addCircle(t[0], this.pointRadius), this._endpoints.addCircle(t[t.length - 1], this.pointRadius), e.drawCircles(this._endpoints);
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._positions) t.push(e.toJson());
    return {
      name: this._name,
      points: t,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolygonAreaMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Bc(e);
    return n._name = i.name, n._positions = Rn._constructPointArray(i.points), n.textPosition = m.fromJson(i.textPoint), n.leaderPosition = m.fromJson(i.leaderPoint), n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._textShape.setTextString(i.text), n._finalized = !0, n;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(t) {
    const e = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), i = this._textShape.getPosition();
    return !(t.x < i.x || t.x > i.x + e.x || t.y < i.y || t.y > i.y + e.y);
  }
  getClassName() {
    return Bc.className;
  }
};
Bc.className = "Communicator.Markup.Measure.MeasurePolygonAreaMarkup";
let Cl = Bc;
us(Cl.className, Cl.fromJson);
class wy extends Oi {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new X(10, -25), this._anchor = al.Last, this._dragPlane = null, this._measureManager = i, this._cursor = new Oh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getLast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new Cl(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolygonAreaMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null) return;
    const i = this._markupItem.getPoints(), n = X.fromPoint3(this._view.projectPoint(i[0]));
    X.distance(n, t) < this._markupItem.pointRadius ? i.length > 2 && this._finalizeMeasurement() : this._markupItem.addPoint(e.worldPosition) && this._updateAnchor(t, e.worldPosition);
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), n = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (n === null || n.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(n) : this._updateMarkupItem(t, n);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive()) return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), n = e;
      await this._updateMeasurementItem(n, i);
    }
    this._draw(), super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null) return;
    const e = this._view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem) return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case al.Last:
          this._calculateAnchorPos(t, e);
          break;
        case al.First: {
          if (i.length !== 2) return;
          const n = this._view.projectPoint(i[0]);
          this._calculateAnchorPos(X.fromPoint3(n), i[0]);
          break;
        }
        case al.Midpoint: {
          let n;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let h = 1; h < i.length; h++) {
            const u = m.subtract(i[h], i[h - 1]), f = u.length(), g = o + f;
            if (g > r) {
              const _ = (r - o) / f;
              u.scale(_), n = m.add(i[h - 1], u);
              break;
            }
            o = g;
          }
          const l = this._view.projectPoint(n);
          this._calculateAnchorPos(X.fromPoint3(l), n);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._view.getCamera(), i = m.subtract(e.getPosition(), t);
    return i.normalize(), ln.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._view.getCamera();
    m.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._view.raycastFromPoint(X.add(t, this._textShapeOffset));
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t, this._viewer.view);
    return e && e.getClassName() === "Communicator.MeasurePolygonAreaMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const Vc = class Vc extends Rn {
  constructor(t) {
    super(t), this._polyline = new La(), this._initialPoint = new $r(), this._leaderLine = new es(), this._endpoints = new wg(), this._textboxCorners = [
      X.zero(),
      X.zero(),
      X.zero(),
      X.zero()
    ], this.textPosition = m.zero(), this.leaderPosition = m.zero(), this.isLoop = !1, this.pointRadius = 2.5, this._viewer = t;
    const e = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(e), this._initialPoint.setStrokeColor(e), this._polyline.setStrokeColor(e), this._polyline.setStrokeWidth(2), this._leaderLine.setStrokeColor(e), this._endpoints.setFillColor(e), this._endpoints.setStrokeColor(e), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(yt.white());
  }
  /** Adds a point to the pointlist and updates the calculated polyline distance */
  addPoint(t) {
    if (this._positions.push(t.copy()), this._positions.length > 1) {
      const e = m.subtract(
        this._positions[this._positions.length - 1],
        this._positions[this._positions.length - 2]
      ).length();
      this._setMeasurementValue(this._measurementValue + e);
    }
  }
  getPoints() {
    return this._positions;
  }
  getlast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement and sets the final distance if the polyline is a loop
  finalize() {
    if (this.isLoop && this._positions.length > 2) {
      const t = m.subtract(
        this._positions[this._positions.length - 1],
        this._positions[0]
      ).length();
      this._setMeasurementValue(this._measurementValue + t);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  isValid() {
    return this._positions.length > 1;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polyline */
  _updateProjectedPoints() {
    const t = [];
    this._behindView = !1, this._behindView = !1;
    for (const e of this._positions) {
      const i = this._viewer.view.projectPoint(e);
      i.z <= 0 && (this._behindView = !0), t.push(X.fromPoint3(i));
    }
    return t;
  }
  _updateTextBoxCorners() {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    this._textboxCorners[0].assign(e), this._textboxCorners[1].set(e.x + t.x, e.y), this._textboxCorners[2].set(e.x + t.x, e.y + t.y), this._textboxCorners[3].set(e.x, e.y + t.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(t) {
    this._updateTextBoxCorners();
    const e = X.zero();
    let i = Number.MAX_VALUE;
    for (const n of this._textboxCorners) {
      const r = X.distance(t, n);
      r < i && (e.assign(n), i = r);
    }
    return e;
  }
  draw() {
    if (!this._visibility) return;
    const t = this._updateProjectedPoints();
    if (this._behindView || t.length === 0) return;
    const e = this._viewer.markupManager.getRenderer();
    if (t.length === 1)
      this._initialPoint.set(t[0], this.pointRadius), e.drawCircle(this._initialPoint);
    else {
      this._polyline.clearPoints();
      for (const o of t)
        this._polyline.pushPoint(o);
      this._finalized && this.isLoop && this._polyline.pushPoint(t[0]);
      const i = X.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(i), e.drawPolyline(this._polyline);
      const n = X.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), r = this._calculateLeaderEndpoint(n);
      this._leaderLine.setP1(n), this._leaderLine.setP2(r), e.drawLine(this._leaderLine), e.drawTextBox(this._textShape), this._endpoints.clear(), this.isLoop || (this._endpoints.addCircle(t[0], this.pointRadius), this._endpoints.addCircle(t[t.length - 1], this.pointRadius), e.drawCircles(this._endpoints));
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._positions) t.push(e.toJson());
    return {
      name: this._name,
      points: t,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      isLoop: this.isLoop,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolylineDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Vc(e);
    return n._name = i.name, n._positions = Rn._constructPointArray(i.points), n.textPosition = m.fromJson(i.textPoint), n.leaderPosition = m.fromJson(i.leaderPoint), n.isLoop = i.isLoop, n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._textShape.setTextString(i.text), n._finalized = !0, n;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(t) {
    const e = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), i = this._textShape.getPosition();
    return !(t.x < i.x || t.x > i.x + e.x || t.y < i.y || t.y > i.y + e.y);
  }
  getClassName() {
    return Vc.className;
  }
};
Vc.className = "Communicator.Markup.Measure.MeasurePolylineDistanceMarkup";
let Sl = Vc;
us(
  Sl.className,
  Sl.fromJson
);
class vy extends Oi {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new X(10, -25), this._anchor = ll.Last, this._dragPlane = null, this._measureManager = i, this._cursor = new Oh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getlast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new Sl(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolylineDistanceMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null) return;
    const i = this._markupItem.getPoints(), n = X.fromPoint3(this._view.projectPoint(i[0]));
    X.distance(n, t) < this._markupItem.pointRadius ? i.length > 2 && (this._markupItem.isLoop = !0, this._finalizeMeasurement()) : (this._markupItem.addPoint(e.worldPosition), this._updateAnchor(t, e.worldPosition));
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), n = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (n === null || n.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(n) : this._updateMarkupItem(t, n);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive()) return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), n = e;
      await this._updateMeasurementItem(n, i);
    }
    this._draw(), super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null) return;
    const e = this._view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem) return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case ll.Last:
          this._calculateAnchorPos(t, e);
          break;
        case ll.First: {
          if (i.length !== 2) return;
          const n = this._view.projectPoint(i[0]);
          this._calculateAnchorPos(X.fromPoint3(n), i[0]);
          break;
        }
        case ll.Midpoint: {
          let n;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let h = 1; h < i.length; h++) {
            const u = m.subtract(i[h], i[h - 1]), f = u.length(), g = o + f;
            if (g > r) {
              const _ = (r - o) / f;
              u.scale(_), n = m.add(i[h - 1], u);
              break;
            }
            o = g;
          }
          const l = this._view.projectPoint(n);
          this._calculateAnchorPos(X.fromPoint3(l), n);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._view.getCamera(), i = m.subtract(e.getPosition(), t);
    return i.normalize(), ln.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._view.getCamera();
    m.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._view.raycastFromPoint(X.add(t, this._textShapeOffset));
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t, this._viewer.view);
    return e && e.getClassName() === "Communicator.MeasurePolylineDistanceMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Qe.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const lx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceOperator: dy,
  MeasureEdgeLengthOperator: fy,
  MeasureFaceFaceAngleOperator: gy,
  MeasureFaceFaceDistanceOperator: py,
  MeasureLineLineAngleOperator: _y,
  MeasurePointPointDistanceOperator: yy,
  MeasurePolygonAreaAnchor: al,
  MeasurePolygonAreaOperator: wy,
  MeasurePolylineDistanceAnchor: ll,
  MeasurePolylineDistanceOperator: vy,
  PointCursor: Oh,
  SelectionPoints: my,
  Stage: As,
  worldPointToScreenPoint: Tu
}, Symbol.toStringTag, { value: "Module" })), cx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceMarkup: yl,
  MeasureCircleEdgeLengthMarkup: wl,
  MeasureFaceFaceAngleMarkup: vl,
  MeasureFaceFaceDistanceMarkup: bl,
  MeasureLengthMarkup: ah,
  MeasureLineLineAngleMarkup: xl,
  MeasureMarkup: Rn,
  MeasurePointPointDistanceMarkup: Il,
  MeasurePolygonAreaMarkup: Cl,
  MeasurePolylineDistanceMarkup: Sl,
  MeasureStraightEdgeLengthMarkup: lh
}, Symbol.toStringTag, { value: "Module" })), hl = class hl extends go {
  constructor(t, e, i, n, r) {
    super(), this._uniqueId = Ms(), this._noteElementId = null, this._position = m.zero(), this._text = "", this._color = yt.white(), this._sphereRadius = 0.03, this._deleted = !1, this._active = !1, this._callbacks = null, this._viewer = t, this._noteTextManager = e, this._selectionPosition = i, this._selectionNormal = n, this._partId = r, this._noteTextManager.addNote(this), this._init();
  }
  async _init() {
    const t = this._createPinTransformationMatrix(
      this._selectionPosition,
      this._selectionNormal
    ), [e, i] = await Promise.all([
      this._createPinStemInstance(t),
      this._createPinSphereInstance(t)
    ]);
    this._stemInstanceId = e, this._sphereInstanceId = i, await this._restore(!1), this._callbacks = {
      visibilityChanged: () => {
        this._matchPartVisibility();
      }
    }, this._viewer.setCallbacks(this._callbacks), this._viewer.trigger("noteTextCreated", this);
  }
  _matchPartVisibility() {
    if (this._sphereInstanceId === void 0 || this._stemInstanceId === void 0)
      return;
    const t = this._viewer.model, e = t.getNodeVisibility(this._partId), i = t.getNodeVisibility(this._sphereInstanceId);
    e !== i && !this._noteTextManager.getExplodeActive() && t.setNodesVisibility([this._stemInstanceId, this._sphereInstanceId], e);
    const n = this._noteTextManager.getActiveItem();
    n !== null && n.getStemInstanceId() === this._stemInstanceId && !e && this.hide();
  }
  async updatePosition() {
    if (this._sphereInstanceId === void 0)
      return;
    const t = await this._viewer.model.getNodeRealBounding(this._sphereInstanceId);
    this._pinBoundingBox = t, this._position = this._pinBoundingBox.center(), this.setText(this._text);
  }
  async _restore(t) {
    this._noteTextManager.setActiveItemHandle(
      this._viewer.markupManager.registerMarkup(this, this._viewer.view)
    ), this._noteTextManager.setActiveItem(this), this._show(t), this._updateColor(), await this.draw();
  }
  async restore() {
    return this._restore(!0);
  }
  setText(t) {
    this._text = t, this._noteTextManager.getNoteTextElement().setText(t);
  }
  saveTextValue() {
    this._text = this._noteTextManager.getNoteTextElement().getText();
  }
  async draw() {
    if (this._deleted || !this._active)
      return;
    this._behindView = !1, await this.updatePosition();
    const t = this._viewer.view.projectPoint(this._position);
    if (t.z <= 0 && (this._behindView = !0), this._behindView)
      this._noteElementId !== null && document.getElementById(this._noteElementId) !== null && (this._viewer.markupManager.removeMarkupElement(this._noteElementId, this._viewer.view), this._noteElementId = null);
    else {
      const e = new X(t.x, t.y), i = this._noteTextManager.getNoteTextElement();
      i.setPosition(e), this._noteElementId === null && (this._noteElementId = this._viewer.markupManager.addMarkupElement(
        i.getHtmlContainer(),
        this._viewer.view
      ));
    }
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    if (!this._active) return !1;
    const n = this._noteTextManager.getNoteTextElement(), r = n.getPosition(), o = n.getSize();
    return Mm(t, r, o, i);
  }
  getClassName() {
    return hl.className;
  }
  getUniqueId() {
    return this._uniqueId;
  }
  getSphereInstanceId() {
    return this._sphereInstanceId;
  }
  getStemInstanceId() {
    return this._stemInstanceId;
  }
  onSelect() {
    this._noteTextManager.getNoteTextElement().focus();
  }
  onDeselect() {
    this._noteTextManager.getNoteTextElement().blur();
  }
  hide() {
    const t = this._noteTextManager.getNoteTextElement();
    t.hide(), this.setText(t.getText()), this._noteTextManager.setActiveItem(null), this._active = !1, this._viewer.trigger("noteTextHidden", this);
  }
  _show(t) {
    this._noteTextManager.getNoteTextElement().show(this), this._active = !0, t && this._viewer.trigger("noteTextShown", this);
  }
  show() {
    this._show(!0);
  }
  async remove(t) {
    if (this.getRemoved() === !0)
      return;
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null);
    const e = this._viewer.model, i = [];
    this._stemInstanceId !== void 0 && i.push(e.deleteMeshInstances([this._stemInstanceId])), this._sphereInstanceId !== void 0 && i.push(e.deleteMeshInstances([this._sphereInstanceId])), this.hide(), this._noteTextManager.removeNote(this), this._deleted = !0, await We(i), super.remove(t);
  }
  getRemoved() {
    return this._deleted;
  }
  setColor(t) {
    return this._color = t, this._updateColor(), Promise.resolve();
  }
  getColor() {
    return this._color;
  }
  getPartId() {
    return this._partId;
  }
  _updateColor() {
    this._sphereInstanceId !== void 0 && this._viewer.model.setNodesFaceColor([this._sphereInstanceId], this._color);
  }
  // pin methods
  _createPinTransformationMatrix(t, e) {
    let i = 0, n = e.x;
    Math.abs(e.y) < Math.abs(n) && (n = e.y, i = 1), Math.abs(e.z) < Math.abs(n) && (i = 2);
    const r = [0, 0, 0];
    r[i] = 1;
    const o = m.createFromArray(r), l = m.cross(e, o).normalize(), h = m.cross(e, l);
    let u = new wt();
    return u.m = [
      e.x,
      e.y,
      e.z,
      0,
      l.x,
      l.y,
      l.z,
      0,
      h.x,
      h.y,
      h.z,
      0,
      0,
      0,
      0,
      1
    ], u = wt.multiply(
      u,
      new wt().setScaleComponent(this._sphereRadius, this._sphereRadius, this._sphereRadius)
    ), u.setTranslationComponent(t.x, t.y, t.z), u;
  }
  async _createPinStemInstance(t) {
    const e = this._noteTextManager.getPinStemMeshId();
    if (e === null)
      throw new oe("stem mesh hasn't been created yet");
    const i = new tr(
      e,
      t,
      "pin-stem-instance",
      void 0,
      yt.black()
    );
    i.setOpacity(1);
    const n = ee.SuppressCameraScale | ee.DoNotCut | ee.DoNotExplode | ee.DoNotXRay | ee.ExcludeBounding | ee.OverrideSceneVisibility | ee.AlwaysDraw;
    return i.setCreationFlags(n), this._viewer.model.createMeshInstance(i, void 0, !0, !0);
  }
  async _createPinSphereInstance(t) {
    const e = this._noteTextManager.getPinSphereMeshId();
    if (e === null)
      throw new oe("sphere mesh hasn't been created yet");
    const i = new tr(
      e,
      t,
      "pin-sphere-instance",
      yt.white(),
      void 0
    );
    i.setOpacity(1);
    const n = ee.SuppressCameraScale | ee.DoNotCut | ee.DoNotExplode | ee.DoNotXRay | ee.ExcludeBounding | ee.OverrideSceneVisibility | ee.AlwaysDraw;
    return i.setCreationFlags(n), this._viewer.model.createMeshInstance(i, void 0, !0, !0);
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      selectionPosition: this._selectionPosition.toJson(),
      selectionNormal: this._selectionNormal.toJson(),
      text: this._text,
      color: this._color,
      partId: this._partId
    };
  }
  static _fromJson(t, e, i) {
    const n = t;
    if (!i.findById(n.uniqueId)) {
      const r = m.fromJson(n.selectionPosition), o = m.fromJson(n.selectionNormal), l = n.partId, h = new hl(
        e,
        i,
        r,
        o,
        l
      );
      return h._uniqueId = n.uniqueId, h.setText(n.text), h.setColor(yt.fromJson(n.color)), h;
    }
    return null;
  }
  /**
   * Creates a new [[NoteText]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(t, e, i) {
    return hl._fromJson(t, e, i);
  }
};
hl.className = "Communicator.Markup.Note.NoteText";
let Da = hl;
us(Da.className, Da.fromJson);
class by {
  constructor() {
    this._positionOffset = X.zero(), this._position = X.zero(), this._activeNoteText = null, this._createTextBox();
  }
  _createTextBox() {
    this._container = document.createElement("div"), this._container.className = "noteTextElement", this._textArea = document.createElement("textarea"), this._textArea.oninput = () => {
      this._activeNoteText !== null && this._activeNoteText.saveTextValue();
    }, this._container.appendChild(this._textArea);
    const t = ["blue", "red", "green", "white", "black"];
    let e = 7;
    t.forEach((n) => {
      const r = document.createElement("button");
      r.className = `noteButton color ${n}`, r.style.top = `${e}px`, e += 25, r.id = `${n}_button`;
      let o;
      switch (n) {
        case "blue":
          o = yt.blue();
          break;
        case "red":
          o = yt.red();
          break;
        case "green":
          o = yt.green();
          break;
        case "white":
          o = yt.white();
          break;
        case "black":
          o = yt.black();
          break;
        default:
          o = yt.white();
          break;
      }
      r.onmousedown = () => {
        this._activeNoteText !== null && this._activeNoteText.setColor(o);
      }, this._container.appendChild(r);
    });
    const i = document.createElement("button");
    i.className = "noteButton trash", i.style.top = `${e}px`, i.onmousedown = async () => {
      this._activeNoteText !== null && await this._activeNoteText.remove(null);
    }, this._container.appendChild(i);
  }
  /**
   * Sets the corner offset position of the HTML container.
   * @param positionOffset
   */
  setPositionOffset(t) {
    this._positionOffset = t;
  }
  /**
   * @returns the current HTML container offset position.
   */
  getPositionOffset() {
    return this._positionOffset.copy();
  }
  /**
   * Sets the position of the HTML container, taking into account the position offset.
   * @param position
   */
  setPosition(t) {
    this._position = X.add(t, this._positionOffset), this._container.style.left = `${this._position.x}px`, this._container.style.top = `${this._position.y}px`;
  }
  /**
   * @returns the position of the HTML container, taking into account the position offset.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the text in the HTML container text area.
   * @param text
   */
  setText(t) {
    const e = this._container.querySelector("textarea");
    e !== null && (e.value = t);
  }
  /**
   * @returns the current text in the HTML container text area.
   */
  getText() {
    const t = this._container.querySelector("textarea");
    return t !== null ? t.value : "";
  }
  /**
   * Sets the size of the HTML container.
   * @param size
   */
  setSize(t) {
    this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`;
  }
  /**
   * @returns the size of the HTML container.
   */
  getSize() {
    const t = this._container.getBoundingClientRect();
    return new X(t.width, t.height);
  }
  /**
   * Puts the cursor focus in the HTML container text area.
   */
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto";
  }
  /**
   * Removes the cursor focus from the HTML container text area.
   */
  blur() {
    this._container.blur();
  }
  /**
   * Hides the HTML container.
   */
  hide() {
    this._container.style.visibility = "hidden", this._activeNoteText = null;
  }
  /**
   * Sets the active NoteText and shows the HTML container.
   * @param noteText
   */
  show(t) {
    this._container.style.visibility = "visible", this._activeNoteText = t;
  }
  /**
   * @returns the HTML container element.
   */
  getHtmlContainer() {
    return this._container;
  }
  /**
   * Sets the HTML container element.
   * @param container
   */
  setHtmlContainer(t) {
    this._container = t;
  }
}
class bd {
  /**
   * @returns JSON Array containing markup data.
   */
  exportMarkup() {
    return [];
  }
  /**
   * Loads JSON markup data
   * @param jsonData JSON Array containing markup data.
   */
  loadData(t) {
    return Promise.resolve([]);
  }
}
const Fr = class Fr extends bd {
  constructor(t) {
    super(), this._pinSphereMeshId = null, this._pinStemMeshId = null, this._noteTextList = [], this._activeItemHandle = null, this._activeItem = null, this._explodeActive = !1, this._isolateActive = !1, this._stemLength = 2, this._sphereIterations = 2, this._viewer = t, this._noteTextElement = new by(), this._noteTextElement.setPositionOffset(new X(12, -24));
    const e = {
      sceneReady: async () => {
        await this._init();
      },
      modelSwitched: async () => {
        await this._init();
      }
    };
    this._viewer.setCallbacks(e);
  }
  async _init() {
    Fr._globalPinSphereMeshData === null && (Fr._globalPinSphereMeshData = this._createPinSphereMeshData()), Fr._globalPinStemMeshData === null && (Fr._globalPinStemMeshData = this._createPinStemMeshData());
    const t = this._viewer.model, e = t.createMesh(Fr._globalPinSphereMeshData), i = t.createMesh(Fr._globalPinStemMeshData), n = await Promise.all([e, i]);
    this._pinSphereMeshId = n[0], this._pinStemMeshId = n[1];
  }
  _createPinStemMeshData() {
    const t = new Ss();
    return t.addPolyline([0, 0, 0, this._stemLength, 0, 0]), t;
  }
  _createPinSphereMeshData() {
    const t = (1 + Math.sqrt(5)) / 2, e = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * t), i = e / 2, n = e / (2 * t), r = [];
    r[0] = new m(-n, i, 0), r[1] = new m(n, i, 0), r[2] = new m(-n, -i, 0), r[3] = new m(n, -i, 0), r[4] = new m(0, -n, i), r[5] = new m(0, n, i), r[6] = new m(0, -n, -i), r[7] = new m(0, n, -i), r[8] = new m(i, 0, -n), r[9] = new m(i, 0, n), r[10] = new m(-i, 0, -n), r[11] = new m(-i, 0, n);
    for (const g of r)
      g.normalize();
    let o = [
      [0, 11, 5],
      [0, 5, 1],
      [0, 1, 7],
      [0, 7, 10],
      [0, 10, 11],
      [1, 5, 9],
      [5, 11, 4],
      [11, 10, 2],
      [10, 7, 6],
      [7, 1, 8],
      [3, 9, 4],
      [3, 4, 2],
      [3, 2, 6],
      [3, 6, 8],
      [3, 8, 9],
      [4, 9, 5],
      [2, 4, 11],
      [6, 2, 10],
      [8, 6, 7],
      [9, 8, 1]
    ], l = 12;
    for (let g = 0; g < this._sphereIterations; g++) {
      const y = [];
      o.map((_) => {
        const x = r[_[0]], b = r[_[1]], I = r[_[2]];
        r[l++] = new m(x.x + b.x, x.y + b.y, x.z + b.z).scale(0.5).normalize(), r[l++] = new m(b.x + I.x, b.y + I.y, b.z + I.z).scale(0.5).normalize(), r[l++] = new m(I.x + x.x, I.y + x.y, I.z + x.z).scale(0.5).normalize(), y.push([_[0], l - 3, l - 1]), y.push([l - 3, l - 2, l - 1]), y.push([l - 3, _[1], l - 2]), y.push([l - 2, _[2], l - 1]);
      }), o = y;
    }
    const h = [], u = [];
    for (const g of o)
      for (let y = 0; y < 3; y++) {
        const _ = g[y], x = r[_];
        h.push(x.x + this._stemLength + 1), h.push(x.y), h.push(x.z);
        const b = x.normalize();
        u.push(b.x), u.push(b.y), u.push(b.z);
      }
    const f = new Ss();
    return f.addFaces(h, u), f.setFaceWinding(Qs.CounterClockwise), f;
  }
  /**
   * Retrieves the mesh id of the stem of the note pin, if there is one
   * @returns MeshId of the note pin stem, or null if there is none
   */
  getPinStemMeshId() {
    return this._pinStemMeshId;
  }
  /**
   * Retrieves the mesh id of the spherical head of the note pin, if there is one
   * @returns MeshId of the note pin sphere, or null if there is none
   */
  getPinSphereMeshId() {
    return this._pinSphereMeshId;
  }
  /**
   * Retrieves the note text element
   * @returns note text element
   */
  getNoteTextElement() {
    return this._noteTextElement;
  }
  /**
   * Sets the note text element
   * @param noteTextElement
   */
  setNoteTextElement(t) {
    this._noteTextElement.hide(), this._noteTextElement = t;
  }
  /**
   * Gets an array of all NoteText items that have been added to the manager
   * @returns array of all NoteText items
   */
  getNoteTextList() {
    return this._noteTextList;
  }
  /**
   * Adds a note and makes it active
   * @param note NoteText to be added to the manager
   */
  addNote(t) {
    this._noteTextList.push(t), this._activeItem = t;
  }
  /**
   * Removes a note from the manager
   * @param note NoteText to be removed from the manager
   */
  removeNote(t) {
    const e = this._noteTextList.indexOf(t);
    this._noteTextList.splice(e, 1);
  }
  /**
   * Updates note pin visibility based on manager state (namely the current explode state)
   */
  async updatePinVisibility() {
    if (this._noteTextList.length > 0) {
      const t = [];
      for (const i of this._noteTextList) {
        const n = i.getSphereInstanceId(), r = i.getStemInstanceId();
        n !== void 0 && t.push(n), r !== void 0 && t.push(r);
      }
      const e = this._viewer.model.setNodesVisibility(t, !this._explodeActive);
      return this._explodeActive && this._noteTextElement.hide(), e;
    }
  }
  /**
   * Sets manager explode state based on explosion magnitude. Active explosion hides note pins
   * @param magnitude Explosion magnitude
   */
  explode(t) {
    return this._explodeActive = t > 0, this.updatePinVisibility();
  }
  /**
   * Gets managers explosion state. Active explosion hides note pins
   */
  getExplodeActive() {
    return this._explodeActive;
  }
  /**
   * Sets whether an isolate is currently active or not
   * @param isolateActive
   */
  setIsolateActive(t) {
    this._isolateActive = t;
  }
  /**
   * Gets whether an isolate is currently active or not
   * @returns isolate status
   */
  getIsolateActive() {
    return this._isolateActive;
  }
  /**
   * Get the currently active note text
   * @returns Currently active note text
   */
  getActiveItem() {
    return this._activeItem;
  }
  /**
   * Sets a new currently active note text
   * @param activeItem note text to be marked as currently active
   */
  setActiveItem(t) {
    this._activeItem = t;
  }
  /**
   * Get the active handle string, such as the one returned by [[MarkupManager.registerMarkup]]
   * @returns Active handle string
   */
  getActiveItemHandle() {
    return this._activeItemHandle;
  }
  /**
   * Set the active handle string, should be provided by [[MarkupManager.registerMarkup]]
   * @param activeItemHandle Active handle string
   */
  setActiveItemHandle(t) {
    this._activeItemHandle = t;
  }
  /**
   * Attempts to set the active note to the one associated with the
   * pins elected by the provided [[SelectionItem]]
   * @param selection SelectionItem to attempt to find note from
   */
  selectPin(t) {
    this._activeItem && this._activeItem.hide();
    const e = t.getNodeId();
    if (e !== null) {
      const i = this._getNoteTextFromNodeId(e);
      if (i !== null)
        return i.restore(), !0;
    }
    return !1;
  }
  /**
   * Checks if a nodeId is part of a note pin
   * @param nodeId NodeId to be checked
   */
  checkPinInstance(t) {
    return this._getNoteTextFromNodeId(t) !== null;
  }
  _getNoteTextFromNodeId(t) {
    for (const e of this._noteTextList)
      if (e.getSphereInstanceId() === t || e.getStemInstanceId() === t)
        return e;
    return null;
  }
  /**
   * Checks if a UUID is associated with any existing notes
   * @param id UUID to check
   */
  findById(t) {
    for (const e of this._noteTextList)
      if (t === e.getUniqueId())
        return !0;
    return !1;
  }
  /**
   * Loads notes from an iterable of JSON data like that returned by [[exportMarkup]]
   * @param notes JSON note data iterable
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      const n = Da.fromJson(i, this._viewer, this).then((r) => r !== null);
      e.push(n);
    }
    return Promise.all(e);
  }
  /**
   * Exports note texts to an array of JSON Objects that can be restored via [[loadData]]
   * @returns Array of JSON objects representing notes
   */
  exportMarkup() {
    const t = [];
    for (const e of this._noteTextList)
      t.push(e.toJson());
    return t;
  }
};
Fr._globalPinSphereMeshData = null, Fr._globalPinStemMeshData = null;
let ch = Fr;
const hx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NoteText: Da,
  NoteTextElement: by,
  NoteTextManager: ch
}, Symbol.toStringTag, { value: "Module" }));
class wc {
  constructor(t, e, i, n, r, o) {
    this.vector = e, this.matrix = i, this.nodeId = n, this.position = t, this.handleType = r, this.translation = m.zero(), this.groupId = o;
  }
}
class xy {
  constructor() {
    this.axis = null, this.plane = null, this.viewPlane = null, this.rotate = null;
  }
}
const he = class he extends go {
  constructor(t) {
    super(), this._meshIds = new xy(), this._scaleModifier = 1, this._id = 0, this._handleData = /* @__PURE__ */ new Map(), this._translationFromInitialHandlePosition = m.zero(), this._groupIdRotationMatrix = /* @__PURE__ */ new Map(), this._viewer = t, this._callbacks = {
      camera: () => {
        this._updateCamera();
      },
      _assemblyTreeReady: async () => {
        this._updateViewport(), this._hideOverlay();
        const e = this._createMeshId(this._getAxisMeshData()).then((o) => {
          this._meshIds.axis = o;
        }), i = this._createMeshId(this._getPlaneMeshData()).then((o) => {
          this._meshIds.plane = o;
        }), n = this._createMeshId(this._getViewPlaneMeshData()).then((o) => {
          this._meshIds.viewPlane = o;
        }), r = this._createMeshId(this._getRotateMeshData()).then((o) => {
          this._meshIds.rotate = o;
        });
        await Promise.all([e, i, n, r]);
      },
      modelSwitchStart: () => {
        this.removeHandles();
      }
    }, this._viewer.setCallbacks(this._callbacks);
  }
  remove(t) {
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null), super.remove(t);
  }
  _getAxisMeshData() {
    return og(
      he._cylinderRadius,
      he._segmentCount,
      he._cylinderHeight,
      he._coneBaseRadius,
      he._capHeight,
      he._taperHeight
    );
  }
  _getPlaneMeshData() {
    const t = new m(he._planeOffset, 0, he._planeOffset), e = new m(
      he._planeOffset + he._planeLength,
      0,
      he._planeOffset
    ), i = new m(
      he._planeOffset + he._planeLength,
      0,
      he._planeOffset + he._planeLength
    ), n = new m(
      he._planeOffset,
      0,
      he._planeOffset + he._planeLength
    ), r = [
      t.x,
      t.y,
      t.z,
      e.x,
      e.y,
      e.z,
      i.x,
      i.y,
      i.z,
      t.x,
      t.y,
      t.z,
      i.x,
      i.y,
      i.z,
      n.x,
      n.y,
      n.z
    ], o = new m(0, -1, 0), l = [
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z
    ], h = new Ss();
    return h.addFaces(r, l), h.setBackfacesEnabled(!0), h.addPolyline([t.x, t.y, t.z, e.x, e.y, e.z]), h.addPolyline([e.x, e.y, e.z, i.x, i.y, i.z]), h.addPolyline([i.x, i.y, i.z, n.x, n.y, n.z]), h.addPolyline([n.x, n.y, n.z, t.x, t.y, t.z]), h;
  }
  _getViewPlaneMeshData() {
    return Ym();
  }
  _getRotateMeshData(t = 35, e = 12, i = 0.5) {
    const n = t * Math.PI / 180, r = 0.1, o = 0.5 * n, l = [];
    for (let g = -o; g <= o; g += r) {
      const y = Math.sin(g) * e, _ = Math.cos(g) * e;
      l.push(_), l.push(0), l.push(y);
    }
    const h = new m(0, 0, 1), f = Qm(l, h, 10, i);
    return f.setBackfacesEnabled(!0), f;
  }
  async setAxisMeshData(t) {
    if (this._meshIds.axis === null) {
      const e = await this._createMeshId(t);
      this._meshIds.axis = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.axis, t);
  }
  async setPlaneMeshData(t) {
    if (this._meshIds.plane === null) {
      const e = await this._createMeshId(t);
      this._meshIds.plane = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.plane, t);
  }
  async setViewPlaneMeshData(t) {
    if (this._meshIds.viewPlane === null) {
      const e = await this._createMeshId(t);
      this._meshIds.viewPlane = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.viewPlane, t);
  }
  async setRotateMeshData(t) {
    if (this._meshIds.rotate === null) {
      const e = await this._createMeshId(t);
      this._meshIds.rotate = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.rotate, t);
  }
  /**
   * Gets the associated overlay id
   */
  getOverlayId() {
    return be.Handles;
  }
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(be.Handles, !1);
  }
  hideOverlay() {
    return this._hideOverlay(), Promise.resolve();
  }
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(be.Handles, !0), this._updateCamera();
  }
  showOverlay() {
    return this._showOverlay(), Promise.resolve();
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      be.Handles,
      qe.UpperLeftCorner,
      0,
      Fe.ProportionOfCanvas,
      0,
      Fe.ProportionOfCanvas,
      1,
      Fe.ProportionOfCanvas,
      1,
      Fe.ProportionOfCanvas
    );
  }
  updateViewport() {
    return this._updateViewport(), Promise.resolve();
  }
  async addHandles(t, e, i) {
    this._scaleModifier = e, this._translationFromInitialHandlePosition.assign(m.zero()), await this.createDefaultHandles(t, i), this._showOverlay();
  }
  _updateCamera() {
    this._viewer.overlayManager.setCamera(
      be.Handles,
      this._viewer.view.getCamera()
    );
  }
  getVector(t) {
    const e = this._handleData.get(t);
    if (e !== void 0) {
      const i = e.vector;
      if (i !== null)
        return i.copy();
    }
    return null;
  }
  getHandleType(t) {
    const e = this._handleData.get(t);
    return e === void 0 ? null : e.handleType;
  }
  getHandleGroupId(t) {
    const e = this._handleData.get(t);
    return e === void 0 ? he.defaultGroupId : e.groupId;
  }
  getPosition(t) {
    const e = this._handleData.get(t);
    if (e) {
      const i = e.translation.copy();
      return e.position.copy().add(this._translationFromInitialHandlePosition).add(i);
    } else
      return null;
  }
  getHandleNodeIds(t = null) {
    let e = [];
    return this._handleData.forEach((i, n) => {
      e.push([n, i]);
    }), t !== null && (e = e.filter((i) => i[1].groupId === t)), e.map((i) => i[0]);
  }
  async removeHandles(t = null) {
    const e = this.getHandleNodeIds(t);
    t === null ? (this._handleData.clear(), this._groupIdRotationMatrix.clear()) : (e.forEach((i) => {
      this._handleData.delete(i);
    }), this._groupIdRotationMatrix.delete(t)), this._handleData.size === 0 && (this._id = 0, this._hideOverlay()), await this._viewer.model.deleteMeshInstances(e);
  }
  isEmpty() {
    return this._handleData.size === 0;
  }
  async createDefaultHandles(t, e) {
    const i = [];
    i.push(this.addViewPlaneHandle(t, he._viewPlaneColor, e)), i.push(
      this.addAxisTranslationHandle(
        t,
        new m(1, 0, 0),
        he._xColor,
        null,
        e
      )
    ), i.push(
      this.addAxisTranslationHandle(
        t,
        new m(0, 1, 0),
        he._yColor,
        null,
        e
      )
    ), i.push(
      this.addAxisTranslationHandle(
        t,
        new m(0, 0, 1),
        he._zColor,
        null,
        e
      )
    ), i.push(
      this.addPlaneTranslationHandle(
        t,
        new m(1, 0, 0),
        he._zColor,
        yt.black(),
        new m(0, -1, 0),
        e
      )
    ), i.push(
      this.addPlaneTranslationHandle(
        t,
        new m(0, 1, 0),
        he._xColor,
        yt.black(),
        new m(0, 0, -1),
        e
      )
    ), i.push(
      this.addPlaneTranslationHandle(
        t,
        new m(0, 0, 1),
        he._yColor,
        yt.black(),
        new m(-1, 0, 0),
        e
      )
    ), i.push(
      this.addRotateHandle(
        t,
        new m(1, 0, 0),
        he._zColor,
        new m(0, -1, 0),
        e
      )
    ), i.push(
      this.addRotateHandle(
        t,
        new m(0, 1, 0),
        he._xColor,
        new m(0, 0, -1),
        e
      )
    ), i.push(
      this.addRotateHandle(
        t,
        new m(0, 0, 1),
        he._yColor,
        new m(-1, 0, 0),
        e
      )
    ), await Promise.all(i);
  }
  async _createMeshId(t) {
    return await this._viewer.model.createMesh(t, { doNotDelete: !0 });
  }
  async addAxisTranslationHandle(t, e, i, n, r) {
    this._meshIds.axis === null && (this._meshIds.axis = await this._createMeshId(this._getAxisMeshData()));
    const o = `handle-axis-translation-${this._id++}`, l = this._getRotationMatrixFromVector(e, n), h = await this._createMeshInstance(
      this._meshIds.axis,
      o,
      i,
      null,
      t.copy(),
      l.copy()
    );
    return this._handleData.set(
      h,
      new wc(
        t.copy(),
        e.copy(),
        l.copy(),
        h,
        zr.Axis,
        r
      )
    ), h;
  }
  async addViewPlaneHandle(t, e, i) {
    this._meshIds.viewPlane === null && (this._meshIds.viewPlane = await this._createMeshId(this._getViewPlaneMeshData()));
    const n = await this._createMeshInstance(
      this._meshIds.viewPlane,
      "handle-sphere-instance",
      e,
      null,
      t,
      new wt()
    );
    return this._handleData.set(
      n,
      new wc(t.copy(), null, new wt(), n, zr.ViewPlane, i)
    ), n;
  }
  async addPlaneTranslationHandle(t, e, i, n, r, o) {
    this._meshIds.plane === null && (this._meshIds.plane = await this._createMeshId(this._getPlaneMeshData()));
    const l = `handle-plane-translation-${this._id++}`, h = this._getRotationMatrixFromVector(e, r), u = await this._createMeshInstance(
      this._meshIds.plane,
      l,
      i,
      n,
      t,
      h
    );
    return this._handleData.set(
      u,
      new wc(
        t.copy(),
        e.copy(),
        h.copy(),
        u,
        zr.Plane,
        o
      )
    ), u;
  }
  async addRotateHandle(t, e, i, n, r) {
    this._meshIds.rotate === null && (this._meshIds.rotate = await this._createMeshId(this._getRotateMeshData()));
    const o = `handle-rotate-${this._id++}`, l = this._getRotationMatrixFromVector(e, n), h = await this._createMeshInstance(
      this._meshIds.rotate,
      o,
      i,
      null,
      t,
      l
    );
    return this._handleData.set(
      h,
      new wc(
        t.copy(),
        e.copy(),
        l.copy(),
        h,
        zr.Rotate,
        r
      )
    ), h;
  }
  _getRotationMatrixFromVector(t, e) {
    e || (e = new m(1, 0, 0), m.cross(e, t).squaredLength() < 1e-3 && (e = new m(0, 1, 0)));
    const i = m.cross(e, t).normalize(), n = m.cross(i, t).normalize();
    t.normalize();
    const r = new wt();
    return r.m[0] = i.x, r.m[1] = i.y, r.m[2] = i.z, r.m[3] = 0, r.m[4] = t.x, r.m[5] = t.y, r.m[6] = t.z, r.m[7] = 0, r.m[8] = n.x, r.m[9] = n.y, r.m[10] = n.z, r.m[11] = 0, r.m[12] = 0, r.m[13] = 0, r.m[14] = 0, r.m[15] = 1, r;
  }
  async _createMeshInstance(t, e, i, n, r, o) {
    let l = this._createTransformationMatrix(r, new wt());
    l = wt.multiply(o, l);
    const h = new tr(
      t,
      l,
      e,
      i ?? void 0,
      n ?? void 0
    );
    return h.setOpacity(1), h.setCreationFlags(
      ee.SuppressCameraScale | ee.DoNotCut | ee.DoNotExplode | ee.ExcludeBounding | ee.DoNotXRay | ee.OverrideSceneVisibility | ee.AlwaysDraw
    ), h.setOverlayIndex(be.Handles), this._viewer.model.createMeshInstance(h, void 0, !1, !0);
  }
  _createTransformationMatrix(t, e) {
    const i = he._defaultScale * this._scaleModifier;
    let n = new wt().setScaleComponent(i, i, i);
    return n = wt.multiply(n, e), n.setTranslationComponent(t.x, t.y, t.z), n;
  }
  _getHandlePosition(t) {
    let e = null;
    return this._handleData.forEach((i) => {
      i.groupId === t && (e = i.position.copy());
    }), e;
  }
  getGroupIdRotationMatrix(t) {
    const e = this._groupIdRotationMatrix.get(t);
    return e === void 0 ? new wt() : e.copy();
  }
  async updatePosition(t, e, i, n, r) {
    const o = this._viewer.model, l = [], h = /* @__PURE__ */ new Map(), u = this._getHandlePosition(n);
    u !== null && (this._handleData.forEach((f, g) => {
      const y = f.groupId, _ = r.get(y) !== void 0;
      if (!(y === n) && !_)
        return;
      const b = f.position.copy();
      b.add(t.copy());
      const I = f.translation.copy();
      b.add(I);
      const C = wt.multiply(
        this.getGroupIdRotationMatrix(y),
        e
      ), M = wt.multiply(f.matrix, C);
      if (_) {
        const O = m.subtract(b, u);
        e.transform(O, b), b.add(u);
      }
      const P = this._createTransformationMatrix(b, M);
      i && (f.position.assign(b), h.set(
        y,
        wt.multiply(this.getGroupIdRotationMatrix(y), e)
      )), l.push(o.setNodeMatrix(g, P));
    }), h.forEach((f, g) => {
      this._groupIdRotationMatrix.set(g, f.copy());
    }), await Promise.all(l));
  }
  resetTranslation() {
    this._translationFromInitialHandlePosition && (this._handleData.forEach((t) => {
      t.translation.add(this._translationFromInitialHandlePosition);
    }), this._translationFromInitialHandlePosition.assign(m.zero()));
  }
  getTranslation() {
    return this._translationFromInitialHandlePosition;
  }
};
he.className = "Communicator.Markup.HandleMarkup", he.defaultGroupId = -1, he._defaultScale = 0.02, he._cylinderRadius = 0.5, he._coneBaseRadius = 0.9, he._cylinderHeight = 7, he._capHeight = 1.2, he._taperHeight = 0.2, he._segmentCount = 20, he._planeOffset = 1, he._planeLength = 2.5, he._xColor = new yt(168, 56, 59), he._yColor = new yt(96, 166, 50), he._zColor = new yt(41, 81, 185), he._viewPlaneColor = yt.white();
let hh = he;
const ux = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CursorMarkup: kg,
  HandleData: wc,
  HandleMarkup: hh,
  HandleMeshIds: xy,
  Measure: cx,
  Note: hx,
  Redline: Gb
}, Symbol.toStringTag, { value: "Module" }));
class Rh extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._activeRedlineItem = null, this._newRedlineItem = null, this._viewer = t;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  createRedlineItem(t) {
    return null;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  updateRedlineItem(t) {
  }
  // Interface method for derived operators to implement
  /** @hidden */
  finalizeRedlineItem(t) {
    return null;
  }
  // Default behavior for redline operators
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && ((t.getButton() === Te.Left || this._primaryTouchId !== null) && this._redlineOperatorStart(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && (this._redlineOperatorMove(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && ((t.getButton() === Te.Left || this._primaryTouchId !== null) && this._redlineOperatorEnd(), t.setHandled(!0)), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    t.setHandled(!0);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  setHandled() {
    return !0;
  }
  _isRedlineItem(t) {
    return Object.getPrototypeOf(t) instanceof Al;
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    if (e === Qe.Backspace || e === Qe.Delete) {
      const i = this._viewer.markupManager, n = i.getSelectedMarkup(), r = i.getActiveMarkupView(this._view);
      n !== null && this._isRedlineItem(n) && r !== null && (r.removeMarkup(n), i.selectMarkup(null, this._view));
    }
  }
  _removeRedlineTextIfInvalid(t) {
    const e = t;
    if (!e.isValid()) {
      const i = this._viewer.markupManager.getActiveMarkupView(this._view);
      i !== null && (i.removeMarkup(e), this._viewer.trigger("redlineDeleted", e)), e.remove(null);
    }
  }
  // Generic behavior to handle dragging of redline
  _redlineOperatorStart() {
    const t = this._viewer.markupManager, e = t.pickMarkupItem(this._ptFirst, this._view), i = t.getSelectedMarkup();
    if (!e)
      i != null && i.onDeselect(), t.selectMarkup(null, this._view), this._markupIsTextArea(i) ? this._removeRedlineTextIfInvalid(i) : this._newRedlineItem = this.createRedlineItem(this._ptFirst);
    else if (this._activeRedlineItem = e, this._dragging && this._activeRedlineItem.onDragStart(this._ptFirst, this._view)) {
      t.refreshMarkup(this._view);
      const n = this._viewer.markupManager.getActiveMarkupView(this._view);
      n && this._viewer.markupManager.refreshMarkupView(n);
    }
  }
  _redlineOperatorMove() {
    if (this._activeRedlineItem) {
      if (this._dragging && this._activeRedlineItem.onDragMove(this._ptCurrent, this._view)) {
        this._viewer.markupManager.refreshMarkup(this._view);
        const t = this._viewer.markupManager.getActiveMarkupView(this._view);
        t && this._viewer.markupManager.refreshMarkupView(t);
      }
    } else
      this.updateRedlineItem(this._ptCurrent);
  }
  _redlineOperatorEnd() {
    const t = this._viewer.markupManager;
    if (this._activeRedlineItem) {
      if (this._ptFirst.equals(this._ptCurrent))
        t.selectMarkup(this._activeRedlineItem, this._view);
      else if (this._viewer.trigger("redlineUpdated", this._activeRedlineItem), this._dragging && this._activeRedlineItem.onDragEnd(this._ptCurrent, this._view)) {
        t.refreshMarkup(this._view);
        const e = this._viewer.markupManager.getActiveMarkupView(this._view);
        e && this._viewer.markupManager.refreshMarkupView(e);
      }
    } else if (this._newRedlineItem) {
      const e = this.finalizeRedlineItem(this._ptCurrent);
      e && this._attachNewMarkupToView(e);
    }
    this._activeRedlineItem = null, this._newRedlineItem = null;
  }
  async _attachNewMarkupToView(t) {
    const e = this._viewer, i = e.model, n = e.markupManager;
    let r = n.getActiveMarkupView(this._view), o = !1;
    if (r === null) {
      const l = i.getAbsoluteRootNode(), h = await i.getVisibilityState(l), u = await i.getNodeColorMap(i.getAbsoluteRootNode(), Jt.Faces), f = n.createMarkupView(
        this._view,
        void 0,
        !1,
        h,
        u,
        null
      );
      r = n.getMarkupView(f), o = !0;
    }
    r !== null && (r.addMarkupItem(t), n.selectMarkup(t, this._view), n.refreshMarkupView(r)), o && r !== null && this._viewer.trigger("viewCreated", r), this._viewer.trigger("redlineCreated", t);
  }
  _markupIsTextArea(t) {
    return t ? t.getClassName() === jo.className : !1;
  }
}
class Iy extends Rh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlineCircle = null, this._previewHandle = null, this._centerSet = !1;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._view;
    this._redlineCircle = new ka(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(
      this._redlineCircle,
      this._view
    );
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && (this._centerSet = !0, this._redlineCircle.setCenter(i), this._redlineCircle.setRadiusPoint(i)), this._redlineCircle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    const e = this._view;
    if (this._redlineCircle) {
      const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._centerSet || (this._centerSet = !0, this._redlineCircle.setCenter(i)), this._redlineCircle.setRadiusPoint(i), this._viewer.markupManager.refreshMarkup(this._view));
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlineCircle && (this._redlineCircle.isValid() && (i = this._redlineCircle), this._redlineCircle = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle, this._view), this._previewHandle = null), e.refreshMarkup(this._view)), this._centerSet = !1, i;
  }
}
class Cy extends Rh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlinePolyline = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._view;
    this._redlinePolyline = new Ea(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(
      this._redlinePolyline,
      this._view
    );
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._redlinePolyline.addPoint(i), this._redlinePolyline;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlinePolyline) {
      const e = this._view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._redlinePolyline.addPoint(i), this._viewer.markupManager.refreshMarkup(this._view));
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlinePolyline && (this._redlinePolyline.isValid() && (i = this._redlinePolyline), this._redlinePolyline = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle, this._view), this._previewHandle = null), e.refreshMarkup(this._view)), i;
  }
}
class Sy extends Rh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlineRectangle = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return this._redlineRectangle = new Aa(this._viewer), i !== null && (this._redlineRectangle.setPoint1(i), this._redlineRectangle.setPoint2(i)), this._previewHandle = this._viewer.markupManager.registerMarkup(
      this._redlineRectangle,
      this._view
    ), this._redlineRectangle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlineRectangle) {
      const e = this._view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && this._redlineRectangle.setPoint2(i), this._viewer.markupManager.refreshMarkup(this._view);
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    let e = null;
    if (this._redlineRectangle && this._previewHandle) {
      const i = this._viewer.markupManager;
      this._redlineRectangle.isValid() && (e = this._redlineRectangle), i.unregisterMarkup(this._previewHandle, this._view), this._previewHandle = null, this._redlineRectangle = null, i.refreshMarkup(this._view);
    }
    return e;
  }
}
class My extends Rh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlineText = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    return this._redlineText = new jo(this._viewer), this._redlineText;
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    if (this._redlineText === null)
      return null;
    const e = this._view, i = this._redlineText, n = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return n !== null && i.setPosition(n), this._redlineText = null, i;
  }
}
const dx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircleOperator: Iy,
  RedlineOperator: Rh,
  RedlinePolylineOperator: Cy,
  RedlineRectangleOperator: Sy,
  RedlineTextOperator: My
}, Symbol.toStringTag, { value: "Module" }));
class Py extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._forceEffectiveSceneVisibilityMask = Pe.None, this._rectangleMarkup = new Pg(t, !1), this._incrementalSelection = Nh.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle())
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _allowSelection(t, e) {
    return !(t.x === e.x || t.y === e.y);
  }
  _createBeginConfig(t, e, i) {
    const n = new _d();
    return n.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, n.ignoreCuttingSections = !1, n.ignoreUnrequestedInstances = !0, i && (n.mustBeFullyContained = !0), {
      pickConfig: n,
      areaCssMin: t,
      areaCssMax: e
    };
  }
  async _performSelection(t) {
    const e = this._rectangleMarkup.min.copy(), i = this._rectangleMarkup.max.copy(), n = this._rectangleMarkup.initialPosition.x < this._rectangleMarkup.currentPosition.x;
    if (t && await this.clearSelection(), !this._allowSelection(e, i))
      return;
    const r = this._createBeginConfig(e, i, n);
    try {
      return await this._incrementalSelection.performSelection(r);
    } catch (o) {
      if (!(o instanceof so))
        throw o;
    }
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Qe.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup(this._view));
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition());
      const e = !t.controlDown();
      this._performSelection(e);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class ky extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._axisTriad = e.axisTriad, this._pickConfig = new Pi(Pe.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._axisTriad.getEnabled() && X.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && this._axisTriad.insideOverlay(t.getPosition())) {
      const e = await this._view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._axisTriad.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class Ey {
  constructor(t, e, i, n, r) {
    this.section = t, this.node = e, this.planeIndex = i, this.plane = n, this.selectionPosition = r, this.origPlaneD = n.d;
  }
}
class Ay extends Oi {
  constructor(t, e, i) {
    super(t, e), this._context = null, this._cuttingManager = i;
  }
  async onMouseDown(t) {
    super.onMouseDown(t), this._context === null && this.isActive() && this._cuttingManager.hasActiveCuttingSection() && (await this._startSelection(t), t.setHandled(this._context !== null));
  }
  async onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !1), this._viewer.trigger("cuttingPlaneDrag", e.section, e.planeIndex));
  }
  async _updatePlane(t, e, i) {
    const n = e.selectionPosition, r = e.plane.normal.copy().add(e.selectionPosition), o = this._view.unprojectPoint(t, 0), l = this._view.unprojectPoint(t, 0.5);
    if (o !== null && l !== null) {
      const h = Cm(n, r, o, l);
      if (h !== null) {
        const u = m.subtract(h, e.selectionPosition), f = m.dot(u, e.plane.normal) < 0 ? u.length() : -u.length();
        e.plane.d = e.origPlaneD + f;
        const g = e.plane.normal.copy().scale(-f), y = new wt().setTranslationComponent(g.x, g.y, g.z);
        await e.section.updatePlane(
          e.planeIndex,
          e.plane,
          y,
          i,
          !1
        );
      }
      this._cuttingManager.delayCapping();
    }
  }
  async onMouseUp(t) {
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !0), this._viewer.trigger("cuttingPlaneDragEnd", e.section, e.planeIndex)), this._context = null, super.onMouseUp(t);
  }
  setHandled() {
    return this.isActive() && this._context !== null;
  }
  /**
   * Perform the selection operation. If successful, the cutting plane context will be properly
   * setup, otherwise the cutting plane context will be null.
   */
  async _startSelection(t) {
    this._context = null;
    const e = t.getPosition(), i = Pe.Face | Pe.Line, n = new Pi(i);
    n.ignoreCappingGeometry = !0, n.forceEffectiveSceneVisibilityMask = Pe.Face;
    const o = (await this._view.compositePickFromPoint(e, n)).fetchMostRelevant(i);
    if (o === null) return;
    const l = o.getNodeId(), h = this._cuttingManager.getCuttingSectionFromNodeId(l);
    if (h !== null) {
      const u = h.getPlaneIndexByNodeId(l);
      this._context = new Ey(
        h,
        l,
        u,
        h.getPlane(u),
        o.getPosition()
      ), this._cuttingManager.delayCapping(), this._viewer.trigger("cuttingPlaneDragStart", h, u);
    }
  }
}
class Ty extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._draggingAvatar = !1, this._restrictToAvatar = !0, this._floorLocked = !1, this._manager = e.floorplanManager;
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), !this._manager.isActive())
      return;
    const e = t.getPosition();
    let i;
    if (!this._restrictToAvatar)
      i = this._manager.insideOverlay(e);
    else {
      const n = new Pi();
      n.restrictToOverlays = !0, i = (await this._view.pickFromPoint(e, n)).getNodeId() === this._manager.getAvatarNodeId();
    }
    i && (this._draggingAvatar = !0, this._floorLocked = this._manager.getFloorLock(), await this._manager.setFloorLock(!0), this._manager.snapAvatarToPoint(e), t.setHandled(!0));
  }
  /** @hidden */
  async onMouseUp(t) {
    super.onMouseUp(t), this._draggingAvatar && await this._manager.setFloorLock(this._floorLocked), this._draggingAvatar = !1;
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), !!this._manager.isActive() && this._draggingAvatar) {
      t.setHandled(!0);
      const e = t.getPosition();
      this._manager.insideOverlay(e) && this._manager.snapAvatarToPoint(e);
    }
  }
  /**
   * Set whether or not dragging is restricted to the avatar. If true the operator will only function if
   * the selection begins on the avatar
   */
  restrictToAvatar(t) {
    this._restrictToAvatar = t;
  }
}
class Dy extends Oi {
  constructor(t, e) {
    super(t, e), this._draggingHandle = !1, this._newRotationMatrix = new wt(), this._translation = m.zero(), this._newTranslation = m.zero(), this._nodeIdGroupMap = /* @__PURE__ */ new Map(), this._groupIdCount = 0, this._activeChildrenGroupIds = /* @__PURE__ */ new Map(), this._initialLocalNodeMatrices = [], this._newLocalNodeMatrices = [], this._trackedPoints = [], this._trackedPointsPositions = [], this._trackedPointCount = 0, this._previousContextClick = !1, this._overlayIndex = null, this._activeHandleNodeId = null, this._handleEventType = Co.Translate, this._highlightedHandleId = null, this._handleSize = 1, this._explodeActive = !1, this._measureActive = !1, this._settingMatrixInProgress = !1, this._handleMarkup = new hh(t), this._pickConfig = new Pi(Pe.Face), this._pickConfig.restrictToOverlays = !0, t.setCallbacks({
      explode: (i) => {
        this._explodeActive = i > 0, this._explodeActive && this.removeHandles();
      },
      measurementBegin: () => {
        this._measureActive = !0, this.removeHandles();
      },
      measurementCreated: () => {
        this._measureActive = !1;
      },
      measurementDeleted: () => {
        this._measureActive = !1;
      }
    });
  }
  /**
   * Sets the mesh data for axis handles.
   * @param meshData
   */
  setAxisMeshData(t) {
    return this._handleMarkup.setAxisMeshData(t);
  }
  /**
   * Sets the mesh data for plane handles.
   * @param meshData
   */
  setPlaneMeshData(t) {
    return this._handleMarkup.setPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for view plane handles.
   * @param meshData
   */
  setViewPlaneMeshData(t) {
    return this._handleMarkup.setViewPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for rotation handles.
   * @param meshData
   */
  setRotateMeshData(t) {
    return this._handleMarkup.setRotateMeshData(t);
  }
  /**
   * Add a point to the tracked points list. When the handle moves, these points will update in world space.
   * @param point
   * @returns point index
   */
  addTrackedPoint(t) {
    const e = this._trackedPointCount;
    return this._trackedPoints[e] = t.copy(), this._trackedPointsPositions[e] = t.copy(), ++this._trackedPointCount, e;
  }
  /**
   * Gets the tracked point list.
   */
  getTrackedPoints() {
    return this._trackedPointsPositions;
  }
  /**
   * Clear the list of tracked points.
   */
  clearTrackedPoints() {
    this._trackedPoints.length = 0, this._trackedPointsPositions.length = 0, this._trackedPointCount = 0;
  }
  /**
   * Returns a boolean value indicating if handles are available to be added to the scene
   * If there is an active explode, active measure, or the model is a 2d drawing.
   * this will be false.
   */
  isEnabled() {
    return !this._explodeActive && !this._measureActive && !this._viewer.sheetManager.isDrawingSheetActive();
  }
  _guardEnabled() {
    if (!this.isEnabled()) {
      const t = this._explodeActive ? "Handles are not enabled when the model is exploded" : this._measureActive ? "Handles are not enabled while a measurement is in progress." : this._viewer.sheetManager.isDrawingSheetActive() ? "Handles are not enabled for 2d drawings." : "Handles are not enabled.";
      throw new oe(t);
    }
  }
  /**
   * Takes a scale value to change the handle size with 1 representing the default size
   * @param size
   */
  setHandleSize(t) {
    this._handleSize = t;
  }
  /**
   * Adds all handles into the scene, oriented along the primary axes
   * @param nodeIds corresponding to the parts that will move with the handles
   * @param position world space coordinates the the handle position
   */
  async addHandles(t, e = null, i = null) {
    if (this._previousContextClick = !1, this._guardEnabled(), !e) {
      const r = await this._viewer.model.getNodesBounding(t);
      return this.addHandles(t, r.center());
    }
    const n = this._findGroupId(t);
    return i === null && (i = n !== null ? n : this.generateGroupId()), this._nodeIdGroupMap.set(i, t), n !== null && await this._handleMarkup.removeHandles(i), this._handleMarkup.addHandles(e, this._handleSize, i);
  }
  /**
   * Returns the group id associated to the given group of node ids, returns null if does not exist
   * @param nodeIds
   */
  _findGroupId(t) {
    let e = null;
    return this._nodeIdGroupMap.forEach((i, n) => {
      i.length === t.length && i.every((r) => t.indexOf(r) !== -1) && (e = n);
    }), e;
  }
  /**
   * This will generate a unique id to associate a group of handles with a group of NodeIds.
   */
  generateGroupId() {
    return this._groupIdCount++;
  }
  _massageGroupId(t) {
    return t ?? hh.defaultGroupId;
  }
  /**
   * Adds a handle that moves along an axis.
   * @param position center of the handle.
   * @param axis axis to move along
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisTranslationHandle(t, e, i, n = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addAxisTranslationHandle(
      t,
      e,
      i,
      n,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that rotates around an axis
   * @param position center of the handle.
   * @param axis axis to rotate around
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisRotationHandle(t, e, i, n = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addRotateHandle(
      t,
      e,
      i,
      n,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that restricts movement to a plane.
   * @param position center of the handle.
   * @param normal normal of the plane
   * @param faceColor face color of the handle geometry
   * @param lineColor outline color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addPlaneTranslationHandle(t, e, i, n, r = null, o = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addPlaneTranslationHandle(
      t,
      e,
      i,
      n,
      r,
      this._massageGroupId(o)
    );
  }
  /**
   * Adds a handle that restricts movement to the viewplane.
   * @param position center of the handle
   * @param color geometry color
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addViewPlaneTranslationHandle(t, e, i = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addViewPlaneHandle(t, e, this._massageGroupId(i));
  }
  /**
   * Sets the NodeIds that any handles in the scene will move.
   * @param nodeIds
   * @param groupId optional parameter that associates a group of NodeIds with a group of handles.
   */
  setNodeIds(t, e = null) {
    this._nodeIdGroupMap.set(this._massageGroupId(e), t);
  }
  /**
   * Gets the NodeIds that the handles in the scene will move.
   * @param groupId optional parameter that specifies if the NodeIds to retrieve are part of a group.
   */
  getNodeIds(t = null) {
    const e = this._nodeIdGroupMap.get(this._massageGroupId(t));
    return e === void 0 ? [] : e.slice();
  }
  /**
   * Shows any handles that have been added to the scene.
   */
  showHandles() {
    this._handleMarkup.showOverlay();
  }
  /**
   * Updates the current handle position.
   * @param translation additional translation
   * @param rotation additional rotation
   * @param finalizePosition keep translation and rotation. If true, added translation and rotation
   * will not reset the next time the position is updated.
   */
  updatePosition(t, e, i, n = null) {
    return this._handleMarkup.updatePosition(
      t,
      e,
      i,
      this._massageGroupId(n),
      this._activeChildrenGroupIds
    );
  }
  /**
   * @returns the current handle position or null if not currently active.
   */
  getPosition() {
    const t = this._handleMarkup.getHandleNodeIds();
    if (t.length > 0) {
      const e = this._handleMarkup.getPosition(t[0]);
      if (e !== null)
        return e.copy();
    }
    return null;
  }
  /**
   * Removes all handles from the scene.
   */
  removeHandles() {
    return this._newRotationMatrix = new wt(), this._translation = m.zero(), this._highlightedHandleId = null, this._nodeIdGroupMap.clear(), this._groupIdCount = 0, this._handleMarkup.removeHandles();
  }
  /**
   * @returns the total translation applied to the handles.
   */
  getTranslation() {
    return this._translation;
  }
  _initLocalNodeMatrices(t) {
    const e = this._viewer.model;
    this._initialLocalNodeMatrices = [];
    for (const i of t)
      this._initialLocalNodeMatrices.push(e.getNodeMatrix(i));
  }
  _getHandleEventType(t) {
    return this._handleMarkup.getHandleType(t) === zr.Rotate ? Co.Rotate : Co.Translate;
  }
  async _rotate(t, e, i, n) {
    if (!this._draggingHandle || this._settingMatrixInProgress) return;
    const r = this.getNodeIds(n);
    await this._genericTransform(
      t,
      e,
      m.zero(),
      i,
      r,
      n
    ), this._viewer.trigger(
      "handleEvent",
      Co.Rotate,
      r,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _translate(t, e, i) {
    if (!this._draggingHandle || this._settingMatrixInProgress) return;
    const n = this.getNodeIds(i);
    await this._genericTransform(m.zero(), 0, t, e, n, i), this._viewer.trigger(
      "handleEvent",
      Co.Translate,
      n,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _genericTransform(t, e, i, n, r, o) {
    this._settingMatrixInProgress = !0;
    const l = this._viewer.model;
    let h = new wt();
    this._newTranslation = i, t.squaredLength() > 0 && (h = this._getRotationMatrix(t, m.zero(), e), this._newRotationMatrix = h.copy());
    const u = [];
    u.push(this.updatePosition(this._newTranslation, this._newRotationMatrix, !1, o)), this._newLocalNodeMatrices = [];
    for (let g = 0; g < r.length; g++) {
      const y = this._newTranslation.copy(), _ = r[g];
      let x = this._initialLocalNodeMatrices[g].copy();
      const b = t.copy(), I = n.copy();
      let C;
      const M = l.getNodeParent(_);
      if (M !== null) {
        C = l.getNodeNetMatrix(M);
        const P = wt.inverse(C);
        P !== null && (P.transform(I, I), P.setTranslationComponent(0, 0, 0), P.transform(b, b), P.transform(y, y));
      } else
        C = null;
      t.squaredLength() > 0 && (h = this._getRotationMatrix(
        b,
        I,
        C && C.upperLeft3x3Determinant() < 0 ? -e : e
      ), x = wt.multiply(x, h)), x.setTranslationComponent(
        x.m[12] + y.x,
        x.m[13] + y.y,
        x.m[14] + y.z
      ), u.push(l.setNodeMatrix(_, x)), this._newLocalNodeMatrices.push(x);
    }
    const f = this._newRotationMatrix.copy();
    f.setTranslationComponent(i.x, i.y, i.z);
    for (let g = 0; g < this._trackedPoints.length; ++g) {
      const y = this._trackedPoints[g].copy(), _ = m.subtract(y, n);
      f.transform(_, _);
      const x = m.add(_, n);
      this._trackedPointsPositions[g] = x;
    }
    await We(u), this._settingMatrixInProgress = !1;
  }
  /** @hidden */
  async _testRotate(t, e, i = null) {
    i = this._massageGroupId(i);
    const n = this._getActiveNodeIdByGroupId(i);
    if (n !== null) {
      const r = this._handleMarkup.getPosition(n);
      if (r === null)
        return;
      this._startDragging(n, Co.Rotate), await this._rotate(t, e, r, i), await this._stopDragging();
    }
  }
  /** @hidden */
  async _testTranslate(t, e = null) {
    e = this._massageGroupId(e);
    const i = this._getActiveNodeIdByGroupId(e);
    i !== null && (this._startDragging(i, Co.Translate), await this._translate(t, m.zero(), e), await this._stopDragging());
  }
  _getActiveNodeIdByGroupId(t) {
    const e = this._handleMarkup.getHandleNodeIds();
    for (let i = 0; i < e.length; ++i) {
      const n = e[i];
      if (this._handleMarkup.getHandleGroupId(n) === t)
        return n;
    }
    return null;
  }
  _startDragging(t, e) {
    this._activeHandleNodeId = t, this._handleEventType = e;
    const i = this._handleMarkup.getHandleGroupId(t), n = this.getNodeIds(i), r = /* @__PURE__ */ new Map();
    this._nodeIdGroupMap.forEach((o, l) => {
      l !== i && o.forEach((h) => {
        let u = this._viewer.model.getNodeParent(h);
        for (; u !== null; ) {
          if (n.indexOf(u) !== -1) {
            r.set(l, h);
            break;
          }
          u = this._viewer.model.getNodeParent(u);
        }
      });
    }), this._activeChildrenGroupIds = r, n.length > 0 && (this._initLocalNodeMatrices(n), this._viewer.trigger(
      "handleEventStart",
      this._handleEventType,
      n,
      this._initialLocalNodeMatrices
    ), this._draggingHandle = !0);
  }
  async _stopDragging() {
    if (this._draggingHandle = !1, this._activeHandleNodeId !== null) {
      const t = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
      await this.updatePosition(this._newTranslation, this._newRotationMatrix, !0, t);
      const e = this.getNodeIds(t);
      this._activeHandleNodeId = null, this._activeChildrenGroupIds.clear(), this._viewer.trigger(
        "handleEventEnd",
        this._handleEventType,
        e,
        this._initialLocalNodeMatrices,
        this._newLocalNodeMatrices
      ), this._newRotationMatrix = new wt(), this._handleMarkup.resetTranslation(), this._translation.add(this._newTranslation), this._newTranslation = m.zero(), this._trackedPoints = this._trackedPointsPositions.slice();
    }
  }
  /** @hidden */
  async onMouseDown(t) {
    super.onMouseDown(t), this._overlayIndex = null;
    const e = await this._view.pickFromPoint(t.getPosition(), this._pickConfig);
    if (e.isNodeEntitySelection()) {
      const i = e.getNodeId(), n = this._viewer.model.getNodeName(i);
      if (n !== null && n.slice(0, 7) === "handle-") {
        t.setHandled(!0);
        const r = this._getHandleEventType(i);
        this._startDragging(i, r);
      }
    }
  }
  _onHandleDrag() {
    if (this._activeHandleNodeId === null)
      return;
    const e = this._view.getCamera();
    let i = 0, n = m.zero(), r = m.zero();
    const o = this._handleMarkup.getHandleType(this._activeHandleNodeId), l = this._handleMarkup.getVector(this._activeHandleNodeId), h = this._handleMarkup.getPosition(this._activeHandleNodeId);
    if (o === null || h === null)
      return;
    const u = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
    switch (o) {
      case zr.Axis:
        l !== null && (r = this._getTranslationComponent(
          h,
          l,
          0,
          u
        ), this._translate(r, h, u));
        break;
      case zr.Plane:
        l !== null && (r = this._getTranslationComponent(
          h,
          l,
          1,
          u
        ), this._translate(r, h, u));
        break;
      case zr.ViewPlane:
        {
          const f = e.getTarget(), g = e.getPosition(), y = m.subtract(g, f).normalize();
          r = this._getTranslationComponent(
            h,
            y,
            2,
            u
          ), this._translate(r, h, u);
        }
        break;
      case zr.Rotate:
        l !== null && (n = l, this._handleMarkup.getGroupIdRotationMatrix(u).copy().setTranslationComponent(0, 0, 0).transform(n, n), i = this._getRotationAngle(h, n), this._rotate(n, i, h, u));
        break;
      default:
        qr();
    }
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._draggingHandle && this._activeHandleNodeId !== null)
      this._onHandleDrag();
    else {
      const e = await this._view.pickFromPoint(t.getPosition(), this._pickConfig);
      await this._highlightHandle(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    !this._draggingHandle && this._dragCount < 3 && t.getButton() !== Te.Right && !this._previousContextClick && !this._viewer.getContextMenuStatus() && (this._overlayIndex === 0 || this._overlayIndex === null) && this.removeHandles(), this._previousContextClick = t.getButton() === Te.Right || this._viewer.getContextMenuStatus(), this._draggingHandle && this._stopDragging(), super.onMouseUp(t);
  }
  /** @hidden */
  setHandled() {
    return this._draggingHandle;
  }
  _getClosestPoint(t, e, i) {
    const n = t.copy(), r = t.copy().add(e), o = this._view.unprojectPoint(i, 0), l = this._view.unprojectPoint(i, 0.5);
    return o !== null && l !== null ? Cm(n, r, o, l) : null;
  }
  _getTranslationComponent(t, e, i, n) {
    i !== 2 && this._handleMarkup.getGroupIdRotationMatrix(n).copy().setTranslationComponent(0, 0, 0).transform(e, e);
    let r = null, o = null;
    return i === 1 || i === 2 ? (r = this._getPlaneIntersectionPoint(t, e, this._ptFirst), r !== null && (o = this._getPlaneIntersectionPoint(r, e, this._ptCurrent))) : i === 0 && (r = this._getClosestPoint(t, e, this._ptFirst), r !== null && (o = this._getClosestPoint(r, e, this._ptCurrent))), o !== null && r !== null ? m.subtract(o, r) : m.zero();
  }
  async _clearHighlightedHandle() {
    this._highlightedHandleId !== null && (await this._viewer.model.unsetNodesFaceColor([this._highlightedHandleId]), this._highlightedHandleId = null);
  }
  async _highlightHandle(t) {
    if (t.isNodeEntitySelection() && t.overlayIndex() === be.Handles) {
      const e = this._viewer.model, i = e.getNodeName(t.getNodeId());
      if (i !== null && i.slice(0, 7) === "handle-") {
        const n = t.getNodeId();
        if (this._highlightedHandleId === n)
          return;
        await this._clearHighlightedHandle(), this._highlightedHandleId = n, e.setNodesFaceColor([this._highlightedHandleId], yt.green());
        return;
      }
    }
    return this._clearHighlightedHandle();
  }
  _getPlaneIntersectionPoint(t, e, i) {
    const n = this._view.unprojectPoint(i, 0), r = this._view.unprojectPoint(i, 0.5);
    if (n === null || r === null)
      return null;
    const o = new vr(n, r.copy().subtract(n)), l = ln.createFromPointAndNormal(t, e), h = m.zero();
    return l.intersectsRay(o, h) ? h : null;
  }
  _getRotationAngle(t, e) {
    console.assert(t !== null);
    const i = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptFirst
    ), n = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptCurrent
    );
    if (i === null || n === null)
      return 0;
    const r = m.subtract(i, t).normalize(), o = m.subtract(n, t).normalize(), l = m.dot(r, o);
    let h = Math.acos(l) * 180 / Math.PI;
    return m.dot(m.cross(r, o), e) < 0 && (h = -h), h;
  }
  _getRotationMatrix(t, e, i) {
    const n = new wt().setTranslationComponent(
      -e.x,
      -e.y,
      -e.z
    ), r = wt.createFromOffAxisRotation(t, i), o = new wt().setTranslationComponent(
      e.x,
      e.y,
      e.z
    );
    return wt.multiply(
      wt.multiply(n, r),
      o
    );
  }
}
class Ny extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._navCube = e.navCube, this._pickConfig = new Pi(Pe.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), !this._navCube.getEnabled() || this._dragging && this._dragCount > 1)
      return;
    const e = t.getPosition();
    if (this._navCube.insideOverlay(e)) {
      const i = await this._view.pickFromPoint(e, this._pickConfig);
      this._navCube.onMoveSelection(i);
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._navCube.getEnabled() && X.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25) {
      const e = await this._view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._navCube.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class Oy extends Oi {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._insertNoteButton = Te.Left, this._callbackFlag = !1, this._noteTextManager = i;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._callbackFlag || (this._viewer.setCallbacks({
      explode: async (e) => {
        await this._noteTextManager.explode(e);
      }
    }), this._callbackFlag = !0), this._dragging = !1);
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive()) {
      const e = new Pi(Pe.Face);
      (this._ptFirst.equals(this._ptCurrent) && t.getButton() === this._insertNoteButton || this._primaryTouchId !== null) && this._view.pickFromPoint(t.getPosition(), e).then((i) => {
        if (!this._noteTextManager.selectPin(i) && !this._noteTextManager.getExplodeActive() && !this._noteTextManager.getIsolateActive() && i.overlayIndex() === 0) {
          if (i.isFaceSelection())
            return new Da(
              this._viewer,
              this._noteTextManager,
              i.getPosition(),
              i.getFaceEntity().getNormal(),
              i.getNodeId()
            );
          t.setHandled(!0);
        }
        return null;
      });
    }
    super.onMouseUp(t);
  }
  /**
   * @returns a NoteTextElement that can be used to configure the NoteText HTML container.
   */
  getNoteTextElement() {
    return this._noteTextManager.getNoteTextElement();
  }
  /**
   * @param noteTextElement
   */
  setNoteTextElement(t) {
    this._noteTextManager.setNoteTextElement(t);
  }
  /**
   * Returns true if the nodeId is the id of a note pin instance.
   * @param nodeId
   */
  checkPinInstance(t) {
    return this._noteTextManager.checkPinInstance(t) !== null;
  }
}
class Ry extends Oi {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._selectionButton = Te.Left, this._ignoreTransparency = !1, this._forceEffectiveSceneVisibilityMask = Pe.None, this._incrementalSelection = Nh.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle()),
      selectionArray: (i) => {
        i.length === 0 && this._incrementalSelection.stopSelection();
      }
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  setIgnoreTransparency(t) {
    this._ignoreTransparency = t;
  }
  getIgnoreTransparency() {
    return this._ignoreTransparency;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _createBeginConfig(t) {
    const e = new _d();
    return e.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, e.ignoreUnrequestedInstances = !0, {
      pickConfig: e,
      rayCssOrigin: t,
      rayCssBoxRadius: 10
    };
  }
  async _selectionPredicate(t) {
    const e = this._viewer.model, i = t.getNodeId();
    if (i === null)
      return !1;
    const [n] = await e.getNodesHaveTransparency([i]);
    return !n;
  }
  async _performSelection(t) {
    const e = this._createBeginConfig(t), i = this._ignoreTransparency ? (n) => this._selectionPredicate(n) : null;
    return this._incrementalSelection.performSelection(e, i);
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Qe.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && (async () => (t.getButton() === this._selectionButton || this._primaryTouchId !== null) && X.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && (t.controlDown() || await this.clearSelection(), await this._performSelection(t.getPosition())))(), super.onMouseUp(t);
  }
}
class Ly extends Oi {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._selectionButton = Te.Left, this._pickConfig = new Pi(Pe.Face | Pe.Line), this._forceEffectiveSceneVisibilityMask = null, this._doubleClickFitWorld = !0, this._noteTextManager = i;
  }
  /** Sets the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  setPickConfig(t) {
    this._pickConfig = t.copy();
  }
  /** Returns the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  getPickConfig() {
    return this._pickConfig.copy();
  }
  /**
   * Gets the button used for selection.
   * @returns Button
   */
  getSelectionButton() {
    return this._selectionButton;
  }
  /**
   * Sets the button used for selection
   * @param button
   */
  setSelectionButton(t) {
    this._selectionButton = t;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Qe.Escape && this._viewer.selectionManager.clear();
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && X.subtract(this._ptFirst, this._ptCurrent).length() < 5 && (t.getButton() === this._selectionButton || this._primaryTouchId !== null)) {
      const i = this._view;
      let n = this._pickConfig;
      this._forceEffectiveSceneVisibilityMask !== null && (n = n.copy(), n.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask), i.pickFromPoint(this._ptCurrent, n).then((r) => {
        const l = this._viewer.cuttingManager.getCuttingSectionFromNodeId(r.getNodeId()) !== null, h = this._noteTextManager.selectPin(r), u = this._viewer.markupManager.pickMarkupItem(
          this._ptCurrent,
          this._view
        );
        u instanceof jo && this._viewer.markupManager.selectMarkup(u, i), !h && !l && u === null && (r.isNodeSelection() ? this._processSelectionClick(t, r) : this._isDoubleClick || this._viewer.selectionManager.clear());
      });
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  async onDoubleClick() {
    if (this._doubleClickFitWorld)
      return this._view.fitWorld();
  }
  /**
   * When enabled, a double click will fit the view to the model bounding box.
   * @param doubleClickFitWorld
   */
  setDoubleClickFitWorldEnabled(t) {
    this._doubleClickFitWorld = t;
  }
  // helper function to get the parent selection item if the part is already selected
  _getSelectionOrParentIfSelected(t) {
    const e = this._viewer.selectionManager;
    if (!e.getSelectParentIfSelected())
      return t;
    const i = this._viewer.model, n = t.getNodeId();
    if (!i.isNodeLoaded(n) || i.getNodeType(n) === Le.PmiBody)
      return t;
    const o = e.containsParent(t);
    if (o !== null) {
      const l = yi.create(i.getNodeParent(o.getNodeId()));
      return l.isNodeSelection() ? l : t;
    } else if (e.contains(t)) {
      const l = yi.create(i.getNodeParent(n));
      return l.isNodeSelection() ? l : t;
    } else
      return t;
  }
  _processSelectionClick(t, e) {
    const i = e.overlayIndex();
    if (i !== 0 && i !== null)
      return;
    const n = this._viewer.selectionManager;
    if (t.controlDown() || t.commandDown())
      n.toggle(e);
    else {
      const r = this._getSelectionOrParentIfSelected(e);
      n.set(r);
    }
  }
}
const fx = `/**
* @license 3DconnexionJS
*
* Copyright (c) 2013-2022 3Dconnexion. All rights reserved.
* License:
*   This file is licensed under the terms of the "3Dconnexion
*   Software Development Kit" license agreement:
*   http://www.3dconnexion.com/service/software-developer/licence-agreement.html
*   All rights not expressly granted by 3Dconnexion are reserved.
*
* $Revision$
*/
var when,CryptoJS,AUTOBAHNJS_VERSION,global;_3Dconnexion=function(n){"use strict";this.version="0.7.0";this.client=n;this.session=null;this.defport=8181;this.connected=!1;this.connexion=null;this._3dcontroller=null;this.viewport=null;this.host="127.51.68.120";this.nlRpcUri=null;this.nlResourceUri=null;this._EVENT_TYPEID_RPC=0;this.V3DK_FIT=31;this.V3DK_MENU=30;this.fnUpdate={motion:this.onMotion.bind(this),"events.keyPress":this.onKeyPress.bind(this),"events.keyRelease":this.onKeyRelease.bind(this)};this.clientFnRead={"view.affine":n.getViewMatrix,"view.constructionPlane":n.getConstructionPlane,"view.extents":n.getViewExtents,"view.fov":n.getFov,"view.frustum":n.getViewFrustum,"view.perspective":n.getPerspective,"view.target":n.getViewTarget,"view.rotatable":n.getViewRotatable,"model.extents":n.getModelExtents,"model.floorPlane":n.getFloorPlane,"model.unitsToMeters":n.getUnitsToMeters,"pivot.position":n.getPivotPosition,"hit.lookat":n.getLookAt,"selection.affine":n.getSelectionAffine,"selection.empty":n.getSelectionEmpty,"selection.extents":n.getSelectionExtents,"pointer.position":n.getPointerPosition,coordinateSystem:n.getCoordinateSystem,"views.front":n.getFrontView,"frame.timingSource":n.getFrameTimingSource,"frame.time":n.getFrameTime};this.clientFnUpdate={motion:n.setMoving,transaction:n.setTransaction,"view.affine":n.setViewMatrix,"view.extents":n.setViewExtents,"view.fov":n.setFov,"view.target":n.setTarget,"commands.activeCommand":n.setActiveCommand,"pivot.position":n.setPivotPosition,"pivot.visible":n.setPivotVisible,"hit.lookfrom":n.setLookFrom,"hit.direction":n.setLookDirection,"hit.aperture":n.setLookAperture,"hit.selectionOnly":n.setSelectionOnly,"selection.affine":n.setSelectionAffine,"events.keyPress":n.setKeyPress,"events.keyRelease":n.setKeyRelease,"settings.changed":n.setSettingsChanged};this.debug=!1;window.hasOwnProperty("_3DCONNEXION_DEBUG")&&(this.debug=window._3DCONNEXION_DEBUG);this.blur=this.blur.bind(this);this.focus=this.focus.bind(this)};typeof module=="object"&&(module.exports=_3Dconnexion);_3Dconnexion.prototype={constructor:_3Dconnexion};Object.freeze(_3Dconnexion.nlOptions={none:0,rowMajorOrder:2});_3Dconnexion.prototype.connect=function(){"use strict";var n=this,e=this.client,u=1,t=new XMLHttpRequest,f,r,i;if(!e.onConnect)throw"onConnect handler required!";i="https://"+n.host+":"+n.defport+"/3dconnexion/nlproxy";t.onreadystatechange=function(){if(t.readyState===4&&t.status===200){n.debug&&console.log(t.responseText);n.nlRpcUri="wss://"+n.host+"/3dconnexion#";n.nlResourceUri="wss://"+n.host+"/3dconnexion";try{f=JSON.parse(t.responseText).port;r="wss://"+n.host+":"+f;n.debug&&console.log("Connecting to "+r+" ...");window.hasOwnProperty("AUTOBAHN_DEBUG")&&window.AUTOBAHN_DEBUG&&window.ab.debug(!0,!0,!0);window.ab.connect(r,function(t){n.session=t;n.connected=!0;n.debug&&console.log("Connected!");t.prefix("3dx_rpc",n.nlRpcUri);t.prefix("3dconnexion",n.nlResourceUri);t.prefix("self",window.location.href);n.client.onConnect()},function(t,i){if(n.client.onDisconnect!==undefined)n.client.onDisconnect(i);n.delete3dmouse();n.connected=!1;n.session=null;n.debug&&console.log("Socket closed!",i)},{maxRetries:3,retryDelay:500})}catch(i){console.error(i)}}};t.onerror=function(){n.debug&&console.log("_3Dconnexion.connect: No response from local 3dmouse server "+i)};t.ontimeout=function(){n.debug&&console.log("_3Dconnexion.connect: Timeout querying local 3dmouse server "+i)};try{t.open("GET",i,!0);t.setRequestHeader("Accept","application/json; charset=utf-8");t.msCaching="disabled";t.timeout=0;t.send()}catch(o){u=0;console.error(o.toString())}return u};_3Dconnexion.prototype.create3dmouse=function(n,t,i){"use strict";i=typeof i!="undefined"?i:_3Dconnexion.nlOptions.none;var r=this;r.viewport=n;r.debug&&console.log("create3dmouse "+r.viewport.id);r.viewport.addEventListener("focus",r.focus);r.viewport.addEventListener("blur",r.blur);r.session.call("3dx_rpc:create","3dconnexion:3dmouse",r.version).then(function(n){r.connexion=n.connexion;var u={version:parseFloat(r.version),name:t,rowMajorOrder:(i&_3Dconnexion.nlOptions.rowMajorOrder)!=0};r.session.call("3dx_rpc:create","3dconnexion:3dcontroller",r.connexion,u).then(function(n){r._3dcontroller=n.instance;r.session.subscribe("3dconnexion:3dcontroller/"+r._3dcontroller,r.onEvent.bind(r));document.hasFocus()&&(document.activeElement===document.body||document.activeElement===null?(r.viewport.focus(),window===r.viewport&&r.focus()):r.viewport.contains(document.activeElement)&&(r.focus(),r.debug&&console.log("self.viewport has focus")));r.client.on3dmouseCreated&&r.client.on3dmouseCreated()},function(n){console.log("3dx_rpc:create 3dconnexion:3dcontroller "+n)})},function(n){console.log("3dx_rpc:create "+n)})};_3Dconnexion.prototype.blur=function(){"use strict";var n=this;n.debug&&console.log("blur on ");n.session&&n._3dcontroller&&n.update3dcontroller({focus:!1})};_3Dconnexion.prototype.focus=function(){"use strict";var n=this;n.debug&&console.log("focus on ");n.session&&n._3dcontroller&&n.update3dcontroller({focus:!0})};_3Dconnexion.prototype.onKeyPress=function(n){"use strict";var t=this;t.debug&&console.log("onKeyPress "+n)};_3Dconnexion.prototype.onKeyRelease=function(n){"use strict";var t=this;t.debug&&console.log("onKeyRelease "+n)};_3Dconnexion.prototype.onMotion=function(n){"use strict";var t=this;n===!0?t.client.onStartMotion!==undefined&&t.client.onStartMotion():t.client.onStopMotion!==undefined&&t.client.onStopMotion()};_3Dconnexion.prototype.onEvent=function(n,t){"use strict";var i=this,f=null,r=null,u=null;if(i.debug&&(console.log(n),console.log(t)),t[0]===window.ab._MESSAGE_TYPEID_CALL){if(t[2]==="self:read")if(r=i.clientFnRead[t[4]],r!==undefined)f=r.bind(i.client)();else{u=[window.ab._MESSAGE_TYPEID_CALL_ERROR,t[1],t[2]+"#generic",t[4]+" unknown property"];i.session._send(u);return}else if(t[2]==="self:update")if(r=i.fnUpdate[t[4]],r!==undefined)f=r(t[5]);else if(r=i.clientFnUpdate[t[4]],r!==undefined)f=r.bind(i.client)(t[5]);else{u=[window.ab._MESSAGE_TYPEID_CALL_ERROR,t[1],t[2]+"#generic",t[4]+" unknown property"];i.session._send(u);return}else{u=[window.ab._MESSAGE_TYPEID_CALL_ERROR,t[1],t[2]+"#generic","unknown procedure"];i.session._send(u);return}u=[window.ab._MESSAGE_TYPEID_CALL_RESULT,t[1],f];i.session._send(u)}};_3Dconnexion.prototype.read3dcontroller=function(n,t){"use strict";var i=this;i.debug&&console.log("read3dcontroller "+i._3dcontroller);try{i.session.call("3dx_rpc:read","3dconnexion:3dcontroller/"+i._3dcontroller,n).then(function(n){t&&t(n)},function(t){console.log("3dx_rpc:read 3dconnexion:3dcontroller/"+i._3dcontroller+" "+n+" "+t)})}catch(r){console.error(r)}};_3Dconnexion.prototype.update3dcontroller=function(n){"use strict";var t=this;t.debug&&console.log("update3dmouse "+t._3dcontroller);try{if(!t._3dcontroller)throw"exception 3dx_rpc:update: 3dcontroller not initialized";t.session.call("3dx_rpc:update","3dconnexion:3dcontroller/"+t._3dcontroller,n).then(function(){return},function(n){console.log("3dx_rpc:update 3dconnexion:3dcontroller/"+t._3dcontroller+" "+n)})}catch(i){console.error(i)}};_3Dconnexion.prototype.delete3dmouse=function(){"use strict";var n=this,t=n.connexion;n.debug&&console.log("delete3dmouse ");n.connexion=null;n._3dcontroller=null;n.viewport!==null&&(n.viewport.removeEventListener("focus",n.focus),n.viewport.removeEventListener("blur",n.blur));n.session&&n.session.call("3dx_rpc:delete","3dconnexion:3dmouse/"+t).then(function(){n.debug&&console.log("deleted connexion "+t)},function(n){console.log("3dx_rpc:delete "+t+" "+n)})};Object.freeze(_3Dconnexion.SiActionNodeType_t={SI_ACTIONSET_NODE:0,SI_CATEGORY_NODE:1,SI_ACTION_NODE:2});_3Dconnexion.ActionNode=function(n,t,i){return this.id=n,this.label=t||n,this.type=i,this};_3Dconnexion.ActionNode.prototype={constructor:_3Dconnexion.ActionNode,id:{value:null,enumerable:!0},label:{value:null,writable:!0,enumerable:!0},type:{value:null,enumerable:!0}};_3Dconnexion.Action=function(n,t,i){return _3Dconnexion.ActionNode.call(this,n,t,_3Dconnexion.SiActionNodeType_t.SI_ACTION_NODE),this.description=i||"",this};_3Dconnexion.Action.prototype=Object.create(_3Dconnexion.ActionNode.prototype,{constructor:{value:_3Dconnexion.Action},description:{value:"",writable:!0,enumerable:!0}});_3Dconnexion.ActionTreeNode=function(){return this.nodes=[],this};_3Dconnexion.ActionTreeNode.prototype=Object.create(_3Dconnexion.ActionNode.prototype,{constructor:{value:_3Dconnexion.ActionTreeNode},nodes:{value:null,writable:!0,enumerable:!0},push:{value:function(n){return this.nodes.push(n),n}}});_3Dconnexion.ActionSet=function(n,t){return _3Dconnexion.ActionNode.call(this,n,t,_3Dconnexion.SiActionNodeType_t.SI_ACTIONSET_NODE),_3Dconnexion.ActionTreeNode.call(this),this};_3Dconnexion.ActionSet.prototype=Object.create(_3Dconnexion.ActionTreeNode.prototype,{constructor:{value:_3Dconnexion.ActionSet}});_3Dconnexion.Category=function(n,t){return _3Dconnexion.ActionNode.call(this,n,t,_3Dconnexion.SiActionNodeType_t.SI_CATEGORY_NODE),_3Dconnexion.ActionTreeNode.call(this),this};_3Dconnexion.Category.prototype=Object.create(_3Dconnexion.ActionTreeNode.prototype,{constructor:{value:_3Dconnexion.Category}});_3Dconnexion.ActionTree=function(){return this.nodes=[],this};_3Dconnexion.ActionTree.prototype=Object.create(null,{constructor:{value:_3Dconnexion.ActionTree},nodes:{value:null,writable:!0,enumerable:!0},push:{value:function(n){return this.nodes.push(n),n}}});_3Dconnexion.ImageItem=function(){};Object.freeze(_3Dconnexion.SiImageType_t={e_none:0,e_image_file:1,e_resource_file:2,e_image:3});_3Dconnexion.ImageItem.prototype={constructor:_3Dconnexion.ImageItem,id:{value:"",writable:!0},type:{value:"e_none",enumerable:!0}};_3Dconnexion.ImageItem.fromImage=function(n,t){var i=new _3Dconnexion.ImageItem;return Object.defineProperties(i,{id:{value:t||"",writable:!0,enumerable:!0},type:{value:_3Dconnexion.SiImageType_t.e_image,enumerable:!0},index:{value:0,writable:!0,enumerable:!0},data:{value:_3Dconnexion.ImageItem.base64FromArrayBuffer(n),enumerable:!0},status:{value:200}})};_3Dconnexion.ImageItem.fromURL=function(n,t){var r=new _3Dconnexion.ImageItem,i;return Object.defineProperties(r,{id:{value:t||"",writable:!0,enumerable:!0},type:{value:_3Dconnexion.SiImageType_t.e_image,enumerable:!0},index:{value:0,writable:!0,enumerable:!0},buffer:{value:null,writable:!0},data:{get:function(){return this.buffer},set:function(n){r.buffer=n;r.onload()},enumerable:!0},status:{value:100,writable:!0},onload:{value:function(){},writable:!0}}),i=new XMLHttpRequest,i.overrideMimeType("text/plain; charset=x-user-defined"),i.open("GET",n,!0),i.responseType="arraybuffer",i.onload=function(){if(r.status=i.status,i.status===200&&i.response!==null){r.data=_3Dconnexion.ImageItem.base64FromArrayBuffer(i.response);return}r.status=404;r.data=null},i.onerror=function(){r.status=i.status;r.data=null},i.send(null),r};_3Dconnexion.ImageItem.base64FromArrayBuffer=function(n){for(var u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",t=new Uint8Array(n),e=t.length%3,f=t.length-e,i="",r=0;r<f;r+=3)i+=u[t[r]>>2],i+=u[(t[r]&3)<<4|t[r+1]>>4],i+=u[(t[r+1]&15)<<2|t[r+2]>>6],i+=u[t[r+2]&63];return e!==0&&(i+=u[t[f]>>2],e===2?(i+=u[(t[f]&3)<<4|t[f+1]>>4],i+=u[(t[f+1]&15)<<2],i+="="):(i+=u[(t[f]&3)<<4],i+="==")),i};_3Dconnexion.ImageCache=function(){this.images=[];this.outstanding_requests=0};_3Dconnexion.ImageCache.prototype={constructor:_3Dconnexion.ImageCache,images:{value:null,writable:!0,enumerable:!0},outstanding_requests:{value:0,writable:!0},push:function(n){var t=this;if(n.status===100)++t.outstanding_requests,n.onload=function(){var n=this,i;n.onload=function(){};n.status!==200&&(i=t.images.indexOf(n),i>-1&&t.images.splice(i,1));--t.outstanding_requests;t.outstanding_requests===0&&t.onload()}.bind(n);else if(n.data===null)return;t.images.push(n)},onload:function(){}};
/** @license AutobahnJS - http://autobahn.ws
 *
 * Copyright (C) 2011-2014 Tavendo GmbH.
 * Licensed under the MIT License.
 * See license text at http://www.opensource.org/licenses/mit-license.php
 *
 * AutobahnJS includes code from:
 *
 * when - http://cujojs.com
 *
 * (c) copyright B Cavalier & J Hann
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Crypto-JS - http://code.google.com/p/crypto-js/
 *
 * (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Licensed under the New BSD License at:
 * http://code.google.com/p/crypto-js/wiki/License
 * 
 * console-normalizer - https://github.com/Zenovations/console-normalizer
 *
 * (c) 2012 by Zenovations.
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 * 
 */
(function(n){n||(n=window.console={log:function(){},info:function(){},warn:function(){},error:function(){}});Function.prototype.bind||(Function.prototype.bind=function(n){var t=this,i=Array.prototype.slice.call(arguments,1);return function(){return t.apply(n,Array.prototype.concat.apply(i,arguments))}});typeof n.log=="object"&&(n.log=Function.prototype.call.bind(n.log,n),n.info=Function.prototype.call.bind(n.info,n),n.warn=Function.prototype.call.bind(n.warn,n),n.error=Function.prototype.call.bind(n.error,n));"group"in n||(n.group=function(t){n.info("\\n--- "+t+" ---\\n")});"groupEnd"in n||(n.groupEnd=function(){n.log("\\n")});"time"in n||function(){var t={};n.time=function(n){t[n]=(new Date).getTime()};n.timeEnd=function(i){var r=(new Date).getTime(),u=i in t?r-t[i]:0;n.info(i+": "+u+"ms")}}()})(window.console);
/** @license MIT License (c) copyright 2011-2013 original author or authors */
when=function(n){"use strict";function t(n,t,i,r){return at(n).then(t,i,r)}function e(n){return new f(n,h.PromiseStatus&&h.PromiseStatus())}function f(n,t){function c(){return f?f.inspect():ii()}function l(n,t,r,u,e){function o(i){i._when(n,t,r,u,e)}i?i.push(o):y(function(){o(f)})}function o(n){if(i){var r=i;i=u;y(function(){f=pt(e,n);t&&bt(f,t);w(r,f)})}}function s(n){o(new r(n))}function a(n){if(i){var t=i;y(function(){w(t,new b(n))})}}var e,f,i=[];e=this;this._status=t;this.inspect=c;this._when=l;try{n(o,s,a)}catch(h){s(h)}}function at(n){return n instanceof f?n:o(n)}function o(n){return e(function(t){t(n)})}function vt(n){return t(n,function(n){return new r(n)})}function yt(){function f(u,f,e){n.resolve=n.resolver.resolve=function(n){return t?o(n):(t=!0,u(n),i)};n.reject=n.resolver.reject=function(n){return t?o(new r(n)):(t=!0,f(n),i)};n.notify=n.resolver.notify=function(n){return e(n),n}}var n,i,t;return n={promise:u,resolve:u,reject:u,notify:u,resolver:{resolve:u,reject:u,notify:u}},n.promise=i=e(f),n}function w(n,t){for(var i=0;i<n.length;i++)n[i](t)}function pt(n,t){if(t===n)return new r(new TypeError);if(t instanceof f)return t;try{var i=t===Object(t)&&t.then;return typeof i=="function"?wt(i,t):new c(t)}catch(u){return new r(u)}}function wt(n,t){return e(function(i,r){d(n,t,i,r)})}function c(n){this.value=n}function r(n){this.value=n}function b(n){this.value=n}function bt(n,t){function i(){t.fulfilled()}function r(n){t.rejected(n)}n.then(i,r)}function rt(n){return n&&typeof n.then=="function"}function ut(n,i,r,u,f){return t(n,function(n){function o(r,u,f){function y(n){c(n)}function w(n){h(n)}var o,v,s,a,h,c,l,e;if(l=n.length>>>0,o=Math.max(0,Math.min(i,l)),s=[],v=l-o+1,a=[],o)for(c=function(n){a.push(n);--v||(h=c=p,u(a))},h=function(n){s.push(n);--o||(h=c=p,r(s))},e=0;e<l;++e)e in n&&t(n[e],w,y,f);else r(s)}return e(o).then(r,u,f)})}function kt(n,t,i,r){function u(n){return t?t(n[0]):n[0]}return ut(n,1,u,i,r)}function ft(n,t,i,r){return l(n,p).then(t,i,r)}function dt(){return l(arguments,p)}function gt(n){return l(n,et,ot)}function ni(n,t){return l(n,t)}function l(n,i,r){return t(n,function(n){function u(u,f,e){function l(n,o){t(n,i,r).then(function(n){s[o]=n;--h||u(s)},f,e)}var s,c,h,o;if(h=c=n.length>>>0,s=[],!h){u(s);return}for(o=0;o<c;o++)o in n?l(n[o],o):--h}return new f(u)})}function ti(n,i){var r=d(k,arguments,1);return t(n,function(n){var u;return u=n.length,r[0]=function(n,r,f){return t(n,function(n){return t(r,function(t){return i(n,t,f,u)})})},st.apply(n,r)})}function et(n){return{state:"fulfilled",value:n}}function ot(n){return{state:"rejected",reason:n}}function ii(){return{state:"pending"}}function y(n){v.push(n)===1&&s(lt)}function lt(){w(v);v=[]}function p(n){return n}function ri(n){typeof h.reportUnhandled=="function"?h.reportUnhandled():y(function(){throw n;});throw n;}t.promise=e;t.resolve=o;t.reject=vt;t.defer=yt;t.join=dt;t.all=ft;t.map=ni;t.reduce=ti;t.settle=gt;t.any=kt;t.some=ut;t.isPromise=rt;t.isPromiseLike=rt;i=f.prototype;i.then=function(n,t,i){var r=this;return new f(function(u,f,e){r._when(u,e,n,t,i)},this._status&&this._status.observed())};i["catch"]=i.otherwise=function(n){return this.then(u,n)};i["finally"]=i.ensure=function(n){function t(){return o(n())}return typeof n=="function"?this.then(t,t)["yield"](this):this};i.done=function(n,t){this.then(n,t)["catch"](ri)};i["yield"]=function(n){return this.then(function(){return n})};i.tap=function(n){return this.then(n)["yield"](this)};i.spread=function(n){return this.then(function(t){return ft(t,function(t){return n.apply(u,t)})})};i.always=function(n,t){return this.then(n,n,t)};a=Object.create||function(n){function t(){}return t.prototype=n,new t};c.prototype=a(i);c.prototype.inspect=function(){return et(this.value)};c.prototype._when=function(n,t,i){try{n(typeof i=="function"?i(this.value):this.value)}catch(u){n(new r(u))}};r.prototype=a(i);r.prototype.inspect=function(){return ot(this.value)};r.prototype._when=function(n,t,i,u){try{n(typeof u=="function"?u(this.value):this)}catch(f){n(new r(f))}};b.prototype=a(i);b.prototype._when=function(n,t,i,r,u){try{t(typeof u=="function"?u(this.value):this.value)}catch(f){t(f)}};var i,a,st,k,d,s,v,g,nt,tt,h,ht,it,ct,u;if(it=n,v=[],h=typeof console!="undefined"?console:t,typeof process=="object"&&process.nextTick)s=process.nextTick;else if(ct=typeof MutationObserver=="function"&&MutationObserver||typeof WebKitMutationObserver=="function"&&WebKitMutationObserver)s=function(n,t,i){var r=n.createElement("div");return new t(i).observe(r,{attributes:!0}),function(){r.setAttribute("x","x")}}(document,ct,lt);else try{s=it("vertx").runOnLoop||it("vertx").runOnContext}catch(ui){ht=setTimeout;s=function(n){ht(n,0)}}return g=Function.prototype,nt=g.call,d=g.bind?nt.bind(nt):function(n,t){return n.apply(t,k.call(arguments,2))},tt=[],k=tt.slice,st=tt.reduce||function(n){var i,u,r,f,t;if(t=0,i=Object(this),f=i.length>>>0,u=arguments,u.length<=1)for(;;){if(t in i){r=i[t++];break}if(++t>=f)throw new TypeError;}else r=u[1];for(;t<f;++t)t in i&&(r=n(r,i[t],t,i));return r},t}();CryptoJS=CryptoJS||function(n,t){var u={},f=u.lib={},i=f.Base=function(){function n(){}return{extend:function(t){n.prototype=this;var i=new n;return t&&i.mixIn(t),i.hasOwnProperty("init")||(i.init=function(){i.$super.init.apply(this,arguments)}),i.init.prototype=i,i.$super=this,i},create:function(){var n=this.extend();return n.init.apply(n,arguments),n},init:function(){},mixIn:function(n){for(var t in n)n.hasOwnProperty(t)&&(this[t]=n[t]);n.hasOwnProperty("toString")&&(this.toString=n.toString)},clone:function(){return this.init.prototype.extend(this)}}}(),r=f.WordArray=i.extend({init:function(n,i){n=this.words=n||[];this.sigBytes=i!=t?i:n.length*4},toString:function(n){return(n||h).stringify(this)},concat:function(n){var i=this.words,r=n.words,u=this.sigBytes,f=n.sigBytes,e,t;if(this.clamp(),u%4)for(t=0;t<f;t++)e=r[t>>>2]>>>24-t%4*8&255,i[u+t>>>2]|=e<<24-(u+t)%4*8;else if(r.length>65535)for(t=0;t<f;t+=4)i[u+t>>>2]=r[t>>>2];else i.push.apply(i,r);return this.sigBytes+=f,this},clamp:function(){var i=this.words,t=this.sigBytes;i[t>>>2]&=4294967295<<32-t%4*8;i.length=n.ceil(t/4)},clone:function(){var n=i.clone.call(this);return n.words=this.words.slice(0),n},random:function(t){for(var i=[],u=0;u<t;u+=4)i.push(n.random()*4294967296|0);return new r.init(i,t)}}),e=u.enc={},h=e.Hex={stringify:function(n){for(var r,u=n.words,f=n.sigBytes,i=[],t=0;t<f;t++)r=u[t>>>2]>>>24-t%4*8&255,i.push((r>>>4).toString(16)),i.push((r&15).toString(16));return i.join("")},parse:function(n){for(var i=n.length,u=[],t=0;t<i;t+=2)u[t>>>3]|=parseInt(n.substr(t,2),16)<<24-t%8*4;return new r.init(u,i/2)}},o=e.Latin1={stringify:function(n){for(var r,u=n.words,f=n.sigBytes,i=[],t=0;t<f;t++)r=u[t>>>2]>>>24-t%4*8&255,i.push(String.fromCharCode(r));return i.join("")},parse:function(n){for(var i=n.length,u=[],t=0;t<i;t++)u[t>>>2]|=(n.charCodeAt(t)&255)<<24-t%4*8;return new r.init(u,i)}},c=e.Utf8={stringify:function(n){try{return decodeURIComponent(escape(o.stringify(n)))}catch(t){throw new Error("Malformed UTF-8 data");}},parse:function(n){return o.parse(unescape(encodeURIComponent(n)))}},s=f.BufferedBlockAlgorithm=i.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(n){typeof n=="string"&&(n=c.parse(n));this._data.concat(n);this._nDataBytes+=n.sigBytes},_process:function(t){var e=this._data,h=e.words,c=e.sigBytes,o=this.blockSize,a=o*4,u=c/a,i,s,f,l;if(u=t?n.ceil(u):n.max((u|0)-this._minBufferSize,0),i=u*o,s=n.min(i*4,c),i){for(f=0;f<i;f+=o)this._doProcessBlock(h,f);l=h.splice(0,i);e.sigBytes-=s}return new r.init(l,s)},clone:function(){var n=i.clone.call(this);return n._data=this._data.clone(),n},_minBufferSize:0}),a=f.Hasher=s.extend({cfg:i.extend(),init:function(n){this.cfg=this.cfg.extend(n);this.reset()},reset:function(){s.reset.call(this);this._doReset()},update:function(n){return this._append(n),this._process(),this},finalize:function(n){n&&this._append(n);return this._doFinalize()},blockSize:16,_createHelper:function(n){return function(t,i){return new n.init(i).finalize(t)}},_createHmacHelper:function(n){return function(t,i){return new l.HMAC.init(n,i).finalize(t)}}}),l=u.algo={};return u}(Math),function(){var n=CryptoJS,t=n.lib,i=t.WordArray,r=n.enc,u=r.Base64={stringify:function(n){var u=n.words,e=n.sigBytes,o=this._map,i,t,r,f;for(n.clamp(),i=[],t=0;t<e;t+=3){var s=u[t>>>2]>>>24-t%4*8&255,h=u[t+1>>>2]>>>24-(t+1)%4*8&255,c=u[t+2>>>2]>>>24-(t+2)%4*8&255,l=s<<16|h<<8|c;for(r=0;r<4&&t+r*.75<e;r++)i.push(o.charAt(l>>>6*(3-r)&63))}if(f=o.charAt(64),f)while(i.length%4)i.push(f);return i.join("")},parse:function(n){var o=n.length,u=this._map,s=u.charAt(64),f,e,r,t,h,c;for(s&&(f=n.indexOf(s),f!=-1&&(o=f)),e=[],r=0,t=0;t<o;t++)t%4&&(h=u.indexOf(n.charAt(t-1))<<t%4*2,c=u.indexOf(n.charAt(t))>>>6-t%4*2,e[r>>>2]|=(h|c)<<24-r%4*8,r++);return i.create(e,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),function(){var n=CryptoJS,t=n.lib,i=t.Base,r=n.enc,u=r.Utf8,f=n.algo,e=f.HMAC=i.extend({init:function(n,t){var r,f,i;n=this._hasher=new n.init;typeof t=="string"&&(t=u.parse(t));r=n.blockSize;f=r*4;t.sigBytes>f&&(t=n.finalize(t));t.clamp();var e=this._oKey=t.clone(),o=this._iKey=t.clone(),s=e.words,h=o.words;for(i=0;i<r;i++)s[i]^=1549556828,h[i]^=909522486;e.sigBytes=o.sigBytes=f;this.reset()},reset:function(){var n=this._hasher;n.reset();n.update(this._iKey)},update:function(n){return this._hasher.update(n),this},finalize:function(n){var t=this._hasher,i=t.finalize(n);return t.reset(),t.finalize(this._oKey.clone().concat(i))}})}(),function(n){var i=CryptoJS,f=i.lib,s=f.WordArray,r=f.Hasher,h=i.algo,e=[],o=[],t,u;(function(){function u(t){for(var r=n.sqrt(t),i=2;i<=r;i++)if(!(t%i))return!1;return!0}function r(n){return(n-(n|0))*4294967296|0}for(var i=2,t=0;t<64;)u(i)&&(t<8&&(e[t]=r(n.pow(i,1/2))),o[t]=r(n.pow(i,1/3)),t++),i++})();t=[];u=h.SHA256=r.extend({_doReset:function(){this._hash=new s.init(e.slice(0))},_doProcessBlock:function(n,i){for(var r=this._hash.words,f=r[0],s=r[1],h=r[2],y=r[3],e=r[4],a=r[5],v=r[6],p=r[7],u=0;u<64;u++){if(u<16)t[u]=n[i+u]|0;else{var c=t[u-15],b=(c<<25|c>>>7)^(c<<14|c>>>18)^c>>>3,l=t[u-2],k=(l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10;t[u]=b+t[u-7]+k+t[u-16]}var d=e&a^~e&v,g=f&s^f&h^s&h,nt=(f<<30|f>>>2)^(f<<19|f>>>13)^(f<<10|f>>>22),tt=(e<<26|e>>>6)^(e<<21|e>>>11)^(e<<7|e>>>25),w=p+tt+d+o[u]+t[u],it=nt+g;p=v;v=a;a=e;e=y+w|0;y=h;h=s;s=f;f=w+it|0}r[0]=r[0]+f|0;r[1]=r[1]+s|0;r[2]=r[2]+h|0;r[3]=r[3]+y|0;r[4]=r[4]+e|0;r[5]=r[5]+a|0;r[6]=r[6]+v|0;r[7]=r[7]+p|0},_doFinalize:function(){var r=this._data,t=r.words,u=this._nDataBytes*8,i=r.sigBytes*8;return t[i>>>5]|=128<<24-i%32,t[(i+64>>>9<<4)+14]=n.floor(u/4294967296),t[(i+64>>>9<<4)+15]=u,r.sigBytes=t.length*4,this._process(),this._hash},clone:function(){var n=r.clone.call(this);return n._hash=this._hash.clone(),n}});i.SHA256=r._createHelper(u);i.HmacSHA256=r._createHmacHelper(u)}(Math),function(){var n=CryptoJS,i=n.lib,r=i.Base,u=i.WordArray,t=n.algo,f=t.SHA1,e=t.HMAC,o=t.PBKDF2=r.extend({cfg:r.extend({keySize:4,hasher:f,iterations:1}),init:function(n){this.cfg=this.cfg.extend(n)},compute:function(n,t){for(var s=this.cfg,r=e.create(s.hasher,n),f=u.create(),l=u.create([1]),p=f.words,w=l.words,a=s.keySize,b=s.iterations,o,c,y,i;p.length<a;){o=r.update(t).finalize(l);r.reset();var v=o.words,k=v.length,h=o;for(c=1;c<b;c++)for(h=r.finalize(h),r.reset(),y=h.words,i=0;i<k;i++)v[i]^=y[i];f.concat(o);w[0]++}return f.sigBytes=a*4,f}});n.PBKDF2=function(n,t,i){return o.create(i).compute(n,t)}}();
/** @license MIT License (c) 2011-2013 Copyright Tavendo GmbH. */
AUTOBAHNJS_VERSION="0.8.2.1";global=this,function(n,t){n.ab=t(n,n.when)}(global,function(n,t){"use strict";var i={};return i._version=AUTOBAHNJS_VERSION,function(){Array.prototype.indexOf||(Array.prototype.indexOf=function(n){var u,r,t,i;if(this===null)throw new TypeError;if((u=new Object(this),r=u.length>>>0,r===0)||(t=0,arguments.length>0&&(t=Number(arguments[1]),t!==t?t=0:t!==0&&t!==Infinity&&t!==-Infinity&&(t=(t>0||-1)*Math.floor(Math.abs(t)))),t>=r))return-1;for(i=t>=0?t:Math.max(r-Math.abs(t),0);i<r;i++)if(i in u&&u[i]===n)return i;return-1});Array.prototype.forEach||(Array.prototype.forEach=function(n,t){var u,i,r,f,e;if(this===null)throw new TypeError(" this is null or not defined");if(r=new Object(this),f=r.length>>>0,{}.toString.call(n)!=="[object Function]")throw new TypeError(n+" is not a function");for(t&&(u=t),i=0;i<f;)i in r&&(e=r[i],n.call(u,e,i,r)),i++})}(),i._sliceUserAgent=function(n,t,i){var s=[],r=navigator.userAgent,h=r.indexOf(n),f=r.indexOf(t,h),e,o,u;for(f<0&&(f=r.length),e=r.slice(h,f).split(i),o=e[1].split("."),u=0;u<o.length;++u)s.push(parseInt(o[u],10));return{name:e[0],version:s}},i.getBrowser=function(){var n=navigator.userAgent;return n.indexOf("Chrome")>-1?i._sliceUserAgent("Chrome"," ","/"):n.indexOf("Safari")>-1?i._sliceUserAgent("Safari"," ","/"):n.indexOf("Firefox")>-1?i._sliceUserAgent("Firefox"," ","/"):n.indexOf("MSIE")>-1?i._sliceUserAgent("MSIE",";"," "):null},i.getServerUrl=function(t,i){if(n.location.protocol==="file:")return i?i:"ws://127.0.0.1/ws";var r=n.location.protocol==="https:"?"wss://":"ws://",u=n.location.port!==""?":"+n.location.port:"",f=t?t:"ws";return r+n.location.hostname+u+"/"+f},i.browserNotSupportedMessage="Browser does not support WebSockets (RFC6455)",i.deriveKey=function(n,t){if(t&&t.salt){var i=t.salt,r=t.keylen||32,u=t.iterations||1e4,f=CryptoJS.PBKDF2(n,i,{keySize:r/4,iterations:u,hasher:CryptoJS.algo.SHA256});return f.toString(CryptoJS.enc.Base64)}return n},i._idchars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",i._idlen=16,i._subprotocol="wamp",i._newid=function(){for(var n="",t=0;t<i._idlen;t+=1)n+=i._idchars.charAt(Math.floor(Math.random()*i._idchars.length));return n},i._newidFast=function(){return Math.random().toString(36)},i.log=function(){if(arguments.length>1){console.group("Log Item");for(var n=0;n<arguments.length;n+=1)console.log(arguments[n]);console.groupEnd()}else console.log(arguments[0])},i._debugrpc=!1,i._debugpubsub=!1,i._debugws=!1,i._debugconnect=!1,i.debug=function(t,r,u){if("console"in n)i._debugrpc=t,i._debugpubsub=t,i._debugws=r,i._debugconnect=u;else throw"browser does not support console object";},i.version=function(){return i._version},i.PrefixMap=function(){var n=this;n._index={};n._rindex={}},i.PrefixMap.prototype.get=function(n){var t=this;return t._index[n]},i.PrefixMap.prototype.set=function(n,t){var i=this;i._index[n]=t;i._rindex[t]=n},i.PrefixMap.prototype.setDefault=function(n){var t=this;t._index[""]=n;t._rindex[n]=""},i.PrefixMap.prototype.remove=function(n){var t=this,i=t._index[n];i&&(delete t._index[n],delete t._rindex[i])},i.PrefixMap.prototype.resolve=function(n,t){var u=this,i=n.indexOf(":"),r;return i>=0&&(r=n.substring(0,i),u._index[r])?u._index[r]+n.substring(i+1):t===!0?n:null},i.PrefixMap.prototype.shrink=function(n,t){for(var u,r,f=this,i=n.length;i>0;i-=1)if(u=n.substring(0,i),r=f._rindex[u],r)return r+":"+n.substring(i);return t===!0?n:null},i._MESSAGE_TYPEID_WELCOME=0,i._MESSAGE_TYPEID_PREFIX=1,i._MESSAGE_TYPEID_CALL=2,i._MESSAGE_TYPEID_CALL_RESULT=3,i._MESSAGE_TYPEID_CALL_ERROR=4,i._MESSAGE_TYPEID_SUBSCRIBE=5,i._MESSAGE_TYPEID_UNSUBSCRIBE=6,i._MESSAGE_TYPEID_PUBLISH=7,i._MESSAGE_TYPEID_EVENT=8,i.CONNECTION_CLOSED=0,i.CONNECTION_LOST=1,i.CONNECTION_RETRIES_EXCEEDED=2,i.CONNECTION_UNREACHABLE=3,i.CONNECTION_UNSUPPORTED=4,i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT=5,i.CONNECTION_LOST_SCHEDULED_RECONNECT=6,i.Deferred=t.defer,i._construct=function(t,i){return"WebSocket"in n?i?new WebSocket(t,i):new WebSocket(t):"MozWebSocket"in n?i?new MozWebSocket(t,i):new MozWebSocket(t):null},i.Session=function(n,t,r,u){var f=this;if(f._wsuri=n,f._options=u,f._websocket_onopen=t,f._websocket_onclose=r,f._websocket=null,f._websocket_connected=!1,f._session_id=null,f._wamp_version=null,f._server=null,f._calls={},f._subscriptions={},f._prefixes=new i.PrefixMap,f._txcnt=0,f._rxcnt=0,f._websocket=f._options&&f._options.skipSubprotocolAnnounce?i._construct(f._wsuri):i._construct(f._wsuri,[i._subprotocol]),!f._websocket){if(r!==undefined){r(i.CONNECTION_UNSUPPORTED);return}throw i.browserNotSupportedMessage;}f._websocket.onmessage=function(n){var t,r,h,e,c,s,v,y,p,w;if(i._debugws&&(f._rxcnt+=1,console.group("WS Receive"),console.info(f._wsuri+"  ["+f._session_id+"]"),console.log(f._rxcnt),console.log(n.data),console.groupEnd()),t=JSON.parse(n.data),t[1]in f._calls){if(t[0]===i._MESSAGE_TYPEID_CALL_RESULT){if(r=f._calls[t[1]],h=t[2],i._debugrpc&&r._ab_callobj!==undefined){for(console.group("WAMP Call",r._ab_callobj[2]),console.timeEnd(r._ab_tid),console.group("Arguments"),e=3;e<r._ab_callobj.length;e+=1)if(c=r._ab_callobj[e],c!==undefined)console.log(c);else break;console.groupEnd();console.group("Result");console.log(h);console.groupEnd();console.groupEnd()}r.resolve(h)}else if(t[0]===i._MESSAGE_TYPEID_CALL_ERROR){var u=f._calls[t[1]],l=t[2],a=t[3],o=t[4];if(i._debugrpc&&u._ab_callobj!==undefined){for(console.group("WAMP Call",u._ab_callobj[2]),console.timeEnd(u._ab_tid),console.group("Arguments"),s=3;s<u._ab_callobj.length;s+=1)if(v=u._ab_callobj[s],v!==undefined)console.log(v);else break;console.groupEnd();console.group("Error");console.log(l);console.log(a);o!==undefined&&console.log(o);console.groupEnd();console.groupEnd()}o!==undefined?u.reject({uri:l,desc:a,detail:o}):u.reject({uri:l,desc:a})}delete f._calls[t[1]]}else if(t[0]===i._MESSAGE_TYPEID_EVENT)y=f._prefixes.resolve(t[1],!0),y in f._subscriptions&&(p=t[1],w=t[2],i._debugpubsub&&(console.group("WAMP Event"),console.info(f._wsuri+"  ["+f._session_id+"]"),console.log(p),console.log(w),console.groupEnd()),f._subscriptions[y].forEach(function(n){n(p,w)}));else if(t[0]===i._MESSAGE_TYPEID_WELCOME)if(f._session_id===null)f._session_id=t[1],f._wamp_version=t[2],f._server=t[3],(i._debugrpc||i._debugpubsub)&&(console.group("WAMP Welcome"),console.info(f._wsuri+"  ["+f._session_id+"]"),console.log(f._wamp_version),console.log(f._server),console.groupEnd()),f._websocket_onopen!==null&&f._websocket_onopen();else throw"protocol error (welcome message received more than once)";};f._websocket.onopen=function(){if(f._websocket.protocol!==i._subprotocol)if(typeof f._websocket.protocol=="undefined")i._debugws&&(console.group("WS Warning"),console.info(f._wsuri),console.log("WebSocket object has no protocol attribute: WAMP subprotocol check skipped!"),console.groupEnd());else if(f._options&&f._options.skipSubprotocolCheck)i._debugws&&(console.group("WS Warning"),console.info(f._wsuri),console.log("Server does not speak WAMP, but subprotocol check disabled by option!"),console.log(f._websocket.protocol),console.groupEnd());else{f._websocket.close(1e3,"server does not speak WAMP");throw"server does not speak WAMP (but '"+f._websocket.protocol+"' !)";}i._debugws&&(console.group("WAMP Connect"),console.info(f._wsuri),console.log(f._websocket.protocol),console.groupEnd());f._websocket_connected=!0};f._websocket.onerror=function(){};f._websocket.onclose=function(n){i._debugws&&(f._websocket_connected?console.log("Autobahn connection to "+f._wsuri+" lost (code "+n.code+", reason '"+n.reason+"', wasClean "+n.wasClean+")."):console.log("Autobahn could not connect to "+f._wsuri+" (code "+n.code+", reason '"+n.reason+"', wasClean "+n.wasClean+")."));f._websocket_onclose!==undefined&&(f._websocket_connected?n.wasClean?f._websocket_onclose(i.CONNECTION_CLOSED,"WS-"+n.code+": "+n.reason):f._websocket_onclose(i.CONNECTION_LOST):f._websocket_onclose(i.CONNECTION_UNREACHABLE));f._websocket_connected=!1;f._wsuri=null;f._websocket_onopen=null;f._websocket_onclose=null;f._websocket=null};f.log=function(){f._options&&"sessionIdent"in f._options?console.group("WAMP Session '"+f._options.sessionIdent+"' ["+f._session_id+"]"):console.group("WAMP Session ["+f._session_id+"]");for(var n=0;n<arguments.length;++n)console.log(arguments[n]);console.groupEnd()}},i.Session.prototype._send=function(t){var r=this,u;if(!r._websocket_connected)throw"Autobahn not connected";switch(!0){case n.Prototype&&typeof top.root.__prototype_deleted=="undefined":case typeof t.toJSON=="function":u=t.toJSON();break;default:u=JSON.stringify(t)}r._websocket.send(u);r._txcnt+=1;i._debugws&&(console.group("WS Send"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(r._txcnt),console.log(u),console.groupEnd())},i.Session.prototype.close=function(){var n=this;n._websocket_connected&&n._websocket.close()},i.Session.prototype.sessionid=function(){var n=this;return n._session_id},i.Session.prototype.wsuri=function(){var n=this;return n._wsuri},i.Session.prototype.shrink=function(n,t){var i=this;return t===undefined&&(t=!0),i._prefixes.shrink(n,t)},i.Session.prototype.resolve=function(n,t){var i=this;return t===undefined&&(t=!0),i._prefixes.resolve(n,t)},i.Session.prototype.prefix=function(n,t){var r=this,u;r._prefixes.set(n,t);(i._debugrpc||i._debugpubsub)&&(console.group("WAMP Prefix"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(n),console.log(t),console.groupEnd());u=[i._MESSAGE_TYPEID_PREFIX,n,t];r._send(u)},i.Session.prototype.call=function(){for(var t=this,n=new i.Deferred,r,e,u,f;;)if(r=i._newidFast(),!(r in t._calls))break;for(t._calls[r]=n,e=t._prefixes.shrink(arguments[0],!0),u=[i._MESSAGE_TYPEID_CALL,r,e],f=1;f<arguments.length;f+=1)u.push(arguments[f]);return t._send(u),i._debugrpc&&(n._ab_callobj=u,n._ab_tid=t._wsuri+"  ["+t._session_id+"]["+r+"]",console.time(n._ab_tid),console.info()),n.promise.then?n.promise:n},i.Session.prototype.subscribe=function(n,t){var r=this,u=r._prefixes.resolve(n,!0),f,e;if(u in r._subscriptions||(i._debugpubsub&&(console.group("WAMP Subscribe"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(n),console.log(t),console.groupEnd()),f=[i._MESSAGE_TYPEID_SUBSCRIBE,n],r._send(f),r._subscriptions[u]=[]),e=r._subscriptions[u].indexOf(t),e===-1)r._subscriptions[u].push(t);else throw"callback "+t+" already subscribed for topic "+u;},i.Session.prototype.unsubscribe=function(n,t){var r=this,u=r._prefixes.resolve(n,!0),f,e,o;if(u in r._subscriptions){if(t!==undefined)if(e=r._subscriptions[u].indexOf(t),e!==-1)f=t,r._subscriptions[u].splice(e,1);else throw"no callback "+t+" subscribed on topic "+u;else f=r._subscriptions[u].slice(),r._subscriptions[u]=[];r._subscriptions[u].length===0&&(delete r._subscriptions[u],i._debugpubsub&&(console.group("WAMP Unsubscribe"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(n),console.log(f),console.groupEnd()),o=[i._MESSAGE_TYPEID_UNSUBSCRIBE,n],r._send(o))}else throw"not subscribed to topic "+u;},i.Session.prototype.publish=function(){var o=this,t=arguments[0],r=arguments[1],f=null,n=null,e=null,u=null;if(arguments.length>3){if(!(arguments[2]instanceof Array))throw"invalid argument type(s)";if(!(arguments[3]instanceof Array))throw"invalid argument type(s)";n=arguments[2];e=arguments[3];u=[i._MESSAGE_TYPEID_PUBLISH,t,r,n,e]}else if(arguments.length>2)if(typeof arguments[2]=="boolean")f=arguments[2],u=[i._MESSAGE_TYPEID_PUBLISH,t,r,f];else if(arguments[2]instanceof Array)n=arguments[2],u=[i._MESSAGE_TYPEID_PUBLISH,t,r,n];else throw"invalid argument type(s)";else u=[i._MESSAGE_TYPEID_PUBLISH,t,r];i._debugpubsub&&(console.group("WAMP Publish"),console.info(o._wsuri+"  ["+o._session_id+"]"),console.log(t),console.log(r),f!==null?console.log(f):n!==null&&(console.log(n),e!==null&&console.log(e)),console.groupEnd());o._send(u)},i.Session.prototype.authreq=function(n,t){return this.call("http://api.wamp.ws/procedure#authreq",n,t)},i.Session.prototype.authsign=function(n,t){return t||(t=""),CryptoJS.HmacSHA256(n,t).toString(CryptoJS.enc.Base64)},i.Session.prototype.auth=function(n){return this.call("http://api.wamp.ws/procedure#auth",n)},i._connect=function(t){var r=new i.Session(t.wsuri,function(){t.connects+=1;t.retryCount=0;t.onConnect(r)},function(r,u){var f=null;switch(r){case i.CONNECTION_CLOSED:t.onHangup(r,"Connection was closed properly ["+u+"]");break;case i.CONNECTION_UNSUPPORTED:t.onHangup(r,"Browser does not support WebSocket.");break;case i.CONNECTION_UNREACHABLE:if(t.retryCount+=1,t.connects===0)t.onHangup(r,"Connection could not be established.");else if(t.retryCount<=t.options.maxRetries)if(f=t.onHangup(i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT,"Connection unreachable - scheduled reconnect to occur in "+t.options.retryDelay/1e3+" second(s) - attempt "+t.retryCount+" of "+t.options.maxRetries+".",{delay:t.options.retryDelay,retries:t.retryCount,maxretries:t.options.maxRetries}),f){i._debugconnect&&console.log("Connection unreachable - retrying stopped by app");t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Number of connection retries exceeded.")}else i._debugconnect&&console.log("Connection unreachable - retrying ("+t.retryCount+") .."),n.setTimeout(function(){i._connect(t)},t.options.retryDelay);else t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Number of connection retries exceeded.");break;case i.CONNECTION_LOST:if(t.retryCount+=1,t.retryCount<=t.options.maxRetries)if(f=t.onHangup(i.CONNECTION_LOST_SCHEDULED_RECONNECT,"Connection lost - scheduled "+t.retryCount+"th reconnect to occur in "+t.options.retryDelay/1e3+" second(s).",{delay:t.options.retryDelay,retries:t.retryCount,maxretries:t.options.maxRetries}),f){i._debugconnect&&console.log("Connection lost - retrying stopped by app");t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Connection lost.")}else i._debugconnect&&console.log("Connection lost - retrying ("+t.retryCount+") .."),n.setTimeout(function(){i._connect(t)},t.options.retryDelay);else t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Connection lost.");break;default:throw"unhandled close code in ab._connect";}},t.options)},i.connect=function(n,t,r,u){var f={};if(f.wsuri=n,f.options=u?u:{},f.options.retryDelay===undefined&&(f.options.retryDelay=5e3),f.options.maxRetries===undefined&&(f.options.maxRetries=10),f.options.skipSubprotocolCheck===undefined&&(f.options.skipSubprotocolCheck=!1),f.options.skipSubprotocolAnnounce===undefined&&(f.options.skipSubprotocolAnnounce=!1),t)f.onConnect=t;else throw"onConnect handler required!";f.onHangup=r?r:function(n,t,r){i._debugconnect&&console.log(n,t,r)};f.connects=0;f.retryCount=0;i._connect(f)},i.launch=function(n,t,r){i.connect(n.wsuri,function(r){n.appkey&&n.appkey!==""?r.authreq(n.appkey,n.appextra).then(function(u){var f=null,e;typeof n.appsecret=="function"?f=n.appsecret(u):(e=i.deriveKey(n.appsecret,JSON.parse(u).authextra),f=r.authsign(u,e));r.auth(f).then(function(){t?t(r):i._debugconnect&&r.log("Session opened.")},r.log)},r.log):r.authreq().then(function(){r.auth().then(function(){t?t(r):i._debugconnect&&r.log("Session opened.")},r.log)},r.log)},function(n,t,u){r?r(n,t,u):i._debugconnect&&i.log("Session closed.",n,t,u)},n.sessionConfig)},i});ab._UA_FIREFOX=new RegExp(".*Firefox/([0-9+]*).*");ab._UA_CHROME=new RegExp(".*Chrome/([0-9+]*).*");ab._UA_CHROMEFRAME=new RegExp(".*chromeframe/([0-9]*).*");ab._UA_WEBKIT=new RegExp(".*AppleWebKit/([0-9+.]*)w*.*");ab._UA_WEBOS=new RegExp(".*webOS/([0-9+.]*)w*.*");ab._matchRegex=function(n,t){var i=t.exec(n);return i?i[1]:i};ab.lookupWsSupport=function(){var n=navigator.userAgent,t;return n.indexOf("MSIE")>-1?n.indexOf("MSIE 10")>-1?[!0,!0,!0]:n.indexOf("chromeframe")>-1?(t=parseInt(ab._matchRegex(n,ab._UA_CHROMEFRAME)),t>=14)?[!0,!1,!0]:[!1,!1,!1]:n.indexOf("MSIE 8")>-1||n.indexOf("MSIE 9")>-1?[!0,!0,!0]:[!1,!1,!1]:n.indexOf("Firefox")>-1?(t=parseInt(ab._matchRegex(n,ab._UA_FIREFOX)),t)?t>=7?[!0,!1,!0]:t>=3?[!0,!0,!0]:[!1,!1,!0]:[!1,!1,!0]:n.indexOf("Safari")>-1&&n.indexOf("Chrome")==-1?(t=ab._matchRegex(n,ab._UA_WEBKIT),t)?n.indexOf("Windows")>-1&&t=="534+"?[!0,!1,!0]:n.indexOf("Macintosh")>-1&&(t=t.replace("+","").split("."),parseInt(t[0])==535&&parseInt(t[1])>=24||parseInt(t[0])>535)?[!0,!1,!0]:n.indexOf("webOS")>-1?(t=ab._matchRegex(n,ab._UA_WEBOS).split("."),parseInt(t[0])==2)?[!1,!0,!0]:[!1,!1,!1]:[!0,!0,!0]:[!1,!1,!1]:n.indexOf("Chrome")>-1?(t=parseInt(ab._matchRegex(n,ab._UA_CHROME)),t)?t>=14?[!0,!1,!0]:t>=4?[!0,!0,!0]:[!1,!1,!0]:[!1,!1,!1]:n.indexOf("Android")>-1?n.indexOf("Firefox")>-1?[!0,!1,!0]:n.indexOf("CrMo")>-1?[!0,!1,!0]:n.indexOf("Opera")>-1?[!1,!1,!0]:n.indexOf("CrMo")>-1?[!0,!0,!0]:[!1,!1,!1]:n.indexOf("iPhone")>-1||n.indexOf("iPad")>-1||n.indexOf("iPod")>-1?[!1,!1,!0]:[!1,!1,!1]};`;
window.eval(fx);
class Fy extends Oi {
  constructor(t, e) {
    super(t, e), this._modelBounding = new wn(), this._selectionBounding = new wn(), this._pivot = m.zero(), this._hitRayOrigin = null, this._hitRayDirection = null, this._hitRayAperture = 0, this._hitRaySelectionOnly = !1, this._hitRaySelectionItem = null, this._client = {
      onConnect: () => {
        if (this._connexion === null)
          return;
        const i = this._viewer.getViewElement();
        i.addEventListener("focusin", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !0 });
        }), i.addEventListener("focusout", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !1 });
        }), this._connexion.create3dmouse(i, "WebViewer");
      },
      on3dmouseCreated: () => {
        this._3dMouseInitialized = !0, this._connexion !== null && (this._updateModelBounding(), this._connexion.update3dcontroller({ focus: !0 }));
      },
      onDisconnect: (i) => {
        console.log(`3Dconnexion NL-Server disconnected ${i}`);
      },
      getCoordinateSystem: () => [
        1,
        0,
        0,
        0,
        0,
        0,
        -1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getConstructionPlane: () => {
        const i = this._viewer.model.getViewAxes().upVector;
        return [i.x, i.y, i.z, 0];
      },
      getFov: () => {
        const i = this._view.getCamera(), n = i.getHeight() / i.getWidth(), r = i.getWidth() / (2 * m.subtract(i.getTarget(), i.getPosition()).length());
        return 2 * Math.atan(r / n);
      },
      setFov: (i) => {
        const n = this._view.getCamera(), r = Math.tan(i / 2), l = m.subtract(n.getTarget(), n.getPosition()).length() * r, h = n.getHeight() / n.getWidth();
        n.setWidth(l), n.setHeight(l * h), this._view.setCamera(n);
      },
      getPerspective: () => this._view.getCamera().getProjection() === ri.Perspective,
      getViewExtents: () => {
        const i = this._view.getCamera(), n = i.getPosition(), r = i.getTarget(), o = i.getWidth() / 2, l = i.getHeight() / 2, h = m.subtract(n, r), u = i.getNearLimit(), f = h.z / u;
        return [-o, -l, -f, o, l, -u];
      },
      setViewExtents: (i) => {
        const n = new X(i[0], i[4]), r = new X(i[3], i[4]), o = new X(i[3], i[1]), l = X.distance(n, r), h = X.distance(r, o), u = this._view.getCamera();
        u.setWidth(l), u.setHeight(h), this._view.setCamera(u);
      },
      getViewFrustum: () => {
        const i = this._view.getCamera(), n = i.getHeight(), r = m.subtract(i.getTarget(), i.getPosition()).length(), o = 2 * Math.atan(n / (2 * r)), l = this._view.getCanvasSize().x / this._view.getCanvasSize().y, h = i.getNearLimit(), u = Math.tan(o * 0.5) * h, f = -u, g = l * f, y = l * u, _ = m.distance(i.getPosition(), i.getTarget()) / h;
        return [g, y, f, u, h, _];
      },
      getViewMatrix: () => {
        const i = this._view.getCamera(), n = i.getUp().normalize(), r = m.subtract(i.getTarget(), i.getPosition()).normalize(), o = m.cross(r, n).normalize(), l = i.getPosition();
        return [
          o.x,
          o.y,
          o.z,
          0,
          n.x,
          n.y,
          n.z,
          0,
          -r.x,
          -r.y,
          -r.z,
          0,
          l.x,
          l.y,
          l.z,
          1
        ];
      },
      setViewMatrix: (i) => {
        const n = this._view.getCamera(), r = new m(i[4], i[5], i[6]), o = new m(-i[8], -i[9], -i[10]), l = new m(i[12], i[13], i[14]), h = m.subtract(n.getPosition(), n.getTarget()).length(), u = l.copy().add(o.copy().scale(h));
        n.setTarget(u), n.setPosition(l), n.setUp(r), this._view.setCamera(n);
      },
      getViewRotatable: () => !this._viewer.model.isDrawing(),
      getFrontView: () => [
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getPivotPosition: () => [this._pivot.x, this._pivot.y, this._pivot.z],
      setPivotPosition: (i) => {
        this._pivot = m.createFromArray(i);
      },
      setPivotVisible: (i) => {
        if (this._pivotMarkup.enable(i), i) {
          const n = this._view.projectPoint(this._pivot), r = new X(n.x, n.y);
          this._pivotMarkup.setPosition(r);
        }
        this._viewer.markupManager.refreshMarkup(this._view);
      },
      getPointerPosition: () => {
        const i = this._view.unprojectPoint(this._ptCurrent, 0);
        return i === null ? [0, 0, 0] : [i.x, i.y, i.z];
      },
      getModelExtents: () => [
        this._modelBounding.min.x,
        this._modelBounding.min.y,
        this._modelBounding.min.z,
        this._modelBounding.max.x,
        this._modelBounding.max.y,
        this._modelBounding.max.z
      ],
      getFloorPlane: () => {
        const i = this._viewer.model.getViewAxes().upVector, n = this._modelBounding.min, r = new m(n.x * i.x, n.y * i.y, n.z * i.z);
        return [i.x, i.y, i.z, -r.length()];
      },
      getUnitsToMeters: () => 1e-3,
      setTransaction: (i) => {
        i === 0 && this._viewer.redraw();
      },
      setLookFrom: (i) => {
        this._hitRayOrigin = m.createFromArray(i), this._updateHitTest();
      },
      setLookDirection: (i) => {
        this._hitRayDirection = m.createFromArray(i);
      },
      setLookAperture: (i) => {
        this._hitRayAperture = i;
      },
      setSelectionOnly: (i) => {
        this._hitRaySelectionOnly = i, this._updateHitTest();
      },
      getLookAt: () => {
        if (this._hitRaySelectionItem === null)
          return null;
        const i = this._hitRaySelectionItem.getPosition();
        return i === null ? null : [i.x, i.y, i.z];
      },
      getSelectionEmpty: () => this._viewer.selectionManager.getFirst() === null,
      getSelectionExtents: () => [
        this._selectionBounding.min.x,
        this._selectionBounding.min.y,
        this._selectionBounding.min.z,
        this._selectionBounding.max.x,
        this._selectionBounding.max.y,
        this._selectionBounding.max.z
      ]
    }, this._connexion = null, this._3dMouseInitialized = !1, this._pivotMarkup = new kg(t, e), this._viewer.setCallbacks({
      modelStructureReady: () => {
        this._updateModelBounding();
      },
      subtreeLoaded: () => {
        this._updateModelBounding();
      },
      subtreeDeleted: () => {
        this._updateModelBounding();
      },
      selectionArray: () => {
        this._updateSelectionBounding();
      },
      frameDrawn: () => {
        const i = this._view.projectPoint(this._pivot), n = new X(i.x, i.y);
        this._pivotMarkup.setPosition(n), this._pivotMarkup.draw();
      }
    });
  }
  async _updateModelBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    this._modelBounding = await this._viewer.model.getModelBounding(!0, !0);
    const t = this._modelBounding.center();
    this._pivot = t, this._connexion.update3dcontroller({
      model: {
        extents: [
          this._modelBounding.min.x,
          this._modelBounding.min.y,
          this._modelBounding.min.z,
          this._modelBounding.max.x,
          this._modelBounding.max.y,
          this._modelBounding.max.z
        ]
      }
    });
  }
  async _updateSelectionBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    const t = this._viewer.selectionManager.getResults().map((e) => e.getNodeId());
    if (t.length === 0) {
      this._selectionBounding = new wn();
      return;
    }
    this._selectionBounding = await this._viewer.model.getNodesBounding(t);
  }
  async _updateHitTest() {
    this._hitRayAperture;
    const t = this._viewer;
    if (this._hitRayOrigin === null || this._hitRayDirection === null)
      return;
    const e = new vr(this._hitRayOrigin, this._hitRayDirection), i = new Pi(), n = await this._view.pickFromRay(e, i), r = n.getNodeId();
    if (r === gg) {
      this._hitRaySelectionItem = null;
      return;
    }
    if (this._hitRaySelectionOnly && !t.selectionManager.isNodeSelected(r)) {
      this._hitRaySelectionItem = null;
      return;
    }
    this._hitRaySelectionItem = n;
  }
  /**
   * Connect to the space mouse. To be successful, this method
   * should be called in the sceneReady callback. If you want to
   * connect at a later time, the canvas where the mouse is
   * to be used must have focus.
   *
   * Note: If this is called but the 3d connexion software is not running,
   * a connection error will be shown in the console.
   */
  connect() {
    this._connexion = new _3Dconnexion(this._client), this._connexion.connect();
  }
}
const lS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AreaSelectionOperator: Py,
  AxisTriadOperator: ky,
  ButtonModifier: Wf,
  Camera: ax,
  CuttingPlaneOperator: Ay,
  CuttingPlaneOperatorContext: Ey,
  FloorplanOperator: Ty,
  HandleOperator: Dy,
  Markup: ux,
  Measure: lx,
  NavCubeOperator: Ny,
  NoteOperator: Oy,
  NoteTextManager: ch,
  OperatorBase: Oi,
  RayDrillSelectionOperator: Ry,
  Redline: dx,
  SelectionOperator: Ly,
  SelectionRectangleMarkup: Pg,
  SpaceMouseOperator: Fy
}, Symbol.toStringTag, { value: "Module" }));
var Gf = /* @__PURE__ */ ((s) => (s[s.Cutoff = 476837158203125e-21] = "Cutoff", s))(Gf || {});
class Wp {
  constructor() {
    this.plane = new ln(), this.referenceGeometry = null, this.meshId = null, this.instanceNodeId = null, this.color = yt.createFromFloat(0.65, 0.65, 0.65), this.lineColor = yt.black(), this.opacity = 0.35, this.matrix = new wt();
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      plane: {
        normal: this.plane.normal,
        d: this.plane.d
      },
      referenceGeometry: this.referenceGeometry
    };
  }
  fromJson(t) {
    const e = $c(t), i = e.plane;
    this.plane = new ln();
    const n = i.normal;
    this.plane.normal = new m(n.x, n.y, n.z), this.plane.d = i.d;
    const r = e.referenceGeometry;
    if (Array.isArray(r))
      for (let o = 0; o < r.length; ++o)
        r[o] = m.fromJson(r[o]);
    this.referenceGeometry = r;
  }
  getMatrix() {
    return this.matrix.copy();
  }
  setMatrix(t) {
    this.matrix = t.copy();
  }
  setReferenceGeometry(t) {
    if (t) {
      this.referenceGeometry = [];
      for (const e of t)
        this.referenceGeometry.push(e.copy());
    } else
      this.referenceGeometry = null;
  }
  getReferenceGeometry() {
    if (this.referenceGeometry) {
      const t = [];
      for (const e of this.referenceGeometry)
        t.push(e.copy());
      return t;
    } else
      return null;
  }
  createMeshData() {
    const t = this.referenceGeometry;
    if (t === null)
      return null;
    const e = new Ss(), i = [], n = [];
    i.push(t[0].x, t[0].y, t[0].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[3].x, t[3].y, t[3].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[2].x, t[2].y, t[2].z), i.push(t[3].x, t[3].y, t[3].z);
    const o = ln.createFromPoints(t[0], t[1], t[2]).normal;
    for (let l = 0; l < 6; l++)
      n.push(o.x, o.y, o.z);
    return e.addFaces(i, n), e.addPolyline([t[0].x, t[0].y, t[0].z, t[1].x, t[1].y, t[1].z]), e.addPolyline([t[1].x, t[1].y, t[1].z, t[2].x, t[2].y, t[2].z]), e.addPolyline([t[2].x, t[2].y, t[2].z, t[3].x, t[3].y, t[3].z]), e.addPolyline([t[3].x, t[3].y, t[3].z, t[0].x, t[0].y, t[0].z]), e;
  }
}
class gx {
  /** @hidden */
  constructor(t, e, i, n) {
    this._cuttingPlanes = [], this._isActive = !1, this._viewer = t, this._model = e, this._cuttingManager = i, this._engine = n;
  }
  /**
   * Adds a plane to the cutting section.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry An optional list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   * @param options Optional parameters for the cutting plane.
   * @param options.color The color of the cutting plane.
   * @param options.lineColor The color of the cutting plane's lines.
   * @param options.opacity The opacity of the cutting plane.
   * @returns A promise that resolves to true if the plane was added successfully, or false if the maximum number of cutting planes has been reached.
   */
  async addPlane(t, e = null, i) {
    const n = this._engine.getCuttingSectionLimits();
    if (this._cuttingPlanes.length >= n.maxCuttingPlanesPerSection)
      return !1;
    const r = new Wp();
    if (r.plane = t.copy(), r.setReferenceGeometry(e), this._cuttingPlanes.push(r), !this._isActive || (await this._resetCuttingPlane(r), await this._engine.updateCuttingSection(this), !i))
      return !0;
    const o = this._cuttingPlanes.length - 1;
    if (i.color) {
      const l = yt.fromJson(i.color);
      this.setPlaneColor(o, l), r.color = l;
    }
    if (i.lineColor) {
      const l = yt.fromJson(i.lineColor);
      this.setPlaneLineColor(o, l), r.lineColor = l;
    }
    return i.opacity && (this.setPlaneOpacity(o, i.opacity), r.opacity = i.opacity), !0;
  }
  /**
   * Sets a plane currently in the cutting section at a given index.
   * @param index The index of the cutting plane to replace.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry a list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   * @param options Optional parameters for the cutting plane.
   * @param options.color The color of the cutting plane.
   * @param options.lineColor The color of the cutting plane's lines.
   * @param options.opacity The opacity of the cutting plane.
   * @returns A promise that resolves when the operation has completed.
   */
  async setPlane(t, e, i = null, n) {
    const r = this._cuttingPlanes[t];
    if (r) {
      if (r.plane = e.copy(), r.setReferenceGeometry(i), n != null && n.color) {
        const o = yt.fromJson(n.color);
        this.setPlaneColor(t, o), r.color = o;
      }
      if (n != null && n.lineColor) {
        const o = yt.fromJson(n.lineColor);
        this.setPlaneLineColor(t, o), r.lineColor = o;
      }
      n != null && n.opacity && (this.setPlaneOpacity(t, n.opacity), r.opacity = n.opacity), this._isActive && (await this._resetCuttingPlane(r), await this._engine.updateCuttingSection(this));
    }
  }
  /**
   * Updates the position of a cutting plane and stand-in geometry if present.
   * @param index The index of the cutting plane.
   * @param plane The plane to use for cutting.
   * @param geometryMatrix A matrix that is multiplied by the previous position matrix to update the geometry position.
   * @param finalizePosition If true, sets the result of the geometry matrix multiplication as the new position matrix.
   * @param resetTranslation If true, uses the provided geometry matrix for the geometry position.
   */
  async updatePlane(t, e, i = new wt(), n = !1, r = !1) {
    const o = this._cuttingPlanes[t];
    if (o !== void 0 && (o.plane = e.copy(), this._isActive))
      if (o.instanceNodeId !== null) {
        this._engine.pauseAllRendering();
        let l = o.getMatrix();
        r && (l = new wt());
        const h = wt.multiply(l, i);
        n && o.setMatrix(h), await Promise.all([
          this._model.setNodeMatrix(o.instanceNodeId, h),
          this._engine.updateCuttingSection(this)
        ]), this._engine.resumeAllRendering();
      } else
        return this._engine.updateCuttingSection(this);
  }
  /**
   * Removes the cutting plane at the specified index.
   * @param index The index of the cutting plane to remove.
   */
  removePlane(t) {
    const e = [], i = this._cuttingPlanes[t];
    return i !== void 0 && (i.meshId !== null && i.instanceNodeId !== null && e.push(this._destroyMeshes([i.meshId], [i.instanceNodeId])), this._cuttingPlanes.splice(t, 1)), this._isActive && e.push(this._engine.updateCuttingSection(this)), We(e);
  }
  /**
   * Gets the plane for the item at the given index. In the case of an invalid index, null will be returned.
   * @param index The index of the cutting plane.
   * @returns Plane that is used for cutting at the given index or null.
   */
  getPlane(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.plane.copy() : null;
  }
  /**
   * Gets the [[NodeId]] for the reference geometry for the cutting plane at the given index.
   * In the case of an invalid index or a cutting plane with no reference geometry, null will be returned.
   * @param index the index of the cutting plane.
   * @returns [[NodeId]] of the reference geometry for the cutting plane at the given index or null.
   */
  getNodeId(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.instanceNodeId : null;
  }
  /**
   * Gets the reference geometry for the item at the given index. In the case of an invalid index, null will be returned
   * @param index The index of the cutting plane.
   * @returns A list of four points representing a quad to be used as reference geometry for the cutting plane, or null if there is no reference geometry.
   */
  getReferenceGeometry(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.getReferenceGeometry() : null;
  }
  /**
   * Gets the index of a plane for the corresponding node id. In the case of an invalid id, null will be returned.
   * @param id The [[NodeId]] for the plane reference geometry.
   * @returns The index of a plane associated with the provided [[NodeId]], or null if no plane is found.
   */
  getPlaneIndexByNodeId(t) {
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      if (this._cuttingPlanes[e].instanceNodeId === t)
        return e;
    return null;
  }
  /**
   * Gets the opacity for the plane at the given index.
   * @param index The index of the cutting plane.
   */
  getPlaneOpacity(t) {
    const e = this._cuttingPlanes[t];
    if (e)
      return e.opacity;
  }
  /**
   * Sets the opacity for the plane at the given index.
   *
   * Equivalent to `section.applyPlaneOpacity(index, opacity)`
   *
   * @param index The index of the cutting plane.
   * @param opacity A number between 0 and 1.
   */
  setPlaneOpacity(t, e) {
    this.applyPlaneOpacity(t, e);
  }
  /**
   * Apply the opacity factor to the plane.
   *
   * @param index The index of the cutting plane.
   * @param opacity The value used to change the opacity if needed
   */
  applyPlaneOpacity(t, e) {
    const i = this._cuttingPlanes[t];
    i !== void 0 && (e && (i.opacity = e), i.instanceNodeId !== null && this._model.setNodesOpacity([i.instanceNodeId], i.opacity));
  }
  /**
   * Reapply the opacity of the cutting planes to the engine
   * This function must be explicitly called after _resetOpacity has been emitted by the engine
   */
  resetPlanesOpacity() {
    this._cuttingPlanes.forEach((t, e) => {
      this.applyPlaneOpacity(e);
    });
  }
  /**
   * Sets the color for all planes in the cutting section
   * @param color Color to set
   * @returns Promise that resolves when the operation has completed.
   */
  setColor(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.color.assign(t), i.instanceNodeId !== null && e.push(i.instanceNodeId);
    return this._model.setNodesFaceColor(e, t), Promise.resolve();
  }
  /**
   * Sets the opacity for all planes in the cutting section
   * @param opacity opacity to set
   */
  setOpacity(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.opacity = t, i.instanceNodeId !== null && e.push(i.instanceNodeId);
    this._model.setNodesOpacity(e, t);
  }
  /**
   * Sets the line color for all planes in the cutting section
   * @param color Color to set
   * @returns The color of the cutting plane.
   */
  getPlaneColor(t) {
    const e = this._cuttingPlanes[t];
    if (e)
      return e.color;
  }
  /**
   * Sets the color for the plane at the given index.
   * @param index The index of the cutting plane.
   * @param color The color to set.
   */
  setPlaneColor(t, e) {
    const i = this._cuttingPlanes[t];
    !i || !i.instanceNodeId || (i.color = e, this._model.setNodesFaceColor([i.instanceNodeId], e));
  }
  /**
   * Sets the line color for the plane at the given index.
   * @param index The index of the cutting plane.
   * @returns The color of the cutting plane's line.
   */
  getPlaneLineColor(t) {
    const e = this._cuttingPlanes[t];
    if (e)
      return e.lineColor;
  }
  /**
   * Sets the line color for the plane at the given index.
   * @param index The index of the cutting plane.
   * @param color The color to set.
   */
  setPlaneLineColor(t, e) {
    const i = this._cuttingPlanes[t];
    !i || !i.instanceNodeId || (i.lineColor = e, this._model.setNodesLineColor([i.instanceNodeId], e));
  }
  /**
   * Gets the cutting planes for this cutting section.
   * @returns the cutting planes for this cutting
   */
  getCuttingPlanes() {
    return this._cuttingPlanes;
  }
  /**
   * Gets the number of planes in this cutting secton.
   * @returns the number of planes in this cutting section
   */
  getCount() {
    return this._cuttingPlanes.length;
  }
  /**
   * Removes all planes from this cutting section. This will also deactivate the cutting section.
   */
  async clear() {
    await this.deactivate(), this._cuttingPlanes.length = 0;
  }
  /**
   * Activates a cutting section for use. A cutting section must have at least one plane to be activated.
   * @returns a promise if the cutting section was activated.
   */
  async activate() {
    if (!this._isActive) {
      if (this._isActive = !0, this._cuttingPlanes.length > 0) {
        if (!this._cuttingManager.hasActiveCuttingSection())
          for (const i of this._viewer.views)
            this._engine.setDefaultDepthRange(i.id, 0, 1 - Gf.Cutoff);
        const t = [], e = [];
        for (const i of this._cuttingPlanes)
          t.push(
            this._createCuttingPlaneGeometry(i).then((n) => {
              n !== null && e.push(n);
            })
          );
        await We(t), this._initCuttingPlanesByNodeId(e);
      }
      return this._engine.addCuttingSection(this);
    }
  }
  /**
   * Removes a cutting section from use.
   */
  async deactivate() {
    if (this._isActive) {
      this._isActive = !1;
      const t = [];
      if (t.push(this._destroyGeometry()), t.push(this._engine.removeCuttingSection(this)), !this._cuttingManager.hasActiveCuttingSection())
        for (const e of this._viewer.views)
          this._engine.setDefaultDepthRange(e.id, 0, 1);
      return We(t);
    }
  }
  /**
   * Gets whether a cutting section is active
   * @returns boolean value indicating whether this cutting section is active
   */
  isActive() {
    return this._isActive;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      t[e] = this._cuttingPlanes[e].toJson();
    return {
      planes: t
    };
  }
  async fromJson(t) {
    await this.clear();
    const i = $c(t).planes;
    for (const n of i) {
      const r = new Wp();
      r.fromJson(n), this._cuttingPlanes.push(r);
    }
    return this.activate();
  }
  _initCuttingPlanesByNodeId(t) {
    this._model.setInstanceModifier(tn.DoNotCut, t, !0), this._model.setInstanceModifier(tn.DoNotExplode, t, !0), this._cuttingManager.getStandinGeometryPickable() || this._model.setInstanceModifier(tn.DoNotSelect, t, !0);
  }
  _destroyGeometry() {
    const t = [], e = [];
    for (const i of this._cuttingPlanes)
      i.meshId !== null && t.push(i.meshId), i.instanceNodeId !== null && e.push(i.instanceNodeId), i.meshId = null, i.instanceNodeId = null;
    return this._destroyMeshes(t, e);
  }
  /** @hidden */
  _getInstanceNodeIds() {
    const t = [];
    for (const e of this._cuttingPlanes) {
      const i = e.instanceNodeId;
      i !== null && t.push(i);
    }
    return t;
  }
  async _resetCuttingPlane(t) {
    if (t.meshId !== null && t.instanceNodeId !== null) {
      const e = this._destroyMeshes([t.meshId], [t.instanceNodeId]);
      return t.meshId = null, t.instanceNodeId = null, await e, this._createInstanceGeometry(t);
    } else if (t.referenceGeometry !== null)
      return this._createInstanceGeometry(t);
  }
  async _createInstanceGeometry(t) {
    const e = [], i = await this._createCuttingPlaneGeometry(t);
    i !== null && e.push(i), this._initCuttingPlanesByNodeId(e);
  }
  async _destroyMeshes(t, e) {
    const i = [];
    i.push(this._model.deleteMeshInstances(e)), i.push(this._model.deleteMeshes(t)), await We(i);
    for (const n of e)
      this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.delete(n);
  }
  async _createCuttingPlaneGeometry(t) {
    const e = t.createMeshData();
    if (e === null)
      return null;
    e.setBackfacesEnabled(!0);
    const i = await this._model.createMesh(e);
    t.meshId = i;
    const n = ee.OverrideSceneVisibility | ee.ExcludeBounding | ee.DoNotXRay, r = t.plane.copy(), o = r.normal.copy().scale(-r.d), l = new wt().setTranslationComponent(o.x, o.y, o.z);
    t.setMatrix(l.copy());
    const h = new tr(
      i,
      l,
      null,
      t.color,
      null,
      null,
      n
    );
    h.setLineColor(t.lineColor), this._engine.pauseAllRendering();
    const u = await this._model.createMeshInstance(h, void 0, !0, !0);
    return t.instanceNodeId = u, this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.add(u), this._model.setDepthRange([u], Gf.Cutoff, 1), this._model.setNodesOpacity([u], t.opacity), this._engine.resumeAllRendering(), u;
  }
}
const Qi = class Qi {
  /** @hidden */
  constructor(t, e) {
    this._position = new Go(0, Fe.Pixels, 0, Fe.Pixels), this._viewportSize = new Go(
      0.2,
      Fe.MinimumProportionOfCanvas,
      0.2,
      Fe.MinimumProportionOfCanvas
    ), this._anchor = qe.LowerLeftCorner, this._instanceKeys = [], this._enabled = !1, this._sceneReady = vi(), this._assemblyTreeReady = vi(), this._axisTriadReadyToInit = [this._sceneReady, this._assemblyTreeReady], this._geometryCreated = !1, this._viewer = t, this._view = e, this._viewer.getSceneReady() && this._sceneReady.resolve(), this._viewer.getModelReady() && this._assemblyTreeReady.resolve(), this._viewer.setCallbacks({
      sceneReady: async () => {
        this._sceneReady.resolve();
      },
      _assemblyTreeReady: async () => {
        this._assemblyTreeReady.resolve();
      },
      _firstAttachment: async () => {
        await this._onCameraUpdate(), this._updateVisibility();
      },
      overlayViewportSet: (i, n) => {
        var r;
        n.id === ((r = this._view) == null ? void 0 : r.id) && i === be.AxisTriad && this._onViewportSet();
      },
      _drawContextDestroyed: (i) => {
        this._view !== void 0 && i === this._view.id && delete this._view;
      }
    }), Promise.all(this._axisTriadReadyToInit).then(async () => {
      this._createViewport(), this._updateVisibility(), await this._createGeometry();
      const i = this._viewer.model;
      for (const n of this._instanceKeys) {
        const r = i._getNodeFromInstanceInc(!0, Ni.Local, n, !0);
        i._preventNodeDeletion(r);
      }
    });
  }
  /**
   * Sets the color of one axis on this [[AxisTriad]]
   * @param axis The axis that will change color
   * @param color The color to set
   */
  async setAxisColor(t, e) {
    await this._sceneReady;
    let i, n;
    switch (t) {
      case Ze.X:
        i = this._instanceKeys[0], n = this._instanceKeys[3];
        break;
      case Ze.Y:
        i = this._instanceKeys[1], n = this._instanceKeys[4];
        break;
      case Ze.Z:
        i = this._instanceKeys[2], n = this._instanceKeys[5];
        break;
      default:
        return;
    }
    const r = this._getScEngine();
    r.setPartColor([Ni.Local, i], Jt.Faces, e), r.setPartColor([Ni.Local, n], Jt.Lines, e);
  }
  /**
   * Sets the anchor position for this [[AxisTriad]].
   * @param anchor The anchor position.
   * @returns A promise that resolves on completion.
   */
  async setAnchor(t) {
    return this._anchor = t, await this._sceneReady, this._updateViewport();
  }
  /**
   * Gets the anchor position for this [[AxisTriad]].
   * Default position is in the lower left corner.
   * @returns The overlay anchor value of the triad.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Updates the visibility of this [[AxisTriad]] based on the enabled status.
   * @returns A promise that resolves on completion.
   */
  _updateVisibility() {
    this._enabled ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window.
   * @returns A promise that resolves on completion.
   */
  _hideOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.AxisTriad, !1);
  }
  /**
   * Shows the overlay window.
   * @returns A promise that resolves on completion.
   */
  _showOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.AxisTriad, !0);
  }
  /**
   * Gets the current state of this [[AxisTriad]].
   * @returns `true` if enabled and `false` otherwise.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the overlay id. This id should be considered reserved and not be used by client applications.
   * @returns The overlay id used by this [[AxisTriad]].
   */
  getOverlayId() {
    return be.AxisTriad;
  }
  _updateViewport() {
    if (!this._view) return;
    this._view.overlayManager.setViewport(
      be.AxisTriad,
      this._anchor,
      this._position.x,
      Fe.Pixels,
      this._position.y,
      Fe.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    if (!this._view) return;
    const t = this._view.overlayManager;
    this._updateViewport();
    const e = new Sn();
    e.setPosition(new m(0, 0, 10)), e.setTarget(m.zero()), e.setUp(new m(0, 1, 0)), e.setWidth(Qi._fieldSize), e.setHeight(Qi._fieldSize), e.setProjection(ri.Orthographic), t.setCamera(be.AxisTriad, e);
  }
  _onViewportSet() {
    if (!this._view) return;
    const t = this._view.overlayManager, e = t._getViewportPosition(be.AxisTriad), i = t._getViewportSize(be.AxisTriad), n = t.getViewportAnchor(be.AxisTriad);
    e === null || i === null || n === null || (this._position = e, this._viewportSize = i, this._anchor = n);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const t = [
      this._createAxis(Qi._xRotMatrix, 0, Qi._xColor),
      this._createAxis(Qi._yRotMatrix, 1, Qi._yColor),
      this._createAxis(Qi._zRotMatrix, 2, Qi._zColor),
      this._createAxisLabel(Ze.X, Qi._xColor, 3),
      this._createAxisLabel(Ze.Y, Qi._yColor, 4),
      this._createAxisLabel(Ze.Z, Qi._zColor, 5)
    ], e = await Promise.all(t);
    this._onCameraUpdate();
    const i = [];
    for (const r of e)
      i.push(Ni.Local, r);
    this._getScEngine().setPartVisibility(i, !0, !0), this._createGeomCallbacks(), this._geometryCreated = !0;
  }
  _createGeomCallbacks() {
    this._viewer.setCallbacks({
      camera: (t, e) => {
        this._view !== void 0 && e.id === this._view.id && this._onCameraUpdate();
      }
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the axis triad overlay
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the axis triad overlay
   */
  insideOverlay(t) {
    if (!this._view) return !1;
    const e = this._view.overlayManager._toPixelPoint(this._viewportSize), i = this._getOverlayOffset();
    return t.x >= i.x && t.y >= i.y && t.x <= i.x + e.x && t.y <= i.y + e.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    if (!this._view) return X.zero();
    const t = this._view.overlayManager._toPixelPoint(this._viewportSize);
    return this._view.overlayManager._getOverlayOffset(this._anchor, t);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._view ? this._view.overlayManager._toPixelPoint(this._viewportSize) : X.zero();
  }
  /**
   * Checks if a selection is part of the axis triad, and return the corresponding axis.
   * @param selectionItem selection item to check.
   * @returns Axis if selected, null otherwise.
   */
  getSelectionAxis(t) {
    if (console.assert(this._enabled), t === null || !t.isFaceSelection() || t.overlayIndex() !== be.AxisTriad)
      return null;
    const e = this._viewer.model, i = t.getNodeId(), n = e._gatherInstanceIncsFromNodeIds([i], Wt.BodyInstance);
    if (n.length !== 2 || n[0] !== Ni.Local)
      return null;
    const r = n[1];
    for (let o = 0; o < this._instanceKeys.length; ++o)
      if (this._instanceKeys[o] === r)
        switch (o % 3) {
          case 0:
            return Ze.X;
          case 1:
            return Ze.Y;
          case 2:
            return Ze.Z;
        }
    return null;
  }
  /**
   * Called when the axis triad is clicked. Realigns the view along the axis selected by `selection`
   * or does nothing if no axis is selected.
   * @param selection
   */
  async onClickSelection(t) {
    if (this._view === void 0)
      return;
    const e = this.getSelectionAxis(t);
    if (e === null)
      return;
    const i = this._viewer.model, n = this._view;
    let r;
    switch (e) {
      case Ze.X:
        r = cc.EyeX_UpY;
        break;
      case Ze.Y:
        r = cc.EyeY_UpZ;
        break;
      case Ze.Z:
        r = cc.EyeZ_UpX;
        break;
    }
    const o = await i.getModelBounding(!0, !1), l = n.getCamera();
    let h = this._alignedFitBounding(r, !1, !1, o);
    l.equals(h) && (h = this._alignedFitBounding(r, !0, !1, o)), await n._setCameraPromise(h, cs);
    const u = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(u).length === 0)
      return this._viewer._getScEngine().markCameraAsEmpty(this._view.id);
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(t, e, i, n, r, o) {
    const l = await this._viewer.model.createMesh(t), h = new tr(l);
    if (h.setCreationFlags(
      o | ee.DoNotCut | ee.DoNotExplode | ee.ExcludeBounding | ee.Invisible
    ), !this._view)
      throw Error("Impossible to create a axis triad without an associated view");
    h.overlayId = {
      viewKey: this._view.id,
      overayIndex: be.AxisTriad
    }, h.setFaceColor(i), h.setLineColor(n), h.setMatrix(r);
    const g = (await this._getScEngine().createMeshInstance(h))[1];
    return this._instanceKeys[e] = g, g;
  }
  _createAxis(t, e, i) {
    const n = og(
      qs.CylinderRadius,
      qs.SegmentCount,
      qs.StemHeight,
      qs.ConeBaseRadius,
      qs.CapHeight,
      qs.TaperHeight
    );
    return this._createInstance(
      n,
      e,
      i,
      yt.black(),
      t,
      ee.None
    );
  }
  _createAxisLabel(t, e, i) {
    const n = new Ss();
    n.setFaceWinding(Qs.Clockwise);
    const r = 0.5 * qs.LetterWidth, o = 0.5 * qs.LetterHeight, l = qs.StemHeight + qs.CapHeight + qs.LetterOffsetPos, h = new wt();
    return t === Ze.X ? (n.addPolyline([r, o, 0, -r, -o, 0]), n.addPolyline([-r, o, 0, r, -o, 0]), h.setTranslationComponent(l, 0, 0)) : t === Ze.Y ? (n.addPolyline([-r, o, 0, 0, 0, 0]), n.addPolyline([0, 0, 0, r, o, 0]), n.addPolyline([0, 0, 0, 0, -1.25 * o, 0]), h.setTranslationComponent(0, l, 0)) : t === Ze.Z && (n.addPolyline([-r, o, 0, r, o, 0]), n.addPolyline([r, o, 0, -r, -o, 0]), n.addPolyline([-r, -o, 0, r, -o, 0]), h.setTranslationComponent(0, 0, l)), this._createInstance(
      n,
      i,
      yt.black(),
      e,
      h,
      ee.ScreenOriented
    );
  }
  _onCameraUpdate() {
    if (this._view === void 0)
      return;
    const t = new Sn(), e = this._view.getCamera();
    t.setPosition(
      e.getPosition().subtract(e.getTarget()).normalize()
    ), t.setTarget(m.zero()), t.setUp(e.getUp()), t.setProjection(ri.Orthographic), t.setWidth(Qi._fieldSize), t.setHeight(Qi._fieldSize), this._view.overlayManager.setCamera(be.AxisTriad, t);
  }
  _alignedFitBounding(t, e, i, n) {
    if (this._view === void 0)
      return;
    const r = m.subtract(n.max, n.min).length(), o = m.add(m.scale(n.min, 0.5), m.scale(n.max, 0.5)), l = new m(o.x, o.y, o.z + r), h = m.subtract(o, l);
    let u = -h.length();
    const f = i ? -1 : 1;
    let g, y;
    t === cc.None ? (g = h, y = new m(0, f, 0), e && g.negate()) : (e && (u = -u), (t & xu.X) !== 0 ? g = new m(u, 0, 0) : (t & xu.Y) !== 0 ? g = new m(0, u, 0) : (console.assert((t & xu.Z) !== 0), g = new m(0, 0, u)), (t & Iu.X) !== 0 ? y = new m(f, 0, 0) : (t & Iu.Y) !== 0 ? y = new m(0, f, 0) : (console.assert((t & Iu.Z) !== 0), y = new m(0, 0, f)));
    const _ = m.subtract(o, g), x = this._view.getCamera();
    return Sn.create(
      _,
      o,
      y,
      x.getProjection(),
      r,
      r,
      x.getNearLimit()
    );
  }
};
Qi._xRotMatrix = wt.createFromOffAxisRotation(new m(0, 0, 1), -90), Qi._yRotMatrix = new wt(), Qi._zRotMatrix = wt.createFromOffAxisRotation(new m(1, 0, 0), 90), Qi._xColor = new yt(168, 56, 59), Qi._yColor = new yt(96, 166, 50), Qi._zColor = new yt(41, 81, 185), Qi._fieldSize = 8;
let $f = Qi;
class px {
  /** @hidden */
  constructor(t, e, i, n) {
    this._cuttingSections = [], this._isInit = !1, this._standinGeometryPickable = !0, this._cappingFaceColor = yt.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = yt.createFromFloat(0.5, 0.5, 0.5), this._cappingIdleCallbackEnabled = !1, this._cappingIdlePromise = null, this._conservativeIsCappingIdle = !1, this._viewer = t, this._model = e, this._callbackManager = i, this._engine = n, t.setCallbacks({
      cappingIdle: (r) => {
        this._conservativeIsCappingIdle = r, r && this._cappingIdlePromise !== null && (this._cappingIdlePromise.resolve(), this._cappingIdlePromise = null);
      },
      _resetAssemblyTreeBegin: () => (this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(new oe("Model became reset.")), this._cappingIdlePromise = null), Promise.resolve()),
      _resetOpacity: () => {
        this._cuttingSections.forEach((r) => r.resetPlanesOpacity());
      }
    });
  }
  /**
   * generates reference geometry for a cutting plane.
   * @param axis axis for reference geometry.
   * @param modelBounding modelBounding for geometry size.
   */
  createReferenceGeometryFromAxis(t, e) {
    const i = [];
    switch (t) {
      case Ze.X:
        i.push(new m(0, e.max.y, e.min.z)), i.push(new m(0, e.max.y, e.max.z)), i.push(new m(0, e.min.y, e.max.z)), i.push(new m(0, e.min.y, e.min.z));
        break;
      case Ze.Y:
        i.push(new m(e.min.x, 0, e.min.z)), i.push(new m(e.max.x, 0, e.min.z)), i.push(new m(e.max.x, 0, e.max.z)), i.push(new m(e.min.x, 0, e.max.z));
        break;
      case Ze.Z:
        i.push(new m(e.min.x, e.max.y, 0)), i.push(new m(e.max.x, e.max.y, 0)), i.push(new m(e.max.x, e.min.y, 0)), i.push(new m(e.min.x, e.min.y, 0));
        break;
    }
    return i;
  }
  /**
   * Uses a selection normal and position to create reference geometry for a cutting plane.
   * @param normal face normal.
   * @param position face position.
   * @param modelBounding model bounding for geometry size.
   */
  createReferenceGeometryFromFaceNormal(t, e, i) {
    const n = [], r = t.copy().normalize(), o = new ln().setFromPointAndNormal(e, r).d, l = e.copy().add(m.scale(r, o)), h = i.center(), u = m.add(
      h,
      m.scale(r, m.dot(r, m.subtract(l, h)))
    ), f = uv(r), g = i.extents().length() / 2, y = m.fromJson(f[1]), _ = m.fromJson(f[2]), x = m.fromJson(f[1]).negate(), b = m.fromJson(f[2]).negate(), I = dv(
      [
        m.add(_, x),
        m.add(y, _),
        m.add(x, b),
        m.add(b, y)
      ],
      f
    ).map((C) => {
      const M = new m(C.x, C.y, C.z).normalize();
      return M.x *= g, M.y *= g, M.z *= g, M.add(u), M;
    });
    return n.push(...I), n;
  }
  /**
   * Activates all cutting sections, and restores any planes contained to the scene.
   */
  activateCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.activate());
    return We(t);
  }
  /**
   * Deactivates all cutting sections.
   * Cutting planes are not removed from section and can be restored using [[activateCuttingSections]]
   */
  deactivateAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.deactivate());
    return We(t);
  }
  /**
   * Clears all cutting sections.
   * This causes all cutting sections to be deactivated and all their cutting planes removed.
   */
  clearAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.clear());
    return We(t);
  }
  /**
   * Sets the color for all cutting plane reference geometry.
   * @param color
   */
  setCuttingPlaneColor(t) {
    for (const e of this._cuttingSections)
      e.setColor(t);
    return Promise.resolve();
  }
  /**
   * Sets the color to be used for capping geometry faces. If null is passed in as the color object, no capping face will be shown.
   * @param color color to use for capping geometry faces.
   */
  setCappingFaceColor(t) {
    return this._cappingFaceColor = t ? t.copy() : null, this._engine.setCappingFaceColor(this._cappingFaceColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry faces.
   * @returns color used for capping geometry faces.
   */
  getCappingFaceColor() {
    return this._cappingFaceColor ? this._cappingFaceColor.copy() : null;
  }
  /**
   * Sets the color to be used for capping geometry lines. If null is passed in as the color object, no capping line will be shown.
   * @param color color to use for capping geometry lines.
   */
  setCappingLineColor(t) {
    return this._cappingLineColor = t ? t.copy() : null, this._engine.setCappingLineColor(this._cappingLineColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry lines.
   * @returns color used for capping geometry lines.
   */
  getCappingLineColor() {
    return this._cappingLineColor ? this._cappingLineColor.copy() : null;
  }
  /**
   * Gets a cutting section by index. Cutting sections are created automatically by the system and may be queried at any point during or after the sceneReady callback has been triggered.
   * @returns the cutting section for the given index.
   */
  getCuttingSection(t) {
    return this._isInit && t < this._cuttingSections.length ? this._cuttingSections[t] : null;
  }
  /**
   * Gets the total number of planes supported by each cutting section.
   * Cutting planes contained in the same cutting section will work together (an object is only cut if all cutting planes in a section would cut it).
   * Cutting planes in separate cutting sections do not work together when cutting (an object is cut if any one of the cutting sections would cut it).
   * @returns the number of planes each cutting section may contain.
   */
  getCuttingSectionCapacity() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingPlanesPerSection : 0;
  }
  /**
   * Gets the total number of cutting sections supported by the system.
   * @returns the number of cutting sections supported by the system.
   */
  getCuttingSectionCount() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingSections : 0;
  }
  /**
   * Gets the cutting section containing the cutting plane with the given node ID. If the supplied node ID is not contained by any cutting section null will be returned.
   * @param nodeId a node ID for cutting plane stand-in geometry.
   * @returns the ICuttingSection that contains the plane with the given node id or null if none contain it.
   */
  getCuttingSectionFromNodeId(t) {
    if (t !== null) {
      for (const e of this._cuttingSections)
        if (e._getInstanceNodeIds().indexOf(t) >= 0) return e;
    }
    return null;
  }
  /**
   * Gets all nodes that have capping drawn for them.
   * @returns an array of node IDs that have capping drawn for them
   */
  async getNodesWithCapping() {
    const t = await this._engine.getCappedInstances(), e = [];
    for (let i = 0; i < t.length - 1; i += 2) {
      const n = this._model._getNodeFromInstanceInc(
        !1,
        t[i],
        t[i + 1],
        !1
      );
      e.push(n);
    }
    return e;
  }
  /**
   * Sets whether stand-in geometry for cutting sections should be pickable.
   * If this option is set to false, picking rays will pass though stand-in geometry for cutting planes.
   * The default value is not pickable.
   * @param pickable boolean value indicating whether stand-in geometry should be pickable in the scene.
   */
  setStandinGeometryPickable(t) {
    this._standinGeometryPickable = t;
    const e = this._gatherStandinGeometryIds();
    return this._model.setInstanceModifier(tn.DoNotSelect, e, !t), Promise.resolve();
  }
  /**
   * Gets whether stand-in geometry for cutting sections is pickable.
   * @returns boolean value indicating whether stand-in geometry for cutting sections is pickable.
   */
  getStandinGeometryPickable() {
    return this._standinGeometryPickable;
  }
  /** @hidden */
  _setStandinGeometryVisible(t) {
    const e = this._gatherStandinGeometryIds(), i = this._model._gatherInstanceIncsFromNodeIds(e);
    this._engine.pauseAllRendering(() => {
      this._engine.setPartVisibility(i, t, !1);
    });
  }
  /**
   * Sets the delay used by delayCapping() in milliseconds.
   * @param delayInMilliseconds The delay amount.
   */
  setCappingDelay(t) {
    this._engine.setCappingDelay(t);
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this._engine.delayCapping();
  }
  /**
   * Enables or disables activation of "cappingIdle" callback event.
   * @param enable Enables or disables activation of "cappingIdle" callback event.
   * @returns A promise returning whether or not capping generation was idle when this call resolves.
   */
  enableCappingIdleCallback(t) {
    return t !== this._cappingIdleCallbackEnabled && (this._cappingIdleCallbackEnabled = t, this._conservativeIsCappingIdle = !1, !t && this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(
      new oe("Capping idle callback became disabled.")
    ), this._cappingIdlePromise = null)), this._engine.enableCappingIdleCallback(t);
  }
  async waitForCappingIdle() {
    if (!this._cappingIdleCallbackEnabled)
      throw console.assert(this._cappingIdlePromise === null), new oe("Capping idle callback is not enabled.");
    if (!this._conservativeIsCappingIdle)
      return this._cappingIdlePromise === null && (this._cappingIdlePromise = vi()), this._cappingIdlePromise;
  }
  /**
   * Sets whether capping geometry will show.
   * The default value is true.
   * @param cappingGeometryVisibility
   */
  setCappingGeometryVisibility(t) {
    for (const e of this._viewer.views)
      this._engine.setCappingGeometryVisibility(e.id, t);
    return Promise.resolve();
  }
  /**
   * Gets whether capping geometry will show
   * @returns boolean value indicating whether capping geometry will show
   */
  getCappingGeometryVisibility() {
    return this._engine.getCappingGeometryVisibility();
  }
  /**
   * @returns the number of active cutting sections.
   */
  getActiveCuttingSectionCount() {
    let t = 0;
    if (this._cuttingLimits)
      for (let e = 0; e < this._cuttingLimits.maxCuttingSections; e++) {
        const i = this.getCuttingSection(e);
        i != null && i.isActive() && (t += i.getCount());
      }
    return t;
  }
  /** @hidden */
  _init() {
    if (!this._isInit) {
      this._cuttingLimits = this._engine.getCuttingSectionLimits();
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = new gx(this._viewer, this._model, this, this._engine);
        this._cuttingSections.push(e);
      }
      this._isInit = !0;
    }
  }
  /** @hidden */
  _isInitialized() {
    return this._isInit;
  }
  /**
   * Updates all cutting plane geometry.
   */
  refreshPlaneGeometry() {
    const t = [];
    for (const e of this._cuttingSections)
      for (let i = 0; i < e.getCount(); i++) {
        const n = e.getPlane(i);
        n !== null && t.push(e.updatePlane(i, n, new wt(), !1, !1));
      }
    return We(t);
  }
  /**
   * @returns true if there is an active cutting section.
   */
  hasActiveCuttingSection() {
    if (this._cuttingLimits)
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = this.getCuttingSection(t);
        if (e !== null && e.isActive()) return !0;
      }
    return !1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingSections.length; e++)
      t[e] = this._cuttingSections[e].toJson();
    return {
      cuttingSections: t,
      cappingGeometryVisibility: this.getCappingGeometryVisibility(),
      cappingFaceColor: this.getCappingFaceColor(),
      cappingLineColor: this.getCappingLineColor(),
      pickable: this.getStandinGeometryPickable()
    };
  }
  /**
   * Removes any cutting planes in the scene, and restores cutting planes from a json object.
   * @param json
   */
  async fromJson(t) {
    const e = $c(t), i = [], n = e.cuttingSections;
    for (let r = 0; r < n.length; r++) {
      const o = n[r], l = this._cuttingSections[r];
      i.push(l.fromJson(o));
    }
    this.setStandinGeometryPickable(e.pickable), i.push(this.setCappingGeometryVisibility(e.cappingGeometryVisibility)), i.push(this.setCappingFaceColor(yt.fromJson(e.cappingFaceColor))), i.push(this.setCappingLineColor(yt.fromJson(e.cappingLineColor))), await Promise.all(i), this._callbackManager.trigger("cuttingSectionsLoaded");
  }
  _gatherStandinGeometryIds() {
    const t = [];
    for (const e of this._cuttingSections) {
      const i = e._getInstanceNodeIds();
      for (const n of i)
        t.push(n);
    }
    return t;
  }
}
class mx {
  /** @hidden */
  constructor(t, e, i) {
    this._explodeActive = !1, this._explodeMagnitude = 0, this._model = t, this._engine = e, i.bind({
      _modelSwitched: async () => {
        this.stop();
      }
    });
  }
  /**
   * Starts an explode operation. This will cancel any currently active explode operation.
   * @param nodeIds an array of NodeId for the parts that should be exploded. If this parameter is omitted or is an empty array, the entire model will be considered for explosion.
   * @param explosionVector the vector to use for the center of the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  start(t, e) {
    return this.getActive() ? (this.stop(), this._doExplode(t, e)) : this._doExplode(t, e);
  }
  /**
   * Sets the explosion magnitude if there is an active explosion operation.
   * A value of 1.0 indicates that the distance between a part's exploded center, and exploded center will be double.
   * @param magnitude the magnitude for the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  async setMagnitude(t) {
    if (t > 0 && !this._explodeActive ? await this.start() : t === 0 && this._explodeActive && this.stop(), this._explodeActive)
      return this._explodeMagnitude = t, this._engine.setExplodeMagnitude(t);
  }
  /**
   * Terminates any active explode operation.
   * @returns a promise that resolves when this operation is complete.
   */
  stop() {
    return this._engine.stopExplode(), this._explodeMagnitude = 0, this._explodeActive = !1, this._engine.setExplodeMagnitude(0), Promise.resolve();
  }
  /**
   * Gets the current explode magnitude. This will always return 0 when there is no active explode operation.
   * @returns the current explode magnitude.
   */
  getMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Indicates whether there is a currently active explode operation.
   * @returns boolean value indicating if there is an active explode operation.
   */
  getActive() {
    return this._explodeActive;
  }
  async _doExplode(t, e) {
    this._explodeActive = !0;
    let i;
    if (t !== void 0 && t.length > 0 ? i = this._model._gatherInstanceIncsFromNodeIds(t) : i = [], e)
      this._engine.startExplode(i, e);
    else {
      const n = await this._model.getModelBounding(!0, !1);
      this._engine.startExplode(i, n.center());
    }
  }
}
class By {
  /**
   * @param type The light's type. See [[type]].
   * @param space The space in which a light is defined. See [[space]]
   * @param position The light's position. See [[position]].
   * @param color The light's color. See [[color]].
   */
  constructor(t, e, i, n) {
    this.type = t, this.space = e, this.position = i, this.color = n;
  }
}
class _x extends By {
  constructor(t, e, i, n) {
    super(t, e, i, n);
  }
}
class yx extends By {
  /**
   * @param type The light's type. See [[type]].
   * @param space The space in which a light is defined. See [[space]]
   * @param position The light's position. See [[position]].
   * @param color The light's color. See [[color]].
   * @param power The light's power. See [[power]].
   * @param decay The light's power. See [[decay]].
   */
  constructor(t, e, i, n, r, o) {
    super(t, e, i, n), this.power = r, this.decay = o;
  }
}
class wx extends bd {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllLines();
      }
    });
  }
  /**
   * Adds a new Line to the Line Manager
   * @param lineItem LineMarkup Object that will be added
   */
  async addLine(t) {
    this._markupArray.push(t), await t.updateLine(), this._callbackManager.trigger("lineCreated", t);
  }
  /**
   * Removes an existing line item.
   * @param lineItem the line item to remove.
   */
  async removeLine(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      this._markupArray[e].getId() === t.getId() && (await t.removeLine(), this._markupArray.splice(e, 1), this._callbackManager.trigger("lineDeleted", t));
  }
  /**
   * Removes all line items.
   */
  removeAllLines() {
    const t = [];
    for (let e = this._markupArray.length - 1; e >= 0; e--) {
      const i = this._markupArray[e];
      t.push(
        i.removeLine().then(() => {
          this._callbackManager.trigger("lineDeleted", i);
        })
      ), this._markupArray.splice(e, 1);
    }
    return We(t);
  }
  /**
   * Return an array of line items.
   * @returns array of all line items.
   */
  getAllLines() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added line item.
   */
  async removeLastLine() {
    this._markupArray.length > 0 && await this.removeLine(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Gets a line markup item associated with a node id.
   * @param id
   */
  getLineByNodeId(t) {
    for (const e of this._markupArray) {
      const i = e.getNodeId();
      if (i !== null && i === t)
        return e;
    }
    return null;
  }
  /**
   * @returns JSON Array with line markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      t.push(e.toJson());
    return t;
  }
  async _handleLoadLine(t) {
    return t instanceof Ta ? (await this.addLine(t), this._callbackManager.trigger("lineLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param lineData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const n = sg(i.className);
      if (n) {
        const r = n(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadLine(o))
        ) : e.push(this._handleLoadLine(r));
      }
    }
    return Promise.all(e);
  }
}
class vx extends bd {
  constructor(t, e, i, n, r, o) {
    super(), this._markupViews = /* @__PURE__ */ new Map(), this._defaultViewCounter = 1, this._markupItemManager = e, this._callbackManager = i, this._explodeManager = n, this._cuttingManager = r, this._viewer = t, this._sheetManager = o, this._initEvents();
  }
  _initEvents() {
    this._callbackManager.bind({
      modelSwitchStart: () => {
        this._markupItemManager.shutdown();
      }
    });
  }
  getView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? e : null;
  }
  getViewKeys() {
    const t = [];
    return this._markupViews.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  async loadData(t) {
    const e = [];
    for (const i of t) {
      const n = oh._fromJson(i, this._viewer).then((r) => {
        if (!r.itemResults.every(Boolean))
          return !1;
        const o = r.markupView, l = o.getUniqueId();
        return this._markupViews.has(l) ? !1 : (this._markupViews.set(l, o), this._callbackManager.trigger("viewLoaded", o), !0);
      });
      e.push(n);
    }
    return Promise.all(e);
  }
  exportMarkup() {
    const t = [];
    return this._markupViews.forEach((e) => {
      t.push(e.toJson());
    }), t;
  }
  createView(t = this._createDefaultViewName(), e, i = !0, n = null, r = null, o = null, l = null) {
    const h = Ms(), u = new oh(
      h,
      t,
      e.getCamera(),
      this._explodeManager.getMagnitude(),
      this._cuttingManager.toJson(),
      n
    );
    return this._markupViews.set(h, u), u.setLineVisibility(e.getLineVisibility()), u.setFaceVisibility(e.getFaceVisibility()), r !== null && (u.setDefaultVisibility(r.defaultVisibility), u.setVisibilityExceptions(r.visibilityExceptions)), o !== null && u.setColorMap(o), l !== null && u.setSnapshotImage(l), this._markupItemManager.setActiveView(e, u), i && this._callbackManager.trigger("viewCreated", u), u;
  }
  async _activateSheet(t) {
    if (t !== null)
      return this._sheetManager.setActiveSheetId(t, !0, !1);
  }
  async _activateViewImpl(t, e, i) {
    await this._activateSheet(t.getSheetId()), e.setFaceVisibility(t.getFaceVisibility()), e.setLineVisibility(t.getLineVisibility()), i > 0 ? (await this._markupItemManager.setActiveView(e, null), await e._setCameraPromise(t.getCamera(), i)) : e.setCamera(t.getCamera()), await this._setActiveView(t, e);
  }
  _activateView(t, e, i) {
    const n = this._markupViews.get(t);
    if (n !== void 0) {
      const r = this._activateViewImpl(n, e, i);
      return To(!0, r);
    } else
      return To(!1, Promise.resolve());
  }
  async activateView(t, e, i = cs) {
    return this._activateView(t, e, i);
  }
  /** This is a helper for `activateView`. */
  async _setActiveView(t, e) {
    if (this._viewer.model.isDrawing())
      if (t.getSheetId() === null)
        await this._viewer.sheetManager.deactivateSheets(!0, !0);
      else {
        const i = t.getVisibilityExceptions(), n = t.getDefaultVisibility();
        if (i.size > 0 && n) {
          const r = [];
          i.forEach((o) => {
            r.push(o);
          }), await this._viewer.model.setNodesVisibility(r, !1);
        }
      }
    else {
      const i = t.getDefaultVisibility(), n = t.getVisibilityExceptions();
      await this._viewer.model.setBodyNodesVisibility(
        this._viewer.model.getAbsoluteRootNode(),
        (r) => n.has(r) ? !i : i
      );
    }
    await this._markupItemManager.setActiveView(e, t), await this._cuttingManager.fromJson(t.getCuttingPlaneData()), await this._viewer.model.setNodesColors(t.getColorMap()), await this._explodeManager.setMagnitude(t.getExplodeMagnitude());
  }
  deleteView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? (this._callbackManager.trigger("viewDeleted", e), this._markupItemManager.markupViewDeleted(e), this._markupViews.delete(t), !0) : !1;
  }
  _createDefaultViewName() {
    return `View ${this._defaultViewCounter++}`;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.exportMarkup();
  }
}
class bx {
  /** @hidden */
  constructor(t, e, i, n, r, o) {
    this._markupTypeMap = /* @__PURE__ */ new Map(), this._callbackManager = i, this._viewer = o, this._sheetManager = n, this._sheetManager.setMarkupManager(this), this._noteTextManager = r, this._renderer = new K_(), this._itemManager = new j_(this._callbackManager, this._renderer), this._viewManager = new vx(
      this._viewer,
      this._itemManager,
      this._callbackManager,
      o.explodeManager,
      o.cuttingManager,
      this._sheetManager
    ), this._measurementManager = t, this._lineManager = e;
  }
  /**
   * Registers a MarkupTypeManager to add markup to exported data.
   * @param markupTypeManager
   */
  registerMarkupTypeManager(t, e) {
    this._markupTypeMap.set(t, e);
  }
  /**
   * Registers a factory to load custom markups in markup views when using loadMarkupData.
   * @param className identifier of the markup item type, this is what's returned by getClassName function of MarkupItem.
   * @param factory a function to create the markup object from a json object outputed by toJson function of MarkupItem.
   */
  registerMarkupFactory(t, e) {
    us(t, e);
  }
  /**
   * Creates a new markup view based on a given view, line, and face visibility values.
   * @param view the reference view for values used to create the markup view (camera, line and face visibility).
   * @param name optional name for the markup view. If omitted or null, the system will generate a default name
   * @param triggerEvent optional parameter indicating whether a [[CallbackMap.viewCreated]] event should be triggered. This parameter defaults to true
   * @param visibilityState optional parameter
   * @returns Unique identifier for the new view
   */
  createMarkupView(t, e, i = !0, n = null, r = null, o = null) {
    const l = this._viewer.sheetManager.getActiveSheetId();
    return this._viewManager.createView(
      e,
      t,
      i,
      l,
      n,
      r,
      o
    ).getUniqueId();
  }
  /**
   * Gets a [[MarkupView]] object from the viewer.
   * @param uniqueId the handle for the view object to retreive
   * @returns [[MarkupView]] object for the corresponding ID or null if no view was found
   */
  getMarkupView(t) {
    return this._viewManager.getView(t);
  }
  /**
   * @returns an array of string keys for all markup views
   */
  getMarkupViewKeys() {
    return this._viewManager.getViewKeys();
  }
  /**
   * Activates a [[MarkupView]] in the given view.
   * @param uniqueId the handle for the [[MarkupView]] object to activate
   * @param view the view to activate the markup view
   * @param duration the time in milliseconds for the transition to this view
   */
  async activateMarkupViewWithPromise(t, e, i = cs) {
    return this._viewManager.activateView(t, e, i);
  }
  /**
   * Returns the currently active [[MarkupView]].
   * @returns [[MarkupView]] object for the currently active view, or null if no view is active
   */
  getActiveMarkupView(t) {
    return this._itemManager.getActiveView(t);
  }
  /**
   * Deletes a [[MarkupView]] object.
   * @param uniqueId the handle for the view object to delete
   * @returns true if a [[MarkupView]] with the supplied uniqueId was deleted, false otherwise
   */
  deleteMarkupView(t) {
    return this._viewManager.deleteView(t);
  }
  /**
   * Registers a [[MarkupItem]] to be rendered with the 3D view in the given view.
   * @param markupItem the item to register
   * @param view the view where display markup
   * @returns unique handle to this [[MarkupItem]].
   */
  registerMarkup(t, e) {
    const i = this._itemManager.registerMarkupItem(t, e);
    return this.updateLater(e), i;
  }
  /**
   * Unregisters a [[MarkupItem]]. It will no longer be rendered with the 3D view.
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   * @param view the view the markup belongs to
   */
  unregisterMarkup(t, e) {
    this._itemManager.unregisterMarkupItem(t, e), this.updateLater(e);
  }
  /**
   * Add an HTML element to the markup element layer of a given view. The element will have its ID set to a system generated unique identifier.
   * @param element the HTML Element to add
   * @param view the view where to add the HTML element
   * @returns system generated unique identifier which is the id of the passed in object
   */
  addMarkupElement(t, e) {
    const i = Ms();
    return t.id = i, e.domElements.getRedlineElement().appendChild(t), i;
  }
  /**
   * Removes a markup element from the markup element layer of the given view
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   * @param view the view where to remove the HTML element
   */
  removeMarkupElement(t, e) {
    const i = e.domElements.getRedlineElement();
    for (let n = 0; n < i.children.length; n++) {
      const r = i.children.item(n);
      r !== null && r.id === t && i.removeChild(r);
    }
  }
  /**
   * Redraws the markup without rendering the scene. Useful when markup is added or removed but the scene is not affected.
   * @param view the view where markups need to be redrawn
   */
  refreshMarkup(t) {
    this.updateLater(t);
  }
  /**
   * Redraws all views where the given markup view is active. Scene is not rendered.
   * Useful when something in a markup view has been updated and views need to reflect the changes.
   * @param markupView the markup view that has changed.
   */
  refreshMarkupView(t) {
    const e = this._itemManager.getViews(t);
    for (const i of e)
      this.refreshMarkup(i);
  }
  updateLater(t) {
    this._itemManager.updateLater(t);
  }
  /**
   * Picks a [[MarkupItem]]. Tests scene based and markup attached to the active view (if any)
   * @param point position to pick against
   * @param view view where the test is triggered
   * @returns [[MarkupItem]] that was selected or null if none was picked
   */
  pickMarkupItem(t, e) {
    return this._itemManager.pick(t, e);
  }
  /**
   * Gets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @returns Current tolerance
   */
  getPickTolerance() {
    return this._itemManager.getPickTolerance();
  }
  /**
   * Sets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @param tolerance The new tolerance
   */
  setPickTolerance(t) {
    return this._itemManager.setPickTolerance(t);
  }
  /**
   * Selects a [[MarkupItem]]. Pass null to clear the selection.
   * Will refresh all views with markups.
   * @param markupItem The [[MarkupItem]] to select.
   * @param view The view the selection come from.
   */
  selectMarkup(t, e) {
    this._itemManager.select(t, e);
  }
  /**
   * Returns the currently selected [[MarkupItem]], or null if nothing is currently selected
   * @returns selected [[MarkupItem]]
   */
  getSelectedMarkup() {
    return this._itemManager.getSelected();
  }
  /**
   * export markup from the viewer
   * @returns Serialized markup objects
   */
  exportMarkup() {
    const t = {
      views: this._viewManager.exportMarkup(),
      notes: this._noteTextManager.exportMarkup(),
      measurement: this._measurementManager.exportMarkup(),
      lines: this._lineManager.exportMarkup()
    };
    return this._markupTypeMap.forEach((e, i) => {
      t[i] = e.exportMarkup();
    }), t;
  }
  /**
   * Loads markup data into the viewer.
   * @param data markup data to be loaded into the viewer
   */
  async loadMarkupData(t) {
    return typeof t == "string" && (t = JSON.parse(t)), this._loadMarkupData(t);
  }
  async _loadMarkupData(t) {
    const e = [];
    if (t.hasOwnProperty("views")) {
      const i = this._viewManager.loadData(t.views).then((n) => n.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("notes")) {
      const i = this._noteTextManager.loadData(t.notes).then((n) => n.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("measurement")) {
      const i = this._measurementManager.loadData(t.measurement).then((n) => n.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("lines")) {
      const i = this._lineManager.loadData(t.lines).then((n) => n.every(Boolean));
      e.push(i);
    }
    return this._markupTypeMap.forEach((i, n) => {
      if (t.hasOwnProperty(n)) {
        const r = i.loadData(t[n]).then((o) => o.every(Boolean));
        e.push(r);
      }
    }), Promise.all(e).then((i) => i.every(Boolean));
  }
  /**
   * Returns a the interface to the [[MarkupRenderer]].
   * @returns [[MarkupRenderer]] interface
   */
  getRenderer() {
    return this._renderer;
  }
  /** @hidden */
  _shutdown() {
    this._itemManager.shutdown(), this._renderer._clear();
  }
  /** @hidden */
  _update() {
    this._itemManager.update();
  }
  /** @hidden */
  async _setActiveMarkupView(t, e) {
    return this._itemManager.setActiveView(t, e);
  }
  /** @hidden */
  _getItemManager() {
    return this._itemManager;
  }
  /** @hidden */
  _viewDeleted(t) {
    this._itemManager.viewDeleted(t);
  }
}
class xx extends bd {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._color = new yt(0, 0, 0), this._edgeColor = new yt(0, 0, 0), this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllMeasurements();
      }
    });
  }
  /**
   * Adds a new Measurement to the Measure Manager
   * @param measurementItem MeasureMarkup Object that will be added
   */
  addMeasurement(t) {
    this._markupArray.push(t);
    const e = this._viewer.markupManager.registerMarkup(t, this._viewer.view);
    return t._setId(e), e;
  }
  /**
   * Triggers a measurementCreated callback
   * @param measureItem
   * @param triggerEvent boolean trigger a callback event
   */
  finalizeMeasurement(t) {
    this._callbackManager.trigger("measurementCreated", t);
  }
  /**
   * Removes an existing measurement item.
   * @param measurementItem the measurement item to remove.
   */
  removeMeasurement(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      if (this._markupArray[e]._getId() === t._getId()) {
        this._markupArray.splice(e, 1), this._viewer.markupManager.unregisterMarkup(t._getId(), this._viewer.view), this._callbackManager.trigger("measurementDeleted", t);
        break;
      }
  }
  /**
   * Removes all measurement items.
   */
  removeAllMeasurements() {
    for (let t = this._markupArray.length - 1; t >= 0; t--) {
      const e = this._markupArray[t];
      this._viewer.markupManager.unregisterMarkup(e._getId(), this._viewer.view), this._markupArray.splice(t, 1), this._callbackManager.trigger("measurementDeleted", e);
    }
  }
  /**
   * Return an array of measurement items.
   * @returns array of all measurement items.
   */
  getAllMeasurements() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added measurement item.
   */
  removeLastMeasurement() {
    this._markupArray.length > 0 && this.removeMeasurement(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Sets the current measurement color.
   * @param color the measurement color to set.
   */
  setMeasurementColor(t) {
    this._color.assign(t);
  }
  /**
   * Gets the current measurement color.
   * @returns color current measurement color.
   */
  getMeasurementColor() {
    return this._color.copy();
  }
  /**
   * Sets the current measurement edge color.
   * @param color the measurement edge color to set.
   */
  setMeasurementEdgeColor(t) {
    this._edgeColor.assign(t);
  }
  /**
   * Gets the current measurement edge color.
   * @returns color current measurement edge color.
   */
  getMeasurementEdgeColor() {
    return this._edgeColor.copy();
  }
  /**
   * @returns JSON Array with measurement markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      e != null && e.isMarkupValid() && t.push(e.toJson());
    return t;
  }
  _handleLoadMeasurement(t) {
    return t instanceof Rn ? (this.addMeasurement(t), this._callbackManager.trigger("measurementLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param measurementData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const n = sg(i.className);
      if (n) {
        const r = n(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadMeasurement(o))
        ) : e.push(Promise.resolve(this._handleLoadMeasurement(r)));
      }
    }
    return Promise.all(e);
  }
}
const zc = class zc {
  /** @hidden */
  constructor(t, e) {
    this._position = new Go(0, Fe.Pixels, 0, Fe.Pixels), this._viewportSize = new Go(
      0.2,
      Fe.MinimumProportionOfCanvas,
      0.2,
      Fe.MinimumProportionOfCanvas
    ), this._anchor = qe.UpperRightCorner, this._dimension = 3, this._fieldSize = 8, this._instanceKeys = [], this._enabled = !1, this._textImageId = null, this._selectionFaceColor = new yt(76, 186, 240), this._outlineColor = new yt(17, 94, 133), this._lastSelectedNodes = [], this._nodeIds = [], this._adjacentFaces = [], this._preserveModelUp = !0, this._cameraRotation = 0, this._lastOrientation = null, this._lastCamera = null, this._lastFaceIndex = null, this._textWidths = [], this._sceneReady = vi(), this._assemblyTreeReady = vi(), this._navcubeReadyToInit = [this._sceneReady, this._assemblyTreeReady], this._texturesReady = !1, this._geometryCreated = !1, this._viewer = t, this._view = e, this._fontSize = 25, this._fontInfo = `${this._fontSize}px Arial`, this._textureSize = 512, this._viewer.getSceneReady() && this._sceneReady.resolve(), this._viewer.getModelReady() && this._assemblyTreeReady.resolve(), this._viewer.setCallbacks({
      sceneReady: () => {
        this._sceneReady.resolve();
      },
      _assemblyTreeReady: async () => {
        this._assemblyTreeReady.resolve();
      },
      _firstAttachment: async () => {
        this._onCameraUpdate(), this._updateVisibility();
      },
      camera: (i, n) => {
        var r;
        n.id === ((r = this._view) == null ? void 0 : r.id) && this._onCameraUpdate();
      },
      overlayViewportSet: (i, n) => {
        var r;
        n.id === ((r = this._view) == null ? void 0 : r.id) && i === be.NavCube && this._onViewportSet();
      },
      transitionEnd: (i) => {
        var n;
        i.id === ((n = this._view) == null ? void 0 : n.id) && this._onCameraUpdate();
      },
      viewAxes: () => {
        this._updateOrientationMatrices();
      },
      _resetOpacity: () => {
        this._viewer.model.setNodesOpacity(this._nodeIds.slice(1), 0);
      },
      viewOrientation: (i, n) => {
        var r;
        this._view !== void 0 && n.id === ((r = this._view) == null ? void 0 : r.id) && (this._lastOrientation = i, this._cameraRotation = 0, this._lastCamera = this._view.getCamera());
      },
      _drawContextDestroyed: (i) => {
        this._view !== void 0 && i === this._view.id && delete this._view;
      }
    }), Promise.all(this._navcubeReadyToInit).then(async () => {
      this._createViewport(), this._updateVisibility(), await this._createGeometry(), this._setTextures();
    });
  }
  /**
   * Sets the anchor position for the NavCube.
   * @param anchor the anchor position.
   */
  async setAnchor(t) {
    return this._anchor = t, await this._sceneReady, this._updateViewport();
  }
  /**
   * Gets the anchor position for the NavCube. Default position is in the UpperRightCorner, see [[OverlayAnchor]] for more details.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables the NavCube.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables the NavCube.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Determines if model up or camera up will the preserved when navigating with the NavCube.
   * If model up is preserved, navigation with the NavCube will keep the model upright all the time.
   * If camera up is preserved, navigation with the NavCube will attempt to preserve the current up direction of
   * the camera as much as possible.
   * Defaults to `true`.
   * @param preserve If true, model up is preserved. Otherwise, camera up is preserved.
   */
  setPreserveModelUp(t) {
    this._preserveModelUp = t;
  }
  /**
   * Gets the NavCube preserveModelUp state.
   * @returns true if model up is preserved, false if camera up is preserved.
   */
  getPreserveModelUp() {
    return this._preserveModelUp;
  }
  /**
   * Sets the visibility for the NavCube based on the enabled and textures state.
   */
  _updateVisibility() {
    this._enabled && this._texturesReady ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window
   */
  _hideOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.NavCube, !1);
  }
  /**
   * Shows the overlay window
   */
  _showOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.NavCube, !0);
  }
  /**
   * Gets whether the NavCube is currently enabled.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the associated overlay id.
   */
  getOverlayId() {
    return be.NavCube;
  }
  async _setTextures() {
    if (!this._textImageId || this._nodeIds.length > 0 || this._instanceKeys.length <= 0)
      return;
    const t = this._viewer.model;
    for (const e of this._instanceKeys) {
      const i = t._getNodeFromInstanceInc(!0, Ni.Local, e, !0);
      this._nodeIds.push(i), t._preventNodeDeletion(i);
    }
    t.setNodesOpacity(this._nodeIds.slice(1), 0), await t.setNodesTexture([this._nodeIds[0]], {
      imageId: this._textImageId
    }), this._texturesReady = !0, this._updateVisibility();
  }
  _updateViewport() {
    if (!this._view) return;
    this._view.overlayManager.setViewport(
      be.NavCube,
      this._anchor,
      this._position.x,
      Fe.Pixels,
      this._position.y,
      Fe.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    if (!this._view) return;
    const t = this._view.overlayManager;
    this._updateViewport();
    const e = new Sn();
    e.setPosition(new m(0, 0, 10)), e.setTarget(m.zero()), e.setUp(new m(0, 1, 0)), e.setWidth(this._fieldSize), e.setHeight(this._fieldSize), e.setProjection(ri.Orthographic), t.setCamera(be.NavCube, e);
  }
  _onViewportSet() {
    if (!this._view) return;
    const t = this._view.overlayManager, e = t._getViewportPosition(be.NavCube), i = t._getViewportSize(be.NavCube), n = t.getViewportAnchor(be.NavCube);
    e === null || i === null || n === null || (this._position = e, this._viewportSize = i, this._anchor = n);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const t = this._initializeTextures();
    let e = 0;
    const i = [];
    i.push(this._createCube(e++, this._dimension));
    const n = [];
    n.push(this._makeRotationMatrixX(-0.5 * Math.PI)), n.push(this._makeRotationMatrixX(0.5 * Math.PI)), n.push(this._makeRotationMatrixY(0.5 * Math.PI)), n.push(this._makeRotationMatrixY(-0.5 * Math.PI)), n.push(this._makeRotationMatrixZ(0.5 * Math.PI)), n.push(this._makeRotationMatrixZ(-0.5 * Math.PI));
    const r = this._dimension / 4, o = this._dimension / 2, l = -0.01, h = [], u = new m(0, 0, 0);
    let f = new m(0, 0, 0), g = new m(0, 0, 0);
    for (let I = 0; I < n.length; I++) {
      const C = this._dimension, M = n[I];
      let P = !1;
      I === n.length - 1 && (P = !0, u.z += this._dimension + 0.02), f = new m(
        0.5 * C - r,
        -0.5 * C + r,
        -0.5 * C + l
      ), g = new m(f.x + r, f.y - r, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(-0.5 * C, -0.5 * C + r, -0.5 * C + l), g = new m(f.x + r, f.y - r, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(-0.5 * C, 0.5 * C, -0.5 * C + l), g = new m(f.x + r, f.y - r, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(0.5 * C - r, 0.5 * C, -0.5 * C + l), g = new m(f.x + r, f.y - r, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(-0.5 * C + r, 0.5 * C, -0.5 * C + l), g = new m(f.x + o, f.y - r, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(
        -0.5 * C + r,
        -0.5 * C + r,
        -0.5 * C + l
      ), g = new m(f.x + o, f.y - r, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(-0.5 * C, 0.5 * C - r, -0.5 * C + l), g = new m(f.x + r, f.y - o, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(0.5 * C - r, 0.5 * C - r, -0.5 * C + l), g = new m(f.x + r, f.y - o, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      ), f = new m(
        -0.5 * C + r,
        0.5 * C - r,
        -0.5 * C + l
      ), g = new m(f.x + o, f.y - o, f.z), i.push(
        this._createSelectionFace(
          e++,
          f,
          g,
          M,
          P,
          u,
          h
        )
      );
    }
    const y = 9;
    for (let I = 0; I < h.length; I++) {
      const C = Math.floor(I / y), M = [], P = h[I];
      for (let O = 0; O < P.length; O += 2) {
        const B = P[O], j = P[O + 1];
        for (let F = 0; F < h.length; F++) {
          if (Math.floor(F / y) === C)
            continue;
          const J = h[F];
          for (let rt = 0; rt < J.length; rt += 2) {
            const ft = J[rt], H = J[rt + 1];
            this._isSameEdge(B, j, ft, H) && M.push(F);
          }
        }
      }
      this._adjacentFaces.push(M);
    }
    const _ = await Promise.all(i);
    this._updateOrientationMatrices(), this._onCameraUpdate();
    const x = [];
    for (const I of _)
      x.push(Ni.Local, I);
    return this._getScEngine().setPartVisibility(x, !0, !0), this._geometryCreated = !0, t;
  }
  _createTexture(t, e) {
    const n = t.getImageData(0, 0, e, e).data, r = new ArrayBuffer(e * e * 3), o = new Uint8Array(r);
    let l = 0;
    for (let u = 0; u < n.length; u += 4)
      o[l] = n[u], o[l + 1] = n[u], o[l + 2] = n[u], l += 3;
    return this._viewer.model.createImage({
      format: ys.Rgb24,
      data: o,
      width: this._textureSize,
      height: this._textureSize
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the NavCube overlay.
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the NavCube overlay
   */
  insideOverlay(t) {
    if (!this._view) return !1;
    const e = this._view.overlayManager._toPixelPoint(this._viewportSize), i = this._getOverlayOffset();
    return t.x >= i.x && t.y >= i.y && t.x <= i.x + e.x && t.y <= i.y + e.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    if (!this._view) return X.zero();
    const t = this._view.overlayManager._toPixelPoint(this._viewportSize);
    return this._view.overlayManager._getOverlayOffset(this._anchor, t);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._view ? this._view.overlayManager._toPixelPoint(this._viewportSize) : X.zero();
  }
  /** @hidden */
  _onNoSelection() {
    this._enabled && this._lastSelectedNodes.length > 0 && (this._viewer.model.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0);
  }
  /**
   * Called when the NavCube is clicked. Realigns the view to the side/edge/corner
   * selected by `selection`, or rotates the view 90 degrees if the selection matches
   * the current view orientation, or does nothing if no side is selected.
   * @param selection
   */
  async onClickSelection(t) {
    if (console.assert(this._enabled), t === null || !t.isFaceSelection() || t.overlayIndex() !== be.NavCube) {
      this._onNoSelection();
      return;
    }
    const e = this._getFaceIndexFromNodeId(t.getNodeId());
    e < this._nodeIds.length && e > 0 && await this._setViewOrientation(e);
  }
  /**
   * Called when the NavCube is "moused over". Displays face/edge/corner that will be selected.
   * @param selection
   */
  onMoveSelection(t) {
    if (console.assert(this._enabled), t === null || !t.isFaceSelection() || t.overlayIndex() !== be.NavCube) {
      this._onNoSelection();
      return;
    }
    const e = t.getNodeId(), i = this._getFaceIndexFromNodeId(e) - 1;
    i >= 0 && e !== this._nodeIds[0] && this._viewer.pauseRendering(() => {
      const n = this._viewer.model;
      n.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0, this._lastSelectedNodes.push(e), console.assert(i < this._adjacentFaces.length);
      const r = this._adjacentFaces[i];
      for (const o of r) {
        const l = o + 1, h = this._getNodeIdFromFaceIndex(l);
        this._lastSelectedNodes.push(h);
      }
      n.setNodesOpacity(this._lastSelectedNodes, 1);
    });
  }
  /**
   * Returns the corresponding view orientation for each node index.
   * If the node indexes change in the future, this will need to be updated.
   */
  _getViewOrientationFromFaceIndex(t) {
    let e = Ct.Front;
    switch (t) {
      // Left
      case 1:
        e = Ct.LeftBottomBack;
        break;
      case 2:
        e = Ct.LeftBottomFront;
        break;
      case 3:
        e = Ct.LeftTopFront;
        break;
      case 4:
        e = Ct.LeftTopBack;
        break;
      case 5:
        e = Ct.LeftTop;
        break;
      case 6:
        e = Ct.LeftBottom;
        break;
      case 7:
        e = Ct.LeftFront;
        break;
      case 8:
        e = Ct.LeftBack;
        break;
      case 9:
        e = Ct.Left;
        break;
      // Right
      case 10:
        e = Ct.RightTopBack;
        break;
      case 11:
        e = Ct.RightTopFront;
        break;
      case 12:
        e = Ct.RightBottomFront;
        break;
      case 13:
        e = Ct.RightBottomBack;
        break;
      case 14:
        e = Ct.RightBottom;
        break;
      case 15:
        e = Ct.RightTop;
        break;
      case 16:
        e = Ct.RightFront;
        break;
      case 17:
        e = Ct.RightBack;
        break;
      case 18:
        e = Ct.Right;
        break;
      // Back
      case 19:
        e = Ct.BackTopRight;
        break;
      case 20:
        e = Ct.BackBottomRight;
        break;
      case 21:
        e = Ct.BackBottomLeft;
        break;
      case 22:
        e = Ct.BackTopLeft;
        break;
      case 23:
        e = Ct.BackLeft;
        break;
      case 24:
        e = Ct.BackRight;
        break;
      case 25:
        e = Ct.BackBottom;
        break;
      case 26:
        e = Ct.BackTop;
        break;
      case 27:
        e = Ct.Back;
        break;
      // Front
      case 28:
        e = Ct.FrontBottomRight;
        break;
      case 29:
        e = Ct.FrontTopRight;
        break;
      case 30:
        e = Ct.FrontTopLeft;
        break;
      case 31:
        e = Ct.FrontBottomLeft;
        break;
      case 32:
        e = Ct.FrontLeft;
        break;
      case 33:
        e = Ct.FrontRight;
        break;
      case 34:
        e = Ct.FrontTop;
        break;
      case 35:
        e = Ct.FrontBottom;
        break;
      case 36:
        e = Ct.Front;
        break;
      // Bottom
      case 37:
        e = Ct.BottomRightFront;
        break;
      case 38:
        e = Ct.BottomLeftFront;
        break;
      case 39:
        e = Ct.BottomLeftBack;
        break;
      case 40:
        e = Ct.BottomRightBack;
        break;
      case 41:
        e = Ct.BottomBack;
        break;
      case 42:
        e = Ct.BottomFront;
        break;
      case 43:
        e = Ct.BottomLeft;
        break;
      case 44:
        e = Ct.BottomRight;
        break;
      case 45:
        e = Ct.Bottom;
        break;
      // Top
      case 46:
        e = Ct.TopLeftBack;
        break;
      case 47:
        e = Ct.TopRightBack;
        break;
      case 48:
        e = Ct.TopRightFront;
        break;
      case 49:
        e = Ct.TopLeftFront;
        break;
      case 50:
        e = Ct.TopFront;
        break;
      case 51:
        e = Ct.TopBack;
        break;
      case 52:
        e = Ct.TopRight;
        break;
      case 53:
        e = Ct.TopLeft;
        break;
      case 54:
        e = Ct.Top;
        break;
      default:
        e = Ct.Front;
    }
    return e;
  }
  async _setViewOrientation(t) {
    const e = this._view;
    if (e === void 0)
      return;
    const i = this._getViewOrientationFromFaceIndex(t), n = await e.getViewOrientationCamera(
      i,
      void 0,
      this._preserveModelUp
    );
    let r = !1;
    console.assert(t - 1 >= 0), console.assert(t - 1 < this._adjacentFaces.length);
    const o = this._adjacentFaces[t - 1];
    for (const f of o)
      if (f + 1 === this._lastFaceIndex) {
        r = !0;
        break;
      }
    this._lastFaceIndex = t;
    const l = this._lastCamera !== null && this._lastCamera.equals(e.getCamera());
    if ((this._lastOrientation === i || r) && l ? this._cameraRotation = this._preserveModelUp ? (this._cameraRotation + 90) % 360 : 90 : this._cameraRotation = 0, this._lastOrientation = i, this._cameraRotation > 0) {
      const f = m.subtract(n.getPosition(), n.getTarget()).normalize(), g = wt.createFromOffAxisRotation(f, this._cameraRotation), y = n.getUp();
      g.transform(y, y), n.setUp(y);
    }
    await e.fitWorld(cs, n);
    const u = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(u).length === 0)
      return this._getScEngine().markCameraAsEmpty(e.id);
    this._lastCamera = e.getCamera();
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(t, e) {
    var h;
    const i = await this._viewer.model.createMesh(t), n = new tr(i);
    if (n.setCreationFlags(
      ee.DoNotCut | ee.DoNotExplode | ee.ExcludeBounding | ee.DoNotLight | ee.Invisible
    ), !this._view)
      throw Error("Impossible to create a navcube without an associated view");
    n.overlayId = {
      viewKey: (h = this._view) == null ? void 0 : h.id,
      overayIndex: be.NavCube
    };
    const l = (await this._getScEngine().createMeshInstance(n))[1];
    return this._instanceKeys[e] = l, l;
  }
  _createCube(t, e) {
    const i = [], n = [], r = [], o = [];
    let l = this._textWidths[0];
    for (const O of this._textWidths)
      O > l && (l = O);
    l += 10, i.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), n.push(new m(0, 1, 0)), n.push(new m(0, 1, 0)), n.push(new m(0, 1, 0)), n.push(new m(0, 1, 0)), n.push(new m(0, 1, 0)), n.push(new m(0, 1, 0));
    const h = 60;
    let u = 22 / this._textureSize, f = (22 + h) / this._textureSize;
    u = 1 - u, f = 1 - f;
    let g = (l - this._textWidths[0]) / 2, y = -(g / this._textureSize), _ = (this._textWidths[0] + g) / this._textureSize;
    r.push(new X(y, u)), r.push(new X(_, f)), r.push(new X(_, u)), r.push(new X(y, f)), r.push(new X(_, f)), r.push(new X(y, u)), o.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, 0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, 0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, 0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), n.push(new m(0, -1, 0)), n.push(new m(0, -1, 0)), n.push(new m(0, -1, 0)), n.push(new m(0, -1, 0)), n.push(new m(0, -1, 0)), n.push(new m(0, -1, 0)), u -= h / this._textureSize, f -= h / this._textureSize, g = (l - this._textWidths[1]) / 2, y = -(g / this._textureSize), _ = (this._textWidths[1] + g) / this._textureSize, r.push(new X(y, u)), r.push(new X(y, f)), r.push(new X(_, u)), r.push(new X(_, u)), r.push(new X(y, f)), r.push(new X(_, f)), o.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, 0.5 * e)), n.push(new m(-1, 0, 0)), n.push(new m(-1, 0, 0)), n.push(new m(-1, 0, 0)), n.push(new m(-1, 0, 0)), n.push(new m(-1, 0, 0)), n.push(new m(-1, 0, 0)), u -= h / this._textureSize, f -= h / this._textureSize, g = (l - this._textWidths[2]) / 2, y = -(g / this._textureSize), _ = (this._textWidths[2] + g) / this._textureSize, r.push(new X(y, u)), r.push(new X(y, f)), r.push(new X(_, f)), r.push(new X(y, u)), r.push(new X(_, f)), r.push(new X(_, u)), o.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), o.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), o.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), o.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), n.push(new m(1, 0, 0)), n.push(new m(1, 0, 0)), n.push(new m(1, 0, 0)), n.push(new m(1, 0, 0)), n.push(new m(1, 0, 0)), n.push(new m(1, 0, 0)), u -= h / this._textureSize, f -= h / this._textureSize, g = (l - this._textWidths[3]) / 2, y = -(g / this._textureSize), _ = (this._textWidths[3] + g) / this._textureSize, r.push(new X(_, u)), r.push(new X(y, f)), r.push(new X(_, f)), r.push(new X(_, u)), r.push(new X(y, u)), r.push(new X(y, f)), o.push(new m(0.5 * e, 0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new m(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, -0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, -0.5 * e)), n.push(new m(0, 0, -1)), n.push(new m(0, 0, -1)), n.push(new m(0, 0, -1)), n.push(new m(0, 0, -1)), n.push(new m(0, 0, -1)), n.push(new m(0, 0, -1)), u -= h / this._textureSize, f -= h / this._textureSize, g = (l - this._textWidths[4]) / 2, y = -(g / this._textureSize), _ = (this._textWidths[4] + g) / this._textureSize, r.push(new X(y, u)), r.push(new X(y, f)), r.push(new X(_, f)), r.push(new X(_, u)), r.push(new X(y, u)), r.push(new X(_, f)), i.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(-0.5 * e, -0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new m(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new m(0.5 * e, 0.5 * e, 0.5 * e)), n.push(new m(0, 0, 1)), n.push(new m(0, 0, 1)), n.push(new m(0, 0, 1)), n.push(new m(0, 0, 1)), n.push(new m(0, 0, 1)), n.push(new m(0, 0, 1)), u -= h / this._textureSize, f -= h / this._textureSize, g = (l - this._textWidths[5]) / 2, y = -(g / this._textureSize), _ = (this._textWidths[5] + g) / this._textureSize, r.push(new X(y, f)), r.push(new X(_, f)), r.push(new X(_, u)), r.push(new X(y, f)), r.push(new X(_, u)), r.push(new X(y, u));
    const x = new Ss();
    x.setFaceWinding(Qs.CounterClockwise);
    let b = [], I = [], C = [], M = 0;
    for (let O = 0; O < i.length; O++) {
      const B = i[O];
      b.push(B.x), b.push(B.y), b.push(B.z);
      const j = n[O];
      I.push(j.x), I.push(j.y), I.push(j.z);
      const F = r[O];
      if (C.push(F.x), C.push(F.y), b.length >= 18) {
        const J = [
          // y
          [0, 255, 0, 255],
          [0, 255, 0, 255],
          // x
          [255, 0, 0, 255],
          [255, 0, 0, 255],
          // z
          [0, 0, 255, 255],
          [0, 0, 255, 255]
        ][M], rt = [];
        for (let ft = 0; ft < 6; ft++)
          rt.push(J[0]), rt.push(J[1]), rt.push(J[2]), rt.push(J[3]);
        x.addFaces(b, I, new Uint8Array(rt), C), b = [], I = [], C = [], ++M;
      }
    }
    b = [];
    const P = new Uint8Array(4 * o.length);
    for (let O = 0; O < o.length; O++) {
      const B = o[O];
      b.push(B.x), b.push(B.y), b.push(B.z);
      const j = 4 * O;
      P[j] = this._outlineColor.r, P[j + 1] = this._outlineColor.g, P[j + 2] = this._outlineColor.b, P[j + 3] = 255;
    }
    return x.addPolyline(b, P), this._createInstance(x, t);
  }
  _onCameraUpdate() {
    if (this._view === void 0)
      return;
    const t = new Sn(), e = this._view.getCamera();
    t.setPosition(
      e.getPosition().subtract(e.getTarget()).normalize()
    ), t.setTarget(m.zero()), t.setUp(e.getUp()), t.setProjection(ri.Orthographic), t.setWidth(this._fieldSize), t.setHeight(this._fieldSize), this._view.overlayManager.setCamera(be.NavCube, t);
  }
  _updateOrientationMatrices() {
    const e = this._viewer.model.getViewAxes(), i = e.upVector.copy(), n = e.frontVector.copy(), r = m.cross(i, n.copy().scale(-1)), o = new wt();
    o.m[0] = -n.x, o.m[1] = -n.y, o.m[2] = -n.z, o.m[4] = r.x, o.m[5] = r.y, o.m[6] = r.z, o.m[8] = i.x, o.m[9] = i.y, o.m[10] = i.z;
    const l = this._getScEngine(), h = [];
    for (const u of this._instanceKeys)
      h.push(Ni.Local, u);
    l.setInstancesMatrix(h, o);
  }
  _createSelectionFace(t, e, i, n, r, o, l) {
    const h = new Ss();
    h.setFaceWinding(Qs.CounterClockwise);
    const u = [];
    this._createQuad(e, i, u, n, o, r);
    let f = [], g = [], y = [];
    for (const I of u)
      f.push(I.x), f.push(I.y), f.push(I.z), g.push(0), g.push(0), g.push(-1), y.push(this._selectionFaceColor.r), y.push(this._selectionFaceColor.g), y.push(this._selectionFaceColor.b), y.push(128);
    const _ = [], x = [
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255,
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255
    ];
    h.addFaces(f, g, new Uint8Array(y)), f = [], g = [], y = [];
    let b = [];
    return r ? (b.push(u[4].x, u[4].y, u[4].z), b.push(u[5].x, u[5].y, u[5].z)) : (b.push(u[0].x, u[0].y, u[0].z), b.push(u[1].x, u[1].y, u[1].z)), h.addPolyline(b, new Uint8Array(x)), _.push(
      new m(b[0], b[1], b[2]),
      new m(b[3], b[4], b[5])
    ), b = [], b.push(u[1].x, u[1].y, u[1].z), b.push(u[2].x, u[2].y, u[2].z), h.addPolyline(b, new Uint8Array(x)), _.push(
      new m(b[0], b[1], b[2]),
      new m(b[3], b[4], b[5])
    ), b = [], b.push(u[3].x, u[3].y, u[3].z), b.push(u[4].x, u[4].y, u[4].z), h.addPolyline(b, new Uint8Array(x)), _.push(
      new m(b[0], b[1], b[2]),
      new m(b[3], b[4], b[5])
    ), b = [], r ? (b.push(u[3].x, u[3].y, u[3].z), b.push(u[2].x, u[2].y, u[2].z)) : (b.push(u[5].x, u[5].y, u[5].z), b.push(u[3].x, u[3].y, u[3].z)), h.addPolyline(b, new Uint8Array(x)), _.push(
      new m(b[0], b[1], b[2]),
      new m(b[3], b[4], b[5])
    ), b = [], l.push(_), this._createInstance(h, t);
  }
  _createQuad(t, e, i, n, r, o = !1) {
    const l = new m(t.x, t.y, t.z), h = new m(e.x, e.y, e.z);
    r && (l.x += r.x, l.y += r.y, l.z += r.z, h.x += r.x, h.y += r.y, h.z += r.z);
    const u = i.length;
    let f = new m(h.x, h.y, l.z), g = n.transform(f);
    if (i.push(g), f = new m(l.x, h.y, l.z), g = n.transform(f), i.push(g), f = new m(l.x, l.y, l.z), g = n.transform(f), i.push(g), f = new m(h.x, l.y, l.z), g = n.transform(f), i.push(g), f = new m(h.x, h.y, l.z), g = n.transform(f), i.push(g), f = new m(l.x, l.y, l.z), g = n.transform(f), i.push(g), o)
      for (let y = 0; y < 3; y++) {
        const _ = u + y, x = i[u + y], b = new m(x.x, x.y, x.z), I = u + (6 - y - 1);
        i[_].x = i[I].x, i[_].y = i[I].y, i[_].z = i[I].z, i[I].x = b.x, i[I].y = b.y, i[I].z = b.z;
      }
  }
  _makeRotationMatrixX(t) {
    const e = Math.cos(t), i = Math.sin(t), n = new wt();
    return n.m[5] = e, n.m[6] = -i, n.m[9] = i, n.m[10] = e, n;
  }
  _makeRotationMatrixY(t) {
    const e = Math.cos(t), i = Math.sin(t), n = new wt();
    return n.m[0] = e, n.m[2] = i, n.m[8] = -i, n.m[10] = e, n;
  }
  _makeRotationMatrixZ(t) {
    const e = Math.cos(t), i = Math.sin(t), n = new wt();
    return n.m[0] = e, n.m[1] = -i, n.m[4] = i, n.m[5] = e, n;
  }
  _getFaceIndexFromNodeId(t) {
    for (let e = 0; e < this._nodeIds.length; e++)
      if (this._nodeIds[e] === t)
        return e;
    return -1;
  }
  _getNodeIdFromFaceIndex(t) {
    return this._nodeIds[t];
  }
  _isSameEdge(t, e, i, n) {
    const r = m.subtract(t, i).squaredLength() + m.subtract(e, n).squaredLength(), o = m.subtract(e, i).squaredLength() + m.subtract(t, n).squaredLength();
    return Math.min(r, o) < 0.03;
  }
  async _initializeTextures() {
    const t = document.createElement("canvas");
    t.width = this._textureSize, t.height = this._textureSize;
    const e = t.getContext("2d"), i = 2 * (this._fontSize + 5);
    e.beginPath(), e.rect(0, 0, this._textureSize, this._textureSize), e.fillStyle = "gray", e.fill(), e.fillStyle = "black", e.font = this._fontInfo;
    for (let r = 0; r < zc._faceTexts.length; r++) {
      const o = zc._faceTexts[r];
      e.fillText(o, 0, i * (r + 1));
      const l = e.measureText(o);
      this._textWidths.push(l.width);
    }
    const n = await this._createTexture(e, this._textureSize);
    this._textImageId = n;
  }
};
zc._faceTexts = [
  "LEFT",
  "RIGHT",
  "FRONT",
  "BACK",
  "BOTTOM",
  "TOP"
];
let qf = zc;
class Ix {
  /** @hidden */
  constructor(t) {
    this._operatorStack = [], this._operators = /* @__PURE__ */ new Map(), this._customOperatorIdCount = 0, this._customOperatorIdIndex = 1e4, this._mergeableEvents = [
      le.MouseMove,
      le.Mousewheel,
      le.TouchMove,
      le.KeyUp,
      le.KeyDown
    ], this._eventSequencePromise = Promise.resolve(), this._events = [], this._viewer = t, this._viewer.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        const e = [];
        return this._operators.forEach((i, n) => {
          let r;
          r = this._deactivateOperator(n), r !== void 0 && e.push(r), r = this._activateOperator(n), r !== void 0 && e.push(r);
        }), We(e);
      }
    });
  }
  /** @hidden */
  _shutdown() {
    for (; this.pop() !== void 0; )
      ;
  }
  /** @hidden */
  _registerOperator(t, e) {
    this._operators.set(t, e);
  }
  /**
   * Registers a custom operator
   * @param operator
   * @returns operatorId
   */
  registerCustomOperator(t) {
    const e = this._customOperatorIdIndex + this._customOperatorIdCount++;
    return this._operators.set(e, t), e;
  }
  /**
   * Removes a custom operator from the registered operator list.
   * @param operatorId
   */
  unregisterCustomOperator(t) {
    t >= this._customOperatorIdIndex && this._operators.delete(t);
  }
  /**
   * Replaces the operator that the specified id refers to. Returns a boolean indicating success or failure.
   * @param previousOperatorId operator id for the operator to be replaced.
   * @param newOperatorId operator id for the new operator.
   */
  replaceOperator(t, e) {
    const i = this.getOperator(e);
    return i !== null ? (this._operators.set(t, i), !0) : !1;
  }
  /**
   * Returns the index of an operator on the stack
   * @param operatorId
   * @returns operator index or -1 if not found
   */
  indexOf(t) {
    for (let e = this.size() - 1; e >= 0; e--)
      if (this._operatorStack[e] === t)
        return e;
    return -1;
  }
  /**
   * Adds an operator on the stack if it's not already on the stack
   * @param operatorId id of the operator to add to the stack
   * @returns boolean indicating success or failure
   */
  push(t) {
    return this._isValid(t) && !this._contains(t) ? (this._operatorStack.push(t), this._activateOperator(t), !0) : !1;
  }
  /**
   * Sets a position on the stack to an operator if it's not already on the stack
   * If there is already an operator in that position, it is replaced.
   * @param operatorId id of the operator to add to the stack
   * @param position position on the stack to assign
   * @returns boolean indicating success or failure
   */
  set(t, e) {
    const i = this._operatorStack[e];
    return t === i ? !1 : this._isValid(t) && !this._contains(t) ? (this._deactivateOperator(i), this._activateOperator(t), this._operatorStack[e] = t, !0) : !1;
  }
  /**
   * Removes an operator from the top of the stack
   * @returns the operator id
   */
  pop() {
    const t = this._operatorStack.pop();
    return t !== void 0 && this._deactivateOperator(t), t;
  }
  /**
   * Removes an operator from the stack
   * @param operatorId id of the operator to remove from the stack
   */
  remove(t) {
    const e = this.indexOf(t);
    e !== -1 && (this._operatorStack.splice(e, 1), this._deactivateOperator(t));
  }
  /**
   * @returns the operator id at the top of the stack
   */
  peek() {
    return this.size() > 0 ? this._operatorStack[this.size() - 1] : ve.Invalid;
  }
  /**
   * @returns the operator id at the given position of the stack
   * Will return OperatorId.Invalid if position is out of bounds.
   */
  get(t) {
    return t < 0 || t >= this._operatorStack.length ? ve.Invalid : this._operatorStack[t];
  }
  /**
   * Removes all operators from the stack
   */
  clear() {
    for (let t = this.size() - 1; t >= 0; t--)
      this.pop();
  }
  /**
   * @returns the operator stack size
   */
  size() {
    return this._operatorStack.length;
  }
  getOperator(t) {
    return this._operators.get(t) ?? null;
  }
  async _injectEvent(t, e) {
    for (let i = this.size() - 1; i >= 0; i--) {
      const n = this._operators.get(this._operatorStack[i]);
      if (n !== void 0)
        try {
          switch (e) {
            case le.KeyDown:
              n.onKeyDown && await n.onKeyDown(t);
              break;
            case le.KeyUp:
              n.onKeyUp && await n.onKeyUp(t);
              break;
            case le.MouseDown:
              n.onMouseDown && await n.onMouseDown(t);
              break;
            case le.MouseMove:
              n.onMouseMove && await n.onMouseMove(t);
              break;
            case le.MouseUp:
              n.onMouseUp && await n.onMouseUp(t);
              break;
            case le.Mousewheel:
              n.onMousewheel && await n.onMousewheel(t);
              break;
            case le.TouchStart:
              n.onTouchStart && await n.onTouchStart(t);
              break;
            case le.TouchMove:
              n.onTouchMove && await n.onTouchMove(t);
              break;
            case le.TouchEnd:
              n.onTouchEnd && await n.onTouchEnd(t);
              break;
            case le.ViewOrientationChange:
              n.onViewOrientationChange && await n.onViewOrientationChange();
              break;
            default:
              qr(e);
          }
        } catch (r) {
          r instanceof No || console.log(r);
        }
      if (t.getHandled()) {
        (e === le.MouseUp || e === le.TouchEnd) && await this._stopInteraction();
        break;
      }
    }
  }
  async injectEvent(t, e) {
    return this._addOrMergeEventToQueue(t, e, t.viewKey), this._eventSequencePromise = this._eventSequencePromise.then(async () => {
      await this._injectNextEvent();
    }), this._eventSequencePromise;
  }
  _addOrMergeEventToQueue(t, e, i) {
    let n = !1;
    if (this._mergeableEvents.indexOf(e) !== -1)
      for (let r = 0; r < this._events.length; r++) {
        const o = this._events[r];
        if (!(e !== o.eventType || i !== o.event.viewKey) && !((e === le.KeyDown || e === le.KeyUp) && t.getKeyCode() !== o.event.getKeyCode()) && !(e === le.TouchMove && t.getId() !== o.event.getId())) {
          o.event = t, n = !0;
          break;
        }
      }
    n || this._events.push({ event: t, eventType: e });
  }
  async _injectNextEvent() {
    const t = this._events.shift();
    t !== void 0 && await this._injectEvent(t.event, t.eventType);
  }
  async _stopInteraction() {
    const t = [];
    for (let e = this.size() - 1; e >= 0; e--) {
      const i = this._operators.get(this._operatorStack[e]);
      if (i != null && i.stopInteraction) {
        const n = i.stopInteraction();
        n !== void 0 && t.push(n);
      }
    }
    return We(t);
  }
  /** @hidden */
  _injectViewOrientationChangeEvent() {
    for (let t = this.size() - 1; t >= 0; t--) {
      const e = this._operators.get(this._operatorStack[t]);
      e != null && e.onViewOrientationChange && e.onViewOrientationChange();
    }
  }
  _isValid(t) {
    return this._operators.has(t) || t === ve.None;
  }
  _contains(t) {
    return this.indexOf(t) !== -1;
  }
  _activateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onActivate)
      return e.onActivate();
  }
  _deactivateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onDeactivate)
      return e.onDeactivate();
  }
}
class Cx {
  /* @hidden */
  constructor(t, e, i, n) {
    this._activeSheetId = null, this._backgroundSheetMeshId = null, this._sheetIds = [null, null, null], this._backgroundSheetEnabled = !1, this._backgroundSelectionEnabled = !1, this._backgroundColor = new yt(180, 180, 180), this._sheetColor = yt.white(), this._sheetShadowColor = new yt(75, 75, 75), this._viewer = t, this._engine = e, this._callbackManager = i;
    const r = async () => {
      if (!this._viewer.model.isDrawing())
        return;
      const o = this._viewer.sheetManager.getActiveSheetId();
      if (o == null) {
        await this.deactivateSheets(!1);
        const l = this.getSheetIds();
        this.get3DNodes().length === 0 && l.length > 0 && await this.setActiveSheetId(l[0], !0, !0);
      } else
        await this._activateSheetId(o, !0, !0);
    };
    this._viewer.setCallbacks({
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.model.isDrawing() && !n)
          return this.setBackgroundSheetEnabled(!0);
      },
      _firstModelLoaded: async () => {
        await r();
      },
      _resetAssemblyTreeBegin: async () => {
        await this.setBackgroundSheetEnabled(!1), await this.setBackgroundSelectionEnabled(!1), this._activeSheetId = null, this._backgroundSheetMeshId = null;
        const o = this._viewer.view, l = o.getBackgroundColor();
        o.setBackgroundColor(l.top, l.bottom);
      },
      _resetDrawing: async () => {
        await r();
      }
    });
  }
  /**
   * @returns an array of 2D [[SheetId]]s.
   */
  getSheetIds() {
    const t = this._viewer.model, e = (n) => {
      let r = [];
      const o = t.getNodeChildren(n);
      for (const l of o)
        r = r.concat(e(l));
      return t.getNodeType(n) === Le.DrawingSheet && r.push(n), r;
    }, i = t.getAbsoluteRootNode();
    return e(i);
  }
  /**
   * Returns Ids of sheet nodes which contain 3D data.
   */
  get3DNodes() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode(), i = t.getNodeChildren(e), n = t.getNodeChildren(i[0]), r = t.getNodeChildren(n[0]), o = [];
    for (const l of r)
      t.getNodeType(l) !== Le.DrawingSheet && o.push(l);
    return o;
  }
  /**
   * Deactivate sheets and only display 3D content
   * @param triggerCallback triggers a "sheetDeactivated" callback if true
   * @param ignoreFitNodes camera will not fit nodes if true
   * @returns promise that resolves when the operation has completed
   */
  async deactivateSheets(t = !0, e = !1) {
    this._activeSheetId = null, this._viewer.pauseRendering();
    const i = this.get3DNodes(), n = e ? !1 : i.length > 0;
    await this._viewer.view.isolateNodes(i, 0, n), await this._refreshBackgroundSheets();
    const r = this._viewer.view, o = r.getBackgroundColor();
    r.setBackgroundColor(o.top, o.bottom), this._viewer.resumeRendering(), t && this._callbackManager.trigger("sheetDeactivated");
  }
  /**
   * Sets the id of the current active sheet
   * @param activeSheetId id of the sheet which will be activated.
   * @param isolateNodes indicates whether the nodes in the sheet should be isolated
   * @param fitNodes indicates whether a fit world should be performed after isolating the nodes.  Note: This parameter has no effect if `isolateNodes` is `false`.
   * @returns promise that resolves when the operation has completed
   */
  async setActiveSheetId(t, e = !0, i = !0) {
    this._activeSheetId !== t && (this._activeSheetId = t, await this._activateSheetId(t, e, i));
  }
  async _activateSheetId(t, e, i) {
    await this._markupManager._setActiveMarkupView(this._viewer.view, null), e && (this._viewer.pauseRendering(), await this._viewer.view.isolateNodes([t], 0, i), await this._refreshBackgroundSheets(), this._viewer.resumeRendering()), this._callbackManager.trigger("sheetActivated", this._activeSheetId);
  }
  /**
   * @returns gets the id of the current active sheet. null if none has been set.
   */
  getActiveSheetId() {
    return this._activeSheetId;
  }
  /**
   * @returns true if a drawing sheet is activated, false otherwise
   */
  isDrawingSheetActive() {
    return this._viewer.model.isDrawing() && this._activeSheetId !== null;
  }
  /** @hidden */
  setMarkupManager(t) {
    this._markupManager = t;
  }
  async _createBackgroundSheetMesh() {
    const t = [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      0
    ], e = [
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ], i = new Ss();
    return i.addFaces(t, e), i.setBackfacesEnabled(!0), this._viewer.model.createMesh(i);
  }
  _createBackgroundSheetMatrix(t, e) {
    const i = t.min, n = t.max, r = this._viewer.view.getCamera(), o = r.getPosition(), l = r.getTarget(), h = m.subtract(l, o);
    let u = n.x - i.x, f = n.y - i.y;
    const g = Math.max(0.1 * u, 0.1 * (n.z - i.z)), y = i.x + 0.5 * u, _ = i.y + 0.5 * f, x = 0.05, b = Math.max(u * x, f * x);
    u += b, f += b;
    let I = y - 0.5 * u, C = _ - 0.5 * f, M = h.z > 0 ? n.z + g : i.z - g;
    if (e) {
      const O = r.getUp();
      let B = 0.3 * b;
      I += B, O.y > 0 && (B = -B), C += B, M += h.z > 0 ? g : -g;
    }
    const P = new wt();
    return P.setTranslationComponent(I, C, M), P.setScaleComponent(u, f, 1), P;
  }
  async _createBackgroundSheetInstance(t, e, i, n, r, o) {
    let l = ee.DoNotExplode | ee.DoNotCut | ee.OverrideSceneVisibility | ee.DoNotLight | ee.DoNotOutlineHighlight | ee.AlwaysDraw | ee.ExcludeBounding;
    o || (l |= ee.DoNotSelect);
    const h = new tr(
      t,
      i,
      e,
      n,
      null,
      null,
      l
    ), u = await this._viewer.model.createMeshInstance(h, null, !1, !0);
    return this._viewer.model.setNodesOpacity([u], r), u;
  }
  /**
   * Deletes background sheets described by sheetTypes, but only if they exist.
   * @param sheetTypes An array with the sheets to delete. Omitting will delete all sheets.
   */
  async _deleteBackgroundSheetInstances(t = [
    0,
    2,
    1
    /* Shadow */
  ]) {
    const e = [];
    for (const i of t) {
      const n = this._sheetIds[i];
      n !== null && (this._sheetIds[i] = null, e.push(n));
    }
    if (e.length > 0)
      return this._viewer.model.deleteMeshInstances(e);
  }
  /**
   *  Creates the sheet-type into our array, or if the sheet already exists updates the necessary state values
   */
  async _createOrUpdateSheet(t, e, i, n, r, o) {
    const l = this._viewer.model;
    if (this._sheetIds[t] === null)
      return this._sheetIds[t] = await this._createBackgroundSheetInstance(
        this._backgroundSheetMeshId,
        e,
        i,
        n,
        r,
        o
      ), Promise.resolve();
    {
      const h = this._sheetIds[t];
      return l.setNodesFaceColor([h], n), l.setNodesOpacity([h], r), o !== null && l.setInstanceModifier(tn.DoNotSelect, [h], !o), l.setNodeMatrix(h, i, !0);
    }
  }
  /**
   * Refreshes the background sheets used for 2D drawings.
   */
  async _refreshBackgroundSheets() {
    const t = this._viewer.model;
    if (!this.isDrawingSheetActive())
      return this._backgroundSelectionEnabled = !1, this._deleteBackgroundSheetInstances();
    this._backgroundSheetMeshId === null && (this._backgroundSheetMeshId = await this._createBackgroundSheetMesh());
    const e = await t.getModelBounding(!0, !1), i = this._createBackgroundSheetMatrix(e, !1), n = [];
    this._backgroundSelectionEnabled ? await this._createOrUpdateSheet(
      2,
      "2d_drawing_background_selection_sheet",
      i,
      yt.black(),
      0,
      !0
    ) : n.push(
      2
      /* Selection */
    );
    for (const r of this._viewer.views)
      this._engine.setBackgroundGradient(r.id, this._backgroundColor, this._backgroundColor);
    if (this._backgroundSheetEnabled) {
      const r = this._createBackgroundSheetMatrix(e, !0);
      await this._createOrUpdateSheet(
        0,
        "2d_drawing_background_sheet",
        i,
        this._sheetColor,
        1,
        !1
      ), await this._createOrUpdateSheet(
        1,
        "2d_drawing_background_shadow_sheet",
        r,
        this._sheetShadowColor,
        1,
        !1
      );
    } else
      n.push(
        0,
        1
        /* Shadow */
      );
    if (n.length > 0)
      return this._deleteBackgroundSheetInstances(n);
  }
  /**
   * Sets custom sheet colors.
   * @param backgroundColor viewer background color.
   * @param sheetColor sheet background color.
   * @param sheetShadowColor sheet shadow effect color.
   */
  setSheetColors(t, e, i) {
    return this._backgroundColor = t.copy(), this._sheetColor = e.copy(), this._sheetShadowColor = i.copy(), this._refreshBackgroundSheets();
  }
  /**
   * Gets the sheet Background Color.
   */
  getSheetBackgroundColor() {
    return this._backgroundColor;
  }
  /**
   * Gets the Sheet Color.
   */
  getSheetColor() {
    return this._sheetColor;
  }
  /**
   * Gets the Sheet Shadow Color.
   */
  getSheetShadowColor() {
    return this._sheetShadowColor;
  }
  /**
   * Enables or disables the background sheet used for 2D drawings.
   */
  async setBackgroundSheetEnabled(t) {
    t !== this._backgroundSheetEnabled && (this._backgroundSheetEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /**
   * Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSheetEnabled() {
    return this._backgroundSheetEnabled;
  }
  /**
   * Sets whether the background for 2D drawings is selectable. By default it is not.
   * 2D drawings have an invisible selection plane with a single face. Note that this setting
   * is unaffected by the background-sheet enable setting.
   */
  async setBackgroundSelectionEnabled(t) {
    this.isDrawingSheetActive() || (t = !1), t !== this._backgroundSelectionEnabled && (this._backgroundSelectionEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /** Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSelectionEnabled() {
    return this._backgroundSelectionEnabled;
  }
  /**
   * Enables a visual comparison of two drawing sheets. The nodes specified
   * by `sheetId1` are filled with one color, the nodes specified by
   * `sheetId2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endSheetComparison]], [[View.startComparison]].
   *
   * @param sheetId1 the drawing sheet to compare against `sheetId2`
   * @param sheetId2 the drawing sheet to compare against `sheetId1`
   * @param config settings controlling the behavior of the comparison
   */
  async startComparison(t, e, i) {
    const n = this._viewer.view;
    n.startComparison([t], [e], i), await this.setActiveSheetId(t, !1, !1), await n.isolateNodes([t, e], 0, !0), await this._refreshBackgroundSheets();
  }
  /**
   * Disables a visual comparison of two drawing sheets enabled by
   * [[startSheetComparison]]. The `Promise` returned by that function
   * should be waited upon before calling [[endSheetComparison]].
   */
  async endComparison() {
    this._activeSheetId !== null && (await this.setActiveSheetId(this._activeSheetId, !0, !1), this._viewer.view.endComparison());
  }
}
class Sx {
  /**
   * Creates a new SnapshotConfig object.
   */
  constructor(t = 0, e = 0, i = Ec.All, n = Ae.Default) {
    this.viewKey = n, this.width = t, this.height = e, this.layers = i;
  }
}
class Gp {
  constructor() {
    this.svgXmlPrologEnabled = !0, this.svgBackgroundCssColor = "", this.silhouettesEnabled = !0, this.linesDrawModelLinesEnabled = !0, this.linesStrokeWidth = 20, this.linesCssColor = "#000000", this.linesClipProximityToPlane = 5.5, this.linesClipZNudgeFactor = 5.5, this.polygonsForceDrawCssColor = "", this.logProgress = !1, this.logDiagnostics = !1;
  }
}
class Vy {
  constructor(t, e) {
    this.top = t, this.bottom = e;
  }
}
class Mx {
  constructor(t, e) {
    this._callbackManager = t, this._operatorManager = e, this._contextEventChecker = new Px(this._callbackManager);
  }
  injectMouseDownEvent(t, e, i, n, r, o) {
    const l = new Gr(
      t,
      e,
      i,
      n,
      r,
      _r.Down,
      o
    ), h = le.MouseDown;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h), this._contextEventChecker.onMouseDownEvent(l);
  }
  injectMouseMoveEvent(t, e, i, n, r, o) {
    const l = new Gr(
      t,
      e,
      i,
      n,
      r,
      _r.Move,
      o
    ), h = le.MouseMove;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h);
  }
  injectMouseUpEvent(t, e, i, n, r, o) {
    const l = new Gr(t, e, i, n, r, _r.Up, o), h = le.MouseUp;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h), this._contextEventChecker.onMouseUpEvent(l);
  }
  injectMousewheelEvent(t, e, i, n, r, o) {
    const l = new z_(
      t,
      e,
      i,
      n,
      r,
      _r.Wheel,
      o
    ), h = le.Mousewheel;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h);
  }
  injectKeyDownEvent(t, e, i) {
    const n = new Lf(t, e, Pf.Down, i), r = le.KeyDown;
    this._callbackManager.trigger("_inputInteraction", n, r), this._operatorManager.injectEvent(n, r);
  }
  injectKeyUpEvent(t, e, i) {
    const n = new Lf(t, e, Pf.Up, i), r = le.KeyUp;
    this._callbackManager.trigger("_inputInteraction", n, r), this._operatorManager.injectEvent(n, r);
  }
  injectTouchStartEvent(t, e, i, n, r) {
    const o = new Au(t, e, i, n, Su.Start, r), l = le.TouchStart;
    this._callbackManager.trigger("_inputInteraction", o, l), this._operatorManager.injectEvent(o, l), this._contextEventChecker.onTouchStartEvent(o);
  }
  injectTouchMoveEvent(t, e, i, n, r) {
    const o = new Au(t, e, i, n, Su.Start, r), l = le.TouchMove;
    this._callbackManager.trigger("_inputInteraction", o, l), this._operatorManager.injectEvent(o, l), this._contextEventChecker.onTouchMoveEvent(o);
  }
  injectTouchEndEvent(t, e, i, n, r) {
    const o = new Au(t, e, i, n, Su.End, r), l = le.TouchEnd;
    this._callbackManager.trigger("_inputInteraction", o, l), this._operatorManager.injectEvent(o, l), this._contextEventChecker.onTouchEndEvent(o);
  }
  injectViewOrientationChangeEvent(t) {
    this._operatorManager._injectViewOrientationChangeEvent();
  }
}
class Px {
  constructor(t) {
    this._contextMenuMouseButton = Te.Right, this._contextMenuPositionStart = X.zero(), this._touchTimer = new Ko(), this._activeTouchCount = 0, this._initialPosition = X.zero(), this._callbackManager = t;
  }
  onMouseDownEvent(t) {
    t.getHandled() || this._contextMenuPositionStart.assign(t.getPosition());
  }
  onMouseUpEvent(t) {
    if (!t.getHandled()) {
      const e = t.getPosition();
      t.getButton() === this._contextMenuMouseButton && this._contextMenuPositionStart.equals(e) && this._callbackManager.trigger("contextMenu", e, t.getModifiers());
    }
  }
  onTouchStartEvent(t) {
    const e = t.getPosition().copy();
    this._activeTouchCount === 0 && (this._initialPosition = e), ++this._activeTouchCount, t.getHandled() || this._touchTimer.set(600, () => {
      this._callbackManager.trigger("contextMenu", e, Mi.None);
    });
  }
  onTouchMoveEvent(t) {
    if (!this._touchTimer.isIdle(Nn.BeforeAction)) {
      const e = X.subtract(this._initialPosition, t.getPosition()), i = Math.abs(e.squaredLength()), n = window.outerHeight * 0.02, r = n * n;
      i > r && this._touchTimer.clear();
    }
  }
  onTouchEndEvent(t) {
    this._activeTouchCount > 0 && --this._activeTouchCount, this._touchTimer.clear();
  }
}
class kx {
  static calculate(t, e, i, n) {
    let r;
    const o = 2 / (e + 2 * i + n);
    return t <= e ? r = this._PA(t, o, e) : t >= e && t <= e + i ? r = this._PA(t, o, e) : r = this._PC(t, o, e, i, n), r = Math.min(r, 1), r;
  }
  static _PA(t, e, i) {
    return t * t * 0.5 * e / i;
  }
  static _PB(t, e, i) {
    return this._PA(i, e, i) + (t - i) * e;
  }
  static _PC(t, e, i, n, r) {
    return this._PB(i + n, e, i) + (t - (i + n)) * e * (1 - 0.5 * (t - (i + n)) / r);
  }
}
class Ex {
  constructor(t, e, i, n, r) {
    this._completeCallback = null, this._startTime = null, this._progress = 0, this._positionMoveDelta = null, this._targetMoveDelta = null, this._interpolationUsesRotation = !1, this._beginQuaternion = null, this._endQuaternion = null, this._viewVectorLength = 0, this._viewVectorLengthDelta = 0, this._fieldWidthDelta = 0, this._fieldHeightDelta = 0, this._beginCam = t.copy(), this._endCam = e.copy();
    const o = m.subtract(
      this._endCam.getTarget(),
      this._endCam.getPosition()
    ).normalize(), l = this._endCam.getUp().normalize(), h = m.cross(l, o), u = m.cross(o, h);
    this._endCam.setUp(u.normalize()), this._completeCallback = n, this._duration = i, this._view = r;
  }
  isComplete() {
    return this._progress >= 1;
  }
  getCallback() {
    return this._completeCallback;
  }
  stop() {
  }
  start() {
    this._startTime = Date.now(), this._progress = 0, this._init(), this._view.getProjectionMode() !== this._endCam.getProjection() && this._view.setProjectionMode(this._endCam.getProjection());
  }
  update() {
    if (this._startTime === null)
      return;
    let e = (Date.now() - this._startTime) / this._duration;
    e = Math.min(e, 1), e = Math.max(e, 0), e = kx.calculate(e, 0.49, 0.02, 0.49), e = Math.min(e, 1), e = Math.max(e, 0);
    const i = m.scale(this._positionMoveDelta, e), n = m.scale(this._targetMoveDelta, e), r = this._beginCam.getUp();
    let o = m.add(this._beginCam.getPosition(), i);
    const l = m.add(this._beginCam.getTarget(), n), h = this._beginCam.getWidth() + e * this._fieldWidthDelta, u = this._beginCam.getHeight() + e * this._fieldHeightDelta;
    if (this._interpolationUsesRotation) {
      const g = this._viewVectorLength + this._viewVectorLengthDelta * e, y = ts.interpolate(this._beginQuaternion, this._endQuaternion, e), _ = ts.toMatrix(y);
      o = new m(
        l.x - _.m[8] * g,
        l.y - _.m[9] * g,
        l.z - _.m[10] * g
      ), r.set(_.m[4], _.m[5], _.m[6]);
    }
    const f = Sn.create(
      o,
      l,
      r,
      this._endCam.getProjection(),
      h,
      u,
      this._endCam.getNearLimit()
    );
    this._view.setCamera(f), this._progress = e, this._progress >= 1 && this._view.setCamera(this._endCam);
  }
  /**
   * Returns the transpose of the camera's view matrix without the
   * translation component and with the x- and z- axes flipped.
   *
   * Reproduced here because the public version is deprecated.
   */
  getMatrixFromCamera(t) {
    const e = m.subtract(t.getTarget(), t.getPosition()).normalize(), i = t.getUp().normalize(), n = m.cross(i, e), r = m.cross(e, n);
    return wt.createFromBasis(n, r, e);
  }
  _init() {
    const t = m.subtract(
      this._beginCam.getTarget(),
      this._beginCam.getPosition()
    ), e = m.subtract(this._endCam.getTarget(), this._endCam.getPosition()), i = t.length(), n = e.length() - i;
    t.normalize(), e.normalize();
    const r = m.subtract(t, e), o = m.subtract(this._endCam.getUp(), this._beginCam.getUp());
    let l = !0;
    r.length() < 1e-4 && o.length() < 1e-4 && (l = !1);
    let h = null, u = null;
    if (l) {
      const f = this.getMatrixFromCamera(this._beginCam), g = this.getMatrixFromCamera(this._endCam);
      h = ts.createFromMatrix(f), u = ts.createFromMatrix(g);
      const y = ts.subtract(h, u).magnitudeSquared();
      ts.add(h, u).magnitudeSquared() < y && u.negate();
    }
    this._interpolationUsesRotation = l, this._beginQuaternion = h, this._endQuaternion = u, this._viewVectorLength = i, this._viewVectorLengthDelta = n, this._positionMoveDelta = m.subtract(
      this._endCam.getPosition(),
      this._beginCam.getPosition()
    ), this._targetMoveDelta = m.subtract(this._endCam.getTarget(), this._beginCam.getTarget()), this._fieldWidthDelta = this._endCam.getWidth() - this._beginCam.getWidth(), this._fieldHeightDelta = this._endCam.getHeight() - this._beginCam.getHeight();
  }
}
class Ax {
  constructor() {
    this._obscuredLineColor = yt.black(), this._obscuredLineOpacity = 0.2, this._visibleLineColor = yt.black(), this._visibleLineOpacity = 1, this._backgroundColorTop = yt.white(), this._backgroundColorBottom = yt.white();
  }
  /**
   * Returns the `Color` used for rendering obscured lines.
   * @returns The color used for obscured lines.
   */
  getObscuredLineColor() {
    return this._obscuredLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering obscured lines.
   * @param color The color used for obscured lines.
   */
  setObscuredLineColor(t) {
    this._obscuredLineColor.assign(t);
  }
  /**
   * Returns the opacity used for rendering obscured lines.
   * @returns The opacity used for obscured lines.
   */
  getObscuredLineOpacity() {
    return this._obscuredLineOpacity;
  }
  /**
   * Sets the opacity used for rendering obscured lines.
   * @param opacity The opacity used for obscured lines.
   */
  setObscuredLineOpacity(t) {
    0 <= t && t <= 1 && (this._obscuredLineOpacity = t);
  }
  /**
   * Gets the `Color` used for rendering visible lines.
   * @returns The color used for visible lines.
   */
  getVisibleLineColor() {
    return this._visibleLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering visible lines.
   * @param color The color used for visible lines.
   */
  setVisibleLineColor(t) {
    this._visibleLineColor.assign(t);
  }
  /**
   * Gets the opacity used for rendering visible lines.
   * @returns The opacity used for visible lines.
   */
  getVisibleLineOpacity() {
    return this._visibleLineOpacity;
  }
  /**
   * Sets the opacity used for rendering visible lines.
   * @param opacity The opacity used for visible lines.
   */
  setVisibleLineOpacity(t) {
    0 <= t && t <= 1 && (this._visibleLineOpacity = t);
  }
  /**
   * Gets the colors used for the background in hidden line rendering.
   * @returns The background colors used for hidden line.
   */
  getBackgroundColor() {
    const t = this._backgroundColorTop !== null ? this._backgroundColorTop.copy() : null, e = this._backgroundColorBottom !== null ? this._backgroundColorBottom.copy() : null;
    return new Vy(t, e);
  }
  /**
   * Sets the background color in hidden line rendering to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * To enable a transparent background, pass null to the parameters of this function.
   *
   * @param top the top color for the the background gradient, null for transparent.
   * @param bottom the bottom color for the the background gradient, null for transparent.
   */
  setBackgroundColor(t = null, e = null) {
    this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null;
  }
}
class Tx extends go {
  constructor(t) {
    super(), this._position = new X(10, 10), this._nextItemPosition = X.zero(), this._statItemOffset = new X(5, 5), this._maxStatWidth = 0, this._viewer = t, this._backgroundPanel = new pd(this._position, new X(300, 100)), this._backgroundPanel.setFillColor(yt.white()), this._backgroundPanel.setStrokeWidth(0), this._statsText = new q_();
  }
  draw() {
    this._updateBackgroundSize();
    const t = this._viewer.markupManager.getRenderer();
    t.drawRectangle(this._backgroundPanel), t.drawTexts(this._statsText);
  }
  clearStatsText() {
    this._statsText.clear(), this._nextItemPosition.assign(this._position);
  }
  setPosition(t) {
    this._position.assign(t), this._backgroundPanel.setPosition(this._position);
  }
  addStatistic(t, e) {
    const i = X.add(this._nextItemPosition, this._statItemOffset), n = `${t}: ${e}`;
    this._statsText.addString(n, i), this._nextItemPosition.y += this._statsText.getFontSize();
  }
  _updateBackgroundSize() {
    const t = this._viewer.markupManager.getRenderer(), e = this._statsText.getStrings(), i = this._statsText.getFontSize();
    for (const o of e) {
      const l = t.measureText(o.text, this._statsText);
      this._maxStatWidth = Math.max(this._maxStatWidth, l.x);
    }
    const n = 2 * this._statItemOffset.x + this._maxStatWidth, r = e.length * (i + this._statItemOffset.y);
    this._backgroundPanel.setSize(new X(n, r));
  }
}
class zy {
  constructor() {
    this.total_element_count = 0, this.total_triangle_count = 0;
  }
}
class Dx {
  constructor(t, e) {
    this._statisticsDisplayHandle = null, this._statistics = new zy(), this._viewer = e, this._callbackManager = t, this._callbackManager.bind({
      frameDrawn: async () => {
        await this.update();
      }
    }), this._statisticsDisplay = new Tx(this._viewer);
  }
  async update() {
    const t = await this._viewer.getStatistics();
    this._statistics = t, this._statisticsDisplay.clearStatsText();
    const e = Object.keys(this._statistics);
    for (const i of e) {
      const n = i, r = this._statistics[n];
      this._statisticsDisplay.addStatistic(n, r.toString());
    }
  }
  isShown() {
    return this._statisticsDisplayHandle !== null;
  }
  getStatistics() {
    return this._statistics;
  }
  async showDisplay() {
    this.isShown() || (await this.update(), this._statisticsDisplayHandle = this._viewer.markupManager.registerMarkup(
      this._statisticsDisplay,
      this._viewer.view
    ));
  }
  hideDisplay() {
    this.isShown() && (this._viewer.markupManager.unregisterMarkup(
      this._statisticsDisplayHandle,
      this._viewer.view
    ), this._statisticsDisplayHandle = null);
  }
}
class Nx {
  constructor() {
    this.left = 0, this.top = 0;
  }
}
const zi = class zi {
  constructor(t, e, i) {
    this._isIE = !1, this._isFirefox = !1, this._canvas = null, this._canvasEventFunctions = /* @__PURE__ */ new Map(), this._documentEventFunctions = /* @__PURE__ */ new Map(), this._pointerEventsEnabled = !0, this._processInput = !1, this._eventsBound = !1, this._dragStarted = !1, this._captureInput = !1, this._elementOffset = new Nx(), this._pointerUp = !1, this._buttons = ws.None, this._viewKey = t, this._eventDispatcher = e, this._timeoutMonitor = i, this._document = document;
    const n = navigator.userAgent.toLowerCase();
    this._isIE = n.indexOf("trident") >= 0 || n.indexOf("edge") >= 0, this._isFirefox = n.indexOf("firefox") > -1;
  }
  _tryLockEventDispatcher() {
    return !zi._activeEventDispatcherLocked || zi._activeEventDispatcher === this._eventDispatcher ? (this._calculateElementOffset(), zi._activeEventDispatcher = this._eventDispatcher, zi._activeOffset = this._elementOffset, zi._activeEventDispatcherLocked = !0, !0) : !1;
  }
  _unlockEventDispatcher() {
    zi._activeEventDispatcherLocked = !1;
  }
  shutdown() {
    this.unbindEvents();
  }
  setDocument(t) {
    this._unbindDocumentEvents(), this._document = t, this._initDocumentEvents();
  }
  setOptions(t) {
    t.hasOwnProperty("usePointerEvents") && this.setPointerEventsEnabled(!!t.usePointerEvents);
  }
  elementResize() {
    this._calculateElementOffset();
  }
  setPointerEventsEnabled(t) {
    this._pointerEventsEnabled = t;
  }
  getPointerEventsEnabled() {
    return this._pointerEventsEnabled;
  }
  _browserSupportsPointerEvents() {
    return window.hasOwnProperty("PointerEvent");
  }
  _usePointerEvents() {
    return this._browserSupportsPointerEvents() && this._pointerEventsEnabled && this._isIE;
  }
  _calculateElementOffset() {
    if (this._canvas !== null) {
      const t = this._canvas.getBoundingClientRect();
      this._elementOffset.left = t.left, this._elementOffset.top = t.top;
    }
  }
  _initDocumentEvents() {
    this._usePointerEvents() ? (this._bindDocumentEvent("pointermove", (t) => {
      this._processDocumentPointerMove(t);
    }), this._bindDocumentEvent("pointerup", (t) => {
      this._processDocumentPointerUp(t);
    })) : (this._bindDocumentEvent("mousemove", (t) => {
      this._processDocumentMouseMove(t);
    }), this._bindDocumentEvent("mouseup", (t) => {
      this._processDocumentMouseUp(t);
    }));
  }
  _initCanvasEvents() {
    this._usePointerEvents() ? (this._bindCanvasEvent("pointerdown", (t) => {
      this._processPointerDown(t);
    }), this._bindCanvasEvent("pointermove", (t) => {
      this._processPointerMove(t);
    }), this._bindCanvasEvent("pointerup", (t) => {
      this._processPointerUp(t);
    }), this._bindCanvasEvent("pointerenter", (t) => {
      this._processPointerEnter(t);
    }), this._bindCanvasEvent("pointerleave", (t) => {
      this._processPointerLeave(t);
    })) : (this._bindCanvasEvent("mousedown", (t) => {
      this._processMouseDown(t);
    }), this._bindCanvasEvent("mousemove", (t) => {
      this._processMouseMove(t);
    }), this._bindCanvasEvent("mouseup", (t) => {
      this._processMouseUp(t);
    }), this._bindCanvasEvent("mouseenter", (t) => {
      this._processMouseEnter(t);
    }), this._bindCanvasEvent("mouseleave", (t) => {
      this._processMouseLeave(t);
    }), this._bindCanvasEvent("touchstart", (t) => {
      this._processTouchStart(t);
    }), this._bindCanvasEvent("touchmove", (t) => {
      this._processTouchMove(t);
    }), this._bindCanvasEvent("touchend", (t) => {
      this._processTouchEnd(t);
    }), this._bindCanvasEvent("touchcancel", (t) => {
      this._processTouchEnd(t);
    })), this._isFirefox ? this._bindCanvasEvent("DOMMouseScroll", (t) => {
      this._processMousewheel(t);
    }) : this._bindCanvasEvent("mousewheel", (t) => {
      this._processMousewheel(t);
    }), this._bindCanvasEvent("keydown", (t) => {
      this._processKeyDownEvent(t);
    }), this._bindCanvasEvent("keyup", (t) => {
      this._processKeyUpEvent(t);
    });
  }
  bindEvents(t) {
    this._eventsBound || (this._canvas = t, this.elementResize(), this._processInput = !0, this._initCanvasEvents(), this._initDocumentEvents(), this._eventsBound = !0);
  }
  _bindDocumentEvent(t, e) {
    if (this._document === null)
      return;
    const i = this._documentEventFunctions.get(t);
    i !== void 0 && this._document.removeEventListener(t, i), this._documentEventFunctions.set(t, e), this._document.addEventListener(t, e);
  }
  _bindCanvasEvent(t, e) {
    if (this._canvas === null)
      return;
    const i = this._canvasEventFunctions.get(t);
    i !== void 0 && this._canvas.removeEventListener(t, i), this._canvasEventFunctions.set(t, e), this._canvas.addEventListener(t, e);
  }
  _unbindDocumentEvents() {
    this._documentEventFunctions.forEach((t, e) => {
      this._document.removeEventListener(e, t);
    }), this._documentEventFunctions.clear();
  }
  _unbindCanvasEvents() {
    this._canvas !== null && (this._canvasEventFunctions.forEach((t, e) => {
      this._canvas.removeEventListener(e, t);
    }), this._canvasEventFunctions.clear()), console.assert(this._canvasEventFunctions.size === 0);
  }
  unbindEvents() {
    this._unbindCanvasEvents(), this._unbindDocumentEvents(), this._processInput = !1, this._eventsBound = !1, zi._activeEventDispatcher === this._eventDispatcher && this._unlockEventDispatcher();
  }
  _convertEventCoordsToTargetCoords(t, e, i = !0) {
    let n;
    return i && zi._activeOffset !== null ? n = zi._activeOffset : n = this._elementOffset, new X(t - n.left, e - n.top);
  }
  focusInput(t) {
    this._canvas !== null && (t ? this._canvas.focus() : this._canvas.blur());
  }
  _setButtons(t) {
    t.buttons && (this._buttons = t.buttons);
  }
  ////Mouse Events
  _processMouseDown(t) {
    if (this._tryLockEventDispatcher()) {
      switch (t.button) {
        case 0:
          this._buttons |= ws.Left;
          break;
        case 1:
          this._buttons |= ws.Middle;
          break;
        case 2:
          this._buttons |= ws.Right;
          break;
      }
      if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
        const e = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), i = this._getEventModifiers(t);
        zi._activeEventDispatcher.injectMouseDownEvent(
          e.x,
          e.y,
          t.button,
          this._buttons,
          i,
          this._viewKey
        ), this._dragStarted = !0;
      }
    }
  }
  _processMouseMove(t, e = !1) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!e && !this._tryLockEventDispatcher()) && this._processInput) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      zi._activeEventDispatcher !== null && zi._activeEventDispatcher.injectMouseMoveEvent(
        i.x,
        i.y,
        Te.None,
        this._buttons,
        n,
        this._viewKey
      );
    }
  }
  _processMouseUp(t, e = !1) {
    switch (t.button) {
      case 0:
        this._buttons &= ~ws.Left;
        break;
      case 1:
        this._buttons &= ~ws.Middle;
        break;
      case 2:
        this._buttons &= ~ws.Right;
        break;
    }
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && (t.stopPropagation(), this._processInput)) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      zi._activeEventDispatcher.injectMouseUpEvent(
        i.x,
        i.y,
        t.button,
        this._buttons,
        n,
        this._viewKey
      ), this._buttons === ws.None && (this._dragStarted = !1, this._captureInput = !1, e && this._unlockEventDispatcher());
    }
  }
  _processMousewheel(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      let e;
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      this._isFirefox ? e = t.detail > 0 ? -1 : 1 : e = t.wheelDelta > 0 ? 1 : -1, this._eventDispatcher.injectMousewheelEvent(
        i.x,
        i.y,
        e,
        this._buttons,
        n,
        this._viewKey
      );
    }
  }
  _processDocumentMouseMove(t) {
    this._dragStarted && this._captureInput && this._processMouseMove(t, !0);
  }
  _processDocumentMouseUp(t) {
    this._dragStarted && this._captureInput && this._processMouseUp(t, !0);
  }
  _processMouseLeave(t) {
    if (this._dragStarted) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processMouseEnter(t) {
    this._tryLockEventDispatcher() && this._dragStarted && (this._captureInput = !1);
  }
  //KeyEvents
  _isFunctionKey(t) {
    return 112 <= t.which && t.which <= 123;
  }
  _processKeyDownEvent(t) {
    if (this._isFunctionKey(t) || t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const e = this._getEventModifiers(t);
      this._eventDispatcher.injectKeyDownEvent(
        // tslint:disable-next-line:deprecation
        t.which,
        e,
        this._viewKey
      );
    }
  }
  _processKeyUpEvent(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const e = this._getEventModifiers(t);
      this._eventDispatcher.injectKeyUpEvent(
        // tslint:disable-next-line:deprecation
        t.which,
        e,
        this._viewKey
      );
    }
  }
  //Touch Events
  _processTouchStart(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let e = 0; e < t.changedTouches.length; e++) {
        const i = t.changedTouches.item(e), n = this._convertEventCoordsToTargetCoords(i.clientX, i.clientY, !1);
        this._eventDispatcher.injectTouchStartEvent(
          i.identifier,
          n.x,
          n.y,
          this._buttons,
          this._viewKey
        );
      }
  }
  _processTouchMove(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let e = 0; e < t.changedTouches.length; e++) {
        const i = t.changedTouches.item(e), n = this._convertEventCoordsToTargetCoords(i.clientX, i.clientY, !1);
        this._eventDispatcher.injectTouchMoveEvent(
          i.identifier,
          n.x,
          n.y,
          this._buttons,
          this._viewKey
        );
      }
  }
  _processTouchEnd(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let e = 0; e < t.changedTouches.length; e++) {
        const i = t.changedTouches.item(e), n = this._convertEventCoordsToTargetCoords(i.clientX, i.clientY, !1);
        this._eventDispatcher.injectTouchEndEvent(
          i.identifier,
          n.x,
          n.y,
          this._buttons,
          this._viewKey
        );
      }
  }
  //PointerEvents
  _processPointerDown(t) {
    if (this._tryLockEventDispatcher() && (this._setButtons(t), t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)) {
      const e = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), i = this._getEventModifiers(t);
      t.pointerType === "mouse" ? zi._activeEventDispatcher.injectMouseDownEvent(
        e.x,
        e.y,
        t.button,
        this._buttons,
        i,
        this._viewKey
      ) : t.pointerType === "touch" && zi._activeEventDispatcher.injectTouchStartEvent(
        t.pointerId,
        e.x,
        e.y,
        this._buttons,
        this._viewKey
      ), this._pointerUp = !1;
    }
  }
  _processPointerMove(t, e = !1) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!e && !this._tryLockEventDispatcher()) && (this._setButtons(t), this._processInput)) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      zi._activeEventDispatcher !== null && (t.pointerType === "mouse" ? zi._activeEventDispatcher.injectMouseMoveEvent(
        i.x,
        i.y,
        t.button,
        this._buttons,
        n,
        this._viewKey
      ) : t.pointerType === "touch" && zi._activeEventDispatcher.injectTouchMoveEvent(
        t.pointerId,
        i.x,
        i.y,
        this._buttons,
        this._viewKey
      ));
    }
  }
  _processPointerUp(t, e = !1) {
    if (this._setButtons(t), t.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && this._processInput) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      t.pointerType === "mouse" && !this._pointerUp ? zi._activeEventDispatcher.injectMouseUpEvent(
        i.x,
        i.y,
        t.button,
        this._buttons,
        n,
        this._viewKey
      ) : t.pointerType === "touch" && this._eventDispatcher.injectTouchEndEvent(
        t.pointerId,
        i.x,
        i.y,
        this._buttons,
        this._viewKey
      ), this._buttons === ws.None && (this._dragStarted = !1, this._captureInput = !1, this._pointerUp = !0, e && this._unlockEventDispatcher());
    }
  }
  _processPointerEnter(t) {
    this._tryLockEventDispatcher() && (this._pointerUp || (this._captureInput = !1));
  }
  _processPointerLeave(t) {
    if (!this._pointerUp) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processDocumentPointerMove(t) {
    !this._pointerUp && this._captureInput && this._processPointerMove(t, !0);
  }
  _processDocumentPointerUp(t) {
    !this._pointerUp && this._captureInput && this._processPointerUp(t, !0);
  }
  _getEventModifiers(t) {
    let e = Mi.None;
    return t.altKey && (e |= Mi.Alt), t.ctrlKey && (e |= Mi.Control), t.shiftKey && (e |= Mi.Shift), t.metaKey && (e |= Mi.Command), e;
  }
};
zi._activeEventDispatcher = null, zi._activeEventDispatcherLocked = !1, zi._activeOffset = null;
let Kf = zi;
class $p {
  /** @hidden */
  constructor(t, e, i, n, r, o) {
    this._backfacesVisible = !1, this._initialCamera = null, this._lineVisibility = !0, this._faceVisibility = !0, this._boundingCalculationIgnoresInvisible = !0, this._backgroundColorTop = null, this._backgroundColorBottom = null, this._drawMode = cr.WireframeOnShaded, this._ambientOcclusionEnabled = !1, this._ambientOcclusionRadius = 0.03, this._antiAliasingMode = pg.SMAA, this._lightingEnabled = !0, this._ambientLightColor = yt.black(), this._massageExtremeCameras = !0, this._bloomEnabled = !1, this._bloomThreshold = 0, this._bloomThresholdRampWidth = 0, this._bloomIntensityScale = 0, this._bloomLayers = [], this._simpleShadowEnabled = !1, this._simpleReflectionEnabled = !1, this._silhouetteEnabled = !1, this._hardEdgesEnabled = !1, this._imageBasedLightingEnabled = !0, this._lineJitterEnabled = !1, this._hiddenLineSettings = new Ax(), this._projectionMode = ri.Orthographic, this._drawStrategy = C_.FixedFramerate, this._id = o.id, this._viewer = t, this._engine = e, this._callbackManager = i, this._interpolationManager = r, this.operatorManager = new Ix(t), this._eventDispatcher = new Mx(this._callbackManager, this.operatorManager), this._model = t.model, this._statistics = new Dx(i, t), this._navCube = new qf(t, this), this._axisTriad = new $f(t, this), this.overlayManager = new V_(this, t.model, i, this._engine), this._inputMonitor = new Kf(o.id, this._eventDispatcher, n), this._inputMonitor.setOptions(t.config), this._determineInitialAxes = sl(t.config.calculateDefaultViewAxes, !0);
    const l = new Eh();
    sl(
      t.config.disableAutomaticFloorplanOverlay,
      !1
    ) && (l.autoActivate = Wo.Never), this.floorplanManager = new td(
      t,
      t.model,
      this.overlayManager,
      this._engine,
      l
    ), this._initEvents(), this._initEventDispatcher(), this.domElements = o.domElements;
  }
  get id() {
    return this._id;
  }
  get inputMonitor() {
    return this._inputMonitor;
  }
  _initEvents() {
    this._callbackManager.bind({
      _resetAssemblyTreeBegin: async () => {
        this._initialCamera = null;
      },
      _firstAttachment: async (t) => {
        if (t === vs.Direct)
          return this._massageInitialCamera(!1);
      },
      _firstModelLoaded: (t, e) => e ? Promise.resolve() : this._massageInitialCamera(!1),
      _modelSwitched: async (t) => {
        if (!t)
          return await this._massageInitialCamera(!1), this._setInitialView(0);
      },
      hwfParseComplete: () => this._massageInitialCamera(!0),
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.sheetManager.isDrawingSheetActive())
          return this._model.setViewAxes(new m(0, 0, 1), new m(0, 1, 0)), this.setViewOrientation(Ct.Front, 0);
      },
      _sessionStarted: async () => {
        this._initEffects();
      },
      _drawContextCreated: (t) => {
        t == this._id && this._initEffects();
      },
      viewAxes: (t, e) => {
        this._updateGroundPlane(t, e), this._updateImageBasedLightingOrientation(t, e);
      }
    });
  }
  _initEffects() {
    this.setBloomIntensityScale(1), this.setBloomThreshold(0.65), this.setBloomThresholdRampWidth(0.1), this.setBloomLayers([
      {
        intensity: 0.5,
        blurSamples: 5,
        blurInterval: [1 / 400, Xs.ProportionOfHeight]
      },
      {
        intensity: 0.5,
        blurSamples: 5,
        blurInterval: [1 / 200, Xs.ProportionOfHeight]
      },
      {
        intensity: 0.5,
        blurSamples: 9,
        blurInterval: [1 / 100, Xs.ProportionOfHeight]
      },
      {
        intensity: 1,
        blurSamples: 9,
        blurInterval: [1 / 50, Xs.ProportionOfHeight]
      },
      {
        intensity: 2,
        blurSamples: 11,
        blurInterval: [1 / 25, Xs.ProportionOfHeight]
      }
    ]), this.setGroundPlane({
      normal: new m(0, 0, 1),
      followViewAxes: !0
    }), this.setSimpleShadowColor(yt.black()), this.setSimpleShadowOpacity(0.65), this.setSimpleShadowResolution(512), this.setSimpleShadowBlurSamples(5), this.setSimpleShadowBlurInterval(1), this.setSimpleShadowInteractiveUpdateEnabled(), this.setSimpleReflectionOpacity(0.65), this.setSimpleReflectionFadeAngle(10), this.setSimpleReflectionBlurSamples(9), this.setSimpleReflectionBlurInterval(1, Xs.Pixels), this.setSimpleReflectionAttenuation(
      0,
      1,
      Af.ProportionOfBoundingHeight
    ), this.setSilhouetteColor(yt.black()), this.setSilhouetteOpacity(1), this.setSilhouetteThreshold(0.05), this.setSilhouetteThresholdRampWidth(0.025), this.setHardEdgeColor(yt.black()), this.setHardEdgeOpacity(1), this.setHardEdgeThreshold(30), this.setHardEdgeThresholdRampWidth(20), this.setImageBasedLightingIntensity(1), this.setImageBasedLightingOrientation({
      matrix: new wt(),
      followViewAxes: !0
    }), this.setGoochBlue(0.55), this.setGoochYellow(0.3), this.setGoochBaseColorProminence(0.25), this.setGoochLuminanceShiftStrength(0.5), this.setLineJitterInstanceCount(4), this.setLineJitterFrequency(5), this.setLineJitterRadius(5e-3), this.setToonShadingBandCount(3), this.setToonShadingSpecularFactor(1);
  }
  _initEventDispatcher() {
    const t = new Mg(this._viewer, this), e = new oy(this._viewer, this), i = new uy(this._viewer, this), n = new hy(this._viewer, this), r = new ry(
      this._viewer,
      this,
      t,
      e,
      i
    ), o = new cy(this._viewer, this), l = new id(this._viewer, this), h = new ly(
      this._viewer,
      o,
      l
    ), u = new ay(this._viewer, this), f = new Ly(this._viewer, this, this._viewer.noteTextManager), g = new Py(this._viewer, this), y = new Ry(this._viewer, this), _ = new Iy(this._viewer, this), x = new My(this._viewer, this), b = new Sy(this._viewer, this), I = new Cy(this._viewer, this), C = new fy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), M = new py(
      this._viewer,
      this,
      this._viewer.measureManager
    ), P = new _y(
      this._viewer,
      this,
      this._viewer.measureManager
    ), O = new yy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), B = new dy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), j = new gy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), F = new vy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), K = new wy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), J = new Oy(this._viewer, this, this._viewer.noteTextManager), rt = new Ay(
      this._viewer,
      this,
      this._viewer.cuttingManager
    ), ft = new Dy(this._viewer, this), H = new Ny(this._viewer, this), $ = new ky(this._viewer, this), D = new Ty(this._viewer, this), R = new Fy(this._viewer, this);
    this.operatorManager._registerOperator(ve.Navigate, r), this.operatorManager._registerOperator(ve.Orbit, t), this.operatorManager._registerOperator(ve.Pan, e), this.operatorManager._registerOperator(ve.Zoom, i), this.operatorManager._registerOperator(ve.WindowZoom, n), this.operatorManager._registerOperator(ve.Walk, o), this.operatorManager._registerOperator(ve.KeyboardWalk, l), this.operatorManager._registerOperator(ve.WalkMode, h), this.operatorManager._registerOperator(ve.Turntable, u), this.operatorManager._registerOperator(ve.Select, f), this.operatorManager._registerOperator(ve.AreaSelect, g), this.operatorManager._registerOperator(ve.RayDrillSelect, y), this.operatorManager._registerOperator(ve.RedlineCircle, _), this.operatorManager._registerOperator(ve.RedlineText, x), this.operatorManager._registerOperator(ve.RedlineRectangle, b), this.operatorManager._registerOperator(ve.RedlinePolyline, I), this.operatorManager._registerOperator(ve.MeasureEdgeLength, C), this.operatorManager._registerOperator(
      ve.MeasureFaceFaceDistance,
      M
    ), this.operatorManager._registerOperator(
      ve.MeasureLineLineAngle,
      P
    ), this.operatorManager._registerOperator(
      ve.MeasurePointPointDistance,
      O
    ), this.operatorManager._registerOperator(
      ve.MeasureBodyBodyDistance,
      B
    ), this.operatorManager._registerOperator(
      ve.MeasureFaceFaceAngle,
      j
    ), this.operatorManager._registerOperator(
      ve.MeasurePolylineDistance,
      F
    ), this.operatorManager._registerOperator(
      ve.MeasurePolygonArea,
      K
    ), this.operatorManager._registerOperator(ve.Note, J), this.operatorManager._registerOperator(ve.Cutting, rt), this.operatorManager._registerOperator(ve.Handle, ft), this.operatorManager._registerOperator(ve.NavCube, H), this.operatorManager._registerOperator(ve.AxisTriad, $), this.operatorManager._registerOperator(ve.Floorplan, D), this.operatorManager._registerOperator(ve.SpaceMouse, R), r.setBimNavigationEnabled(!1), C.addMapping(Te.Left), M.addMapping(Te.Left), O.addMapping(Te.Left), O.addMapping(Te.Left, Mi.Alt), j.addMapping(Te.Left), n.addMapping(Te.Left), rt.addMapping(Te.Left), g.addMapping(Te.Left), g.addMapping(Te.Left, Mi.Control), this.operatorManager.set(ve.Navigate, 0), this.operatorManager.set(ve.Select, 1), this.operatorManager.push(ve.Cutting), this.operatorManager.push(ve.Handle), this.operatorManager.push(ve.NavCube), this.operatorManager.push(ve.AxisTriad), this.operatorManager.push(ve.Floorplan), this.operatorManager.push(ve.SpaceMouse);
  }
  /** hidden */
  injectViewOrientationChangeEvent() {
    this._eventDispatcher.injectViewOrientationChangeEvent(this._id);
  }
  async _massageInitialCamera(t) {
    this._initialCamera === null && (this._initialCamera = await this._engine.getCameraPromise(this._id), this._projectionMode = this._initialCamera.getProjection(), this._determineInitialAxes && !this._viewer.sheetManager.isDrawingSheetActive() && !this._model.viewAxesHaveBeenSet() && this._determineViewAxes(this._initialCamera), t && (await this.fitWorld(), this._initialCamera = this.getCamera()));
  }
  /**
   * Sets the line visibility for the view.
   * @param lineVisibility indicates whether to draw lines.
   */
  setLineVisibility(t) {
    return this._setLineVisibility(t), Promise.resolve();
  }
  _setLineVisibility(t) {
    t !== this._lineVisibility && (this._lineVisibility = t, this._engine.setLineVisibility(this._id, t));
  }
  /**
   * Gets the line visibility for the view.
   * @returns whether lines are currently being drawn.
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets the face visibility for the view.
   * @param faceVisibility indicates whether to draw faces.
   */
  setFaceVisibility(t) {
    return this._setFaceVisibility(t), Promise.resolve();
  }
  _setFaceVisibility(t) {
    return t !== this._faceVisibility && (this._faceVisibility = t, this._engine.setFaceVisibility(this._id, t)), Promise.resolve();
  }
  /**
   * Gets the face visibility for the view.
   * @returns whether faces are currently being drawn.
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets the projection mode.
   * @param projection the projection mode to set.
   */
  setProjectionMode(t) {
    this._projectionMode !== t && (this._projectionMode = t, this._engine.isInit() && this._engine.setProjection(this._id, t), this._eventDispatcher.injectViewOrientationChangeEvent(this._id));
  }
  /**
   * Gets the projection mode.
   * @returns The current projection mode.
   */
  getProjectionMode() {
    return this._projectionMode;
  }
  /**
   * Gets the draw strategy.
   * @returns The current draw strategy.
   */
  getDrawStrategy() {
    return this._drawStrategy;
  }
  /**
   * Gets the view matrix.
   * @returns The current view matrix.
   */
  getViewMatrix() {
    const t = this.getCamera();
    return this._engine.getViewMatrix(t);
  }
  /**
   * Gets the projection matrix.
   * @returns The current projection matrix.
   */
  getProjectionMatrix() {
    const t = this.getCamera();
    return this._engine.getProjectionMatrix(t, this.id);
  }
  /**
   * This is equivalent to (projectionMatrix * viewMatrix).
   * @returns The current full camera matrix.
   */
  getFullCameraMatrix() {
    const t = this.getCamera();
    return this._engine.getFullCameraMatrix(t, this.id);
  }
  /**
   * Creates a ray based on a viewport position.
   * @param point The (X, Y) viewport position.
   * @returns The ray if it was generated, otherwise null.
   */
  raycastFromPoint(t) {
    const e = this.getCanvasSize(), i = this.getCamera(), n = this._engine.getViewMatrix(i), r = this._engine.getProjectionMatrix(i, this.id), o = new m(t.x, e.y - t.y, 0), l = this._unproject(o, r, n, e);
    if (l === null)
      return null;
    o.z = 0.5;
    const h = this._unproject(o, r, n, e);
    if (h === null)
      return null;
    const u = m.subtract(h, l).normalize();
    return new vr(l, u);
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _unproject(t, e, i, n) {
    const r = wt.multiply(i, e), o = wt.inverse(r);
    if (o === null)
      return null;
    const l = new Ur(t.x, t.y, t.z, 1);
    l.x = l.x / n.x, l.y = l.y / n.y, l.x = l.x * 2 - 1, l.y = l.y * 2 - 1, l.z = l.z * 2 - 1;
    const h = o.transform4(l);
    return h.w === 0 ? null : (h.scale(1 / h.w), new m(h.x, h.y, h.z));
  }
  _rectifySelectionItem(t) {
    const e = t.getInclusionKey(), i = t.getNodeId(), n = this._model._getNodeFromInstanceInc(!1, e, i, !0);
    t._setNodeId(n);
  }
  // TODO:
  // Mark this as hidden and rename to have an underscore?
  // Or is it too late? It wouldn't be a bad thing
  // to expose this functionality as public.
  /** @hidden */
  isOutsideCanvasArea(t) {
    const e = this.getCanvasSize();
    return t.x < 0 || t.y < 0 || t.x >= e.x || t.y >= e.y;
  }
  /**
   * Performs a picking operation from the given position on the canvas. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new No();
    const i = await this._engine.pickFromScreen(
      this._id,
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    return i ? (this._rectifySelectionItem(i), i) : yi.create();
  }
  /**
   * Performs a picking operation from the given position on the canvas. All candidate entities are returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new No();
    const i = await this._engine.pickAllFromScreen(
      this._id,
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    for (const n of i)
      this._rectifySelectionItem(n);
    return i;
  }
  /**
   * Performs a composite picking operation.  This operation will return all candidate Node entities according to the PickConfig.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async compositePickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new No();
    const { faceItem: i, lineItem: n, pointItem: r } = await this._engine.compositePickFromScreen(
      this._id,
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    ), o = new ed(i, n, r);
    return o.faceItem !== null && this._rectifySelectionItem(o.faceItem), o.lineItem !== null && this._rectifySelectionItem(o.lineItem), o.pointItem !== null && this._rectifySelectionItem(o.pointItem), new ed(
      o.faceItem,
      o.lineItem,
      o.pointItem
    );
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromRay(t, e) {
    const i = await this._engine.pickFromRay(t, e);
    return i ? (this._rectifySelectionItem(i), i) : yi.create();
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromRay(t, e) {
    const i = await this._engine.pickAllFromRay(t, e);
    for (const n of i)
      this._rectifySelectionItem(n);
    return i;
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coodinate in CSS pixel space for the selection window.
   * @param areaCssMax The maximum coodinate in CSS pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginScreenSelectByArea(t, e, i) {
    if (this.isOutsideCanvasArea(t) || this.isOutsideCanvasArea(e))
      throw new No();
    return this._engine.beginScreenAreaSelection(this._id, t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in CSS pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in CSS pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginRayDrillSelection(t, e, i) {
    if (this.isOutsideCanvasArea(t))
      throw new No();
    return this._engine.beginRayDrillSelection(this._id, t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for prioritizing returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._engine.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginSphereSelection(t, e, i) {
    const n = pl(t);
    return this._engine.beginSphereSelection(n, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._endIncrementalSelection(t), Promise.resolve();
  }
  _endIncrementalSelection(t) {
    this._engine.endIncrementalSelection(t);
  }
  /**
   * Returns the next batch of geometry selected by the supplied selection context.
   * @param handle The handle to an active area selection context.
   * @returns Returns selected items. If the resulting list is null then there are no more items to select.
   */
  async advanceIncrementalSelection(t) {
    try {
      const e = await this._engine.advanceIncrementalSelection(t);
      if (e === null)
        return null;
      const i = this._viewer.selectionManager, n = [];
      for (const r of e) {
        this._rectifySelectionItem(r);
        const o = r, l = o.getNodeId();
        if (!l)
          continue;
        i._incrementalBlacklistedInstanceNodes.has(l) || n.push(o);
      }
      return n;
    } catch (e) {
      throw e.scFunction === "advanceVolumeSelection" ? new so() : e;
    }
  }
  /**
   * Projects a 3d world space point to a 3d screen space point.
   * @param point world space point to be projected.
   * @param camera if a camera is provided, its projection and view matrix will be used.
   * @returns point projected into 3d screen space.
   */
  projectPoint(t, e) {
    e === void 0 && (e = this.getCamera());
    const i = e.getProjectionMatrix(this._viewer, this), n = e.getViewMatrix(this._viewer), r = this.getCanvasSize(), o = this._project(t, i, n, r);
    return o.y = r.y - o.y, o;
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _project(t, e, i, n) {
    const r = new Ur(t.x, t.y, t.z, 1);
    i.transform4(r, r), e.transform4(r, r);
    const o = r.w <= 0, l = r.w;
    return r.w <= 0 && (r.w = 1e-3), r.scale(1 / r.w), r.x = r.x * 0.5 + 0.5, r.y = r.y * 0.5 + 0.5, r.z = r.z * 0.5 + 0.5, r.x = r.x * n.x, r.y = r.y * n.y, o && (r.z = l), new m(r.x, r.y, r.z);
  }
  /**
   * Unprojects a 2d screen space point to a 3d world space point.
   * @param point 2d screen space
   * @param z z value, default 0
   * @returns point world space point
   */
  unprojectPoint(t, e) {
    const i = this.getCanvasSize(), n = this.getProjectionMatrix(), r = this.getViewMatrix(), o = new m(t.x, i.y - t.y, e);
    return this._unproject(o, n, r, i);
  }
  /**
   * Creates a normalized window position in the range of (-1, 1) for a given point in window space.
   * @returns the normalized window position
   */
  pointToWindowPosition(t) {
    const e = this._engine.getCanvasSize(this.id);
    return new X(t.x / e.x * 2 - 1, 1 - t.y / e.y * 2);
  }
  /**
   * Sets the camera that will be used for the initial camera view.
   * @param camera
   */
  setInitialCamera(t) {
    this._initialCamera = t.copy();
  }
  /**
   * Sets the current camera
   * @param camera the camera to set
   * @param duration camera transition time in milliseconds
   */
  setCamera(t, e = 0) {
    return t === null ? !1 : this._setCameraImpl(t, e).unsafeValue;
  }
  /** @hidden */
  _setCameraPromise(t, e) {
    return this._setCameraImpl(t, e).readyPromise;
  }
  _setCameraImpl(t, e) {
    if (e > 0)
      return this._interpolateCamera(t, e);
    if (this._engine.isInit()) {
      const i = t.getProjection();
      this._projectionMode !== i && this.setProjectionMode(i), this._engine.setCamera(this._id, t);
      const n = this._viewer.markupManager._setActiveMarkupView(this, null);
      return this._callbackManager.trigger("camera", t, this), To(!0, n);
    } else
      return To(!1, Promise.resolve());
  }
  _interpolateCamera(t, e) {
    if (this._engine.isInit()) {
      const i = this.getCamera();
      if (i.equals(t))
        return this._viewer.markupManager && this._viewer.markupManager._update(), To(!1, Promise.resolve());
      {
        this._callbackManager.trigger("transitionBegin", e, this);
        const n = vi(), r = () => {
          this._eventDispatcher.injectViewOrientationChangeEvent(this._id), this._callbackManager.trigger("transitionEnd", this), n.resolve();
        };
        return this._interpolationManager.start(
          new Ex(i, t, e, r, this)
        ), To(!0, n);
      }
    } else
      return To(!1, Promise.resolve());
  }
  /**
   * Updates camera properties individually. This method should be used to incrementally update camera properties individually.
   * @param camera the camera to set.
   * @returns updated camera object.
   */
  updateCamera(t) {
    return t = this._engine.updateCamera(this._id, t), this._callbackManager.trigger("camera", t, this), t;
  }
  /**
   * Resets the camera to the initial view of the model when first loaded.
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   */
  resetCamera(t = cs) {
    return this._setInitialView(t);
  }
  /**
   * Unsets the default camera. After this is called the next camera to be set will be the new default
   */
  unsetDefaultCamera() {
    this._engine.markCameraAsEmpty(this._id);
  }
  /**
   * Gets the current camera
   * @returns the current camera
   */
  getCamera() {
    if (this._engine.isInit())
      return this._engine.getCamera(this._id);
    throw new oe("getCamera() called before sceneReady");
  }
  /**
   * Returns a camera set to a ViewOrientation
   * @param orientation The desired view orientation for the camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   */
  async getViewOrientationCamera(t, e, i = !0) {
    const n = this.getCamera(), r = n.getUp().copy().normalize(), o = this._model.getViewAxes(), l = o.upVector.copy(), h = o.frontVector.copy();
    e === void 0 ? e = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    ) : this._fitCameraToBounding(n, e);
    const u = e.center();
    let f = u.copy();
    const g = u.copy(), y = m.subtract(n.getPosition(), n.getTarget()).length(), _ = m.subtract(n.getPosition(), u).length();
    let x = new m(0, 0, 1), b = new m(-1, 0, 0);
    l !== null && (x = l.copy()), h !== null && (b = h.copy());
    const I = b.copy().scale(-1), C = b.copy(), M = x.copy(), P = x.copy().scale(-1), O = m.cross(M, I), B = O.copy().scale(-1), j = (rt) => {
      const ft = m.subtract(g, rt);
      let H = x;
      const $ = wr(ft, x);
      ($ === 0 || $ === 180) && (H = b);
      const D = m.cross(ft, H), R = D.copy().negate(), U = m.cross(ft, D), it = U.copy().negate(), at = [D, R, U, it];
      let mt = 1 / 0, Nt = D;
      for (const lt of at) {
        const ot = wr(r, lt);
        ot <= mt && (mt = ot, Nt = lt);
      }
      return Nt.normalize();
    };
    let F = null;
    switch (t) {
      case Ct.Front:
        f = m.add(g, C);
        break;
      case Ct.Back:
        f = m.add(g, I);
        break;
      case Ct.Left:
        f = m.add(g, O);
        break;
      case Ct.Right:
        f = m.add(g, B);
        break;
      case Ct.Bottom:
        f = m.add(g, P), F = I.copy();
        break;
      case Ct.Top:
        f = m.add(g, M), F = I.copy();
        break;
      case Ct.FrontTop:
      case Ct.TopFront:
        f = m.add(g, m.add(C, M)), F = m.add(I, M).normalize();
        break;
      case Ct.FrontTopLeft:
      case Ct.LeftTopFront:
      case Ct.TopLeftFront:
        f = m.add(g, m.add(C, m.add(O, M))), F = m.add(I, m.add(B, M)).normalize();
        break;
      case Ct.Iso:
      case Ct.FrontTopRight:
      case Ct.RightTopFront:
      case Ct.TopRightFront:
        f = m.add(g, m.add(C, m.add(B, M))), F = m.add(I, m.add(O, M)).normalize();
        break;
      case Ct.FrontLeft:
      case Ct.LeftFront:
        f = m.add(g, m.add(C, O));
        break;
      case Ct.FrontRight:
      case Ct.RightFront:
        f = m.add(g, m.add(C, B));
        break;
      case Ct.FrontBottom:
      case Ct.BottomFront:
        f = m.add(g, m.add(C, P)), F = m.add(C, M).normalize();
        break;
      case Ct.FrontBottomLeft:
      case Ct.LeftBottomFront:
      case Ct.BottomLeftFront:
        f = m.add(g, m.add(C, m.add(O, P))), F = m.add(C, m.add(O, M)).normalize();
        break;
      case Ct.FrontBottomRight:
      case Ct.RightBottomFront:
      case Ct.BottomRightFront:
        f = m.add(g, m.add(C, m.add(B, P))), F = m.add(C, m.add(B, M)).normalize();
        break;
      case Ct.BackTop:
      case Ct.TopBack:
        f = m.add(g, m.add(I, M)), F = m.add(C, M).normalize();
        break;
      case Ct.BackTopLeft:
      case Ct.LeftTopBack:
      case Ct.TopLeftBack:
        f = m.add(g, m.add(I, m.add(O, M))), F = m.add(C, m.add(B, M)).normalize();
        break;
      case Ct.BackTopRight:
      case Ct.RightTopBack:
      case Ct.TopRightBack:
        f = m.add(g, m.add(I, m.add(B, M))), F = m.add(C, m.add(O, M)).normalize();
        break;
      case Ct.BackLeft:
      case Ct.LeftBack:
        f = m.add(g, m.add(I, O));
        break;
      case Ct.BackRight:
      case Ct.RightBack:
        f = m.add(g, m.add(I, B));
        break;
      case Ct.BackBottom:
      case Ct.BottomBack:
        f = m.add(g, m.add(I, P)), F = m.add(I, M).normalize();
        break;
      case Ct.BackBottomLeft:
      case Ct.LeftBottomBack:
      case Ct.BottomLeftBack:
        f = m.add(g, m.add(I, m.add(O, P))), F = m.add(I, m.add(O, M)).normalize();
        break;
      case Ct.BackBottomRight:
      case Ct.RightBottomBack:
      case Ct.BottomRightBack:
        f = m.add(g, m.add(I, m.add(B, P))), F = m.add(I, m.add(B, M)).normalize();
        break;
      case Ct.LeftBottom:
      case Ct.BottomLeft:
        f = m.add(g, m.add(O, P)), F = m.add(O, M).normalize();
        break;
      case Ct.LeftTop:
      case Ct.TopLeft:
        f = m.add(g, m.add(O, M)), F = m.add(B, M).normalize();
        break;
      case Ct.RightBottom:
      case Ct.BottomRight:
        f = m.add(g, m.add(B, P)), F = m.add(B, M).normalize();
        break;
      case Ct.RightTop:
      case Ct.TopRight:
        f = m.add(g, m.add(B, M)), F = m.add(O, M).normalize();
        break;
      default:
        qr();
    }
    i || (F = j(f)), F === null && (F = x);
    const K = m.add(
      m.subtract(f, u).normalize().scale(_),
      u
    ), J = m.add(
      m.subtract(f, u).normalize().scale(_ - y),
      u
    );
    return n.setPosition(K), n.setTarget(J), n.setUp(F), n;
  }
  /**
   * Sets the view to a standard orientation.
   * @param orientation The desired view orientation for the camera.
   * @param duration The number of milliseconds used to transition to the new camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   * @param preserveModelUp Indicates whether the camera up will be set according to model up or current camera.
   */
  async setViewOrientation(t, e = cs, i, n = !0) {
    const r = await this.getViewOrientationCamera(t, i, n);
    i === void 0 ? await this.fitWorld(e, r) : await this.fitBounding(i, e, r), this._callbackManager.trigger("viewOrientation", t, this);
  }
  /**
   * Centers the camera on a specified node id.
   * @param nodeId
   * @param duration the number of milliseconds to transition to the new camera.
   */
  async centerCameraOnNode(t, e = 0, i = this.getCamera()) {
    const r = (await this._model.getNodesBounding([t])).center(), o = i.getPosition(), l = i.getTarget(), h = m.subtract(l, r);
    if (o.subtract(h), i.setPosition(o), i.setTarget(r), e > 0)
      return this._setCameraPromise(i, e);
    this.setCamera(i);
  }
  /** @hidden */
  async _setInitialView(t) {
    if (!this._initialCamera)
      return this.fitWorld(t);
    if (t > 0)
      return this._setCameraPromise(this._initialCamera, t);
    this.setCamera(this._initialCamera), this._eventDispatcher.injectViewOrientationChangeEvent(this._id);
  }
  /**
   * Returns the size of the viewer canvas.
   * @returns the current size of the viewer canvas.
   */
  getCanvasSize() {
    return this._engine.getCanvasSize(this.id);
  }
  /**
   * Sets the display for the default statistic overlay.
   * @param visible whether the default statistics overlay should be drawn.
   */
  async setStatisticsDisplayVisibility(t) {
    t ? await this._statistics.showDisplay() : this._statistics.hideDisplay();
  }
  /**
   * Returns the background colors of the canvas.
   * @returns the canvas background colors.
   */
  getBackgroundColor() {
    var i, n;
    const t = ((i = this._backgroundColorTop) == null ? void 0 : i.copy()) ?? null, e = ((n = this._backgroundColorBottom) == null ? void 0 : n.copy()) ?? null;
    return new Vy(t, e);
  }
  /**
   * Sets the viewer background color to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * Background Transparency is only available with client-side rendering.
   * To re-enable a transparent background, pass null to the parameters of this function.
   *
   * When draw mode is set to {@link DrawMode.HiddenLine}, the background color is defined in {@link HiddenLineSettings HiddenLineSettings}.
   * See {@link HiddenLineSettings.setBackgroundColor HiddenLineSettings.setBackgroundColor}.
   * @param top the top color for the the background gradient.
   * @param bottom the bottom color for the the background gradient.
   * @returns a promise that resolves when the operation has completed.
   */
  setBackgroundColor(t = null, e = null) {
    return this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null, this._drawMode !== cr.HiddenLine && !this._viewer.sheetManager.isDrawingSheetActive() && this._engine.setBackgroundGradient(
      this._id,
      this._backgroundColorTop,
      this._backgroundColorBottom
    ), Promise.resolve();
  }
  /**
   * Hides all nodes except those specified. Also fits the camera to those nodes' bounding box.
   * @param nodeIds An array of the node IDs to be isolated.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @param fitNodes If true, then the view is fitted around the isolated nodes.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   */
  async isolateNodes(t, e = cs, i = !0, n = null) {
    const r = this._model.getAbsoluteRootNode(), o = /* @__PURE__ */ new Map();
    o.set(r, !1);
    for (const l of t)
      o.set(l, !0);
    if (await this._model.setNodesVisibilities(o, n), i)
      return this.fitNodes(t, e);
  }
  /**
   * Fits the camera to the bounding box containing the node ids.
   * @param nodeIds Array of node ids to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitNodes(t, e = cs) {
    const i = await this._model.getNodesBounding(t);
    return this.fitBounding(i, e);
  }
  /**
   * Fits the view to the model bounding box.
   * @param duration the number of milliseconds to transition to the new camera.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitWorld(t = 0, e) {
    e || (e = this.getCamera());
    const i = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    );
    await this.fitBounding(i, t, e);
  }
  _fitCameraToBounding(t, e) {
    if (this._viewer.sheetManager.isDrawingSheetActive()) {
      const i = e.extents(), n = e.center(), r = new m(n.x, n.y, e.min.z + i.length());
      t.setProjection(ri.Orthographic), t.setPosition(r), t.setTarget(n), t.setWidth(i.x * 1.25), t.setHeight(i.y * 1.25);
    } else {
      const n = e.extents().length();
      if (n !== 0) {
        const r = t.getWidth(), o = m.subtract(t.getPosition(), t.getTarget()), l = o.length(), h = n * l / r, u = e.center(), f = m.add(u, o.normalize().scale(h));
        t.setTarget(u), t.setPosition(f), t.setWidth(n), t.setHeight(n);
      } else {
        const r = m.subtract(t.getPosition(), t.getTarget()), o = e.center(), l = m.add(o, r);
        t.setTarget(o), t.setPosition(l);
      }
    }
  }
  /**
   * Fits the camera to the bounding box.
   * @param bounding bounding box to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitBounding(t, e = cs, i = this.getCamera()) {
    if (t) {
      if (t.isDegenerate() || this._fitCameraToBounding(i, t), e > 0)
        return this._setCameraPromise(i, e);
      this.setCamera(i);
    }
  }
  /**
   * Sets whether backfaces should be rendered in the scene.
   * @param visible Boolean value indicating whether backfaces should be rendered.
   * @returns Promise that is resolved when this operation has completed.
   */
  setBackfacesVisible(t) {
    return this._backfacesVisible = t, this._engine.setBackFacesVisible(this._id, t), Promise.resolve();
  }
  /**
   * Gets whether backfaces are being rendered in the scene.
   * @returns Boolean value indicating whether backfaces are being rendered in the scene.
   */
  getBackfacesVisible() {
    return this._backfacesVisible;
  }
  /**
   * Sets the drawing mode for the scene.
   * @param drawMode The drawing mode to set.
   */
  setDrawMode(t) {
    return this._setDrawMode(t), Promise.resolve();
  }
  _setDrawMode(t) {
    switch (this._drawMode = t, this._drawMode !== cr.HiddenLine && this.setBackgroundColor(this._backgroundColorTop, this._backgroundColorBottom), t) {
      case cr.Wireframe:
        this._engine.setDrawMode(this._id, fr.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!1);
        break;
      case cr.Shaded:
        this._engine.setDrawMode(this._id, fr.Highlight), this._setLineVisibility(!1), this._setFaceVisibility(!0);
        break;
      case cr.WireframeOnShaded:
        this._engine.setDrawMode(this._id, fr.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case cr.HiddenLine:
        {
          const e = this._hiddenLineSettings.getBackgroundColor();
          this._setLineVisibility(!0), this._setFaceVisibility(!0), this._engine.enableHiddenLineRendering(this._id, this._hiddenLineSettings), this._engine.setBackgroundGradient(
            this._id,
            e.top,
            e.bottom
          );
        }
        break;
      case cr.XRay:
        this._engine.setDrawMode(this._id, fr.XRay), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case cr.Gooch:
        this._engine.setDrawMode(this._id, fr.Gooch);
        break;
      case cr.Toon:
        this._setLineVisibility(!1), this._engine.setDrawMode(this._id, fr.Toon);
    }
  }
  /**
   * @returns The current draw mode
   */
  getDrawMode() {
    return this._drawMode;
  }
  /**
   * Sets the anti-aliasing mode for the scene.
   * @param antiAliasingMode
   */
  setAntiAliasingMode(t) {
    return this._setAntiAliasingMode(t), Promise.resolve();
  }
  _setAntiAliasingMode(t) {
    this._antiAliasingMode = t, this._engine.setAntiAliasingMode(this._id, t);
  }
  /**
   * Gets the anti-aliasing mode for the scene. The Default value is AntiAliasingMode.SMAA
   * @returns the current anti-aliasing mode.
   */
  getAntiAliasingMode() {
    return this._antiAliasingMode;
  }
  /**
   * @returns a [[HiddenLineSettings]] object.
   */
  getHiddenLineSettings() {
    return this._hiddenLineSettings;
  }
  /**
   * Sets whether ambient occlusion is enabled
   * @param enabled sets whether ambient occlusion will be enabled
   */
  setAmbientOcclusionEnabled(t = !0) {
    return this._setAmbientOcclusionEnabled(t), Promise.resolve();
  }
  _setAmbientOcclusionEnabled(t = !0) {
    this._ambientOcclusionEnabled = t, this._engine.setAmbientOcclusionEnabled(this._id, t);
  }
  /**
   * @returns boolean value indicating whether ambient occlusion is enabled
   */
  getAmbientOcclusionEnabled() {
    return this._ambientOcclusionEnabled;
  }
  /**
   * Sets the ambient occlusion radius. This value represents the maximum screen-proportional distance between two points such that one will cast a shadow on the other.
   * @param radius the ambient occlusion radius.
   */
  setAmbientOcclusionRadius(t) {
    return this._setAmbientOcclusionRadius(t), Promise.resolve();
  }
  _setAmbientOcclusionRadius(t) {
    this._ambientOcclusionRadius = t, this._engine.setAmbientOcclusionRadius(this._id, t);
  }
  /**
   * @returns the ambient occlusion radius
   */
  getAmbientOcclusionRadius() {
    return this._ambientOcclusionRadius;
  }
  /**
   * Sets whether lighting is enabled. When disabled, material colors
   * are drawn at full intensity.
   *
   * See also [[InstanceModifier.DoNotLight]], [[clearLights]].
   */
  setLightingEnabled(t = !0) {
    return this._setLightingEnabled(t), Promise.resolve();
  }
  _setLightingEnabled(t = !0) {
    this._lightingEnabled = t, this._engine.setLightingEnabled(this._id, t);
  }
  /**
   * Returns whether lighting is enabled.
   *
   * See also [[setLightingEnabled]].
   */
  getLightingEnabled() {
    return this._lightingEnabled;
  }
  /**
   * Sets how transparent objects are blended.
   */
  setTransparencyMode(t) {
    this._engine.setTransparencyMode(this._id, t);
  }
  /**
   * Sets the opacity of unselected items in x-ray mode.
   * @param opacity a number between 0 and 1
   * @param element the type of element to which the opacity will apply.
   * If unspecified, the opacity will apply to all element types.
   */
  setXRayOpacity(t, e) {
    return this._setXRayOpacity(t, e), Promise.resolve();
  }
  _setXRayOpacity(t, e) {
    this._engine.setXRayOpacity(this._id, t, e);
  }
  /**
   * Sets how transparent (unselected) objects are blended in x-ray mode.
   */
  setXRayTransparencyMode(t) {
    return this._setXRayTransparencyMode(t), Promise.resolve();
  }
  _setXRayTransparencyMode(t) {
    this._engine.setXRayTransparencyMode(this._id, t);
  }
  /**
   * Sets the color applied to nodes in x-ray mode.
   * By default, the color is unset.
   *
   * See [[unsetXRayColor]].
   *
   * @param element the type of geometry to apply the color to
   * @param color the color to apply
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  setXRayColor(t, e, i = rh.Selected) {
    return this._engine.setXRayColor(this._id, i, t, e), Promise.resolve();
  }
  /**
   * Unsets the color applied to selected items in x-ray mode.
   * Selected items will be displayed without overriding their colors.
   *
   * See [[setXRayColor]].
   *
   * @param element the type of geometry affected by the change
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  unsetXRayColor(t, e = rh.Selected) {
    return this._engine.unsetXRayColor(this._id, e, t);
  }
  /**
   * Sets the value to use as the blue tone in Gooch shading.
   * @param blue the blue tone.  This value should be in the range [0,1]
   */
  setGoochBlue(t) {
    this._goochBlue = t, this._engine.setGoochBlue(this._id, t);
  }
  /**
   * Gets the value to use as the blue tone in Gooch shading.
   */
  getGoochBlue() {
    return this._goochBlue;
  }
  /**
   * Sets the prominence of the object's base color in Gooch shading.
   * @param prominence this scalar value determines the amount of the object's base color is applied to the final shaded color.
   */
  setGoochBaseColorProminence(t) {
    this._goochBaseColorProminence = t, this._engine.setGoochBaseColorProminence(this._id, t);
  }
  /**
   * Gets the prominence of the object's base color in Gooch shading.
   */
  getGoochBaseColorProminence() {
    return this._goochBaseColorProminence;
  }
  /**
   * Sets the value to use as the yellow tone in Gooch shading.
   * @param yellow the yellow tone. This value should be in the range [0,1]
   *
   */
  setGoochYellow(t) {
    this._goochYellow = t, this._engine.setGoochYellow(this._id, t);
  }
  /**
   * Gets the value to use as the yellow tone in Gooch shading.
   */
  getGoochYellow() {
    return this._goochYellow;
  }
  /**
   * Sets the number of discrete shading bands that will be used when toon shading is enabled.  Each band represents a shade between dark and light which will control the final color of the pixel based on its light intensity.  The default band count is 3.
   */
  setToonShadingBandCount(t) {
    this._toonBandCount = t, this._engine.setToonShadingBandCount(this._id, t);
  }
  /**
   * Gets the current number of discrete shading bands that will be used when toon shading is enabled.
   */
  getToonShadingBandCount() {
    return this._toonBandCount;
  }
  /**
   * Sets a scale factor which controls the size of specular highlights when toon shading is enabled.  The default value is 1.0.
   */
  setToonShadingSpecularFactor(t) {
    this._toonSpecularFactor = t, this._engine.setToonShadingSpecularFactor(this._id, t);
  }
  /**
   * Gets the current toon shading specular scale factor.
   */
  getToonShadingSpecularFactor() {
    return this._toonSpecularFactor;
  }
  /**
   * Sets the strength of the luminance shift in Gooch shading.
   * @param shiftStrength this scalar values determines the amount of luminance shift that is applied to the object's base color
   */
  setGoochLuminanceShiftStrength(t) {
    this._goochLuminanceShiftStrength = t, this._engine.setGoochLuminanceShiftStrength(this._id, t);
  }
  /**
   * Gets the strength of the luminance shift in Gooch shading.
   */
  getGoochLuminanceShiftStrength() {
    return this._goochLuminanceShiftStrength;
  }
  /**
   * Sets the diameter of rendered points. (default: 1, ScreenPixels) See [[PointSizeUnit]].
   */
  setPointSize(t, e) {
    return this._setPointSize(t, e), Promise.resolve();
  }
  _setPointSize(t, e) {
    this._engine.setPointSize(this._id, t, e);
  }
  /**
   * Gets the diameter of rendered points. See [[PointSizeUnit]].
   */
  getPointSize() {
    return this._engine.getPointSize(this._id);
  }
  /**
   * Controls the appearance of rendered points. (default: Square) See [[PointShape]].
   */
  setPointShape(t) {
    return this._setPointShape(t), Promise.resolve();
  }
  _setPointShape(t) {
    this._engine.setPointShape(this._id, t);
  }
  /**
   * Gets the PointShape. See [[PointShape]]
   */
  getPointShape() {
    return this._engine.getPointShape(this._id);
  }
  /**
   * Enables or disables eye-dome lighting for point clouds. (default: disabled)
   */
  setEyeDomeLightingEnabled(t = !0) {
    return this._setEyeDomeLightingEnabled(t), Promise.resolve();
  }
  _setEyeDomeLightingEnabled(t = !0) {
    this._engine.setEyeDomeLightingEnabled(this._id, t);
  }
  /**
   * @returns boolean value indicating if eye-dome lighting is enabled or disabled.
   */
  getEyeDomeLightingEnabled() {
    return this._engine.getEyeDomeLightingEnabled(this._id);
  }
  /**
   * Sets the diameter of the blur filter used in eye-dome lighting for point clouds.
   * Setting the value to 0 will disable blurring. (default: 7)
   */
  setEyeDomeLightingBlurSamples(t) {
    return this._setEyeDomeLightingBlurSamples(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurSamples(t) {
    this._engine.setEyeDomeLightingBlurSamples(this._id, t);
  }
  /**
   * Returns the diameter of the blur filter used in eye-dome lighting for point clouds.
   * A value of 0 means that blurring is disabled.
   */
  getEyeDomeLightingBlurSamples() {
    return this._engine.getEyeDomeLightingBlurSamples(this._id);
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds. (default: 1)
   */
  setEyeDomeLightingBlurInterval(t) {
    return this._setEyeDomeLightingBlurInterval(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurInterval(t) {
    this._engine.setEyeDomeLightingBlurInterval(this._id, t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds.
   */
  getEyeDomeLightingBlurInterval() {
    return this._engine.getEyeDomeLightingBlurInterval(this._id);
  }
  /**
   * Controls the maximum Z-distance between samples taken by the blur filter used in eye-dome
   * lighting for point clouds. The value is taken as a proportion of the screen size.
   * Decreasing the value will result in sharper edges, and increasing the value will result
   * in softer edges. (default: .03)
   */
  setEyeDomeLightingBlurEdgeDistance(t) {
    return this._setEyeDomeLightingBlurEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurEdgeDistance(t) {
    this._engine.setEyeDomeLightingBlurEdgeDistance(this._id, t);
  }
  /**
   * Returns a value that controls the maximum Z-distance between samples taken by
   * the blur filter used in eye-dome lighting for point clouds.
   * The value is a proportion of the screen size.
   */
  getEyeDomeLightingBlurEdgeDistance() {
    return this._engine.getEyeDomeLightingBlurEdgeDistance(this._id);
  }
  /**
   * Controls the shading contrast in eye-dome lighting for point clouds. The value is taken
   * as a number of pixels. Increasing the value will result in overall lighter shading, and
   * decreasing the value will result in overall darker shading. (default: 2)
   */
  setEyeDomeLightingShadingEdgeDistance(t) {
    return this._setEyeDomeLightingShadingEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingShadingEdgeDistance(t) {
    this._engine.setEyeDomeLightingShadingEdgeDistance(this._id, t);
  }
  /**
   * Returns a value that controls the shading contrast in eye-dome lighting for point clouds.
   * The value is a number of pixels.
   */
  getEyeDomeLightingShadingEdgeDistance() {
    return this._engine.getEyeDomeLightingShadingEdgeDistance(this._id);
  }
  /**
   * Sets the opacity of the shading rendered by eye-dome lighting for point clouds. (default: 1)
   * @param value A number in the range [0,1].
   */
  setEyeDomeLightingOpacity(t) {
    return this._setEyeDomeLightingOpacity(t), Promise.resolve();
  }
  _setEyeDomeLightingOpacity(t) {
    this._engine.setEyeDomeLightingOpacity(this._id, t);
  }
  /**
   * Returns the opacity of the shading rendered by eye-dome lighting for point clouds.
   * The value is in the range [0,1].
   */
  getEyeDomeLightingOpacity() {
    return this._engine.getEyeDomeLightingOpacity(this._id);
  }
  /**
   * Sets whether or not bounding calculations by this View object ignores invisible geometry.
   */
  setBoundingCalculationIgnoresInvisible(t) {
    this._boundingCalculationIgnoresInvisible = t;
  }
  /**
   * @returns whether or not bounding calculations by this View object ignores invisible geometry.
   */
  getBoundingCalculationIgnoresInvisible() {
    return this._boundingCalculationIgnoresInvisible;
  }
  /**
   * Sets whether intermediate frames of an incremental draw will be displayed. (default: true)
   *
   * If false, the image will only be displayed once completely drawn, except immediately
   * after certain operations, such as setting the camera. To disable these exceptions,
   * call [[setInteractiveDrawDelay]] with a value of 0.
   */
  setDisplayIncompleteFrames(t) {
    return this._setDisplayIncompleteFrames(t), Promise.resolve();
  }
  _setDisplayIncompleteFrames(t) {
    this._engine.setDisplayIncompleteFrames(t, this.id);
  }
  /**
   * Sets whether to change cad view cameras with extreme values to functionally identical cameras with
   * better behavior. This should be disabled if it is important that cameras have their authored values
   * Default: true
   * @param value Whether to modify cameras
   */
  setMassageExtremeCameras(t) {
    this._massageExtremeCameras = t;
  }
  getMassageExtremeCameras() {
    return this._massageExtremeCameras;
  }
  /**
   * Sets how long after certain operations, such as setting the camera, to wait before
   * starting a redraw. This delay exists in order to prevent flicker during continuous
   * interaction. The initial value is 200ms.
   * @param value The delay in milliseconds
   */
  setInteractiveDrawDelay(t) {
    return this._setInteractiveDrawDelay(t), Promise.resolve();
  }
  _setInteractiveDrawDelay(t) {
    this._engine.setInteractiveDrawDelay(t, this.id);
  }
  /**
   * Sets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * Setting this to `false` may improve periodic framerate dips caused by such adjustments.
   * @param enable
   */
  setInteractiveDrawLimitIncreaseEnabled(t) {
    this._engine.setInteractiveDrawLimitIncreaseEnabled(t, this.id);
  }
  /**
   * Gets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * @return boolean value indicating whether this feature is enabled or not
   */
  getInteractiveDrawLimitIncreaseEnabled() {
    return this._engine.getInteractiveDrawLimitIncreaseEnabled(this.id);
  }
  /**
   * Sets a minimum frame rate that will be maintained by this views.
   * The view will use various culling techniques in order to maintain the value passed in.
   *
   * Passing `0` will cause the entire scene to be drawn for every frame.
   * @param minimum The minimum framerate to be maintained by this view.
   */
  setMinimumFramerate(t) {
    this._engine.setMinimumFramerate(this.id, t);
  }
  /**
   * Forces the a redraw of this view.
   * @param callback A function to be called once the draw is complete.
   * This is provided instead of a `Promise` to ensure the callback is
   * called before the start of another redraw.
   */
  redraw(t) {
    if (t) {
      const e = (i) => {
        i === this.id && (this._callbackManager.unbind({ _drawComplete: e }), t());
      };
      this._callbackManager.bind({ _drawComplete: e });
    }
    this._engine.redraw(this.id);
  }
  getNavCube() {
    return this._navCube;
  }
  get navCube() {
    return this._navCube;
  }
  getAxisTriad() {
    return this._axisTriad;
  }
  get axisTriad() {
    return this._axisTriad;
  }
  _determineViewAxes(t) {
    const e = t.getUp().normalize(), i = m.subtract(t.getTarget(), t.getPosition()).normalize();
    let n = kp(e), r = kp(i);
    n === null && r === null ? (n = new m(0, 1, 0), r = new m(0, 0, 1)) : n === null ? r.y === 0 ? n = new m(0, 1, 0) : n = new m(0, 0, 1) : r === null && (n.z === 0 ? r = new m(0, 0, 1) : r = new m(0, 1, 0));
    try {
      this._model.setViewAxes(r, n);
    } catch {
    }
  }
  /**
   * Sets the color of the ambient light applied to the scene.
   * This is a constant source of light that affects every point
   * in the scene in the same way regardless of position
   * or surface normal.
   *
   * See also [[getAmbientLightColor]].
   */
  setAmbientLightColor(t) {
    this._ambientLightColor = t, this._engine.setAmbientLightColor(this._id, t);
  }
  /**
   * Gets the color of the ambient light applied to the scene.
   *
   * See also [[setAmbientLightColor]].
   */
  getAmbientLightColor() {
    return this._ambientLightColor;
  }
  /**
   * Get the list of light keys in the scene.
   * @returns The list of light keys in the scene.
   */
  getLightKeys() {
    return this._engine.getLightKeys(this._id);
  }
  /**
   * Get a Light given its key if it exists.
   * @param key The key of the light to get.
   * @returns A Light given its key if it exists.
   */
  getLight(t) {
    return this._engine.getLight(this._id, t);
  }
  /**
   * Removes all lights from the scene. When there are no lights,
   * material colors are drawn at full intensity. This has the same
   * visual effect as calling `setLightingEnabled(false)`.
   *
   * See also:
   *  - [[InstanceModifier.DoNotLight]]
   *  - [[setLightingEnabled]]
   */
  clearLights() {
    this._engine.clearLights(this._id);
  }
  /**
   * Adds a light to the scene. The returned promise may be rejected if
   * there are too many lights in the scene. See [[Light]].
   *
   * See also:
   *  - [[clearLights]]
   *  - [[removeLight]]
   *  - [[updateLight]]
   *  - [[setAmbientLightColor]]
   */
  addLight(t) {
    return this._engine.addLight(this._id, t);
  }
  /**
   * removes a light from the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[updateLight]]
   */
  removeLight(t) {
    this._engine.removeLight(this._id, t);
  }
  /**
   * Updates a light in the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[removeLight]]
   */
  updateLight(t, e) {
    this._engine.updateLight(this._id, t, e);
  }
  /**
   * Sets whether bloom is enabled.
   *
   * See [[getBloomEnabled]].
   */
  setBloomEnabled(t = !0) {
    this._engine.setBloomEnabled(this._id, t), this._bloomEnabled = t;
  }
  /**
   * Returns whether bloom is enabled.
   *
   * See [[setBloomEnabled]].
   */
  getBloomEnabled() {
    return this._bloomEnabled;
  }
  /**
   * Sets the minimum luminance value a pixel must have for it to
   * contribute to bloom. The value should be in the range `[0,1]`.
   *
   * See [[getBloomThreshold]], [[setBloomThresholdRampWidth]].
   */
  setBloomThreshold(t) {
    this._engine.setBloomThreshold(this._id, t), this._bloomThreshold = t;
  }
  /**
   * Returns the minimum luminance value a pixel must have for it to
   * contribute to bloom.
   *
   * See [[setBloomThreshold]], [[getBloomThresholdRampWidth]].
   */
  getBloomThreshold() {
    return this._bloomThreshold;
  }
  /**
   * Sets how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * If the pixel's luminance value does not exceed
   * the threshold by at least the amount set by this function,
   * the pixel's contribution will be diminished based on how close
   * its luminance value is to the threshold.
   *
   * See [[getBloomThresholdRampWidth]].
   */
  setBloomThresholdRampWidth(t) {
    this._engine.setBloomThresholdRampWidth(this._id, t), this._bloomThresholdRampWidth = t;
  }
  /**
   * Returns how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * See [[setBloomThresholdRampWidth]].
   */
  getBloomThresholdRampWidth() {
    return this._bloomThresholdRampWidth;
  }
  /**
   * Sets the intensity of the bloom effect. This value is multiplied
   * by the intensities of the individual layers set by [[setBloomLayers]].
   *
   * See [[getBloomIntensityScale]].
   */
  setBloomIntensityScale(t) {
    this._engine.setBloomIntensityScale(this._id, t), this._bloomIntensityScale = t;
  }
  /**
   * Gets the intensity of the bloom effect.
   *
   * See [[setBloomIntensityScale]].
   */
  getBloomIntensityScale() {
    return this._bloomIntensityScale;
  }
  /**
   * Sets the number of layers in the bloom effect and the layers'
   * attributes.
   *
   * The bloom effect is achieved by applying a luminance filter to the
   * source image, then progressively downsampling, blurring, and adding
   * the results together. The result of each downsample/blur operation is
   * fed into the next, which is executed at half the resolution of the
   * previous. The number of stages and the behavior of each stage
   * are controlled by this function.
   *
   * See [[BloomLayerInfo]], [[getBloomLayers]].
   */
  setBloomLayers(t) {
    const e = $c(t);
    for (const i of e)
      i.intensity === void 0 && (i.intensity = 1), i.blurSamples === void 0 && (i.blurSamples = 9), i.blurInterval === void 0 && (i.blurInterval = [1, Xs.Pixels]);
    this._engine.setBloomLayers(this._id, e), this._bloomLayers = e;
  }
  /**
   * Returns an array of objects describing each layer in the bloom
   * effect.
   *
   * See [[setBloomLayers]].
   */
  getBloomLayers() {
    return $c(this._bloomLayers);
  }
  /**
   * Enables a visual comparison of two sets of nodes. The nodes specified
   * by `nodeIdSet1` are filled with one color, the nodes specified by
   * `nodeIdSet2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endComparison]].
   *
   * @param nodeIdSet1 the nodes to compare against `nodeIdSet2`
   * @param nodeIdSet2 the nodes to compare against `nodeIdSet1`
   * @param config settings controlling the behavior of the comparison
   */
  startComparison(t, e, i) {
    const n = this._model._getModelStructure(), r = n.gatherInstanceIncsFromNodeIds(
      t,
      Wt.All,
      Vt.None
    ), o = n.gatherInstanceIncsFromNodeIds(
      e,
      Wt.All,
      Vt.None
    );
    this._engine.startComparison(this._id, r, o, i);
  }
  /**
   * Disables a visual comparison of two sets of nodes enabled by
   * [[startComparison]].
   */
  endComparison() {
    this._engine.endComparison(this._id);
  }
  /**
   * Enables or disables a full-scene shadow projected onto an
   * invisible ground plane.
   *
   * See also:
   *  - [[getSimpleShadowEnabled]]
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowOpacity]]
   *  - [[setGroundPlane]]
   *  - [[setSimpleShadowResolution]]
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *
   * @param value Whether simple shadows should be enabled.
   */
  setSimpleShadowEnabled(t = !0) {
    this._simpleShadowEnabled = t, this._engine.setSimpleShadowEnabled(this._id, t);
  }
  /**
   * Returns whether simple shadows are enabled.
   *
   * See [[setSimpleShadowEnabled]].
   */
  getSimpleShadowEnabled() {
    return this._simpleShadowEnabled;
  }
  /**
   * Sets the color of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param color The color to set.
   */
  setSimpleShadowColor(t) {
    this._simpleShadowColor = t.copy(), this._engine.setSimpleShadowColor(this._id, t);
  }
  /**
   * Returns the color of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowColor() {
    return this._simpleShadowColor.copy();
  }
  /**
   * Sets the opacity of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleShadowOpacity(t) {
    this._simpleShadowOpacity = t, this._engine.setSimpleShadowOpacity(this._id, t);
  }
  /**
   * Returns the opacity of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowOpacity() {
    return this._simpleShadowOpacity;
  }
  /**
   * Defines the invisible ground plane onto which simple shadows
   * and reflections are projected.
   *
   * See also:
   *  - [[getGroundPlane]]
   *  - [[setSimpleShadowEnabled]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param plane The plane to set.
   */
  setGroundPlane(t) {
    this._groundPlane = { ...t }, this._updateGroundPlane();
  }
  _updateGroundPlane(t, e) {
    if (!(this._groundPlane.followViewAxes && (t !== void 0 && e !== void 0 || this._model.viewAxesHaveBeenSet()))) {
      this._engine.setGroundPlane(this._id, this._groundPlane.normal, this._groundPlane.position);
      return;
    }
    if (t === void 0 || e === void 0) {
      const h = this._model.getViewAxes();
      t = h.frontVector, e = h.upVector;
    }
    const i = t.copy().negate(), n = e, r = m.cross(n, i), o = wt.createFromBasis(i, r, n), l = new m(0, 0, 0);
    o.transform(this._groundPlane.normal, l), this._engine.setGroundPlane(this._id, l, this._groundPlane.position);
  }
  /**
   * Returns information about the invisible ground plane onto which
   * simple shadows and reflections are projected.
   *
   * See also:
   *  - [[setGroundPlane]]
   */
  getGroundPlane() {
    return { ...this._groundPlane };
  }
  /**
   * Sets the width and height in pixels of the texture image into which
   * simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param pixels The resolution to set.
   */
  setSimpleShadowResolution(t) {
    this._simpleShadowResolution = t, this._engine.setSimpleShadowResolution(this._id, t);
  }
  /**
   * Returns the width and height in pixels of the texture image
   * into which simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowResolution() {
    return this._simpleShadowResolution;
  }
  /**
   * Sets the diameter of the blur filter used for simple shadows.
   * Setting the value to `0` will disable blurring.
   *
   * See also:
   *  - [[getSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The number of samples.
   */
  setSimpleShadowBlurSamples(t) {
    this._simpleShadowBlurSamples = t, this._engine.setSimpleShadowBlurSamples(this._id, t);
  }
  /**
   * Returns the diameter of the blur filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurSamples() {
    return this._simpleShadowBlurSamples;
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter
   * used for simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The interval to set.
   */
  setSimpleShadowBlurInterval(t) {
    this._simpleShadowBlurInterval = t, this._engine.setSimpleShadowBlurInterval(this._id, t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur
   * filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurInterval() {
    return this._simpleShadowBlurInterval;
  }
  /**
   * Enables or disables updates to simple shadows during user
   * interaction.
   *
   * See also:
   *  - [[getSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  setSimpleShadowInteractiveUpdateEnabled(t = !0) {
    this._simpleShadowInteractiveUpdateEnabled = t, this._engine.setSimpleShadowInteractiveUpdateEnabled(this._id, t);
  }
  /**
   * Returns whether simple shadows will be updated during user
   * interaction.
   *
   * See also:
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowInteractiveUpdateEnabled() {
    return this._simpleShadowInteractiveUpdateEnabled;
  }
  /**
   * Enables or disables silhouette edges.
   *
   * Silhouette edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getSilhouetteEnabled]]
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   *
   * @param value Whether silhouette edges should be enabled.
   */
  setSilhouetteEnabled(t = !0) {
    this._silhouetteEnabled = t, this._engine.setSilhouetteEnabled(this._id, t);
  }
  /**
   * Returns whether silhouette edges are enabled.
   *
   * Silhouette edges are always enabled in hidden line mode, regardless
   * of the return value.
   *
   * See [[setSilhouetteEnabled]].
   */
  getSilhouetteEnabled() {
    return this._silhouetteEnabled;
  }
  /**
   * Sets the color of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The color to set.
   */
  setSilhouetteColor(t) {
    this._silhouetteColor = t.copy(), this._engine.setSilhouetteColor(this._id, t);
  }
  /**
   * Returns the color of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteColor() {
    return this._silhouetteColor.copy();
  }
  /**
   * Sets the opacity of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The opacity to set.
   */
  setSilhouetteOpacity(t) {
    this._silhouetteOpacity = t, this._engine.setSilhouetteOpacity(this._id, t);
  }
  /**
   * Returns the opacity of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteOpacity() {
    return this._silhouetteOpacity;
  }
  /**
   * Sets the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[getSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  setSilhouetteThreshold(t) {
    this._silhouetteThreshold = t, this._engine.setSilhouetteThreshold(this._id, t);
  }
  /**
   * Returns the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  getSilhouetteThreshold() {
    return this._silhouetteThreshold;
  }
  /**
   * Controls how quickly edges fade as z-distance between pixels
   * decreases.
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn
   * at full opacity.
   *
   * See also:
   * - [[getSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  setSilhouetteThresholdRampWidth(t) {
    this._silhouetteThresholdRampWidth = t, this._engine.setSilhouetteThresholdRampWidth(this._id, t);
  }
  /**
   * Returns the value set by [[setSilhouetteThresholdRampWidth]].
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteThresholdRampWidth() {
    return this._silhouetteThresholdRampWidth;
  }
  /**
   * Enables or disables hard edges. Hard edges are edges between two
   * faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getHardEdgesEnabled]]
   * - [[setHardEdgeColor]]
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   *
   * @param value Whether hard edges should be enabled.
   */
  setHardEdgesEnabled(t = !0) {
    this._hardEdgesEnabled = t, this._engine.setHardEdgesEnabled(this._id, t);
  }
  /**
   * Returns whether hard edges are enabled. Hard edges are edges between
   * two faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode, regardless of the
   * return value.
   *
   * See [[setHardEdgesEnabled]].
   */
  getHardEdgesEnabled() {
    return this._hardEdgesEnabled;
  }
  /**
   * Sets the color of hard edges.
   *
   * See also:
   * - [[getHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The color to set.
   */
  setHardEdgeColor(t) {
    this._hardEdgeColor = t.copy(), this._engine.setHardEdgeColor(this._id, t);
  }
  /**
   * Returns the color of hard edges.
   *
   * See also:
   * - [[setHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeColor() {
    return this._hardEdgeColor.copy();
  }
  /**
   * Sets the opacity of hard edges.
   *
   * See also:
   * - [[getHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The opacity to set.
   */
  setHardEdgeOpacity(t) {
    this._hardEdgeOpacity = t, this._engine.setHardEdgeOpacity(this._id, t);
  }
  /**
   * Returns the opacity of hard edges.
   *
   * See also:
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeOpacity() {
    return this._hardEdgeOpacity;
  }
  /**
   * Sets the angle threshold for hard edges. Edges will be drawn between
   * two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[getHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param degrees The threshold to set.
   */
  setHardEdgeThreshold(t) {
    this._hardEdgeThreshold = t, this._engine.setHardEdgeThreshold(this._id, t);
  }
  /**
   * Returns the angle threshold for hard edges. Edges will be drawn
   * between two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The threshold to set.
   */
  getHardEdgeThreshold() {
    return this._hardEdgeThreshold;
  }
  /**
   * Controls how quickly edges fade as the angle between adjacent faces
   * decreases.
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn at full
   * opacity.
   *
   * See also:
   * - [[getHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  setHardEdgeThresholdRampWidth(t) {
    this._hardEdgeThresholdRampWidth = t, this._engine.setHardEdgeThresholdRampWidth(this._id, t);
  }
  /**
   * Returns the value set by [[setHardEdgeThresholdRampWidth]].
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeThresholdRampWidth() {
    return this._hardEdgeThresholdRampWidth;
  }
  /**
   * Enables or disables simple reflections projected onto an
   * invisible ground plane.
   *
   * See also:
   * - [[getSimpleReflectionEnabled]]
   * - [[setSimpleReflectionOpacity]]
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionBlurInterval]]
   * - [[setSimpleReflectionFadeAngle]]
   */
  setSimpleReflectionEnabled(t = !0) {
    this._simpleReflectionEnabled = t, this._engine.setSimpleReflectionEnabled(this._id, t);
  }
  /**
   * Returns whether simple reflections are enabled.
   *
   * See [[setSimpleReflectionEnabled]].
   */
  getSimpleReflectionEnabled() {
    return this._simpleReflectionEnabled;
  }
  /**
   * Sets the distance between samples taken by the blur filter used for
   * simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param value The interval to set.
   * @param unit The unit in which the `value` argument is specified.
   */
  setSimpleReflectionBlurInterval(t, e = Xs.Pixels) {
    this._simpleReflectionBlurInterval = [t, e], this._engine.setSimpleReflectionBlurInterval(this._id, t, e);
  }
  /**
   * Returns the distance between samples taken by the blur filter used
   * for simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurInterval() {
    return [this._simpleReflectionBlurInterval[0], this._simpleReflectionBlurInterval[1]];
  }
  /**
   * Sets the diameter of the blur filter used for simple reflections.
   * Setting the value less than or equal to `1` will disable blurring.
   *
   * See also:
   * - [[getSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  setSimpleReflectionBlurSamples(t) {
    this._simpleReflectionBlurSamples = t, this._engine.setSimpleReflectionBlurSamples(this._id, t);
  }
  /**
   * Returns the diameter of the blur filter used for simple reflections.
   * A value less than or equal to `1` means that blurring is disabled.
   *
   * See also:
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurSamples() {
    return this._simpleReflectionBlurSamples;
  }
  /**
   * Sets the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * Settings the value to `0` will disable the fading effect.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[getSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   *
   * @param degrees The angle in degrees.
   */
  setSimpleReflectionFadeAngle(t) {
    this._simpleReflectionFadeAngle = t, this._engine.setSimpleReflectionFadeAngle(this._id, t);
  }
  /**
   * Returns the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * A value to `0` means that the fading effect is disabled.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[setSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionFadeAngle() {
    return this._simpleReflectionFadeAngle;
  }
  /**
   * Sets the opacity of simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleReflectionOpacity(t) {
    this._simpleReflectionOpacity = t, this._engine.setSimpleReflectionOpacity(this._id, t);
  }
  /**
   * Returns the opacity of simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionOpacity() {
    return this._simpleReflectionOpacity;
  }
  /**
   * Controls how objects drawn in simple reflections fade as they
   * move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[getSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param nearDistance The distance from the ground plane at which
   * objects begin to fade.
   * @param farDistance The distance from the ground plane at which
   * objects are completely faded.
   * @param unit The unit in which `nearDistance` and `farDistance` are
   * specified. If unspecified, [[SimpleReflectionAttenuationUnit.World]]
   * will be used.
   */
  setSimpleReflectionAttenuation(t, e, i = Af.World) {
    this._simpleReflectionAttenuation = {
      nearDistance: t,
      farDistance: e,
      unit: i
    }, this._engine.setSimpleReflectionAttenuation(t, e, i);
  }
  /**
   * Returns properties that control how objects drawn in simple
   * reflections fade as they move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[setSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @returns An object with the following properties:
   */
  // return type properties are listed by Typedoc
  getSimpleReflectionAttenuation() {
    return { ...this._simpleReflectionAttenuation };
  }
  /**
   * Tests whether the given points are visible by comparing them to
   * the depth buffer of the most-recently-drawn frame. Points that
   * are partially obscured by transparent objects are considered visible.
   *
   * If the test is to be run every time a frame is drawn,
   * [[setPointVisibilityTest]] should be used instead for proper
   * synchronization.
   *
   * @param points The points to test.
   * @returns A list of indices of the visible points.
   */
  testPointVisibility(t) {
    return this._engine.testPointVisibility(this._id, t);
  }
  /**
   * Sets a list of points whose visibility will be tested every time a
   * frame is drawn by comparing them to the frame's depth buffer. Points
   * that are partially obscured by transparent objects are considered
   * visible.
   *
   * The results are passed to the [[CallbackMap.frameDrawn]] callback so
   * that UI elements may be updated in sync with rendering.
   *
   * See also [[testPointVisibility]].
   *
   * @param points The points to test. An empty array will disable the test.
   */
  setPointVisibilityTest(t) {
    this._engine.setPointVisibilityTest(this._id, t);
  }
  /**
   * Sets whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[getImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingEnabled(t) {
    this._engine.setImageBasedLightingEnabled(this._id, t), this._imageBasedLightingEnabled = t;
  }
  /**
   * Returns whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingEnabled() {
    return this._imageBasedLightingEnabled;
  }
  /**
   * Sets the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[getImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingIntensity(t) {
    this._engine.setImageBasedLightingIntensity(this._id, t), this._imageBasedLightingIntensity = t;
  }
  /**
   * Returns the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingIntensity() {
    return this._imageBasedLightingIntensity;
  }
  _copyImageBasedLightingOrientation(t) {
    return { ...t, matrix: t.matrix.copy() };
  }
  /**
   * Sets the orientation of the image-based lighting environment applied
   * to physically-based materials.
   *
   * See also:
   * - [[getImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  setImageBasedLightingOrientation(t) {
    this._imageBasedLightingOrientation = this._copyImageBasedLightingOrientation(t), this._updateImageBasedLightingOrientation();
  }
  /**
   * Returns the orientation of the image-based lighting environment
   * applied to physically-based materials.
   *
   * See also:
   * - [[setImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  getImageBasedLightingOrientation() {
    return this._copyImageBasedLightingOrientation(this._imageBasedLightingOrientation);
  }
  _updateImageBasedLightingOrientation(t, e) {
    let i;
    if (this._imageBasedLightingOrientation.followViewAxes) {
      if (t === void 0 || e === void 0)
        if (this._model.viewAxesHaveBeenSet()) {
          const r = this._model.getViewAxes();
          t = r.frontVector, e = r.upVector;
        } else
          t = new m(0, 0, 1), e = new m(0, 1, 0);
      const n = wt.createFromBasis(
        m.cross(e, t),
        e,
        t
      );
      i = wt.multiply(this._imageBasedLightingOrientation.matrix, n);
    } else
      i = this._imageBasedLightingOrientation.matrix;
    this._engine.setImageBasedLightingMatrix(this._id, i);
  }
  /**
   * Sets the environment image used by image-based lighting applied to
   * physically-based materials.
   *
   * Passing `null` will cause the default environment image to be used.
   *
   * The image should be a cube map in KTX2 format with a space-separated
   * list of spherical harmonics coefficients stored under the "sh"
   * metadata key.
   *
   * A compatible image can be created from an equirectangular source
   * image (such as those found at [HDRI Haven](https://hdrihaven.com))
   * with the following process:
   *
   * - cmgen: https://github.com/google/filament
   * - ktx2ktx2, ktx2sc: https://github.com/KhronosGroup/KTX-Software/
   *
   * ```
   * cmgen -x out --format=ktx --size=256 in.hdr
   * ktx2ktx2 -o uncompressed.ktx2 out/out_ibl.ktx
   * ktxsc --zcmp 20 -o out.ktx2 uncompressed.ktx2
   * ```
   */
  setImageBasedLightingEnvironment(t) {
    t != null ? this._engine.setImageBasedLightingEnvironment(this._id, t) : this._engine.setImageBasedLightingEnvironmentToDefault(this._id);
  }
  /**
   * Sets whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterEnabled(t = !0) {
    this._engine.setLineJitterEnabled(this._id, t), this._lineJitterEnabled = t;
  }
  /**
   * Returns whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterEnabled() {
    return this._lineJitterEnabled;
  }
  /**
   * Sets the number of times lines are drawn when line jitter is enabled.
   * The default value is 4.
   *
   * Increasing this number can make the lines look more 'sketchy.'
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterInstanceCount(t) {
    this._engine.setLineJitterInstanceCount(this._id, t), this._lineJitterInstanceCount = t;
  }
  /**
   * Returns the number of times lines are drawn when line jitter is
   * enabled. The default value is 4.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterInstanceCount() {
    return this._lineJitterInstanceCount;
  }
  /**
   * Sets the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterRadius(t) {
    this._engine.setLineJitterRadius(this._id, t), this._lineJitterRadius = t;
  }
  /**
   * Returns the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterRadius() {
    return this._lineJitterRadius;
  }
  /**
   * Sets the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * Decreasing this value causes lines to appear smoother, while
   * increasing it causes lines to look more noisy.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  setLineJitterFrequency(t) {
    this._engine.setLineJitterFrequency(this._id, t), this._lineJitterFrequency = t;
  }
  /**
   * Returns the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  getLineJitterFrequency() {
    return this._lineJitterFrequency;
  }
}
class tl {
  constructor() {
    this._remappedModelKeys = /* @__PURE__ */ new Map(), this._remappedInclusionKeys = /* @__PURE__ */ new Map();
  }
  remapModel(t, e) {
    this._remappedModelKeys.set(e, t), this._remappedInclusionKeys.has(t) || this._remappedInclusionKeys.set(t, /* @__PURE__ */ new Map());
  }
  remapInclusion(t, e, i) {
    const n = this._remappedInclusionKeys.get(t);
    console.assert(n !== void 0), n.set(i, e);
  }
  getEffectiveModelKey(t) {
    const e = this._remappedModelKeys.get(t);
    return e !== void 0 ? e : t;
  }
  getEffectiveInclusionKey(t, e) {
    const i = this._remappedInclusionKeys.get(e);
    if (i !== void 0) {
      const n = i.get(t);
      if (n !== void 0)
        return n;
    }
    return t;
  }
}
async function Ox(s) {
  const t = [], i = {
    enterProductOccurrence: (n) => {
      n.hasPendingExternalModels() && t.push(n);
    }
  };
  return await Ln.walk(i, s, Vt.None), t;
}
class Rx {
  constructor() {
    this._currentTime = 0, this._stopTime = 0;
  }
  stop() {
    this._stopTime = this._currentTime;
  }
  isTicking() {
    return this._refreshCurrentTime(), this._remainingDuration() > 0;
  }
  tickFor(t) {
    this._refreshCurrentTime(), !(this._remainingDuration() >= t) && (this._stopTime = this._currentTime + t);
  }
  _remainingDuration() {
    return this._stopTime - this._currentTime;
  }
  _refreshCurrentTime() {
    this._currentTime = Date.now();
  }
}
const Lx = 4294967296;
class Fx {
  constructor() {
    this.prototypes = /* @__PURE__ */ new Map(), this.partDefinitions = /* @__PURE__ */ new Map();
  }
}
class Bx {
  constructor() {
    this.bodies = /* @__PURE__ */ new Map(), this.contexts = [];
  }
}
class Vx {
  constructor(t, e, i, n, r) {
    this._centralQueueClock = new Rx(), this._productOccurrences = /* @__PURE__ */ new Map(), this._pmis = /* @__PURE__ */ new Map(), this._cadViews = /* @__PURE__ */ new Map(), this._bodyInstances = /* @__PURE__ */ new Map(), this._pmiBodies = /* @__PURE__ */ new Map(), this._viewFrames = /* @__PURE__ */ new Map(), this._partDefinitions = /* @__PURE__ */ new Map(), this._representationItems = /* @__PURE__ */ new Map(), this._partToInstance = /* @__PURE__ */ new Map(), this._filters = [], this._layers = /* @__PURE__ */ new Map(), this._layersIds = /* @__PURE__ */ new Map(), this._nextLayerId = 0, this._genericTypeToNodes = /* @__PURE__ */ new Map(), this._genericIdToNodes = /* @__PURE__ */ new Map(), this._cadConfigurations = /* @__PURE__ */ new Set(), this._modelContents = /* @__PURE__ */ new Map(), this._inclusionContents = /* @__PURE__ */ new Map(), this._nodeDeletionBlackList = /* @__PURE__ */ new Set(), this._meshDeletionBlackList = /* @__PURE__ */ new Set(), this._dynamicNodeIdSeed = Ts, this._currentNodeIdOffset = 0, this._initialEmptyNodeIdOffsetObtained = !1, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._defaultCadViewsByConfiguration = /* @__PURE__ */ new Map(), this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._automaticMeasurementUnitScaling = !0, this._initiallyHiddenStayHidden = !0, this._nextLoadId = 0, this._activeLoadIds = /* @__PURE__ */ new Set(), this._requestedNodes = /* @__PURE__ */ new Map(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._isInitialized = !1, this._seenExternalModel = !1, this._config = { ...t }, this._engine = e, this._callbackManager = i, this._cuttingManager = n, this._model = r, this._isScs = this._engine.getSessionType() === nn.Scs, console.assert(!this._isScs || this._engine.getRendererType() === nh.Client);
  }
  initialize(t) {
    console.assert(this._rootLoadContext === void 0), console.assert(this._rootNode === void 0), console.assert(!this._isInitialized), this._isInitialized = !0, console.assert(this._centralQueue === void 0), this._centralQueue = new Uo(t.maxConcurrentAttachments(), !1), this._callbackManager.bind({
      _inputInteraction: (n, r) => {
        this._onUserInteraction(n, r);
      }
    }), this._rootLoadContext = new Ls(null, wa, null);
    const e = new Pn(
      new tl(),
      ba.OfInitialEmptyModel,
      !1,
      jr.Local,
      this._rootLoadContext
    );
    this._rootLoadContext.addAttachContext(e);
    const i = new $n(
      this,
      e,
      Ni.Local,
      Is.Local
    );
    e.addInclusionContext(i), this._rootNode = _e.createDynamic(
      this,
      i,
      "Models",
      null,
      null,
      !0
    ), i.addProductOccurrence(this._rootNode), console.assert(this._rootNode.isAbsoluteRoot()), this.preventNodeDeletion(this._rootLoadContext), this.preventNodeDeletion(e), this.preventNodeDeletion(i), this.preventNodeDeletion(this._rootNode), this._rootNode.markLoaded();
  }
  isInitialized() {
    return this._isInitialized;
  }
  getRootNode() {
    return this._rootNode;
  }
  getAbstractScEngine() {
    return this._engine;
  }
  generateDynamicNodeId() {
    return --this._dynamicNodeIdSeed;
  }
  newNodeIdOffset() {
    if (!this._initialEmptyNodeIdOffsetObtained)
      return this._initialEmptyNodeIdOffsetObtained = !0, console.assert(this._currentNodeIdOffset === 0), 0;
    const t = this._currentNodeIdOffset;
    return this._currentNodeIdOffset += Lx, t;
  }
  /**
   * Please don't use me. This was kept for legacy reasons with Erwan's tree, which
   * had fundamental design problems with NodeIds (because they could conflict).
   */
  getLowestAvailableNodeId() {
    return this._currentNodeIdOffset;
  }
  tryParseHeader(t) {
    const e = Zs.parseBinary(t);
    return e === null ? null : (this._containsDrawings = this._containsDrawings || e.isDrawing, this._isMeasurable = this._isMeasurable || e.isMeasurable, this._callbackManager.promiseTrigger("_modelStructureHeaderParsed", null, e).then(() => (this._callbackManager.trigger(
      "modelStructureHeaderParsed",
      e.originalFileName,
      e.originalFileType
    ), e)));
  }
  _isRegistered(t) {
    return this._productOccurrences.has(t) || this._pmis.has(t) || this._cadViews.has(t) || this._bodyInstances.has(t) || this._pmiBodies.has(t) || this._viewFrames.has(t) || this._partDefinitions.has(t) || this._representationItems.has(t);
  }
  registerProductOccurrence(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._productOccurrences.set(e, t);
      const i = ih(t);
      i !== null && this.registerGenericType(t, i);
      const n = t.getGenericId();
      n !== null && this.registerGenericGlobalId(t, n), t.isAConfigurationNode() && this._registerCadConfiguration(t), (t.isADrawingSheetNode() || t.isADrawingViewNode()) && (this._containsDrawings = !0);
    }
  }
  lookupProductOccurrence(t) {
    const e = this._productOccurrences.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmi(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._pmis.set(e, t);
  }
  lookupPmi(t) {
    const e = this._pmis.get(t);
    return e !== void 0 ? e : null;
  }
  registerCadView(t) {
    this._firstProductOccurrenceWithView === null && (this._firstProductOccurrenceWithView = t.getParent());
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._cadViews.set(e, t), t.isDefaultView() && this._defaultCadViewsByConfiguration.set(this._firstProductOccurrenceWithView, t);
  }
  getFirstProductOccurrenceWithView() {
    return this._firstProductOccurrenceWithView;
  }
  lookupCadView(t) {
    const e = this._cadViews.get(t);
    return e !== void 0 ? e : null;
  }
  registerBodyInstance(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._bodyInstances.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupBodyInstance(t) {
    const e = this._bodyInstances.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmiBody(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._pmiBodies.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupPmiBody(t) {
    const e = this._pmiBodies.get(t);
    return e !== void 0 ? e : null;
  }
  registerViewFrame(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._viewFrames.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupViewFrame(t) {
    const e = this._viewFrames.get(t);
    return e !== void 0 ? e : null;
  }
  registerPartDefinition(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._partDefinitions.set(e, t);
    }
  }
  lookupPartDefinition(t) {
    const e = this._partDefinitions.get(t);
    return e !== void 0 ? e : null;
  }
  registerRepresentationItem(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._representationItems.set(e, t);
  }
  lookupRepresentationItem(t) {
    const e = this._representationItems.get(t);
    return e !== void 0 ? e : null;
  }
  lookupAnyBody(t) {
    return this.lookupBodyInstance(t) || this.lookupPmiBody(t) || this.lookupViewFrame(t);
  }
  lookupAnyTreeNode(t) {
    return this.lookupProductOccurrence(t) || this.lookupPmi(t) || this.lookupCadView(t) || this.lookupAnyBody(t);
  }
  lookupAnyNonTreeNode(t) {
    return this.lookupRepresentationItem(t) || this.lookupPartDefinition(t);
  }
  lookupAnyNode(t) {
    return this.lookupAnyTreeNode(t) || this.lookupAnyNonTreeNode(t);
  }
  _registerCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), console.assert(!this._cadConfigurations.has(t)), this._cadConfigurations.add(t), t.isADefaultNode() && this._defaultCadConfiguration === null && (this._defaultCadConfiguration = t);
  }
  getInstanceCountByInclusion(t) {
    return this._getInclusionContent(t).bodies.size;
  }
  lookupAnyBodyByInstanceInc(t, e) {
    const n = this._getInclusionContent(t).bodies.get(e);
    return n !== void 0 ? n : null;
  }
  _registerAnyBodyByInstanceInc(t, e) {
    const i = t.getInstanceInc(), n = this._getInclusionContent(e), r = n.bodies.get(i[1]);
    if (r !== void 0)
      if (console.assert(t.hasAuthoredId()), r.hasAuthoredId()) {
        console.assert(r.constructor === t.constructor);
        return;
      } else {
        const o = r;
        console.assert(o.constructor === ji);
        const l = o.getRuntimeId();
        o.getParent().removeBodyInstance(o), t instanceof ji ? this._bodyInstances.set(l, t) : t instanceof Bs ? this._pmiBodies.set(l, t) : this._viewFrames.set(l, t);
      }
    n.bodies.set(i[1], t);
  }
  _getInclusionContent(t) {
    console.assert(t !== Ni.Invalid);
    let e = this._inclusionContents.get(t);
    return e === void 0 && (e = new Bx(), this._inclusionContents.set(t, e)), e;
  }
  _getModelContent(t, e) {
    console.assert(e !== Is.Invalid);
    let i = this._modelContents.get(t);
    i === void 0 && (i = /* @__PURE__ */ new Map(), this._modelContents.set(t, i));
    let n = i.get(e);
    return n === void 0 && (n = new Fx(), i.set(e, n)), n;
  }
  registerPrototypeByDataId(t, e, i, n) {
    const r = this._getModelContent(t, e);
    console.assert(!r.prototypes.has(i)), r.prototypes.set(i, n);
  }
  registerPartDefinitionByDataId(t, e, i, n) {
    const r = this._getModelContent(t, e);
    console.assert(!r.partDefinitions.has(i)), r.partDefinitions.set(i, n);
  }
  lookupPrototypeByDataId(t, e, i) {
    const r = this._getModelContent(t, e).prototypes.get(i);
    return r !== void 0 ? r : null;
  }
  lookupPartDefinitionByDataId(t, e, i) {
    const r = this._getModelContent(t, e).partDefinitions.get(i);
    return r !== void 0 ? r : null;
  }
  registerInclusionContext(t) {
    const e = t.getInclusionKey();
    this._getInclusionContent(e).contexts.push(t);
  }
  getInclusionContexts(t) {
    return this._getInclusionContent(t).contexts;
  }
  _createLayer(t, e, i, n) {
    const r = new co(t, e, i, n);
    return console.assert(!this._layers.has(t)), this._layers.set(t, r), e !== null && this._updateNameToLayersMap(e, t), r;
  }
  _updateNameToLayersMap(t, e) {
    const i = this._layersIds.get(t);
    i !== void 0 ? i.push(e) : this._layersIds.set(t, [e]);
  }
  /**
   * Creates a new layer in the assembly tree. Also creates a mapping in the supplied assembly tree from
   * the authored layer id to the effective, runtime, id.
   * @param authoredLayerId The authored ID of the layer. Used to create the mapping in the assembly tree
   * @param layerName Name of the layer
   * @param loadContext Attach context of the node creating the layer. A layer mapping will be created in it
   */
  createLayer(t, e, i) {
    const n = this._nextLayerId++, r = this._createLayer(n, e, [], []);
    return i.addLayerIdToMap(n, t), r;
  }
  /**
   * Changes the name of an existing layer.
   * @param layerId Layer id to update
   * @param layerName Name to be set
   */
  updateLayerName(t, e) {
    const i = this._layers.get(t);
    i !== void 0 && (i.name = e, this._updateNameToLayersMap(e, t));
  }
  _registerNodeInLayer(t, e, i) {
    const n = Ys(t);
    let r = n.getRuntimeLayerId(e);
    e === co.NoLayerId && r === null ? r = this.createLayer(co.NoLayerId, "No layer", n).id : r === null && (r = this._nextLayerId++, this._createLayer(r, null, [], []), n.addLayerIdToMap(r, e));
    const o = this._layers.get(r);
    o !== void 0 ? i(o).push(t) : (console.assert(!1, "Layer has mapping in LoadContext but not represented in AssemblyTree"), this._createLayer(r, null, [t], []), n.addLayerIdToMap(r, e));
  }
  /**
   * Registers a node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.nodes);
  }
  /**
   * Registers a tree node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerTreeNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.treeNodes);
  }
  addFilter(t, e) {
    this._filters.push({ filter: t, loadContext: e });
  }
  getFilters() {
    const t = /* @__PURE__ */ new Map();
    for (let e = 0; e < this._filters.length; e++) {
      const i = this.getFilterName(e) || "";
      t.set(e, i);
    }
    return t;
  }
  getFilterName(t) {
    if (t < this._filters.length) {
      const { filter: e } = this._filters[t];
      return e.name || "";
    }
    return null;
  }
  getFiltersWithNode(t) {
    const e = t.getAuthoredId(), i = this._filters, n = [];
    for (let r = 0; r < i.length; r++) {
      const { filter: o, loadContext: l } = i[r];
      if (o.layers !== null)
        for (const h of o.layers.authoredIds) {
          const u = l.getRuntimeLayerId(h);
          if (u === null)
            continue;
          const f = this.getNodesFromLayer(u);
          if (f !== null)
            for (const g of f)
              t === g && n.push(r);
        }
      if (o.entities !== null)
        for (const h of o.entities.ids)
          e === h && n.push(r);
    }
    return n;
  }
  getNodesFromFilterIds(t) {
    const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    let n = null;
    for (const r of t) {
      const { filter: o, loadContext: l } = this._filters[r], h = o.layers;
      if (h !== null) {
        const f = h.isInclusive;
        n === null && (n = f);
        for (const g of h.authoredIds) {
          const y = l.getRuntimeLayerId(g);
          if (y === null)
            continue;
          const _ = this._layers.get(y);
          if (_ && _.nodes !== null)
            for (const x of _.nodes) {
              const b = x.getRuntimeId();
              f ? (e.add(b), i.delete(b)) : (e.delete(b), i.add(b));
            }
        }
      }
      const u = o.entities;
      if (u !== null) {
        const f = u.isInclusive;
        n === null && (n = f);
        for (const g of u.ids)
          f ? (e.add(g), i.delete(g)) : (e.delete(g), i.add(g));
      }
    }
    return n === null ? null : n ? new zp(!0, e) : new zp(!1, i);
  }
  getLayers() {
    const t = /* @__PURE__ */ new Map();
    return this._layers.forEach((e, i) => {
      const n = e.name || "";
      t.set(i, n);
    }), t;
  }
  getUniqueLayerNames() {
    const t = /* @__PURE__ */ new Set(), e = [];
    return this._layers.forEach((i) => {
      const n = i.name;
      n !== null && (t.has(n) || (t.add(n), e.push(n)));
    }), e;
  }
  getLayerName(t) {
    const e = this._layers.get(t);
    return e !== void 0 ? e.name || "" : null;
  }
  getLayersIdFromName(t) {
    const e = this._layersIds.get(t);
    return e !== void 0 ? e : null;
  }
  getNodesFromLayer(t, e) {
    const i = this._layers.get(t);
    return i !== void 0 ? e ? i.treeNodes : i.nodes : null;
  }
  getNodesFromLayers(t, e) {
    const i = [];
    for (const n of t) {
      const r = this.getNodesFromLayer(n, e);
      if (r !== null)
        for (const o of r)
          i.push(o);
    }
    return i;
  }
  getNodesFromLayerName(t, e) {
    const i = this._layersIds.get(t);
    return i !== void 0 ? this.getNodesFromLayers(i, e) : null;
  }
  generateProductName() {
    return `Product ${this._unnamedProductCount++}`;
  }
  generateGroupName() {
    return `Product ${this._unnamedGroupCount++}`;
  }
  generateDrawingSheetName() {
    return `Product ${this._unnamedDrawingSheetCount++}`;
  }
  generateDrawingViewName() {
    return `Product ${this._unnamedDrawingViewCount++}`;
  }
  forEachCadView(t) {
    this._cadViews.forEach(t);
  }
  forEachPmi(t) {
    this._pmis.forEach(t);
  }
  forEachCadConfiguration(t) {
    this._cadConfigurations.forEach(t);
  }
  hasActiveCadView() {
    return this._activeCadView !== null;
  }
  activateCadView(t, e, i, n) {
    return console.assert(this._activeCadView === null), this._activeCadView = e, e.activate(
      this,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      t,
      i,
      n,
      this._activeCadConfiguration
    );
  }
  async deactivateActiveCadView() {
    this._activeCadView !== null && (await this._activeCadView.deactivate(this._cuttingManager), console.assert(this._activeCadView !== null), this._activeCadView = null);
  }
  getDefaultCadView(t) {
    let e;
    return t === null ? this._defaultCadViewsByConfiguration.size === 1 && (e = this._defaultCadViewsByConfiguration.values().next().value) : e = this._defaultCadViewsByConfiguration.get(t), e !== void 0 ? e : null;
  }
  getCadViewPmis(t) {
    const e = [];
    return this._pmis.forEach((i) => {
      t.hasPmi(i) && e.push(i);
    }), e;
  }
  isMeasurable() {
    return this._isMeasurable;
  }
  containsDrawings() {
    return this._containsDrawings;
  }
  getCadConfigurations() {
    const t = [];
    return this._cadConfigurations.forEach((e) => {
      t.push(e);
    }), t;
  }
  getDefaultCadConfiguration() {
    return this._defaultCadConfiguration;
  }
  getActiveCadConfiguration() {
    return this._activeCadConfiguration;
  }
  activateCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), this._activeCadConfiguration = t;
  }
  massageAuthoredUserId(t, e) {
    if (e === null)
      return this.generateDynamicNodeId();
    {
      const i = t.toRuntimeId(e);
      return this.lookupAnyNode(i) !== null ? this.generateDynamicNodeId() : e;
    }
  }
  createNode(t, e, i, n, r, o = null) {
    const l = _e.createDynamic(
      this,
      t,
      e,
      i,
      n,
      r,
      !1,
      o
    );
    return t.addProductOccurrence(l), l.markLoaded(), l;
  }
  createPart(t) {
    const e = as.createDynamic(this, t, null);
    return e.markLoaded(), e;
  }
  setPart(t, e) {
    e.addReferrer(t);
    let i = this._partToInstance.get(e);
    if (i === void 0) {
      const n = qi(this._rootNode), r = () => {
        const l = {}, h = Oo.create(() => (console.assert(l.node !== void 0), new cg(Wn.create(l.node))));
        return l.instance = new rl(h, n), l.node = _e.createDynamic(
          this,
          l.instance,
          null,
          null,
          null,
          !0
        ), l.node.setPartDefinition(e), l.node.markLoaded(), l;
      }, { instance: o } = r();
      i = o;
    }
    t.setPrototype(i);
  }
  _createCadView(t, e, i, n, r, o, l, h) {
    const u = ls.createDynamic(
      this,
      t,
      e,
      i,
      n,
      r,
      o,
      l,
      h
    );
    return t.addCadView(u), u.markLoaded(), u;
  }
  async _createCadViewInstance(t, e, i) {
    if (i !== null) {
      const [n, r] = await t.createMeshInstance(i), h = {
        nodeInfo: {
          nodeId: this.generateDynamicNodeId(),
          bits: Hi.IsShownSpecified | Hi.IsShown,
          name: null,
          localTransform: null,
          attributes: [],
          header: Zs.dynamic,
          exchangeId: null,
          layerId: null,
          genericTypeId: null,
          genericId: null,
          userDatas: null
        },
        inclusionKey: n,
        instanceKey: r,
        bits: 0,
        modifierbits: 0
      }, f = Vi(e).getMasterModelKey();
      console.assert(e.isLoaded());
      const g = ho.reify(this, f, e, h);
      e.setViewFrame(g), g.markLoaded();
    }
  }
  createCadView(t, e, i, n, r, o, l, h, u, f) {
    const g = this._createCadView(
      e,
      i,
      n,
      r,
      o,
      l,
      h,
      u
    );
    return f !== null && this._createCadViewInstance(t, g, f), g;
  }
  createMeshInstance(t, e, i, n, r, o, l, h, u, f) {
    let g = 0;
    u && (g |= Hi.InitiallyShown);
    let y = 0;
    l && (y |= Vr.PreventFromResetting), h && (y |= Vr.OutOfHierarchy), f && (y |= Vr.ImplicitBody);
    const _ = ji.createDynamic(
      this,
      e,
      i,
      n,
      r,
      o,
      g,
      y
    );
    return o.addBodyInstance(_), t && _.markLoaded(), _;
  }
  createPmiInstance(t, e, i, n, r, o, l, h) {
    const u = qi(r), y = {
      nodeInfo: {
        nodeId: this.massageAuthoredUserId(u, i),
        bits: Hi.InitiallyShown,
        name: n,
        localTransform: null,
        attributes: [],
        header: Zs.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: t,
      instanceKey: e,
      bits: 0,
      modifierbits: 0
    }, _ = Mn.createDynamic(
      this,
      u,
      r,
      n,
      o,
      l,
      [y],
      h
    );
    return r.addPmi(_), _.markLoaded(), _;
  }
  getRelationshipsOfItem(t, e) {
    const i = /* @__PURE__ */ new Map();
    let n = [];
    const r = this.lookupAnyTreeNode(t);
    if (r === null)
      return i;
    n = qi(r).getRelationships();
    for (const l of n)
      if (l.relating !== null && l.relating.relationElt.id === e)
        ga.addFromRelatingElt(l, i);
      else {
        const h = l.related;
        let u = -1;
        h !== null && (u = ga.findIndexInRelated(e, h.relationships)), u >= 0 && ga.addFromRelatedElt(l, i);
      }
    return i;
  }
  getAutomaticMeasurementUnitScaling() {
    return this._automaticMeasurementUnitScaling;
  }
  setAutomaticMeasurementUnitScaling(t) {
    this._automaticMeasurementUnitScaling = t;
  }
  getInitiallyHiddenStayHidden() {
    return this._initiallyHiddenStayHidden;
  }
  setInitiallyHiddenStayHidden(t) {
    this._initiallyHiddenStayHidden = t;
  }
  async _removeIdMappingsRecursive(t) {
    const e = (h) => {
      const u = h.getGenericId();
      if (u !== null) {
        const g = this._genericIdToNodes.get(u);
        g !== void 0 && g.delete(h);
      }
      const f = ih(h);
      if (f !== null) {
        const g = this._genericTypeToNodes.get(f);
        g !== void 0 && g.delete(h);
      }
    }, i = (h) => {
      const u = /* @__PURE__ */ new Map();
      for (const f of h) {
        const g = f.getAuthoredLayerId();
        if (g === null)
          continue;
        const _ = Ys(f).getRuntimeLayerId(g);
        if (_ === null)
          continue;
        const x = u.get(_);
        x === void 0 ? u.set(_, [f]) : x.push(f);
      }
      u.forEach((f, g) => {
        const y = this._layers.get(g);
        y.nodes = y.nodes.filter((_) => f.indexOf(_) === -1), y.treeNodes = y.treeNodes.filter(
          (_) => f.indexOf(_) === -1
        );
      });
    }, n = (h) => {
      const u = /* @__PURE__ */ new Set();
      h.forEach((f) => {
        const g = f.getInstanceInc();
        u.add(g[0]);
      }), u.forEach((f) => {
        const g = this._inclusionContents.get(f);
        if (g !== void 0)
          for (const y of h) {
            const _ = y.getInstanceInc();
            _[0] === f && g.bodies.delete(_[1]);
          }
      });
    }, r = [], o = [], l = {
      enterProductOccurrence: (h) => {
        e(h), this._productOccurrences.delete(h.getRuntimeId()), r.push(h);
      },
      enterAnyBody: (h) => {
        e(h);
        const u = h.getRuntimeId();
        h instanceof ji ? this._bodyInstances.delete(u) : h instanceof Bs ? this._pmiBodies.delete(u) : this._viewFrames.delete(u), r.push(h), o.push(h);
      },
      enterCadView: (h) => {
        this._cadViews.delete(h.getRuntimeId());
      },
      enterPmi: (h) => {
        this._pmis.delete(h.getRuntimeId());
      }
    };
    await Ln.walk(l, t, Vt.None), i(r), n(o);
  }
  async deleteNode(t) {
    if (!this._canDeleteNode(t)) {
      const i = t.getRuntimeId();
      throw new oe(`Cannot delete node (${i})`);
    }
    const e = Yc(
      t,
      Wt.All,
      !0,
      /* @__PURE__ */ new Set(),
      Vt.None
    );
    if (this._engine.setPartVisibility(e, !1, !1), this._engine.setInstanceModifier(tn.DoNotSelect, e, !0), t instanceof _e) {
      this._cadConfigurations.delete(t) && (t === this._activeCadConfiguration && (this._activeCadConfiguration = null), t === this._defaultCadConfiguration && (this._defaultCadConfiguration = null));
      const i = t.getParent(), n = Ys(i);
      if (console.assert(i !== null), i !== null) {
        let r;
        if (i instanceof rl)
          r = i.removeReferrer(t);
        else if (i instanceof $n && i.getChildren().length === 1) {
          const o = i.getInclusionKey();
          this._inclusionContents.delete(o);
          const l = i.getModelKey(), h = this._modelContents.get(n);
          h !== void 0 && (h.delete(l), h.size === 0 && this._modelContents.delete(n)), r = i.removeProductOccurrence(t);
        } else
          r = i.removeProductOccurrence(t);
        console.assert(r);
      }
      return this._productOccurrences.delete(t.getRuntimeId()), await this._removeIdMappingsRecursive(t), n.getChildren().length === 0 ? n.purgeContents() : t.purgeContents();
    } else if (t instanceof Mn)
      t.getParent().removePmi(t), this._pmis.delete(t.getRuntimeId());
    else {
      t.getParent().removeBodyInstance(t);
      const n = t.getInstanceInc();
      this._getInclusionContent(n[0]).bodies.delete(n[1]), this._bodyInstances.delete(t.getRuntimeId());
    }
  }
  _canDeleteNode(t) {
    return !this._nodeDeletionBlackList.has(t);
  }
  allowNodeDeletion(t) {
    this._nodeDeletionBlackList.delete(t);
  }
  preventNodeDeletion(t) {
    const e = t.getParent();
    if (e instanceof rl)
      throw new oi();
    if (e !== null) {
      if (console.assert(e === null || this._nodeDeletionBlackList.has(e)), t instanceof _e)
        console.assert(!t.hasAuthoredId()), console.assert(!t.isOutOfHierarchy());
      else if (t instanceof ji) {
        const i = t.getInstanceInc();
        console.assert(!t.hasAuthoredId()), console.assert(i[0] === Ni.Local), console.assert(t.isOutOfHierarchy());
      }
    }
    this._nodeDeletionBlackList.add(t);
  }
  preventMeshDeletion(t) {
    this._meshDeletionBlackList.add(t);
  }
  async _resetContents() {
    if (this.hasActiveCadView())
      return await this.deactivateActiveCadView(), this._resetContents();
    await this._rootLoadContext.purgeContents(), this._productOccurrences.clear(), this._pmis.clear(), this._cadViews.clear(), this._bodyInstances.clear(), this._pmiBodies.clear(), this._viewFrames.clear(), this._partDefinitions.clear(), this._representationItems.clear(), this._partToInstance.clear(), this._filters.length = 0, this._layers.clear(), this._layersIds.clear(), this._genericTypeToNodes.clear(), this._genericIdToNodes.clear(), this._cadConfigurations.clear(), this._modelContents.clear(), this._inclusionContents.clear(), this._currentNodeIdOffset = 0, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._requestedNodes.clear(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._seenExternalModel = !1, this._rootNode.unsetMeasurementUnit(), this._nodeDeletionBlackList.forEach((t) => {
      if (t instanceof _e) {
        const e = t.getRuntimeId();
        this._productOccurrences.set(e, t);
        const i = t.getParent();
        i instanceof rl ? console.assert(!1) : i.addProductOccurrence(t), t.setVisibility(!0), t.unsetMeasurementUnit(), t.hasLocalTransformOverride() && t.removeLocalTransformOverride();
      } else if (t instanceof ji) {
        const e = t.getRuntimeId();
        this._bodyInstances.set(e, t);
        const i = t.getInstanceInc(), n = i[0];
        console.assert(n === Ni.Local), this._getInclusionContent(n).bodies.set(i[1], t), t.getParent().addBodyInstance(t);
      } else if (t instanceof Mn) {
        const e = t.getRuntimeId();
        this._pmis.set(e, t), t.getParent().addPmi(t);
      } else if (t instanceof Ls) {
        const e = t.getParent();
        e !== null && e.addLoadContext(t);
      } else if (t instanceof Pn) {
        const e = t.getParent();
        e instanceof _e, e.addAttachContext(t);
      } else {
        const e = t.getInclusionKey();
        console.assert(e === Ni.Local), this._getInclusionContent(e).contexts.push(t), t.getParent().addInclusionContext(t);
      }
    });
  }
  async reset() {
    await this._callbackManager.promiseTrigger("_resetAssemblyTreeBegin", null), await this._resetContents();
    const t = [];
    this._nodeDeletionBlackList.forEach((i) => {
      if (i instanceof ji) {
        const n = i.getInstanceInc();
        console.assert(n[0] === Ni.Local), t.push(n[1]);
      }
    });
    const e = [];
    this._meshDeletionBlackList.forEach((i) => {
      e.push(i);
    }), await this._engine.resetToEmpty(t, e), await this._resetContents();
  }
  setViewAxes(t, e) {
    this._model.setViewAxes(t, e);
  }
  async _requestIncsOfNodes(t) {
    if (this._config.streamingMode !== Ro.OnDemand)
      return;
    const e = /* @__PURE__ */ new Set(), i = [], n = [];
    for (const l of t) {
      const h = f_(l, Wt.All, !1, e).then((u) => {
        for (const f of u)
          i.push(f);
      });
      n.push(h);
    }
    await We(n);
    const r = [], o = [];
    e.forEach((l) => {
      if (!l.isRequested()) {
        l.setRequested();
        const h = l.isInitiallyShown();
        h !== l.isVisible() && (h ? (l.setVisibility(!0), r.push(l.getRuntimeId())) : (l.setVisibility(!1), o.push(l.getRuntimeId())));
      }
    }), r.length + o.length > 0 && this._callbackManager.trigger("visibilityChanged", r, o), this._engine.requestMeshInstances(i);
  }
  async _requestExternalModelsLocal(t, e, i) {
    const n = await e.loadPendingExternalModels(t);
    return n.length !== 0 && (await pa(n), await this._requestNodes(t, [e], i)), n;
  }
  async _requestExternalModelsNonLocal(t, e, i) {
    const n = await Ox(e);
    if (n.length === 0)
      return [];
    const r = [];
    for (const l of n) {
      const h = this._requestExternalModelsLocal(t, l, i);
      r.push(h);
    }
    return (await Promise.all(r)).flat();
  }
  async _requestExternalModelsOfNodes(t, e, i) {
    const n = [];
    for (const o of e) {
      const l = this._requestExternalModelsNonLocal(t, o, i);
      n.push(l);
    }
    return (await Promise.all(n)).flat();
  }
  async _requestNodes(t, e, i) {
    if (!i) {
      const h = this._activeLoadIds.size !== 0, u = [];
      h && this._activeLoadIds.forEach((f) => {
        u.push(f);
      });
      for (const f of e)
        h && this._requestedNodes.set(f, u), f instanceof _e && t.notifyDirectRequest(f);
    }
    const n = this._requestIncsOfNodes(e), r = this._requestExternalModelsOfNodes(
      t,
      e,
      i
    ), o = [n, r];
    return (await Promise.all(o))[1];
  }
  async requestNodes(t, e, i) {
    const n = await this._requestNodes(t, e, i), r = [];
    for (const o of n) {
      const l = o.getChildren();
      r.push(...l);
    }
    if (r.length > 0) {
      const o = r.map((l) => l.getRuntimeId());
      await this._callbackManager.promiseTrigger(
        "_subtreeLoaded",
        "subtreeLoaded",
        o,
        uo.LoadModel
      );
    }
  }
  isBeingRequested(t) {
    let e = t;
    do
      if (e instanceof is) {
        if (this._requestedNodes.has(e))
          return !0;
        e = e.getParent();
      } else if (e instanceof Pn)
        e = e.getParent();
      else if (e instanceof $n)
        e = e.getParent();
      else if (e instanceof Ls) {
        const i = e.getParent();
        if (i === null)
          return !1;
        e = i;
      } else
        return console.assert(!1), !1;
    while (!0);
    return !1;
  }
  onDemandRequestsActive() {
    return this._requestedNodes.size !== 0;
  }
  onLoadBegin() {
    const t = this._nextLoadId++;
    return this._activeLoadIds.add(t), t;
  }
  onLoadEnd(t) {
    this._activeLoadIds.delete(t);
    const e = [];
    this._requestedNodes.forEach((i, n) => {
      let r = !0;
      for (const o of i)
        if (this._activeLoadIds.has(o)) {
          r = !1;
          break;
        }
      r && e.push(n);
    });
    for (const i of e)
      this._requestedNodes.delete(i);
  }
  markSeenExternalModel() {
    this._seenExternalModel = !0;
  }
  seenExternalModel() {
    return this._seenExternalModel;
  }
  getNodesByGenericId(t) {
    return this._genericIdToNodes.get(t) || null;
  }
  getNodesByGenericType(t) {
    return this._genericTypeToNodes.get(t) || null;
  }
  genericTypeToNodes() {
    return this._genericTypeToNodes;
  }
  registerGenericGlobalId(t, e) {
    let i = this._genericIdToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericIdToNodes.set(e, i);
  }
  registerGenericType(t, e) {
    let i = this._genericTypeToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericTypeToNodes.set(e, i);
  }
  disableAutomaticFitWorld() {
    return this._config.disableAutomaticFitWorld;
  }
  markImplicitNodesOutOfHierarchy() {
    return this._config.markImplicitNodesOutOfHierarchy;
  }
  async _throttleLoad() {
    this._engine.throttleLoad(200, 200), await this._engine.sleep(20);
  }
  /**
   * Enqueues an action that can be throttled by user interactions.
   */
  enqueue(t) {
    const e = typeof t == "function" ? Cs.create(t) : t;
    return this._centralQueue.push(async () => {
      const i = this._isScs && this._centralQueueClock.isTicking();
      i && await this._throttleLoad();
      const n = await e.get();
      return i && await this._throttleLoad(), n;
    });
  }
  _onUserInteraction(t, e) {
    if (!this._isScs)
      return;
    let i = !1;
    switch (e) {
      case le.MouseDown:
      case le.MouseUp:
      case le.Mousewheel:
      case le.TouchStart:
      case le.TouchMove:
      case le.TouchEnd:
      case le.KeyDown:
      case le.KeyUp:
      case le.ViewOrientationChange:
        i = !0;
        break;
      case le.MouseMove:
        i = t.getButtons() !== ws.None;
        break;
      default:
        qr();
    }
    i && this._centralQueueClock.tickFor(1e3);
  }
}
class qp {
  constructor(t, e) {
    this._inclusionsOf = /* @__PURE__ */ new Map(), this._masterModelKey = jr.Invalid, this._prototypeInstanceCount = -1, this._attachScope = t, this._attachedInvisibly = e;
  }
  getAttachScope() {
    return this._attachScope;
  }
  getMasterModelKey() {
    return console.assert(this._masterModelKey !== jr.Invalid), this._masterModelKey;
  }
  getModelKeys() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  hasInclusions() {
    return this._inclusionsOf.size > 0;
  }
  getAllInclusions() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      for (const n of e)
        t.push(n, i);
    }), t;
  }
  getInclusionsOf(t) {
    t = t;
    const e = this._inclusionsOf.get(t);
    if (e === void 0)
      return [];
    const i = [];
    for (const n of e)
      i.push(n, t);
    return i;
  }
  hasModelIncluded(t) {
    return this._inclusionsOf.has(t);
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  prototypeInstanceCount() {
    return console.assert(this._prototypeInstanceCount >= 0), this._prototypeInstanceCount;
  }
  registerInclusion(t, e) {
    const i = this._inclusionsOf.get(e);
    i === void 0 ? this._inclusionsOf.set(e, [t]) : i.push(t);
  }
  registerMasterModelKey(t) {
    console.assert(this._masterModelKey === jr.Invalid), this._masterModelKey = t;
  }
  registerPrototypeInstanceCount(t) {
    console.assert(this._prototypeInstanceCount === -1), this._prototypeInstanceCount = t;
  }
}
class zx {
  constructor() {
    this._calculatedCutoff = 0, this._requireBoundingInfo = !1, this._prevPriorityValue = 1, this._priorityProxies = /* @__PURE__ */ new Map();
  }
  getPriorityCompareValue(t) {
    if (typeof t == "number")
      return t;
    {
      const e = this._priorityProxies.get(t);
      return e.worldBounding !== null && console.assert(e.priorityHeuristic <= 1), e.priorityHeuristic;
    }
  }
  setRequireBoundingInfo(t) {
    this._requireBoundingInfo = t;
  }
  comparePriority(t, e) {
    const i = this.getPriorityCompareValue(t), n = this.getPriorityCompareValue(e);
    return i < n;
  }
  _updateHeuristicInfo(t, e) {
    var i;
    if (e.worldBounding !== null) {
      const n = pl(e.worldBounding.center()), r = pl(e.worldBounding.extents()), o = t.calculateAttachHeuristic(r, n);
      e.priorityHeuristic = o;
    }
    if ((i = e.xmlAttachInfo) != null && i.directlyRequested) {
      e.worldBounding === null && (e.priorityHeuristic = 0);
      const n = -1e6;
      e.priorityHeuristic += n;
    }
  }
  createPriority(t, e, i) {
    if (i === null)
      return ++this._prevPriorityValue;
    const n = /* @__PURE__ */ Object.create(null);
    let r, o;
    if (i.bounding !== null)
      r = e.transformBox(i.bounding), o = 0;
    else {
      if (this._requireBoundingInfo)
        throw new Error("WorldBounding must be specified when streamCutoff is enabled");
      r = null, o = ++this._prevPriorityValue;
    }
    const l = {
      xmlAttachInfo: i,
      worldBounding: r,
      priorityHeuristic: o
    };
    return this._updateHeuristicInfo(t, l), this._priorityProxies.set(n, l), n;
  }
  destroyPriority(t) {
    typeof t == "object" && this._priorityProxies.delete(t);
  }
  onViewChange(t, e, i) {
    this._calculateCutoff(i.getProjectionMatrix(e.getCamera(), e.id)), this._priorityProxies.forEach((n) => {
      this._updateHeuristicInfo(t, n);
    });
  }
  reset() {
    this._priorityProxies.clear();
  }
  _calculateCutoff(t) {
    let i = 0.98;
    t.m[11] !== 0 && (i = (1 - t.m[15]) / t.m[11] * t.m[10] + t.m[14]);
    const n = wt.inverse(t);
    if (!n) throw new Error();
    const r = rf(n.transform4(new Ur(0, 0, i, 1))), o = rf(
      n.transform4(new Ur(0.0125, 0, i, 1))
    ), l = rf(
      n.transform4(new Ur(0, 0.0125, i, 1))
    );
    of(1 / r[3], r), of(1 / o[3], o), of(1 / l[3], l), this._calculatedCutoff = Math.min(
      Bp(Mf(o, r)),
      Bp(Mf(l, r))
    );
  }
  getCalculatedCutoff() {
    return this._calculatedCutoff;
  }
  // this will be true if streamcutoff is enabled.
}
class nd {
  constructor(t) {
    this._planes = [], this._absPlanes = [], this._signs = [], this._distanceScale = [];
    const e = t.length;
    for (const i of t) this._planes.push(i.slice());
    for (let i = 0; i < e; ++i) {
      this._planes[i][3] = -this._planes[i][3], this._absPlanes[i] = gb(this._planes[i]), this._signs[i] = [0, 0, 0];
      for (let n = 0; n < 3; ++n) this._signs[i][n] = this._planes[i][n] >= 0 ? 1 : -1;
    }
    for (let i = 0; i < e; ++i) {
      const n = fg(this._planes[i]);
      this._distanceScale[i] = n === 0 ? 0 : 1 / n;
    }
  }
  static fromPlaneCoefficients(t) {
    const e = [];
    for (const i of t) {
      const n = [i.x, i.y, i.z, i.w];
      e.push(n);
    }
    return new nd(e);
  }
  static createFrustumFromMatrix(t) {
    const e = [];
    for (let i = 0; i < 3; ++i)
      e[i] = Mf(fc(t, 3), fc(t, i));
    for (let i = 0; i < 3; ++i)
      e[i + 3] = yb(fc(t, 3), fc(t, i));
    return new nd(e);
  }
  testAxisAlignedBox(t, e) {
    const i = this._planes.length;
    let n = Cu.FullyInside;
    for (let r = 0; r < i; ++r) {
      const o = no(this._planes[r], t), l = no(this._absPlanes[r], e);
      if (o + l <= this._planes[r][3]) return Cu.Outside;
      o - l < this._planes[r][3] && (n = Cu.PartiallyInside);
    }
    return n;
  }
  axisAlignedBoxNotOutside(t, e) {
    const i = this._planes.length;
    for (let n = 0; n < i; ++n)
      if (no(this._planes[n], mb(t, pb(e, this._signs[n]))) <= this._planes[n][3])
        return !1;
    return !0;
  }
  sphereNotOutside(t, e) {
    const i = this._planes.length;
    for (let n = 0; n < i; ++n) {
      const r = no(this._planes[n], t) - this._planes[n][3];
      if (r < 0 && r * r * this._distanceScale[n] >= e)
        return !1;
    }
    return !0;
  }
  sphereFullyInside(t, e) {
    const i = this._planes.length;
    for (let n = 0; n < i; ++n) {
      const r = no(this._planes[n], t) - this._planes[n][3];
      if (r < 0 || r * r * this._distanceScale[n] < e)
        return !1;
    }
    return !0;
  }
  pointInside(t) {
    const e = this._planes.length;
    for (let i = 0; i < e; ++i)
      if (no(this._planes[i], t) - this._planes[i][3] < 0) return !1;
    return !0;
  }
  // 1 / (a^2 + b^2 + c^2) for each plane
}
function Hx(s) {
  return 1 / (1 + Math.exp(s));
}
class Kp {
  constructor(t) {
    const e = t.getCamera(), i = e.getPosition(), n = e.getTarget(), r = m.subtract(n, i);
    let o = r.length();
    o < 1e-7 && (o = 1e-7), this._eyeDistanceInverse = 1 / o, r.scale(this._eyeDistanceInverse);
    const l = t.getFullCameraMatrix();
    this._frustum = nd.createFrustumFromMatrix(l), this._viewProjectionW = fc(l, 3), this._cameraIsOrtho = e.getProjection() === Gc.Orthographic, this._position = pl(i), this._eye = pl(r);
  }
  calculateAttachHeuristic(t, e) {
    let i = 0;
    if (this._frustum.axisAlignedBoxNotOutside(e, t)) {
      const n = fg(t), r = vb(e, n, this._viewProjectionW);
      if (r > 0) {
        let o = _b(e, this._position);
        const h = 1 / (no(this._eye, o) * this._eyeDistanceInverse + 1e-5);
        o = wb(1 / Fp(o), o);
        const u = no(this._eye, o);
        let f = Math.pow(h, 6);
        this._cameraIsOrtho || (f *= Math.pow(u, 10) * 5), f < 1e-5 && (f = 1e-5), i = r * f;
      }
      return console.assert(0 <= i), -i - 1;
    }
    return i = Hx(Fp(t)), console.assert(0 <= i && i < 1), i;
  }
}
const od = class od {
  static isSupported() {
    return od._enabled && typeof fetch == "function" && typeof ReadableStream == "function";
  }
  static async request(t) {
    const e = await fetch(t);
    if (e.status === 200) return e;
    throw new Kr(`Failed to fetch "${t}" with status ${e.status}.`);
  }
};
od._enabled = !0;
let Na = od;
const Ux = 13;
class sd {
  constructor(t, e, i, n) {
    this._cameraTimeoutId = null, this._isFirstAttachment = !0, this._attachScope = 0, n === null && (n = Ux), console.assert(n > 0), this._engine = t, this._view = e, this._callbackManager = i, this._parentToXmlAttachInfos = /* @__PURE__ */ new Map(), this._viewInfo = new Kp(this._view), this._attachPriorityManager = new zx(), this._comparePriority = (r, o) => this._attachPriorityManager.comparePriority(r, o), this._attachQueue = this._createAttachQueue(n), this._prefetchScsQueue = this._createPrefetchScsQueue(n), this._registerCameraListener();
  }
  static async createWithEmptyModel(t, e, i, n) {
    return await t.loadEmpty(), new sd(t, e, i, n);
  }
  setPrefetchScsCutoffScale(t) {
    this._prefetchScsQueue.setCutoffScale(t), this._attachPriorityManager.setRequireBoundingInfo(this._prefetchScsQueue.cutoffEnabled());
  }
  /**
   * Used in the constructor only.
   */
  _createAttachQueue(t) {
    return new h_(
      t,
      this._comparePriority,
      !1
    );
  }
  /**
   * Used in the constructor only.
   */
  _createPrefetchScsQueue(t) {
    const e = t + 15;
    return new k0(
      0,
      this._attachPriorityManager,
      e,
      (i, n) => this._comparePriority(i, n),
      !1
    );
  }
  _reprioritizeAttachments() {
    this._viewInfo = new Kp(this._view), this._attachPriorityManager.onViewChange(this._viewInfo, this._view, this._engine), this._attachQueue.markDirty(), this._prefetchScsQueue.update();
  }
  /**
   * Used in the constructor only.
   */
  _registerCameraListener() {
    const t = () => {
      this._onCameraChange();
    };
    this._callbackManager.bind({
      camera: t,
      _shutdownBegin: () => {
        this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._callbackManager.unbind({ camera: t });
      }
    });
  }
  reprioritizeAttachmentsNow() {
    this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._reprioritizeAttachments();
  }
  _onCameraChange() {
    this._cameraTimeoutId !== null && clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = this._engine.setTimeout(() => {
      this._cameraTimeoutId = null, this._reprioritizeAttachments();
    }, 500);
  }
  /**
   * This listens on SC messages relevant for a given attachment.
   * This abstracts away the low-level details about an attachment
   * and bundles relevant information in a promise return value.
   */
  _awaitAttachInfo(t, e, i, n, r) {
    const o = n === null, l = new qp(e, i);
    let h = !1;
    const u = [], f = vi(), g = vi();
    let y = !1;
    const _ = () => {
      console.assert(!y), y = !0, this._cleanupAttachLowLevel(), this._callbackManager.unbind(b);
    };
    let x = null;
    const b = {
      _priorityMetaDataSent: (I, C) => {
        I === e && (l.registerPrototypeInstanceCount(C), f.resolve());
      },
      _announceModel: (I, C) => {
        I === e && (h = !0, l.registerMasterModelKey(C));
      },
      _inclusion: (I, C, M) => {
        I === e && (l.registerInclusion(C, M), u.push(M));
      },
      _remapModel: (I, C, M) => {
        I === e && t.remapModel(C, M);
      },
      _remapInclusion: (I, C, M, P) => {
        I === e && t.remapInclusion(C, M, P);
      },
      _missingModel: (I, C) => {
        I === e && (x = C);
      },
      _attached: (I) => {
        if (I !== e)
          return;
        if (!h) {
          if (x !== null && (o || r)) {
            console.assert(u.length === 0), g.reject(new fd(x));
            return;
          }
          if (u.length !== 1) {
            g.reject(new Kr("Bad model: Could not find master model key."));
            return;
          }
          const P = u[0];
          l.registerMasterModelKey(P);
        }
        const C = [f], M = this._isFirstAttachment;
        if (M) {
          this._isFirstAttachment = !1;
          const P = o ? vs.Direct : vs.Indirect, O = this._callbackManager.promiseTrigger("_firstAttachment", null, P);
          C.push(O);
        }
        We(C).catch((P) => {
          throw console.assert(!1), P;
        }).then(async () => {
          M && this._engine.getSessionType() === nn.Network && await this._callbackManager.promiseTrigger("_firstBoundingReady", null), _(), g.resolve(l);
        });
      }
    };
    return this._callbackManager.bind(b), g.catch((I) => {
      throw _(), I;
    });
  }
  _createPriority(t, e) {
    return this._attachPriorityManager.createPriority(
      this._viewInfo,
      t,
      e
    );
  }
  _cleanupAttachLowLevel() {
  }
  async _cleanupAttachHighLevel(t, e, i) {
    try {
      return await t;
    } finally {
      i !== null && this._forgetXmlAttachment(i), this._attachPriorityManager.destroyPriority(e);
    }
  }
  newAttachScope() {
    return ++this._attachScope;
  }
  _attachByStream(t, e, i, n, r, o, l, h) {
    const u = wt.toMatrix12(n.m), f = this._createPriority(n, l), g = this._attachQueue.push(async () => {
      const y = this.newAttachScope(), _ = this._awaitAttachInfo(
        e,
        y,
        o.get(),
        l,
        h
      );
      try {
        return await t.enqueue(() => this._engine.attachModel(
          y,
          i,
          u,
          r,
          o.get()
        )), await _;
      } catch (x) {
        throw this._cleanupAttachLowLevel(), x;
      }
    }, f);
    return this._cleanupAttachHighLevel(g, f, l);
  }
  static _getAllModelKeys(t) {
    const e = t.getMasterModelKey(), i = t.getAllInclusions();
    if (i[1] !== e) {
      for (let r = 2; r < i.length; r += 2)
        if (i[r + 1] === e) {
          const l = i[r];
          i[r] = i[0], i[r + 1] = i[1], i[0] = l, i[1] = e;
          break;
        }
    }
    const n = [];
    for (let r = 0, o = 1; o < i.length; ++r, o += 2)
      n[r] = i[o];
    return n;
  }
  /**
   * This function is used to attach SCS buffers that are keyed to an `ExternalModelName`.
   * This happens when attaching an SCS from a model found in a shattered XML file.
   *
   * This function should be used over `simpleAttach` for this case. This is because `simpleAttach`
   * only takes a buffer as an argument. Without storing the entire buffer as a key to the attached
   * model keys of the SCS model, subsequent attachments of equivalent buffers cannot leverage
   * making new inclusions of the existing attached models. On the other hand, this keys the
   * attached models from the SCS buffer, allowing model sharing for subsequent attachments.
   *
   * cancelUnitMatrix is a patch to tell to the engine to cancel the undesired scale matrix for
   * some model type in some version when using the shattered workflow.
   *
   * Returns `Promise<null>` when the attachment is skipped (due to `toAttachData` returning `null`).
   */
  async attachByNamedScsBuffer(t, e, i, n, r, o, l, h, u, f) {
    t.getAutomaticMeasurementUnitScaling() || (o = Ds);
    const g = Ys(h.parent), y = wt.toMatrix12(r.m), _ = this._createPriority(r, h);
    if (typeof _ == "number")
      throw new oi();
    const x = async (I) => {
      const C = await (async () => {
        const B = g.getScsModelKeysOf(e);
        return B === null ? (g.initializeScsModelKeysOf(e), I) : B;
      })(), M = g.getScsModelKeysOf(e);
      if (M === null)
        throw new oi();
      const P = this.newAttachScope();
      let O;
      if (C instanceof Uint8Array || Na.isSupported() && C instanceof Response) {
        const j = this._awaitAttachInfo(
          i,
          P,
          l.get(),
          h,
          !1
        );
        try {
          await t.enqueue(() => {
            const F = this._engine.attachScsBuffer(
              P,
              C instanceof Uint8Array ? C : null,
              // if attachData is not an array, then data will be fed into SC as it arrives
              y,
              o,
              l.get(),
              !0,
              u,
              f
            );
            return C instanceof Uint8Array || this.streamScsData(P, C), F;
          }), O = await j;
        } catch (F) {
          throw this._cleanupAttachLowLevel(), F;
        }
        if (M.state === Wr.Pending) {
          const F = sd._getAllModelKeys(O);
          M.resolve(F);
        }
      } else if (C === null)
        O = null, M.state === Wr.Pending && M.resolve(null);
      else if (C instanceof Array) {
        console.assert(M.state !== Wr.Pending);
        const B = new qp(P, l.get());
        B.registerPrototypeInstanceCount(0);
        for (let j = 0; j < C.length; ++j) {
          const F = C[j], K = this._engine.attachScsModelByKey(
            P,
            F,
            y,
            o,
            l.get()
          );
          B.registerInclusion(K, F), j === 0 && B.registerMasterModelKey(F);
        }
        O = B;
      } else
        throw new oi();
      return O;
    }, b = (async () => {
      const I = await this._prefetchScsQueue.push(async () => g.toScsBuffer(e, n), _);
      return h.directlyRequested = !0, this._attachQueue.push(() => x(I), _);
    })();
    return this._cleanupAttachHighLevel(b, _, h);
  }
  // Streams the data from a fetch response into the the buffer associated with the attach scope
  streamScsData(t, e) {
    this._callbackManager.trigger("_fetchBegin", e.url, t);
    const i = e.body.getReader(), n = async () => {
      for (; ; ) {
        const { done: r, value: o } = await i.read();
        if (r) {
          this._engine.feedScsBuffer(t, null), this._callbackManager.trigger("_fetchEnd", e.url, t);
          return;
        }
        this._engine.feedScsBuffer(t, o);
      }
    };
    this._engine.setTimeout(n, 0);
  }
  _attachByScsBuffer(t, e, i, n, r, o, l, h) {
    const f = wt.toMatrix12(n.m), g = this._createPriority(n, null), y = this._attachQueue.push(async () => {
      const _ = this.newAttachScope(), x = this._awaitAttachInfo(
        e,
        _,
        o.get(),
        null,
        !1
      );
      try {
        return await t.enqueue(() => {
          const I = this._engine.attachScsBuffer(
            _,
            i instanceof Uint8Array ? i : null,
            // if scsBuffer is not an array, then data will be fed into SC as it arrives
            f,
            r,
            o.get(),
            !1,
            l,
            h
          );
          return i instanceof Uint8Array || this.streamScsData(_, i), I;
        }), await x;
      } catch (b) {
        throw this._cleanupAttachLowLevel(), b;
      }
    }, g);
    return this._cleanupAttachHighLevel(y, g, null);
  }
  simpleAttach(t, e, i, n, r, o, l, h) {
    if (t.getAutomaticMeasurementUnitScaling() || (r = Ds), typeof i == "string")
      return this._attachByStream(
        t,
        e,
        i,
        n,
        r,
        o,
        l,
        h
      );
    if (l === null)
      return this._attachByScsBuffer(
        t,
        e,
        i,
        n,
        r,
        o,
        !1,
        !0
      );
    throw new oi();
  }
  reset() {
    return this._isFirstAttachment = !0, this._attachScope = 0, this._parentToXmlAttachInfos.clear(), this._attachPriorityManager.reset(), this.clearAttachQueues();
  }
  /**
   * This method will effectively cancel an active LoadSubtreeByXML operation.
   * All deferred promises in the prefetch queue will be canceled.
   * Note that any open promises i.e. SCS files that are being fetched when this method is called will resolve before this method returns.
   */
  async clearAttachQueues() {
    return this._prefetchScsQueue.killDeferred(), this._attachQueue.killDeferred(), await this._prefetchScsQueue.waitForIdle(), this._attachQueue.waitForIdle();
  }
  isIdle() {
    return this._attachQueue.isIdle();
  }
  /**
   * Call this when a node has been directly requested by `Model.prototype.requestNodes`.
   */
  notifyDirectRequest(t) {
    const e = this._parentToXmlAttachInfos.get(t);
    if (e !== void 0) {
      let i = !1;
      for (const n of e)
        n.directlyRequested || (n.directlyRequested = !0, i = !0);
      i && this._reprioritizeAttachments();
    }
  }
  registerXmlAttachInfo(t) {
    const e = t.parent;
    let i = this._parentToXmlAttachInfos.get(e);
    i === void 0 && (i = [], this._parentToXmlAttachInfos.set(e, i)), i.push(t);
  }
  _forgetXmlAttachment(t) {
    const e = t.parent, i = this._parentToXmlAttachInfos.get(e);
    if (i.length === 1)
      console.assert(i[0] === t), this._parentToXmlAttachInfos.delete(e);
    else {
      console.assert(i.length > 1);
      const n = i.indexOf(t);
      console.assert(n >= 0), i.splice(n, 1);
    }
  }
  maxConcurrentAttachments() {
    return this._attachQueue.maxActivePromises();
  }
}
function Eg(s, t) {
  return new Promise((e, i) => {
    const n = new XMLHttpRequest();
    n.open("GET", s, !0), t && (n.responseType = t), n.onload = function(r) {
      if (n.readyState === e_.Done)
        if (n.status === i_.Ok)
          e(n);
        else {
          const o = new Kr(
            `XMLHttpRequest failed to GET "${s}" with status ${n.status}.`
          );
          i(o);
        }
    }, n.onerror = function(r) {
      i(r);
    }, n.send();
  });
}
async function Hy(s) {
  const t = await Eg(s, "arraybuffer");
  return new Uint8Array(t.response);
}
class jx {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  clear() {
    this._cache.clear();
  }
  async load(t, e) {
    const i = this._cache.get(t);
    return i !== void 0 ? i : (this._cache.set(t, e), e);
  }
}
const Uy = "Missing";
function jy(s) {
  return new DOMParser().parseFromString(s, "application/xml");
}
async function Wx(s) {
  const t = await Eg(s);
  let e = t.responseXML;
  return e === null && (e = jy(t.responseText)), e;
}
function Gx(s) {
  if (!s.hasChildNodes)
    return null;
  const t = s.firstChild;
  if (!(t instanceof Comment))
    return null;
  const e = t.data.split(" ");
  if (e.length !== 2 || e[0] !== "HC")
    return null;
  const i = e[1].split(".");
  if (i.length < 2)
    return null;
  const n = [];
  for (const r of i) {
    if (!n_(r))
      return null;
    n.push(parseInt(r, 10));
  }
  return n;
}
function $x(s) {
  return qc(dg, s);
}
function qx(s) {
  const t = s.getElementsByTagName("parsererror");
  if (t.length > 0)
    throw new si(t[0].textContent || "unknown error");
}
function Kx(s) {
  const t = s.getParent();
  return t instanceof Pn && t.getParent() instanceof Ls;
}
function Xx(s, t, e, i, n, r) {
  const o = new Pn(
    t,
    n,
    r,
    jr.Local,
    e
  );
  switch (i) {
    case 0:
      return o;
    case 1: {
      const l = new $n(
        s,
        o,
        Ni.Local,
        Is.Local
      );
      o.addInclusionContext(l);
      const h = _e.createDynamic(
        s,
        l,
        Uy,
        null,
        // authored node id
        null,
        // local transform
        !r
      );
      return l.addProductOccurrence(h), o;
    }
    default:
      return qr();
  }
}
function Jx(s, t, e, i) {
  return {
    getAttachScope() {
      return s;
    },
    getMasterModelKey() {
      return i;
    },
    getModelKeys() {
      return [i];
    },
    hasInclusions() {
      return !0;
    },
    getAllInclusions() {
      return [e, i];
    },
    getInclusionsOf(n) {
      return n === i ? [e, i] : [];
    },
    hasModelIncluded(n) {
      return n === i;
    },
    attachedInvisibly() {
      return t;
    },
    prototypeInstanceCount() {
      return 0;
    }
  };
}
class Ag {
  constructor(t, e, i, n, r) {
    this._loadQueue = new Uo(1024, !1), this._activeLoadCount = 0, this._activeLoadGeneration = 0, this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, console.assert(t.isInitialized()), this._assemblyTree = t, this._scAttacher = e, this._engine = i, this._view = n, this._callbackManager = r, this._isScsSession = this._engine.getSessionType() === nn.Scs, this._nodesUntilNextSleep = 2e3;
  }
  // Modify the scale of the PO if needed, depends of the unit
  _resolveMeasurementUnits(t, e, i, n, r) {
    if (!this._assemblyTree.getAutomaticMeasurementUnitScaling())
      return;
    const o = mr(t.getParent());
    if (o === null)
      throw new oi();
    const l = o.getMeasurementUnit(), h = t.getMeasurementUnit();
    let u = t.getLocalTransform();
    if (u === null && (u = Gn.getIdentity()), l !== h && i) {
      const f = h / l;
      u[0] *= f, u[5] *= f, u[10] *= f;
    }
    this._applyScalePatchIfNeeded(
      u,
      e,
      n,
      r,
      h
    ), t.setLocalTransformAsInitial(u);
  }
  // Will directly modify localChildMatrix to apply the scale patch
  // COM-4049 Fix for Aras to manage loading monolithic scs from shattered XML
  // Inventor after 2021 (HC v9) + solidedge after 2023 add an unit scale in the first PO root child
  // Because data is in a different unit than the real unit defined in nodeUnit
  // We need to revert it because the scale is already applied in the master assembly (xml)
  // Only if the shattered part is generated with output_scs, else the scale is already skiped during conversion
  _applyScalePatchIfNeeded(t, e, i, n, r) {
    const o = n === ul.Inventor, l = n === ul.Se, h = o && qc(i, [9, 0, 0]) || l && qc(i, [23, 0, 0]), g = o ? 10 : 1e3;
    if (e && h && r !== g) {
      const y = r / g;
      t[0] *= y, t[5] *= y, t[10] *= y;
    }
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByModelInc(t, e, i, n, r) {
    let o = 0;
    if (n.length === 0)
      return;
    let l;
    const h = Cs.create(() => {
      const u = t.get(), f = Vi(u), g = f.getAttachScope();
      l = f.attachedInvisibly();
      const y = f.split(g, l, u);
      u.addAttachContext(y);
      const _ = new $n(
        this._assemblyTree,
        y,
        e,
        i
      );
      y.addInclusionContext(_);
      const x = _e.createDynamic(
        this._assemblyTree,
        _,
        `Of Inclusion (${e})`,
        null,
        null,
        !l,
        r
      );
      return _.addProductOccurrence(x), x;
    });
    for (const u of n) {
      let f = this._assemblyTree.lookupAnyBodyByInstanceInc(e, u);
      if (f === null) {
        const g = h.get(), y = `Implicit Body ${++o}`, _ = await this._engine.getPartsBounding(
          [e, u],
          !0,
          !1
        ), x = _.max !== _.min && !_.isDegenerate();
        f = this._assemblyTree.createMeshInstance(
          !0,
          // mark loaded
          e,
          u,
          null,
          // authored node id
          y,
          g,
          // parent
          !1,
          // prevent from resetting
          !1,
          // out of hierarchy
          x,
          !0
          // is implicit
        ), l && f.setVisibility(!1);
      }
    }
  }
  _getPrototypeInstanceCountByAttachment(t) {
    const e = /* @__PURE__ */ new Set();
    let i = 0;
    const n = t.getAllInclusions();
    for (let r = 0; r < n.length; r += 2) {
      const o = n[r], l = n[r + 1];
      e.has(l) || (e.add(l), i += this._assemblyTree.getInstanceCountByInclusion(o));
    }
    return i;
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByAttachment(t, e, i) {
    console.assert(t.isLoaded());
    let n = null;
    const r = Cs.create(() => {
      const f = new tl(), g = e.getMasterModelKey();
      n = new Pn(
        f,
        e.getAttachScope(),
        e.attachedInvisibly(),
        g,
        t
      );
      const y = new $n(
        this._assemblyTree,
        n,
        Ni.Local,
        Is.Local
      );
      n.addInclusionContext(y);
      const _ = _e.createDynamic(
        this._assemblyTree,
        y,
        "Implicit Bodies",
        null,
        // authored node id
        null,
        // local transform
        !e.attachedInvisibly(),
        i
      );
      return y.addProductOccurrence(_), _;
    });
    let o = e.prototypeInstanceCount();
    o === 0 && ([o] = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      Gu.Attachment,
      $u.KeyCountOnly
    ));
    let l = this._getPrototypeInstanceCountByAttachment(e);
    if (l === o)
      return;
    const h = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      Gu.Attachment,
      $u.AllKeys
    ), u = e.getAllInclusions();
    for (let f = 0; f < u.length; f += 2) {
      const g = u[f], y = u[f + 1], _ = h.get(y);
      _ !== void 0 && await this._patchImplicitNodesByModelInc(
        r,
        g,
        y,
        _,
        i
      );
    }
    if (l = this._getPrototypeInstanceCountByAttachment(e), l < o)
      throw new oi();
    n !== null && (await pa([n]), t instanceof Ls, t.addAttachContext(n));
  }
  /**
   * Newly loaded children should have their instances demanded if any of their
   * ancestors are currently being demanded. This function performs this logic.
   */
  async _updateOnDemandRequests(t) {
    if (!this._assemblyTree.onDemandRequestsActive())
      return;
    const e = t.getChildren(), i = [];
    for (const n of e)
      this._assemblyTree.isBeingRequested(n) && i.push(n);
    return this._assemblyTree.requestNodes(this, i, !0);
  }
  async _populateAttachment(t, e, i, n, r, o) {
    console.assert(r === vs.Indirect == (o !== null));
    const l = await this._parseRootNodes(
      t,
      e,
      i,
      n,
      o
    );
    return await this._postProcessAttachContext(e, n, r, l), l;
  }
  async _postProcessAttachContext(t, e, i, n) {
    await Ln.forceLazyPromises(n), await this._assemblyTree.enqueue(() => S0(this._engine, n));
    let r = this._assemblyTree.markImplicitNodesOutOfHierarchy();
    r && (r = n.getChildren().length > 0 || i === vs.Indirect), await this._patchImplicitNodesByAttachment(t, e, r), await this._updateOnDemandRequests(n);
    const l = n.getChildren().map((h) => h.getRuntimeId());
    this._callbackManager.trigger("_attachmentPopulated", l);
  }
  async _parseRootNodes(t, e, i, n, r) {
    const o = n.getMasterModelKey(), l = n.getInclusionsOf(o);
    o === jr.Invalid && (console.assert(l.length === 0), l.push(Ni.Invalid, Is.Invalid));
    const h = new Pn(
      i,
      n.getAttachScope(),
      n.attachedInvisibly(),
      o,
      e
    );
    r !== null && h.setReservedNodeIdOffset(r);
    const u = new Uo(1, !0), f = await this._assemblyTree.enqueue(() => h.getRootNodeMetaData(this._assemblyTree));
    for (let g = 0; g < l.length; g += 2)
      u.push(() => {
        const y = l[g], _ = l[g + 1];
        return this._parseRootNode(t, h, f, y, _);
      });
    return await u.waitForIdle(), h;
  }
  async _parseRootNode(t, e, i, n, r) {
    console.assert(n !== Ni.Local);
    const o = await this._populateInclusion(
      t,
      e,
      i,
      n,
      r
    );
    if (o.hasAuthoredId()) {
      console.assert(!o.isLoaded());
      const l = qi(o);
      Kx(l) && this._setupRootNode(o, !1, !1, !0);
    } else o.getName() === null && (e.removeProductOccurrence(o) || console.assert(!1));
  }
  _setupRootNode(t, e, i, n, r = [], o = ul.Unknown) {
    console.assert(!t.isAbsoluteRoot()), e && t.markIsExternalModelRoot(this._assemblyTree), this._resolveMeasurementUnits(
      t,
      i,
      n,
      r,
      o
    );
  }
  async _populateInclusion(t, e, i, n, r) {
    console.assert(n !== Ni.Local);
    const o = new $n(
      this._assemblyTree,
      e,
      n,
      r
    );
    e.addInclusionContext(o);
    const l = await (async () => {
      if (i === null || i.bytes.length === 0) {
        let f = null;
        return i === null && (f = Uy), _e.createDynamic(
          this._assemblyTree,
          o,
          f,
          null,
          // authored node id
          null,
          // local transform
          !e.attachedInvisibly()
        );
      }
      const h = new th(i), u = _e.parseBinary(
        t,
        this._assemblyTree,
        o,
        h
      );
      return _e.reify(
        t,
        this,
        this._assemblyTree,
        o,
        u,
        o
      );
    })();
    return o.addProductOccurrence(l), l;
  }
  /**
   * COM-1701
   */
  async _rectifyLateVisibilityChange(t, e) {
    const i = Vi(e.getParent()), n = mr(e.getParent());
    if (console.assert(n === mr(i)), t.attachInvisibly || n === null || !n.isLoaded())
      return;
    const r = n.isVisible();
    if (i.attachedInvisibly() === !r)
      return;
    const o = r ? ao.Initial : ao.Hide;
    return I0({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      attachContext: i,
      setVisibility: o
    });
  }
  _loadCleanup(t, e, i) {
    console.assert(this._activeLoadCount > 0), t.onLoadComplete(), e !== null && this._callbackManager.unbind(e), --this._activeLoadCount, this._assemblyTree.onLoadEnd(i), this._callbackManager.trigger("visibilityChanged", [], []);
  }
  _wrap(t, e, i, n) {
    const r = this._activeLoadGeneration;
    return this._loadQueue.push(async () => {
      const o = this._assemblyTree.onLoadBegin();
      let l = null;
      if (r !== this._activeLoadGeneration)
        throw this._loadCleanup(e, l, o), new dd();
      this._firstAssemblyDataHeader === null && (l = {
        _modelStructureHeaderParsed: async (y) => {
          l !== null && (this._firstAssemblyDataHeader === null && (this._firstAssemblyDataHeader = y), this._callbackManager.unbind(l), l = null);
        }
      }, this._callbackManager.bind(l, !0));
      try {
        await i;
      } catch (y) {
        throw await e.purgeContents(), this._loadCleanup(e, l, o), y;
      }
      const h = e.getParent();
      if (h === null)
        throw this._loadCleanup(e, l, o), new oi();
      n === vs.Direct && (e.hasChildren() ? h.addLoadContext(e) : await e.purgeContents()), this._loadCleanup(e, l, o);
      const f = e.getChildren(), g = [];
      for (const y of f) {
        const _ = this._rectifyLateVisibilityChange(t, y);
        g.push(_);
      }
      if (await We(g), this._isFirstLoad) {
        this._isFirstLoad = !1, e.markAsFirstLoad();
        const y = f.map((x) => x.getRuntimeId()), _ = !1;
        try {
          await this._callbackManager.promiseTrigger(
            "_firstModelLoaded",
            "firstModelLoaded",
            y,
            _,
            n,
            t
          );
        } catch (x) {
          throw console.assert(!1), x;
        }
      }
      return e;
    });
  }
  _initLoad(t, e, i) {
    ++this._activeLoadCount;
    const n = this._isScsSession && i ? new jx() : null;
    return new Ls(t, e, n);
  }
  static _getNetMatrix(t, e) {
    let i = wt.createFromArray(eh(t));
    return e !== null && (i = wt.multiply(e, i)), i;
  }
  _lazyAttachInvisibly(t, e) {
    return Cs.create(() => e.attachInvisibly || !t.isVisible());
  }
  _loadBySingleAttach(t, e, i, n) {
    const r = this._initLoad(e, n, !1), o = Wn.create(async () => {
      const l = await i, h = new tl(), u = Ag._getNetMatrix(e, t.additionalMatrix), f = e.getMeasurementUnit(), g = this._lazyAttachInvisibly(e, t), y = await this._scAttacher.simpleAttach(
        this._assemblyTree,
        h,
        l,
        u,
        f,
        g,
        null,
        // xml attach info
        !1
      ), _ = await this._populateAttachment(
        t,
        r,
        h,
        y,
        vs.Direct,
        null
      );
      return await pa([r, _]), _.hasChildren() && r.addAttachContext(_), {};
    });
    return this._wrap(t, r, o, vs.Direct);
  }
  async _populateFromXml(t, e, i, n) {
    let o = i.documentElement.firstElementChild, l = null, h = null;
    for (; o !== null; ) {
      if (o.localName === "ModelFile" && (console.assert(l === null), l = nf.parseXml(
        t,
        this._assemblyTree,
        e,
        o,
        n
      )), o.localName === "DefaultCamera" && (h = ui.parseCamera(o), !h))
        throw new si(`"DefaultCamera" element exists but couldn't be parsed`);
      o = o.nextElementSibling;
    }
    if (l === null)
      throw new si('Expected "ModelFile" element.');
    let u = !1;
    if (this._isFirstLoad) {
      let g = Ds;
      if (this._assemblyTree.getAutomaticMeasurementUnitScaling() && (g = mr(e).getMeasurementUnit()), h != null)
        u = !0, await this._view._setCameraPromise(h, 0);
      else {
        const y = nf.parseBounding(l, g);
        !y.isDegenerate() && h === null && (u = !0, await this._view.setViewOrientation(Ct.Iso, 0, y));
      }
    }
    const f = await nf.reify(
      t,
      this._callbackManager,
      this,
      this._assemblyTree,
      e,
      l
    );
    for (const g of f)
      this._setupRootNode(g, !1, !1, !0);
    this._isFirstLoad && !u && await this._view.setViewOrientation(Ct.Iso, 0);
  }
  _loadByXml(t, e, i, n, r) {
    const o = this._initLoad(e, r, !0), l = Wn.create(async () => {
      const h = await i;
      qx(h);
      const u = Gx(h);
      if (u === null || !$x(u))
        throw new si("Bad version.");
      const f = (C) => n(C, u);
      this._scAttacher.reprioritizeAttachmentsNow(), e.addLoadContext(o);
      const g = qi(e), y = Vi(g), _ = this._scAttacher.newAttachScope(), x = this._lazyAttachInvisibly(e, t), b = y.split(
        _,
        x.get(),
        o
      );
      o.addAttachContext(b);
      const I = g.split(
        this._assemblyTree,
        b
      );
      return b.addInclusionContext(I), await this._populateFromXml(t, I, h, f), await pa([o, b]), {};
    });
    return this._wrap(t, o, l, vs.Indirect);
  }
  // For external models built-directly inside SC metadata (i.e. not from a shattered XML file).
  async _attachExternalModelByInc(t, e) {
    console.assert(t.inclusionKey !== Ni.Local);
    const i = Vi(e).getAttachScope(), n = t.modelKey, r = this._lazyAttachInvisibly(e, t.config), o = new tl(), l = new Pn(
      o,
      i,
      r.get(),
      n,
      e
    ), h = await l.getRootNodeMetaData(this._assemblyTree);
    return await this._populateInclusion(
      t.config,
      l,
      h,
      t.inclusionKey,
      t.modelKey
    ), l;
  }
  // For external models given by shattered XML files.
  async _attachExternalModelInfoByName(t, e, i) {
    const n = new tl(), r = this._lazyAttachInvisibly(e, t.config), o = e.getMeasurementUnit(), l = (() => {
      const f = wt.createFromArray(eh(e));
      if (o <= 0 || !this._assemblyTree.getAutomaticMeasurementUnitScaling())
        return f;
      const g = (() => {
        const x = i.getAttachContext().getParent();
        if (x === null) return Ds;
        const b = x.getParent();
        return b === null ? Ds : b.getMeasurementUnit();
      })(), y = g === Ds ? 1 : o / g;
      return y === 1 ? f : wt.multiply(
        f,
        new wt().setScaleComponent(y, y, y)
      );
    })(), h = {
      bounding: t.bounding,
      parent: e,
      directlyRequested: !1
    };
    let u;
    if (this._isScsSession)
      this._scAttacher.registerXmlAttachInfo(h), u = await this._scAttacher.attachByNamedScsBuffer(
        this._assemblyTree,
        t.modelName,
        n,
        t.toAttachData,
        l,
        o,
        r,
        h,
        t.cancelUnitScale,
        t.autoUnitScale
      ) || 0;
    else
      try {
        const f = await t.toAttachData(t.modelName);
        if (f === null || f === wa)
          u = 0;
        else {
          if (typeof f != "string")
            throw new oi();
          this._scAttacher.registerXmlAttachInfo(h), u = await this._scAttacher.simpleAttach(
            this._assemblyTree,
            n,
            f,
            l,
            o,
            r,
            h,
            t.config.allowMissingExternalModels
          );
        }
      } catch (f) {
        if (t.config.allowMissingExternalModels && f instanceof fd)
          u = 1;
        else
          throw f;
      }
    if (typeof u == "number") {
      const f = this._scAttacher.newAttachScope(), g = !r.get();
      return Xx(
        this._assemblyTree,
        n,
        e,
        u,
        f,
        g
      );
    } else
      return this._populateAttachment(
        t.config,
        e,
        n,
        u,
        vs.Indirect,
        t.reservedNodeIdOffset
      );
  }
  setPrefetchScsCutoffScale(t) {
    this._scAttacher.setPrefetchScsCutoffScale(t);
  }
  isIdle() {
    return this._activeLoadCount === 0 ? (console.assert(this._scAttacher.isIdle()), !0) : !1;
  }
  waitOnCurrentLoads() {
    return this._loadQueue.waitForIdle();
  }
  cancelPendingLoads() {
    return ++this._activeLoadGeneration, this.waitOnCurrentLoads();
  }
  async cancelActiveAttachmentProcess() {
    return this._scAttacher.clearAttachQueues();
  }
  loadByStream(t, e, i) {
    if (i === wa) {
      const n = new Ls(e, wa, null);
      return Promise.resolve(n);
    }
    return this._loadBySingleAttach(t, e, Promise.resolve(i), i);
  }
  loadByScsBuffer(t, e, i) {
    return this._loadBySingleAttach(t, e, Promise.resolve(i), "*SCS Buffer*");
  }
  async loadByScsFile(t, e, i) {
    if (Na.isSupported())
      return this._loadBySingleAttach(t, e, Na.request(i), i);
    {
      const n = Hy(i);
      return this._loadBySingleAttach(t, e, n, i);
    }
  }
  loadByXmlDoc(t, e, i, n) {
    let r;
    return typeof i == "string" ? r = jy(i) : r = i, this._loadByXml(t, e, Promise.resolve(r), n, "*XML Document*");
  }
  loadByXmlFile(t, e, i, n) {
    const r = Wx(i);
    return this._loadByXml(t, e, r, n, i);
  }
  async attachByExternalModelInfo(t, e, i) {
    let n, r = !1, o = !0;
    Qc(t) ? (r = t.cancelUnitScale, o = t.autoUnitScale, n = await this._attachExternalModelInfoByName(t, e, i)) : n = await this._attachExternalModelByInc(t, e);
    const l = [], h = n.getChildren(), u = n.getAssemblyDataVersion(), f = n.getOriginalFileType();
    for (const g of h) {
      this._setupRootNode(
        g,
        !0,
        r,
        o,
        u,
        f
      );
      const y = this._rectifyLateVisibilityChange(t.config, g);
      l.push(y);
    }
    return await We(l), n;
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadByAssemblyData(t, e, i, n) {
    const r = vs.Direct, [o, l] = i, h = this._scAttacher.newAttachScope(), u = !e.isVisible(), f = Jx(h, u, o, l), g = this._initLoad(e, "*Assembly Data*", !1), y = Wn.create(async () => {
      const _ = new tl(), x = f.getMasterModelKey(), b = new Pn(
        _,
        h,
        f.attachedInvisibly(),
        x,
        g
      );
      return await this._parseRootNode(t, b, n, o, l), await this._postProcessAttachContext(g, f, r, b), await pa([g, b]), b.hasChildren() && g.addAttachContext(b), {};
    });
    return this._wrap(t, g, y, r);
  }
  reset() {
    return this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, this._scAttacher.reset();
  }
  notifyDirectRequest(t) {
    this._scAttacher.notifyDirectRequest(t);
  }
  onLoadChildProductOccurrence() {
    if (this._nodesUntilNextSleep === 0)
      return this._nodesUntilNextSleep = 2e3, this._engine.sleep(
        10
        /* sleepLengthMilliseconds */
      );
    --this._nodesUntilNextSleep;
  }
  firstAssemblyDataHeader() {
    return this._firstAssemblyDataHeader;
  }
}
function Yx(s, t, e, i, n) {
  const r = [], o = (g) => {
    g.getInclusionContexts().forEach((_) => {
      r.push(_.getInclusionKey());
    });
  }, l = (g) => {
    g.getAttachContexts().forEach(o);
  }, u = {
    enterProductOccurrence: (g) => {
      if (i.has(g) || (i.add(g), g.isOutOfHierarchy() && !e))
        return;
      g.getChildContexts().forEach((_) => {
        _ instanceof Ls ? l(_) : o(_);
      });
    }
  }, f = s.walk(u, t, n);
  return f ? f.then(() => r) : r;
}
function Zx(s, t, e, i) {
  return Yx(
    Ph,
    s,
    t,
    e,
    i
  );
}
function Qx(s, t, e) {
  const i = [], n = /* @__PURE__ */ new Set();
  for (const r of t) {
    const o = s.lookupAnyTreeNode(r);
    if (o === null)
      throw new Ns(r);
    const l = Do(o), h = Zx(o, l, n, e);
    for (const u of h)
      i.push(u);
  }
  return i;
}
async function tI(s) {
  let t = !1;
  const e = (n) => {
    n.hasLocalTransformOverride() && (n.removeLocalTransformOverride(), t = !0);
  }, i = {
    enterProductOccurrence: e,
    enterPmi: e,
    enterCadView: e,
    enterAnyBody: (n) => {
      n.preventFromResetting() || e(n);
    }
  };
  return await Ln.walk(i, s, Vt.None), t;
}
function eI(s, t, e) {
  const i = [], n = /* @__PURE__ */ new Set(), r = (l) => n.has(l) ? !1 : (n.add(l), !0), o = {
    followProductOccurrence: r,
    followPmi: r,
    followCadView: r,
    followAnyBody: r,
    enterAnyBody: (l) => {
      if (!l.isOutOfHierarchy()) {
        const h = l.getInstanceInc();
        i.push(h[0], h[1]);
      }
    }
  };
  for (const l of t)
    Ph.walk(o, l, Vt.None);
  s.setMeshLevel(i, e);
}
function iI(s) {
  return s instanceof Bi || s instanceof $i || s instanceof xa || s instanceof Ia || s instanceof Ca || s instanceof ph || s instanceof mh || s instanceof _h || s instanceof yh || s instanceof wh || s instanceof vh || s instanceof bh || s instanceof xh || s instanceof Ih || s instanceof Ch || s instanceof Sh || s instanceof Mh || s instanceof gh;
}
function nI(s) {
  return s instanceof fh || s instanceof kl || s instanceof zo;
}
function Xp(s) {
  return async (t, e) => {
    const i = qc(e, [7, 3]) ? `${t}.scs` : t, n = await s(i);
    return typeof n == "string" ? Na.isSupported() ? Na.request(n) : Hy(n) : n;
  };
}
class sI {
  constructor(t, e, i, n, r) {
    this._clearQueue = new Uo(1, !1), this._clearInProgress = !1, this._cadConfigurationsEnabled = !0, this._engine = e, this._callbackManager = i, this._cuttingManager = n, this._model = r, this._assemblyTree = new Vx(
      t,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      this._model
    ), this._readyPromise = hd();
  }
  async init(t, e) {
    const i = await sd.createWithEmptyModel(
      this._engine,
      t,
      this._callbackManager,
      e
    );
    this._assemblyTree.initialize(i);
    const n = new Ag(
      this._assemblyTree,
      i,
      this._engine,
      t,
      this._callbackManager
    );
    console.assert(this._treeLoader === void 0), this._treeLoader = n, this._readyPromise.resolve();
  }
  async _loadSubtreePrologue(t, e, i) {
    if (this._engine.getSessionType() !== t)
      throw new Kr("Incompatible load types.");
    if (i && await this._clearQueue.waitOnLatest(), this._clearInProgress)
      throw new dd();
    const n = this._assemblyTree.lookupProductOccurrence(e);
    if (n === null)
      throw new os(e, Cn.ProductOccurrence);
    return n;
  }
  async _loadSubtreeEpilogue(t, e) {
    t.isFirstLoad() && this._engine.getSessionType() === nn.Scs && await this._callbackManager.promiseTrigger("_firstBoundingReady", null);
    const n = t.getChildren().map((r) => r.getRuntimeId());
    return e && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      n,
      uo.LoadModel
    ), n;
  }
  async loadSubtreeFromXmlFile(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = nn.Network, o = await this._loadSubtreePrologue(r, t, !0), l = await this._treeLoader.loadByXmlFile(
      n,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(l, !1);
  }
  async loadSubtreeFromXmlDoc(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = nn.Network, o = await this._loadSubtreePrologue(r, t, !0), l = await this._treeLoader.loadByXmlDoc(n, o, e, i);
    return this._loadSubtreeEpilogue(l, !1);
  }
  async loadSubtreeFromScsXmlFile(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = nn.Scs, o = await this._loadSubtreePrologue(r, t, !0), l = Xp(i), h = await this._treeLoader.loadByXmlFile(n, o, e, l);
    return this._loadSubtreeEpilogue(h, !1);
  }
  async loadSubtreeFromScsXmlDoc(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = nn.Scs, o = await this._loadSubtreePrologue(r, t, !0), l = Xp(i), h = await this._treeLoader.loadByXmlDoc(n, o, e, l);
    return this._loadSubtreeEpilogue(h, !1);
  }
  async _loadSubtreeFromStream(t, e, i, n) {
    const r = nn.Network, o = await this._loadSubtreePrologue(r, t, i), l = await this._treeLoader.loadByStream(n, o, e);
    return this._loadSubtreeEpilogue(l, n._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromStream(t, e, i) {
    return this._loadSubtreeFromStream(t, e, !0, i);
  }
  async loadSubtreeFromScsFile(t, e, i) {
    const n = nn.Scs, r = await this._loadSubtreePrologue(n, t, !0), o = await this._treeLoader.loadByScsFile(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromScsBuffer(t, e, i) {
    const n = nn.Scs, r = await this._loadSubtreePrologue(n, t, !0), o = await this._treeLoader.loadByScsBuffer(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadSubtreeFromAssemblyData(t, e, i, n) {
    const r = nn.Network, o = await this._loadSubtreePrologue(r, t, !0), l = await this._treeLoader.loadByAssemblyData(
      n,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(l, n._allowSubtreeLoadedCallback);
  }
  async loadMeasurementFromJson(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const n = parseInt(i, 10);
      if (isNaN(n))
        continue;
      const r = t[n], o = parseInt(r.instance_id, 10);
      if (isNaN(o))
        continue;
      const l = await this._getNodeOrRepItemFromId(o);
      if (!(l instanceof en))
        continue;
      const h = r.edge_properties;
      for (let f = 0; f < h.length; f++) {
        const g = h[f], y = g.id, _ = g.data;
        let x = null;
        switch (g.type) {
          case "circle":
            x = kl.fromJson(_);
            break;
          case "line":
            x = fh.fromJson(_);
            break;
          case "unknown_edge":
            x = zo.fromJson(_);
            break;
        }
        x !== null && l.setEdgeMeasurementProperty(y, x);
      }
      const u = r.face_properties;
      for (let f = 0; f < u.length; f++) {
        const g = u[f], y = g.id, _ = g.data;
        let x = null;
        switch (g.type) {
          case "cylinder":
            x = Bi.fromJson(_);
            break;
          case "plane":
            x = $i.fromJson(_);
            break;
          case "cone":
            x = xa.fromJson(_);
            break;
          case "sphere":
            x = Ia.fromJson(_);
            break;
          case "torus":
            x = Ca.fromJson(_);
            break;
        }
        x !== null && l.setFaceMeasurementProperty(y, x);
      }
    }
  }
  async loadMeasurementFromString(t) {
    const e = JSON.parse(t);
    return this.loadMeasurementFromJson(e);
  }
  async loadMeasurementFromFile(t) {
    const e = await Eg(t, "blob");
    if (e.status !== 200)
      throw new Error(`Cannot pull measurement file '${t}': ${e.response}`);
    const n = (await _g.loadAsync(e.response)).file("measurement.json");
    if (!n)
      throw new Error(`Cannot pull measurement data from '${t}'`);
    const r = await n.async("string");
    return this.loadMeasurementFromString(r);
  }
  async _clearImpl() {
    console.assert(!this._clearInProgress), this._clearInProgress = !0;
    try {
      await this._treeLoader.cancelActiveAttachmentProcess(), await this._treeLoader.cancelPendingLoads(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._treeLoader.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._assemblyTree.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), this._clearInProgress = !1;
    } catch (t) {
      throw console.assert(this._clearInProgress), this._clearInProgress = !1, t;
    }
  }
  clear() {
    return this._clearQueue.push(async () => (this._callbackManager.trigger("modelSwitchStart", !0), await this._clearImpl(), this._callbackManager.promiseTrigger(
      "_modelSwitched",
      "modelSwitched",
      !0,
      [],
      vs.Direct
    )));
  }
  switchToModel(t) {
    const e = t === wa;
    return this._clearQueue.push(async () => {
      this._callbackManager.trigger("modelSwitchStart", !1), await this._clearImpl();
      let i;
      return e ? i = [] : i = await this._loadSubtreeFromStream(
        this.getAbsoluteRootNodeId(),
        t,
        !1,
        new Ma()
      ), await this._callbackManager.promiseTrigger(
        "_modelSwitched",
        "modelSwitched",
        e,
        i,
        vs.Direct
      ), i;
    });
  }
  getAbsoluteRootNodeId() {
    return this._assemblyTree.getRootNode().getRuntimeId();
  }
  isIdValid(t) {
    return this._assemblyTree.lookupAnyNode(t) !== null;
  }
  _getNodeChildren(t, e) {
    let i = t.getChildrenSync();
    e || (i = i.filter((o) => !o.isOutOfHierarchy()));
    const n = t.getBodyInstances();
    for (const o of n)
      (!o.isOutOfHierarchy() || e) && i.push(o);
    const r = t.getPmis();
    for (const o of r)
      i.push(o);
    return i;
  }
  getChildIds(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return [];
    const n = this._getNodeChildren(i, e), r = [];
    for (const o of n)
      r.push(o.getRuntimeId());
    return r;
  }
  isOutOfHierarchy(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null && Do(e);
  }
  getParentId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = v_(e.getParent());
    return i === null ? null : i.getRuntimeId();
  }
  async getPartReferrers(t) {
    const e = this._assemblyTree.lookupProductOccurrence(t);
    if (e === null)
      return null;
    const i = this._assemblyTree.getRootNode();
    await Cf(i), await D0(i);
    const n = e.getPartDefinitionSync();
    if (n === null)
      return null;
    const r = n.getReferrers(), o = /* @__PURE__ */ new Set();
    for (const l of r) {
      const u = l.getParent().getReferrers();
      for (const f of u)
        o.add(f.getRuntimeId());
    }
    return Array.from(o);
  }
  async getAttributes(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e === null ? [] : e.getAttributes();
  }
  async getProperties(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i === null)
      return null;
    const n = await this._getNodeAttributes(i), r = {};
    if (i instanceof en) {
      const o = i.getPhysicalProperties();
      o !== null && Object.assign(n, this._handlePhysicalProperties(t, o));
    } else if (i instanceof _e) {
      await Zc(i);
      const o = await i.getPhysicalProperties(e);
      o !== null && Object.assign(n, this._handlePhysicalProperties(t, o));
      const l = await i.getPartDefinition();
      l !== null && Object.assign(r, await this._getPartDefAttributes(await l.value));
    }
    return { ...r, ...n };
  }
  addProperty(t, e, i, n) {
    const r = this._assemblyTree.lookupAnyNode(t);
    if (r === null)
      return !1;
    const o = new pr(
      Hr.String,
      e,
      null,
      i,
      n
    );
    return r.addAttribute(o), !0;
  }
  setPhysicalProperties(t, e, i, n) {
    const r = this._assemblyTree.lookupRepresentationItem(t);
    if (r === null)
      return !1;
    const o = new _a(i, n, e);
    return r.setPhysicalProperties(o), !0;
  }
  getUserDataIndices(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      throw new Ns(t);
    return e.getUserDataIndices();
  }
  getUserData(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      throw new Ns(t);
    return i.getUserData(e);
  }
  getInstanceIncs(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      return console.assert(!1), [];
    const n = Do(i);
    return Yc(
      i,
      e,
      n,
      /* @__PURE__ */ new Set(),
      Vt.None
    );
  }
  getNodeFromInstanceInc(t, e, i, n) {
    let r = this._assemblyTree.lookupAnyBodyByInstanceInc(
      e,
      i
    );
    if (r === null) {
      const o = t ? this._rectifyParent(e, null) : this._assemblyTree.getRootNode();
      r = this._assemblyTree.createMeshInstance(
        t,
        e,
        i,
        null,
        // authored ID
        null,
        // name
        o,
        !1,
        // prevent from resetting
        n,
        !0,
        // initially visible
        !1
        // implicit body
      );
    } else r instanceof Bs && (r = r.getParent());
    return r.getRuntimeId();
  }
  _getAssociatedModelKey(t) {
    return t instanceof as ? t.getModelKey() : this._getAssociatedModelKey(t.getParent());
  }
  getAssociatedModelKey(t) {
    let e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? (e = this._assemblyTree.lookupAnyNonTreeNode(t), e === null ? null : this._getAssociatedModelKey(e)) : Vi(e).getMasterModelKey();
  }
  getMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      return new wt();
    const i = e.getLocalTransform();
    return i === null ? new wt() : wt.createFromArray(i);
  }
  async setMatrix(t, e, i) {
    const n = this._assemblyTree.lookupAnyTreeNode(t);
    if (n === null)
      return;
    i ? n.setLocalTransformAsInitial(e.m) : n.overrideLocalTransform(e.m);
    const r = Do(n);
    return dc(this._engine, this._callbackManager, [n], r);
  }
  setMatrices(t, e, i) {
    const n = [];
    let r = !1;
    for (let o = 0; o < t.length; o++) {
      const l = this._assemblyTree.lookupAnyTreeNode(t[o]), h = e[o];
      l !== null && (i ? l.setLocalTransformAsInitial(h.m) : l.overrideLocalTransform(h.m), r = r || Do(l), n.push(l));
    }
    return dc(this._engine, this._callbackManager, n, r);
  }
  async resetToInitialMatrix(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null && e.hasLocalTransformOverride()) {
      e.removeLocalTransformOverride();
      const i = Do(e);
      return dc(this._engine, this._callbackManager, [e], i);
    }
  }
  getNetMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? Gn.getIdentity() : eh(e);
  }
  _getBodyInstanceIndexFrom(t, e, i) {
    i === void 0 && (i = {});
    const n = t.getBodyInstances();
    for (const l of n)
      if (i.value !== void 0 ? i.value++ : i.value = 0, l === e) return i.value;
    let r;
    const o = t.getChildrenSync();
    for (const l of o)
      if (r = this._getBodyInstanceIndexFrom(l, e, i), r !== void 0) return r;
  }
  async getNodeOrRepItem(t) {
    if (t instanceof ji) {
      const e = t.getParent();
      let i, n = e;
      for (; ; ) {
        if (!(n instanceof _e))
          return null;
        await Zc(n);
        const l = await n.getPartDefinition();
        if (l !== null) {
          i = await l.value;
          break;
        }
        n = n.getParent();
      }
      const r = this._getBodyInstanceIndexFrom(n, t), o = i.getRepresentationItems();
      return r !== void 0 && r < o.length ? o[r] : null;
    } else if (t instanceof _e || t instanceof Mn || t instanceof ls || t instanceof as || t instanceof en)
      return t;
    return null;
  }
  async _getNodeOrRepItemFromId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? null : this.getNodeOrRepItem(e);
  }
  async getPointAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof en) {
      const n = i.getPointAttributes(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  async getEdgeCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof en ? e.getEdgeCount() : 0;
  }
  async getEdgeAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof en) {
      const n = i.getEdgeAttributes(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  async getEdgeProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof en) {
      const n = i.getEdgeMeasurementProperty(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  async getFaceCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof en ? e.getFaceCount() : 0;
  }
  async getFaceAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof en) {
      const n = i.getFaceAttributes(e);
      if (n != null) return n.copy();
    }
    return null;
  }
  async getFaceProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof en) {
      const n = i.getFaceMeasurementProperty(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  setEdgeProperty(t, e, i) {
    const n = this._assemblyTree.lookupRepresentationItem(t);
    n !== null && nI(i) && n.setEdgeMeasurementProperty(e, i);
  }
  setFaceProperty(t, e, i) {
    const n = this._assemblyTree.lookupRepresentationItem(t);
    n !== null && iI(i) && n.setFaceMeasurementProperty(e, i);
  }
  getName(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getName() : null;
  }
  getNodeExchangeId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getExchangeId() : null;
  }
  getFilters() {
    return this._assemblyTree.getFilters();
  }
  getFilterName(t) {
    return this._assemblyTree.getFilterName(t);
  }
  getFiltersWithNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? [] : this._assemblyTree.getFiltersWithNode(e);
  }
  getNodesFromFilterIds(t) {
    return this._assemblyTree.getNodesFromFilterIds(t);
  }
  getLayers() {
    return this._assemblyTree.getLayers();
  }
  getUniqueLayerNames() {
    return this._assemblyTree.getUniqueLayerNames();
  }
  getLayerName(t) {
    return this._assemblyTree.getLayerName(t);
  }
  getLayerIdsFromName(t) {
    return this._assemblyTree.getLayersIdFromName(t);
  }
  getNodeLayerId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = e.getAuthoredLayerId();
    return i === null ? null : Ys(e).getRuntimeLayerId(i);
  }
  getAuthoredNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((n) => n.getAuthoredId());
  }
  getAuthoredNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((n) => n.getAuthoredId());
  }
  getRuntimeNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((n) => n.getRuntimeId());
  }
  getRuntimeNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((n) => n.getRuntimeId());
  }
  getRuntimeNodesFromLayerName(t, e) {
    const i = this._assemblyTree.getNodesFromLayerName(t, e);
    return i === null ? null : i.map((n) => n.getRuntimeId());
  }
  createCadView(t, e, i, n, r, o, l, h, u) {
    if (this._assemblyTree.lookupProductOccurrence(t) === null)
      return null;
    const g = this._assemblyTree.lookupProductOccurrence(t);
    if (g === null)
      return null;
    let y = null;
    if (n != null) {
      y = [];
      for (const b of n) {
        const I = this._assemblyTree.lookupPmi(b);
        I !== null && y.push(I);
      }
    }
    const _ = /* @__PURE__ */ new Map();
    for (const [b, I] of l)
      _.set(b, I.m);
    return this._assemblyTree.createCadView(
      this._engine,
      g,
      e,
      i,
      y,
      r,
      o,
      _,
      h,
      u
    ).getRuntimeId();
  }
  getCadViewMap() {
    const t = this._assemblyTree.getFirstProductOccurrenceWithView(), e = /* @__PURE__ */ new Map();
    return this._assemblyTree.forEachCadView((i) => {
      const n = i.getRuntimeId(), r = i.getParent();
      let o;
      r === t ? o = i.getName() || "(null)" : o = `${r.getName()} - ${i.getName()}`, e.set(n, o);
    }), e;
  }
  async activateCadView(t, e, i, n) {
    if (this.applyFilters(this.getFiltersFromView(e)), this._assemblyTree.hasActiveCadView())
      return await this._assemblyTree.deactivateActiveCadView(), this.activateCadView(t, e, i, n);
    const r = this._assemblyTree.lookupCadView(e);
    if (r !== null)
      return this._assemblyTree.activateCadView(t, r, i, n);
  }
  getCadViewPmis(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return [];
    const i = [], n = this._assemblyTree.getCadViewPmis(e);
    for (const r of n)
      i.push(r.getRuntimeId());
    return i;
  }
  async _disableCadConfigurations() {
    this._cadConfigurationsEnabled = !1, await this._assemblyTree.deactivateActiveCadView();
  }
  async cadConfigurationsEnabled() {
    return this._cadConfigurationsEnabled && this._assemblyTree.seenExternalModel() && await this._disableCadConfigurations(), this._cadConfigurationsEnabled;
  }
  getCadConfigurations() {
    const t = {};
    return this._assemblyTree.forEachCadConfiguration((e) => {
      const i = e.getRuntimeId(), n = e.getName() || "(null)";
      t[i] = n;
    }), t;
  }
  getDefaultCadConfiguration() {
    const t = this._assemblyTree.getDefaultCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getActiveCadConfiguration() {
    const t = this._assemblyTree.getActiveCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getCadViewConfiguration(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return null;
    const i = e.getParent();
    return i !== null && i.isAConfigurationNode() ? i.getRuntimeId() : null;
  }
  async _activateCadConfiguration(t, e, i) {
    this._assemblyTree.activateCadConfiguration(e);
    const n = e.getRuntimeId(), r = this._assemblyTree.getCadConfigurations().filter((u) => u !== e).map((u) => u.getRuntimeId()), o = /* @__PURE__ */ new Map();
    o.set(n, !0), r.forEach((u) => {
      o.set(u, !1);
    }), await this.setVisibilitiesByMap(o);
    const l = await f_(e, Wt.All, !0, /* @__PURE__ */ new Set());
    i && l !== null && l.length > 0 && await t.fitNodes([n], cs), this._callbackManager.trigger("configurationActivated", n);
  }
  async activateCadConfiguration(t, e, i) {
    const n = this._assemblyTree.lookupProductOccurrence(e);
    if (n !== null)
      return this._activateCadConfiguration(t, n, i);
  }
  async activateDefaultCadConfiguration(t, e) {
    const i = this._assemblyTree.getDefaultCadConfiguration();
    i !== null && await this._activateCadConfiguration(t, i, e);
  }
  getDefaultCadView() {
    const t = this._assemblyTree.getDefaultCadConfiguration(), e = this._assemblyTree.getDefaultCadView(t);
    return e !== null ? e.getRuntimeId() : null;
  }
  async activateDefaultCadView(t, e, i) {
    const n = this.getDefaultCadView();
    n !== null && await this.activateCadView(t, n, e, i);
  }
  getPmis() {
    const t = {};
    return this._assemblyTree.forEachPmi((e) => {
      const i = e.getRuntimeId(), n = e.getName() || "(null)";
      t[i] = n;
    }), t;
  }
  getPmiType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? b_.Unknown : e.getPmiType();
  }
  getPmiSubType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? x_.Unknown : e.getPmiSubType();
  }
  getUnit(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e instanceof _e ? e.getMeasurementUnit() : e instanceof ji ? e.getParent().getMeasurementUnit() : 1;
  }
  _rectifyParent(t, e) {
    if (e !== null) {
      const n = this._assemblyTree.lookupProductOccurrence(e);
      if (n !== null)
        return n;
      console.assert(!1);
    }
    const i = this._assemblyTree.getInclusionContexts(t);
    if (i.length > 0) {
      const r = i[0].getChildren();
      return console.assert(r.length > 0), r[0];
    }
    return this._assemblyTree.getRootNode();
  }
  createMeshInstance(t, e, i, n, r, o, l) {
    const h = this._rectifyParent(t, n);
    return this._assemblyTree.createMeshInstance(
      !0,
      // mark loaded
      t,
      e,
      null,
      // authored id
      i,
      h,
      r,
      o,
      !0,
      // initially visible
      l
    ).getRuntimeId();
  }
  createPmiInstance(t, e, i, n, r, o, l) {
    const h = this._rectifyParent(t, l);
    return this._assemblyTree.createPmiInstance(
      t,
      e,
      null,
      o,
      h,
      i,
      n,
      r
    ).getRuntimeId();
  }
  setVisibilitiesByMap(t, e) {
    const i = /* @__PURE__ */ new Map();
    t.forEach((l, h) => {
      const u = this._assemblyTree.lookupAnyTreeNode(h);
      u !== null && i.set(u, l);
    });
    let n = null;
    const r = this.getActiveCadConfiguration();
    r !== null && (n = this._assemblyTree.lookupProductOccurrence(r));
    const o = this._assemblyTree.getRootNode();
    return If({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: o,
      visibilityFormatter: (l) => i.get(l),
      resetNonAffectedToDefault: !1,
      configurationNode: n !== null ? n : void 0,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: e
    });
  }
  setBodyNodesVisibility(t, e) {
    const i = typeof e == "boolean" ? (n) => e : e;
    return C0({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: i,
      resetNonAffectedToDefault: !1,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: !1
    });
  }
  setVisibilitiesByValue(t, e, i) {
    const n = /* @__PURE__ */ new Map();
    for (const r of t)
      n.set(r, e);
    return this.setVisibilitiesByMap(
      n,
      i !== null ? i : void 0
    );
  }
  resetAllVisibilities() {
    const t = this._assemblyTree.getRootNode(), e = this._assemblyTree.getActiveCadConfiguration();
    return If({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: () => {
      },
      resetNonAffectedToDefault: !0,
      configurationNode: e !== null ? e : void 0,
      callbackManager: this._callbackManager
    });
  }
  async resetAllTransforms() {
    const t = this._assemblyTree.getRootNode();
    if (await tI(t))
      return dc(this._engine, this._callbackManager, [t], !1);
  }
  async reset() {
    if (this._cadConfigurationsEnabled = !0, this.isACadDrawing())
      return this._callbackManager.promiseTrigger("_resetDrawing", null);
    this._assemblyTree.hasActiveCadView() && await this._assemblyTree.deactivateActiveCadView();
    const t = [this.resetAllVisibilities(), this.resetAllTransforms()];
    await We(t);
  }
  setPmiColor(t, e) {
    e === void 0 && (e = this.getAbsoluteRootNodeId());
    const i = this.getInstanceIncs(
      e,
      Wt.PmiBody | Wt.ViewFrame
    );
    i.length > 0 && (this._engine.setPartColor(i, Jt.Faces, t), this._engine.setPartColor(i, Jt.Lines, t));
  }
  resetPmiColor(t) {
    t === void 0 && (t = this.getAbsoluteRootNodeId());
    const e = this.getInstanceIncs(
      t,
      Wt.PmiBody | Wt.ViewFrame
    );
    e.length > 0 && (this._engine.unsetPartColor(e, Jt.Faces), this._engine.unsetPartColor(e, Jt.Lines));
  }
  getPmiTopologyReferences(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? null : e.getPmiTopologyReferences(this._assemblyTree);
  }
  createNode(t, e, i, n = null, r = !0, o = null) {
    let l = null;
    t !== null && (l = this._assemblyTree.lookupProductOccurrence(t)), l === null && (l = this._assemblyTree.getRootNode()), i !== null && !Pl(i) && (i = null);
    const h = (() => {
      if (o) {
        const g = o / l.getMeasurementUnit(), y = new wt().setScaleComponent(g, g, g);
        return n ? wt.multiply(n, y) : y;
      } else
        return n;
    })(), u = h === null ? null : h.m;
    return this._assemblyTree.createNode(
      l,
      e,
      i,
      u,
      r,
      o
    ).getRuntimeId();
  }
  async deleteNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null) {
      if (e instanceof _e || e instanceof ji || e instanceof Mn)
        return this._assemblyTree.deleteNode(e);
      throw new os(
        t,
        Cn.ProductOccurrence,
        Cn.BodyInstance
      );
    }
  }
  createPart(t) {
    return this._assemblyTree.createPart(t).getRuntimeId();
  }
  setPart(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return !1;
    const n = this._assemblyTree.lookupPartDefinition(e);
    return n === null ? !1 : (this._assemblyTree.setPart(i, n), !0);
  }
  createAndAddRepItem(t, e) {
    const i = this._assemblyTree.lookupPartDefinition(t);
    return i === null ? null : i.createRepItem(this._assemblyTree, e).getRuntimeId();
  }
  getLowestAvailableNodeId() {
    return this._assemblyTree.getLowestAvailableNodeId();
  }
  getType(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? Le.Unknown : $0(e);
  }
  isVisible(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.isVisible() : !1;
  }
  getBranchVisibility(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? G0(e) : ue.Hidden;
  }
  setMeshLevel(t, e) {
    const i = [];
    for (const n of t) {
      const r = this._assemblyTree.lookupAnyTreeNode(n);
      r !== null && i.push(r);
    }
    return eI(this._engine, i, e);
  }
  setEnableAutomaticUnitScaling(t) {
    this._assemblyTree.setAutomaticMeasurementUnitScaling(t);
  }
  setBehaviorInitiallyHidden(t) {
    this._assemblyTree.setInitiallyHiddenStayHidden(t);
  }
  isACadDrawing() {
    return this._assemblyTree.containsDrawings();
  }
  isMeasurable() {
    return this._assemblyTree.isMeasurable();
  }
  async isLineMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof en ? i.getEdgeMeasurementProperty(e) !== null : !1;
  }
  async isFaceMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof en ? i.getFaceMeasurementProperty(e) !== null : !1;
  }
  getModelFileNameFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Vi(e).getOriginalFileName() : null;
  }
  getModelFileTypeFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Vi(e).getOriginalFileType() : null;
  }
  isAnnotationView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e !== null)
      return e.isAnnotationView();
    throw new os(t, Cn.CadView);
  }
  isCombineStateView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e)
      return e.isCombineStateView();
    throw new os(t, Cn.CadView);
  }
  /** This will undo the effect of calling preventNodeDeletion() for the given node. */
  allowNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new oi();
    this._assemblyTree.allowNodeDeletion(e);
  }
  preventNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new oi();
    this._assemblyTree.preventNodeDeletion(e);
  }
  preventMeshDeletion(t) {
    this._assemblyTree.preventMeshDeletion(t);
  }
  getBounding(t, e, i, n) {
    return p_(
      this._assemblyTree,
      this._engine,
      t,
      e,
      i,
      n
    );
  }
  getIdOffset(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e !== null) {
      let i;
      return e instanceof as ? i = e.getInclusionContextForNodeId() : e instanceof en ? i = e.getParent().getInclusionContextForNodeId() : i = qi(e), i.getIdOffset();
    }
    return 0;
  }
  /**
   * Motivation for this function:
   *
   * It is possible to begin a load where some SC geometry gets streamed in
   * but the assembly tree has not been fully parsed. Suppose an SC instance
   * (A) gets streamed, and has its node parsed by the assembly tree. If the
   * user attempts to select (A), our internals will find the NodeId associated
   * with (A). This is so far okay (but not ideal perhaps). The big issue comes
   * when the user starts to query the parents or children of the node. Since
   * the entire loaded subtree has not been fully parsed, querying such things
   * may not make sense because they might not be available. (Querying other
   * things might also be problematic.)
   *
   * It might make sense to not expose this function publically (as it is today
   * in `Model`) and do all the required filtering of selection results in the
   * selection internals. This, however might be 'problematic' when loading a
   * giant model (such as the Boeing). In this case, it might take ages for the
   * tree to completely load, which would make geometry not selectable in the
   * meantime. This might be interpreted as a bug from our users because they might
   * want to highlight such selected geometries.
   *
   * Related: COM-1169
   */
  isNodeLoaded(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      throw new Ns(t);
    return e.isLoaded();
  }
  shutdown() {
    this._treeLoader && this._treeLoader.cancelPendingLoads();
  }
  isReady() {
    return console.assert(this._readyPromise.state !== Wr.Rejected), this._readyPromise.state !== Wr.Pending;
  }
  waitForReady() {
    return this._readyPromise;
  }
  lookupAnyTreeNode(t) {
    return this._assemblyTree.lookupAnyTreeNode(t);
  }
  lookupAnyBody(t) {
    return this._assemblyTree.lookupAnyBody(t);
  }
  lookupBodyInstance(t) {
    return this._assemblyTree.lookupBodyInstance(t);
  }
  gatherInstanceIncsFromNodeIds(t, e, i) {
    return g_(this._assemblyTree, t, e, i);
  }
  gatherInclusionKeysFromNodeIds(t) {
    return Qx(this._assemblyTree, t, Vt.None);
  }
  async requestNodes(t) {
    const e = [];
    for (const i of t) {
      const n = this._assemblyTree.lookupAnyTreeNode(i);
      n !== null && e.push(n);
    }
    return this._assemblyTree.requestNodes(this._treeLoader, e, !1);
  }
  isWithinExternalModel(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return !1;
    let i = mr(e);
    for (; i !== null; ) {
      if (i.isExternalModelRoot())
        return !0;
      i = mr(i.getParent());
    }
    return !1;
  }
  getNodeGenericType(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? ih(e) : null;
  }
  getNodeGenericId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? e.getGenericId() : null;
  }
  getNodesByGenericId(t) {
    const e = this._assemblyTree.getNodesByGenericId(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((n) => {
        i.add(n.getRuntimeId());
      }), i;
    }
    return null;
  }
  getNodesByGenericType(t) {
    const e = this._assemblyTree.getNodesByGenericType(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((n) => {
        i.add(n.getRuntimeId());
      }), i;
    }
    return null;
  }
  getGenericTypes() {
    const t = [];
    return this._assemblyTree.genericTypeToNodes().forEach((i, n) => {
      t.push(n);
    }), t;
  }
  getGenericTypeIdMap() {
    const t = /* @__PURE__ */ new Map();
    return this._assemblyTree.genericTypeToNodes().forEach((i, n) => {
      const r = /* @__PURE__ */ new Set();
      i.forEach((o) => {
        r.add(o.getRuntimeId());
      }), t.set(n, r);
    }), t;
  }
  hasEffectiveGenericType(t, e) {
    const i = this.lookupAnyTreeNode(t);
    if (i === null)
      throw new Ns(t);
    return ob(i, e);
  }
  registerGenericId(t, e) {
    return this._assemblyTree.registerGenericGlobalId(t, e);
  }
  registerGenericType(t, e) {
    return this._assemblyTree.registerGenericType(t, e);
  }
  hasRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    if (e === null)
      throw new Ns(t);
    return qi(e).getRelationships().length > 0;
  }
  getBimIdFromNode(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null || !e.hasAuthoredId() ? null : e.getAuthoredId().toString();
  }
  getRuntimeNodeFromBimId(t, e) {
    const i = this.lookupAnyTreeNode(t);
    return i === null ? null : qi(i).getRuntimeNodeFromBimId(e);
  }
  getRelationsByTypeFromNode(t, e) {
    return this._assemblyTree.getRelationshipsOfItem(t, e);
  }
  firstAssemblyDataHeader() {
    return this._treeLoader.firstAssemblyDataHeader();
  }
  setPrefetchScsCutoffScale(t) {
    this._treeLoader.setPrefetchScsCutoffScale(t);
  }
  getAllRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : qi(e).getRelationships();
  }
  getAllBimInfos(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : qi(e).getBimInfos();
  }
  getInfoOfBimId(t, e) {
    const i = this.getAllBimInfos(t);
    for (const n of i)
      if (n.id === e) {
        let r = n.name, o = !1;
        if (n.category === Fo.Connected) {
          const l = this.getRuntimeNodeFromBimId(t, e);
          l !== null && this.getName(l) !== null && (r = this.getName(l), o = !0);
        }
        return { name: r, connected: o };
      }
    return { name: "", connected: !1 };
  }
  getBimIdRelationshipTypes(t, e) {
    const i = this.lookupAnyTreeNode(t);
    if (i === null)
      return [];
    const n = qi(i);
    return this.$mapBimRelationshipTypes(e, n.getRelationships());
  }
  /** @hidden */
  $mapBimRelationshipTypes(t, e) {
    var r, o;
    const i = /* @__PURE__ */ new Map();
    for (const l of e) {
      const h = i.has(l.type) ? i.get(l.type) : { relateds: /* @__PURE__ */ new Set(), relatings: [] };
      ((r = l.relating) == null ? void 0 : r.relationElt.id) === t ? (o = l.related) == null || o.relationships.forEach((u) => h.relateds.add(u.id)) : l.related !== null && l.relating !== null && l.related.relationships.filter((u) => u.id === t).forEach(() => h.relatings.push(l.relating.relationElt.id)), i.set(l.type, h);
    }
    return Array.from(i.entries()).map((l) => ({
      type: l[0],
      relateds: Array.from(l[1].relateds),
      relatings: Array.from(l[1].relatings)
    }));
  }
  getFiltersFromView(t) {
    var e;
    return ((e = this._assemblyTree.lookupCadView(t)) == null ? void 0 : e.getFilters()) ?? [];
  }
  applyFilters(t) {
    const e = this.getNodesFromFilterIds(t);
    if (!e) return;
    const i = [...e.nodeIds];
    this._applyFiltersAsync(e.isInclusive, i).catch((n) => {
      console.error("Unhandled error in _applyFiltersAsync:", n);
    });
  }
  async _applyFiltersAsync(t, e) {
    try {
      await this._engine.pauseAllRendering(), await this.reset(), t && await this.setVisibilitiesByValue([this.getAbsoluteRootNodeId()], !1, !1), await this.setVisibilitiesByValue(e, t, !1), await this._engine.resumeAllRendering();
    } catch (i) {
      console.error("Error resetting model:", i);
    }
  }
  async _getNodeAttributes(t) {
    return (await t.getAttributes()).reduce((i, n) => {
      const r = n.getValueName(), o = r ? `${n.getTitle() ?? ""}/${r}` : n.getTitle() ?? "";
      return i[o] = `${n.getValue()}${n.getUnit()}`, i;
    }, {});
  }
  _handlePhysicalProperties(t, e) {
    const i = {}, n = this.getNetMatrix(t), r = new m(n[0], n[1], n[2]), o = this.getUnit(t), l = r.length() / o, h = e.surfaceArea * l * l, u = e.volume * l * l * l;
    i["Surface Area"] = `${Hc(h, o)}${Iv}`, i.Volume = `${Hc(u, o)}${Cv}`;
    const f = m.scale(
      wt.createFromArray(n).transform(e.centerOfGravity),
      1 / o
    );
    return i.COG = `x:${f.x.toLocaleString()} y:${f.y.toLocaleString()} z:${f.z.toLocaleString()}`, i;
  }
  async _getPartDefAttributes(t) {
    const e = {}, i = await t.getAttributes();
    for (const n of i) {
      const r = n.getValueName();
      let o = n.getTitle();
      r !== null && (o = o ? `${o}/${r}` : r);
      const h = `${n.getValue()}${n.getUnit()}`;
      e[o] = h;
    }
    return e;
  }
}
class rI {
  constructor(t) {
    this._engine = t;
  }
  getIdentityInc() {
    return this._identityInc;
  }
  // SC does not guarante an identity matrix to be created on the client
  // XXX: We should probably just reserve Matrix Inc (0, 1) for an eternal identity matrix in SC C++ code.
  async init() {
    const t = await this._engine.createIdentityMatrix();
    this._identityInc = t;
  }
}
function oI(s, t) {
  const e = [];
  for (let i = 0; i < s.length; i += t)
    e.push(s.slice(i, i + t));
  return e;
}
function cf(s, t, e) {
  if (s.selectionMask === Pe.None)
    throw new oe("selectionMask is None");
  return {
    ...s,
    cullSuboptimalEntities: t,
    enableOcclusionChecks: t,
    restrictLinesAndPointsToSelectedFaceInstances: e ? !1 : s.restrictLinesAndPointsToSelectedFaceInstances
  };
}
function aI(s) {
  let t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = null;
  for (const n of s)
    if (n.length > 0) {
      const r = n[0];
      r.radialMetric < t ? (t = r.radialMetric, e = r.zMetric, i = n) : r.radialMetric === t && r.zMetric < e && (e = r.zMetric, i = n);
    }
  return i;
}
function lI(s, t, e, i) {
  const n = t !== null ? t.entities : [], r = e !== null ? e.entities : [], o = i !== null ? i.entities : [], l = [n, r, o];
  for (; ; ) {
    const h = aI(l);
    if (h === null) {
      console.assert(n.length === 0), console.assert(r.length === 0), console.assert(o.length === 0);
      return;
    }
    console.assert(h.length > 0);
    let u;
    if (h === n) {
      const f = n.pop();
      u = Tg(f);
    } else if (h === r) {
      const f = r.pop();
      u = Dg(f);
    } else {
      console.assert(h === o);
      const f = o.pop();
      u = Ml(f, !0);
    }
    s.push(u);
  }
}
function Ml(s, t) {
  const e = m.createFromArray(s.rayPoint), i = m.createFromArray(s.normal), n = new m(s.bounding.min[0], s.bounding.min[1], s.bounding.min[2]), r = new m(s.bounding.max[0], s.bounding.max[1], s.bounding.max[2]), o = new wn(n, r), l = new Ah(
    e,
    i,
    s.elementIndex,
    s.overlayIndex,
    s.elementBits,
    o,
    t
  ), h = s.instanceInc;
  return yi.create(h[1], h[0], l, null, null);
}
function Tg(s) {
  const t = new m(s.bounding.min[0], s.bounding.min[1], s.bounding.min[2]), e = new m(s.bounding.max[0], s.bounding.max[1], s.bounding.max[2]), i = new wn(t, e), n = new Th(
    s.elementIndex,
    m.createFromArray(s.point),
    s.lineSegmentVertices,
    s.bestLineSegmentVertexIndex,
    i,
    s.overlayIndex,
    s.elementBits
  ), r = s.instanceInc;
  return yi.create(r[1], r[0], null, n, null);
}
function Dg(s) {
  const t = new Dh(
    m.createFromArray(s.point),
    s.elementIndex,
    s.overlayIndex,
    s.elementBits
  ), e = s.instanceInc;
  return yi.create(e[1], e[0], null, null, t);
}
function Jp(s) {
  if (s.point !== null) {
    const t = s.point.entities[0];
    return Dg(t);
  }
  if (s.line !== null) {
    const t = s.line.entities[0];
    return Tg(t);
  }
  if (s.face !== null) {
    const t = s.face.entities[0];
    return Ml(t, !1);
  }
  if (s.proximityFace !== null) {
    const t = s.proximityFace.entities[0];
    return Ml(t, !0);
  }
  return null;
}
function Yp(s) {
  let t = null;
  if (s.face !== null) {
    const n = s.face.entities[0];
    t = Ml(n, !1);
  } else if (s.proximityFace !== null) {
    const n = s.proximityFace.entities[0];
    t = Ml(n, !0);
  }
  let e = null;
  if (s.line !== null) {
    const n = s.line.entities[0];
    e = Tg(n);
  }
  let i = null;
  if (s.point !== null) {
    const n = s.point.entities[0];
    i = Dg(n);
  }
  return new ed(t, e, i);
}
function Zp(s) {
  const t = [];
  if (s.face !== null)
    for (const e of s.face.entities) {
      const i = Ml(e, !1);
      t.push(i);
    }
  return lI(t, s.line, s.point, s.proximityFace), t;
}
class cI {
  constructor(t) {
    this._pickTolerance = 20, this._incrementalChunkedItems = /* @__PURE__ */ new Map(), this._sc = t;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  async beginScreenAreaSelection(t, e, i, n) {
    const r = n;
    let o;
    try {
      o = await this._sc.beginScreenAreaSelection(
        t,
        e.x,
        e.y,
        i.x,
        i.y,
        r
      );
    } catch (l) {
      throw ca(l) && l.scFunction === "beginScreenAreaSelection" ? new so() : l;
    }
    return new yc(o);
  }
  async beginRayDrillSelection(t, e, i, n) {
    const r = n;
    let o;
    try {
      o = await this._sc.beginRayDrillSelection(
        t,
        e.x,
        e.y,
        i,
        r
      );
    } catch (l) {
      throw ca(l) && l.scFunction === "beginRayDrillSelection" ? new so() : l;
    }
    return new yc(o);
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    const n = i, r = [];
    for (const h of t)
      r.push(h.getCoefficients());
    const o = [e.x, e.y, e.z];
    let l;
    try {
      l = await this._sc.beginConvexPolyhedronSelection(
        r,
        o,
        n,
        Ae.Default
      );
    } catch (h) {
      throw ca(h) && h.scFunction === "beginConvexPolyhedronSelection" ? new so() : h;
    }
    return new yc(l);
  }
  async beginSphereSelection(t, e, i) {
    const n = i;
    let r;
    try {
      r = await this._sc.beginSphereSelection(
        Ae.Default,
        t,
        e,
        n
      );
    } catch (o) {
      throw ca(o) && o.scFunction === "beginSphereSelection" ? new so() : o;
    }
    return new yc(r);
  }
  endIncrementalSelection(t) {
    this._incrementalChunkedItems.delete(t._handle), this._sc.endVolumeSelection(t._handle);
  }
  async advanceIncrementalSelection(t, e) {
    const i = this._incrementalChunkedItems.get(t._handle);
    if (i && i.length !== 0)
      return i.pop();
    let n;
    try {
      n = await this._sc.advanceVolumeSelection(
        t._handle,
        5e3
        /* Batch */
      );
    } catch (l) {
      throw ca(l) && l.scFunction === "advanceVolumeSelection" ? new so() : l;
    }
    if (n.length === 2 && n[1] === eg.Invalid)
      return e ? (await this._sc.setStreamIdleMarker(), this.advanceIncrementalSelection(t, !1)) : null;
    const r = [];
    for (let l = 0; l < n.length; l += 2) {
      const h = n[l], u = n[l + 1];
      r.push(yi.create(u, h));
    }
    if (r.length <= 500)
      return r;
    const o = oI(
      r,
      500
      /* Chunk */
    ).reverse();
    return this._incrementalChunkedItems.set(t._handle, o), o.pop();
  }
  async _screenSelectByRay(t, e, i, n, r) {
    const o = cf(i, n, r), l = i.selectionMask, u = i.selectionMask !== Pe.Face || i.enableProximityFaces ? this._pickTolerance : -1;
    return this._sc.screenSelectByRay(t, l, e.x, e.y, u, o);
  }
  async _worldSelectByRay(t, e, i) {
    const n = cf(e, i, !1), r = Wu(t);
    return this._sc.worldSelectByRay(Ae.Default, r, n);
  }
  async pickFromScreen(t, e, i, n) {
    const r = await this._screenSelectByRay(t, e, i, !0, n);
    return Jp(r);
  }
  async pickAllFromScreen(t, e, i, n) {
    const r = await this._screenSelectByRay(t, e, i, !1, n);
    return Zp(r);
  }
  async compositePickFromScreen(t, e, i, n) {
    const r = await this._screenSelectByRay(t, e, i, !0, n);
    return Yp(r);
  }
  async pickFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !0);
    return Jp(i);
  }
  async pickAllFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !1);
    return Zp(i);
  }
  async pickCompositeFromRay(t, e) {
    const i = cf(e, !0, !1), n = Wu(t), r = await this._sc.worldSelectByRay(Ae.Default, n, i);
    return Yp(r);
  }
}
class hI {
  constructor(t, e) {
    this._viewIndices = /* @__PURE__ */ new Set([Ae.Default]), this._windowSizes = /* @__PURE__ */ new Map(), this._engineReadyPromise = vi(), this._sessionStartedPromise = vi(), this._connectionlessEmpty = !1, this._uri = "ws://localhost:9999", this._streamingMode = Ro.Default, this._rendererType = nh.Client, this._meshLevel = 0, this._memoryLimit = 0, this._boundingPreviewMode = So.All, this._streamCutoffScale = 1, this._loadFinished = !1, this._statistics = new zy(), this._cachedTriangleCount = null, this._cachedElementCount = null, this._cuttingSectionToKeyMap = /* @__PURE__ */ new Map(), this._cappingQuantizationGranularity = -1e4, this._cappingFaceColor = yt.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = yt.createFromFloat(0.5, 0.5, 0.5), this._cappingGeometryVisibility = !0, this._cappingNeedsUpdate = !0, this._cappingDelayTimeoutId = null, this._cappingDelay = 500, this._requestBatchCountByType = [], this._pendingRequestsByType = [], this._callbackManager = t, this._applyOptions(e);
    for (let i = 0; i < uc.Count; ++i)
      this._requestBatchCountByType.push(0), this._pendingRequestsByType.push([]);
  }
  async addView(t) {
    const e = await this._sc.addDrawContext();
    oo.setupNewView(this._sc, e, t), this._viewIndices.add(e), this._canvasContainers.set(e, t);
    const i = document.createElement("canvas");
    this._canvases.set(e, i);
    const n = i.getContext("2d");
    if (!n)
      throw new Error("Unable to create 2d context for canvas");
    return this._canvas2dContexts.set(e, n), i.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), i.style.display = "", t.appendChild(i), this.resize(e), e;
  }
  removeView(t) {
    this._viewIndices.delete(t), this._sc.removeDrawContext(t);
  }
  getNetworkModelName() {
    if (console.assert(this._sessionType === nn.Network), this._model !== void 0)
      return this._model;
    throw new oi();
  }
  // Method inherited from AbstractScEngine.  Mainly used as an avenue for the AssemblyTree to log messages for debugging purposes.
  logMessage(t) {
    console.log(t);
  }
  // Method inherited from AbstractScEngine.  Used to abstract the setTimeout method as this method is not available in pure non browser based javascript environments, i.e. v8, JsCore.
  setTimeout(t, e) {
    return setTimeout(t, e);
  }
  // Method inherited from AbstractScEngine. The default Communicator implementation of this method makes use of setTimeout (see above).
  sleep(t) {
    return ud(t);
  }
  getScsInfo() {
    return console.assert(this._sessionType === nn.Scs), this._buffer !== void 0 ? this._buffer : /^wss?:\/\//i.test(this._uri) ? null : this._uri;
  }
  _applyOptions(t) {
    t.empty !== void 0 && (this._connectionlessEmpty = t.empty), t.endpointUri !== void 0 && (this._uri = t.endpointUri), t.model && (this._model = t.model), t.sessionToken !== void 0 && (this._sessionToken = t.sessionToken), t.buffer !== void 0 && (this._buffer = t.buffer), t.streamingMode !== void 0 && (this._streamingMode = t.streamingMode), t.rendererType !== void 0 && (this._rendererType = t.rendererType), t.defaultMeshLevel !== void 0 && (this._meshLevel = t.defaultMeshLevel), t.memoryLimit !== void 0 && (this._memoryLimit = t.memoryLimit), t.boundingPreviewMode !== void 0 && (this._boundingPreviewMode = t.boundingPreviewMode), t.streamCutoffScale !== void 0 && this._setStreamCutoffScale(t.streamCutoffScale);
  }
  start(t, e) {
    this._canvasContainers = /* @__PURE__ */ new Map(), this._canvasContainers.set(Ae.Default, t), this._initOptions = e;
    const i = document.createElement("canvas");
    this._canvases = /* @__PURE__ */ new Map(), this._canvases.set(Ae.Default, i);
    const n = i.getContext("2d");
    if (!n)
      throw new Error("Unable to create 2d context for canvas");
    return this._canvas2dContexts = /* @__PURE__ */ new Map(), this._canvas2dContexts.set(Ae.Default, n), i.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), i.style.display = "", oo.createInstance({
      container: t,
      onReady: (r) => {
        t.appendChild(i), this._onEngineReady(r);
      },
      onError: (r) => {
        this._callbackManager.trigger(
          "modelLoadFailure",
          this._model || "",
          `failed to load engine: ${r}`
        );
      },
      enginePath: e.enginePath
    }), !0;
  }
  setPickTolerance(t) {
    this._scSelectionManager.setPickTolerance(t);
  }
  getPickTolerance() {
    return this._scSelectionManager.getPickTolerance();
  }
  _onEngineReady(t) {
    this._sc = t, this._sessionType = nn.Uninitialized, this._matrixCache = new rI(this), this._scSelectionManager = new cI(this._sc), this._callbackManager.bind({
      _firstBoundingReady: async () => {
        for (const e of this._viewIndices)
          this._regenerateCapping(e);
      },
      _drawContextCreated: (e) => {
        this._sc.setDrawMode(e, fr.Highlight), this._sc.setHighlightedInstanceFilter(e, Rr.Colorize), this._sc.setUnhighlightedFilter(e, Rr.None), this._sc.setHighlightMode(e, Bu.VisibleWithFullOutline), this._sc.setAntiAliasingMode(e, il.SMAA);
      }
    }), this._sc.setEventHandler("session_started", () => {
      const e = () => (this._callbackManager.unbind(i), this._sessionStartedPromise), i = {
        _sessionStarted: () => this._onSessionStarted(),
        _assemblyTreeReady: e,
        _modelSwitched: e
      };
      this._callbackManager.bind(i), this._sessionStartedPromise.resolve(
        this._callbackManager.promiseTrigger("_sessionStarted", null)
      );
    }), this._sc.setEventHandler(
      "announce_model",
      (e, i, n) => {
        this._callbackManager.trigger("_announceModel", i, n);
      }
    ), this._sc.setEventHandler("first_instance", () => {
      this._callbackManager.trigger("_firstInstance");
    }), this._sc.setEventHandler(
      "inclusion",
      (e, i, n, r) => {
        this._callbackManager.trigger("_inclusion", i, n, r);
      }
    ), this._sc.setEventHandler(
      "remap_model",
      (e, i, n, r) => {
        this._callbackManager.trigger(
          "_remapModel",
          i,
          n,
          r
        );
      }
    ), this._sc.setEventHandler(
      "remap_inclusion",
      (e, i, n, r, o) => {
        this._callbackManager.trigger(
          "_remapInclusion",
          i,
          n,
          r,
          o
        );
      }
    ), this._sc.setEventHandler(
      "capping_idle",
      (e, i, n) => {
        this._callbackManager.trigger("cappingIdle", i, n);
      }
    ), this._sc.setEventHandler("stream_active", this._initOptions.streamingActivated), this._sc.setEventHandler("stream_idle", this._initOptions.streamingDeactivated), this._sc.setEventHandler("open_model_failed", (e, i) => {
      let n;
      switch (i.reason) {
        case "UNKNOWN_MODEL":
          n = "Unknown model";
          break;
        case "BAD_NETWORK_VERSION":
          n = "Client/Server network version mismatch";
          break;
        case "BAD_STREAM_VERSION":
        case "BAD_STORE_VERSION":
          n = "Unsupported file version";
          break;
        default:
          n = "Internal Error";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", n);
    }), this._sc.setEventHandler(
      "missing_model",
      (e, i, n) => {
        this._callbackManager.trigger("_missingModel", i, n), this._callbackManager.trigger("missingModel", n);
      }
    ), this._sc.setEventHandler("bad_data", (e, i) => {
      let n;
      switch (i.type) {
        case "TRUNCATED_BLOCK":
          n = "Failed to parse truncated data block.";
          break;
        case "ZFRAME_DECOMPRESS_FAILED":
          n = "Failed to decompress data.";
          break;
        case "UNMATCHED_CODE":
          n = "Unknown opcode.";
          break;
        case "STORE_VERSION_MISMATCHED":
          n = "Store version mismatched.", n += ` Expected='${i.expected}'.`, n += ` Actual='${i.actual}'.`;
          break;
        case "STREAM_VERSION_MISMATCHED":
          n = "Stream version mismatched.", n += ` Expected='${i.expected}'.`, n += ` Actual='${i.actual}'.`;
          break;
        case "PARSE_BOUNDING_TREE_FAILED":
          n = "Failed to parse bounding ";
          break;
        default:
          n = "Unknown error.";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", n);
    }), this._sc.setEventHandler("socket_open_failed", () => {
      this._callbackManager.trigger(
        "modelLoadFailure",
        this._model || "",
        "WebSocket connection failed."
      );
    }), this._sc.setEventHandler(
      "post_draw",
      (e, i, n, r, o) => {
        const l = this._canvases.get(i), h = this._canvas2dContexts.get(i);
        h.clearRect(0, 0, l.width, l.height);
        const u = this._sc.canvas.height - l.height, f = l.width, g = l.height;
        h.drawImage(
          this._sc.canvas,
          0,
          u,
          // source offset
          f,
          g,
          // source dimensions
          0,
          0,
          // destination offset
          f,
          g
          // destination dimensions
        ), this._statistics = n, this._initOptions.renderComplete(), this._fillStatTotalCounts();
        const y = this._fromScCamera(r);
        this._callbackManager.trigger("frameDrawn", y, o, i);
      }
    ), this._sc.setEventHandler(
      "priority_meta_data_sent",
      (e, i, n) => {
        this._initOptions.priorityMetaDataSent(i, n);
      }
    ), this._sc.setEventHandler(
      "meta_data",
      (e, i, n, r) => {
        i < 0 && (i += 4294967296), this._callbackManager.trigger("_metaData", i, n, r);
      }
    ), this._sc.setEventHandler("draw_complete", (e, i) => {
      this._callbackManager.trigger("_drawComplete", i);
    }), this._sc.setEventHandler("webgl_context_lost", () => {
      this._callbackManager.trigger("webGlContextLost");
    }), this._sc.setEventHandler("websocket_connection_closed", () => {
      this._callbackManager.trigger("websocketConnectionClosed");
    }), this._initOptions.engineReady(this._sessionStartedPromise), this._engineReadyPromise.resolve();
  }
  loadFinished() {
    return this._loadFinished;
  }
  resetCachedStatistics() {
    this._cachedElementCount = null, this._cachedTriangleCount = null;
  }
  setAmbientOcclusionEnabled(t, e) {
    this._sc.setAmbientOcclusionEnabled(t, e);
  }
  setAmbientOcclusionRadius(t, e) {
    this._sc.setAmbientOcclusionRadius(t, e);
  }
  setLightingEnabled(t, e) {
    this._sc.setLightingEnabled(t, e);
  }
  _fillStatTotalCounts() {
    this._cachedElementCount !== null && this._cachedTriangleCount !== null && (this._statistics.total_element_count = this._cachedElementCount, this._statistics.total_triangle_count = this._cachedTriangleCount);
  }
  async _updateCachedStats() {
    const t = this._sc.getElementCount(), e = this._sc.getTriangleCount(), i = await Promise.all([t, e]);
    this._cachedElementCount = i[0], this._cachedTriangleCount = i[1], this._fillStatTotalCounts();
  }
  _toVector3(t) {
    return t.toArray();
  }
  startExplode(t, e) {
    this.delayCapping(), this._sc.startExplode(t, this._toVector3(e));
  }
  setExplodeMagnitude(t) {
    this._callbackManager.trigger("explode", t), this.delayCapping(), this._sc.explode(t);
  }
  stopExplode() {
    this.delayCapping(), this._sc.resetExplode();
  }
  async getStatistics(t = !1) {
    return t && !this.loadFinished() ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : this.loadFinished() && this._cachedTriangleCount === null ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : (this._fillStatTotalCounts(), this._statistics);
  }
  setStreamIdleMarker() {
    return this._sc.setStreamIdleMarker();
  }
  hasDepthRange(t) {
    return this._sc.MeshInstance.hasDepthRange(t);
  }
  setDepthRange(t, e, i) {
    this._sc.MeshInstance.setDepthRange(t, e, i);
  }
  unsetDepthRange(t) {
    this._sc.MeshInstance.unsetDepthRange(t);
  }
  setDefaultDepthRange(t, e, i) {
    this._sc.setDefaultDepthRange(t, e, i);
  }
  _getScPlaneArray(t) {
    const e = [];
    for (let i = 0; i < t.getCount(); i++) {
      const n = t.getPlane(i);
      if (n === null)
        continue;
      const r = [];
      n.normal.toArray(r), r[3] = n.d, e.push(r);
    }
    return e;
  }
  getCuttingSectionLimits() {
    return this._sc.cuttingSectionLimits();
  }
  async _addCuttingSection(t, e) {
    let i = el.Invalid;
    const n = this._getScPlaneArray(t);
    if (n.length > 0 && (i = await this._sc.addCuttingSection(n), i === el.Invalid)) {
      const r = e === hc.Add ? "add" : "update";
      throw new oe(`Failed to ${r} cutting section.`);
    }
    this._cuttingSectionToKeyMap.set(t, i), e === hc.Add && this._callbackManager.trigger("addCuttingSection", t);
  }
  addCuttingSection(t) {
    return this._addCuttingSection(t, hc.Add);
  }
  async removeCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (this._cuttingSectionToKeyMap.delete(t), this._callbackManager.trigger("removeCuttingSection"), e !== el.Invalid)
      return this._sc.removeCuttingSections([e]);
  }
  removeAllCuttingSections() {
    return this._cuttingSectionToKeyMap.clear(), this._callbackManager.trigger("removeCuttingSection"), this._sc.removeAllCuttingSections();
  }
  async updateCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (e === el.Invalid)
      return this._addCuttingSection(t, hc.Update);
    const i = this._getScPlaneArray(t);
    return this._sc.replaceCuttingSection(i, e);
  }
  setCappingDelay(t) {
    this._cappingDelay = t;
  }
  enableCappingIdleCallback(t) {
    return this._sc.setCappingIdleHookEnabled(t);
  }
  getCappedInstances() {
    return this._sc.getCappedInstances();
  }
  delayCapping() {
    this._cappingDelayTimeoutId === null ? this._sc.pauseCapping() : clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = setTimeout(() => {
      this._cappingDelayTimeoutId = null, this._sc.resumeCapping();
    }, this._cappingDelay);
  }
  setCappingGeometryVisibility(t, e) {
    if (!(this._cappingGeometryVisibility === e && !this._cappingNeedsUpdate))
      if (this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._cappingNeedsUpdate = !1, this._cappingGeometryVisibility = e, e) {
        const i = this._cappingLineColor !== null ? this._toRgba(this._cappingLineColor, 1) : [-1, -1, -1, -1], n = this._cappingFaceColor !== null ? this._toRgba(this._cappingFaceColor, 1) : [-1, -1, -1, -1];
        this._sc.enableCapping(t, i, n, this._cappingQuantizationGranularity);
      } else
        this._sc.disableCapping(t);
  }
  _regenerateCapping(t) {
    this._cappingNeedsUpdate = !0, this.setCappingGeometryVisibility(t, this._cappingGeometryVisibility);
  }
  getCappingGeometryVisibility() {
    return this._cappingGeometryVisibility;
  }
  _toRgb(t) {
    return t.toFloatArray();
  }
  _toRgba(t, e) {
    return t.toFloatArray([0, 0, 0, e]);
  }
  setCappingFaceColor(t) {
    if (!(t === null && this._cappingFaceColor === null || t !== null && this._cappingFaceColor !== null && t.equals(this._cappingFaceColor))) {
      t !== null ? this._cappingFaceColor = t.copy() : this._cappingFaceColor = null;
      for (const e of this._viewIndices) this._regenerateCapping(e);
    }
  }
  setCappingLineColor(t) {
    if (!(t === null && this._cappingLineColor === null || t !== null && this._cappingLineColor !== null && t.equals(this._cappingLineColor))) {
      t !== null ? this._cappingLineColor = t.copy() : this._cappingLineColor = null;
      for (const e of this._viewIndices) this._regenerateCapping(e);
    }
  }
  async _onSessionStarted() {
    this.setAllowHighDpi(!0), this._sc.suspendDrawing(Ae.Default), this._sc.setDrawMode(Ae.Default, fr.Highlight), this._sc.setHighlightedInstanceFilter(Ae.Default, Rr.Colorize), this._sc.setUnhighlightedFilter(Ae.Default, Rr.None), this._sc.setHighlightMode(Ae.Default, Bu.VisibleWithFullOutline), this._sc.setAntiAliasingMode(Ae.Default, il.SMAA);
    const t = [];
    t.push(this._matrixCache.init()), this._regenerateCapping(Ae.Default), await Promise.all(t), this._initOptions.sceneReady(), this._sc.resumeDrawing(Ae.Default);
  }
  isInit() {
    return this._sc !== void 0;
  }
  setRemoteEndpoint(t, e) {
    this._uri = t, this._model = e;
  }
  getSessionType() {
    return this._sessionType;
  }
  _awaitEmptyLoad() {
    const t = vi(), e = {
      _attached: (i) => {
        this._callbackManager.unbind(e), i === ba.OfInitialEmptyModel ? t.resolve() : t.reject(new oi());
      }
    };
    return this._callbackManager.bind(e), t;
  }
  async loadEmpty() {
    await this._engineReadyPromise;
    try {
      if (this._sessionType !== nn.Uninitialized)
        throw new Kr("Incompatible load types.");
      const t = this._awaitEmptyLoad();
      return this._connectionlessEmpty || this._buffer !== void 0 || this._model === void 0 ? this._sessionType = this._loadEmptyScs() : this._sessionType = this._loadEmptyNetwork(), t;
    } catch (t) {
      throw this._callbackManager.trigger("modelLoadFailure", this._model || "", t.message), t;
    }
  }
  _loadEmpty(t) {
    return console.assert(t.XHRonprogress === void 0), console.assert(t.XHRonerror === void 0), console.assert(t.XHRonloadend === void 0), t.XHRonprogress = (e) => {
      this._callbackManager.trigger("XHRonprogress", e);
    }, t.XHRonerror = (e) => {
      this._callbackManager.trigger("XHRonerror", e);
    }, t.XHRonloadend = (e, i, n) => {
      this._callbackManager.trigger("XHRonloadend", e, i, n);
    }, this._sc.load(t);
  }
  _loadEmptyScs() {
    console.assert(this._model === void 0);
    const t = {
      empty: !0
    };
    return this._streamingMode === Ro.OnDemand && (t.streamInstancesOnDemand = !0), this._loadEmpty(t);
  }
  _loadEmptyNetwork() {
    console.assert(this._model !== void 0);
    const t = {
      model: wa,
      uri: this._uri,
      serverSideRendering: this._rendererType === nh.Server,
      meshLevel: this._meshLevel,
      streamCutoffScale: this._streamCutoffScale
    };
    switch (this._sessionToken !== void 0 && (t.sessionToken = this._sessionToken), this._memoryLimit > 0 && (t.limitMiB = this._memoryLimit), (this._boundingPreviewMode & So.Model) === So.Model && (t.streamModelBoundingPreviews = !0), (this._boundingPreviewMode & So.Instance) === So.Instance && (t.streamInstanceBoundingPreviews = !0), (this._boundingPreviewMode & So.Ejected) === So.Ejected && (t.streamEjectedBoundingPreviews = !0), this._streamingMode) {
      case Ro.OnDemand:
        t.streamInstancesOnDemand = !0;
        break;
      case Ro.All:
        t.streamCulled = !0, t.streamMetaDataOnIdle = !0;
        break;
    }
    return this._loadEmpty(t);
  }
  setProjection(t, e) {
    const i = this.getCamera(t);
    i.getProjection() !== e && (i.setProjection(e), this.setCamera(t, i));
  }
  getViewMatrix(t) {
    const e = this._toCamera(Ae.Default, t);
    return wt.createFromArray(e.viewMatrix());
  }
  getProjectionMatrix(t, e) {
    const i = this._toCamera(e, t), n = this._windowSizes.get(e);
    if (n === void 0)
      throw new oe("Getting projection matrix of non-existent view");
    return wt.createFromArray(i.projectionMatrix(n.x, n.y));
  }
  getFullCameraMatrix(t, e) {
    const i = this._toCamera(e, t), n = this._windowSizes.get(e);
    if (n === void 0)
      throw new oe("Getting full matrix of non-existent view");
    return wt.createFromArray(i.fullMatrix(n.x, n.y));
  }
  getPrimaryModelKey() {
    return this._sc.primaryModelKey();
  }
  getPartsBounding(t, e, i) {
    return this.getBounding(t, e, !1, i);
  }
  async getDrawnPartsBounding(t, e) {
    const i = await this._sc.MeshInstance.getDrawnWorldSpaceBounding(t, e), n = new wn();
    return n.min.fromArray(i.min), n.max.fromArray(i.max), n;
  }
  async getBounding(t, e, i, n) {
    const r = await this._sc.MeshInstance.getWorldSpaceBounding(
      t,
      e,
      i,
      n
    ), o = new wn();
    return o.min.fromArray(r.min), o.max.fromArray(r.max), o;
  }
  async getLooseBounding() {
    const t = await this._sc.getLooseBounding(), e = new wn();
    return e.min.fromArray(t.min), e.max.fromArray(t.max), e;
  }
  getClientDimensions(t) {
    const e = this._sc.containers.get(t);
    return [e.clientWidth, e.clientHeight];
  }
  async getModelBounding(t, e, i) {
    return this.getBounding([], t, e, i);
  }
  async pickFromScreen(t, e, i, n) {
    return this._scSelectionManager.pickFromScreen(t, e, i, n);
  }
  async pickAllFromScreen(t, e, i, n) {
    return this._scSelectionManager.pickAllFromScreen(t, e, i, n);
  }
  async compositePickFromScreen(t, e, i, n) {
    return this._scSelectionManager.compositePickFromScreen(t, e, i, n);
  }
  async beginScreenAreaSelection(t, e, i, n) {
    return this._scSelectionManager.beginScreenAreaSelection(
      t,
      e,
      i,
      n
    );
  }
  async beginRayDrillSelection(t, e, i, n) {
    return this._scSelectionManager.beginRayDrillSelection(
      t,
      e,
      i,
      n
    );
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._scSelectionManager.beginConvexPolyhedronSelection(
      t,
      e,
      i
    );
  }
  async beginSphereSelection(t, e, i) {
    return this._scSelectionManager.beginSphereSelection(t, e, i);
  }
  endIncrementalSelection(t) {
    this._scSelectionManager.endIncrementalSelection(t);
  }
  async advanceIncrementalSelection(t) {
    return this._scSelectionManager.advanceIncrementalSelection(t, !1);
  }
  flushMetaDataCache() {
    this._sc.flushMetaDataCache();
  }
  async safeGetMetaDatas(t, e) {
    const i = [];
    for (const n of e)
      i.push(t, n);
    try {
      return await this.getDataFromIds(i);
    } catch {
      return null;
    }
  }
  async safeGetMetaData(t, e) {
    const i = await this.safeGetMetaDatas(t, [e]);
    return i !== null ? i[0] : null;
  }
  async safeLoadMetaDatas(t) {
    await this.getDataFromIds(t);
  }
  getDataFromIds(t) {
    if (this._requestBatchCountByType[uc.MetaData] === 0)
      return this._getDataFromIds(t);
    const e = new kv(t);
    return this._pendingRequestsByType[uc.MetaData].push(e), e.promise;
  }
  _getDataFromIds(t) {
    return this._sc.getMetaData(t);
  }
  pickFromRay(t, e) {
    return this._scSelectionManager.pickFromRay(t, e);
  }
  pickAllFromRay(t, e) {
    return this._scSelectionManager.pickAllFromRay(t, e);
  }
  updateCamera(t, e) {
    const i = e._getFlags(), n = this._sc.getCamera(t);
    return (i & Zn.Position) === Zn.Position && n.setPosition(this._toVector3(e.getPosition())), (i & Zn.Target) === Zn.Target && n.setTarget(this._toVector3(e.getTarget())), (i & Zn.Up) === Zn.Up && n.setUpVector(this._toVector3(e.getUp())), this._setCamera(t, n), this.getCamera(t);
  }
  _toProjection(t) {
    switch (t) {
      default:
      case ri.Orthographic:
        return Gc.Orthographic;
      case ri.Perspective:
        return Gc.Perspective;
    }
  }
  _toCamera(t, e) {
    const i = this._sc.getCamera(t);
    return i.reset(
      this._toProjection(e.getProjection()),
      this._toVector3(e.getPosition()),
      this._toVector3(e.getTarget()),
      this._toVector3(e.getUp()),
      e.getWidth(),
      e.getHeight()
    ), i.setNearLimit(e.getNearLimit()), i;
  }
  setCamera(t, e) {
    const i = this._toCamera(t, e);
    this._setCamera(t, i);
  }
  _setCamera(t, e) {
    this.delayCapping(), this._sc.setCamera(t, e);
  }
  markCameraAsEmpty(t) {
    this._sc.markCameraAsEmpty(t);
  }
  setInstancesMatrix(t, e) {
    this._sc.MeshInstance.setAnonymousMatrix(t, e.m);
  }
  // This implementation attempts to reduce saturation when setting large quantities of matrices in SSR (i.e. Animation System)
  // A single message containing all new matrix values is sent via setAnonymousMatrices as opposed to individual messages via setAnonymousMatrix
  setMatrices(t, e) {
    const i = [];
    for (let n = 0; n < e.length; n++)
      i.push(...e[n].m);
    this._sc.MeshInstance.setAnonymousMatrices(t, i);
  }
  highlightParts(t, e) {
    this._sc.MeshInstance.setHighlighted(t, e), this._sc.MeshInstance.setXRay(t, e);
  }
  highlightElements(t, e, i, n, r) {
    const o = this._toElementType(e);
    this._sc.MeshInstance.setElementHighlighted(
      t,
      o,
      i,
      n,
      r
    ), this._sc.MeshInstance.setElementXRay(t, o, i, n, r);
  }
  getPartHighlighted(t) {
    return this._sc.MeshInstance.getHighlighted(t);
  }
  getElementHighlighted(t, e, i) {
    return this._sc.MeshInstance.getElementHighlighted(
      t,
      this._toElementType(e),
      i
    );
  }
  setNodeHighlightColor(t, e, i) {
    let n;
    e ? (this._sc.setHighlightedInstanceFilter(t, Rr.Colorize), n = this._toRgba(e, 1), this._sc.setHiddenLineHighlightedInstanceFillColor(t, n), this._sc.setHighlightedInstanceColor(t, n)) : this._sc.setHighlightedInstanceFilter(t, Rr.None), i ? n = this._toRgba(i, 1) : n = [0, 0, 0, 0], this._sc.setHiddenLineHighlightedInstanceOutlineColor(t, n), this._sc.setHighlightedInstanceOutlineColor(t, n);
  }
  setElementHighlightColor(t, e, i) {
    let n;
    e ? (this._sc.setHighlightedElementFilter(t, Rr.Colorize), n = this._toRgba(e, 1), this._sc.setHighlightedElementColor(t, n), this._sc.setHiddenLineHighlightedElementFillColor(t, n)) : this._sc.setHighlightedElementFilter(t, Rr.None), i ? n = this._toRgba(i, 1) : n = [0, 0, 0, 0], this._sc.setHighlightedElementOutlineColor(t, n), this._sc.setHiddenLineHighlightedElementOutlineColor(t, n);
  }
  setHighlightColorizeCompression(t, e) {
    this._sc.setHighlightColorizeCompression(t, e);
  }
  async computeMinimumBodyBodyDistance(t, e) {
    if (t.length !== 2 || e.length !== 2)
      throw new oe("Invalid instance inc.");
    const i = await this._sc.MeshInstance.computeMinimalBodyBodyDistance(
      Ae.Default,
      t,
      e
    );
    return hu(i);
  }
  async computeMininimumFaceFaceDistance(t, e, i, n) {
    if (t.length !== 2 || i.length !== 2)
      throw new oe("Invalid instance inc.");
    const r = await this._sc.MeshInstance.computeMinimalFaceFaceDistance(
      Ae.Default,
      t,
      e,
      i,
      n
    );
    return hu(r);
  }
  async computeMinimumFaceRayDistance(t, e, i) {
    if (t.length !== 2)
      throw new oe("Invalid instance inc.");
    const n = Wu(i), r = await this._sc.MeshInstance.computeMinimalFaceRayDistance(
      Ae.Default,
      t,
      e,
      n
    );
    return hu(r);
  }
  async computeMinimumFaceLineDistance(t, e, i) {
    if (t.length !== 2)
      throw new oe("Invalid instance inc.");
    const n = Wu(i), r = await this._sc.MeshInstance.computeMinimalFaceLineDistance(
      Ae.Default,
      t,
      e,
      n
    );
    return hu(r);
  }
  pauseRendering(t, e) {
    if (this._sc.suspendDrawing(t), typeof e == "function")
      try {
        e();
      } finally {
        this._sc.resumeDrawing(t);
      }
  }
  pauseAllRendering(t) {
    for (const e of this._viewIndices)
      this._sc.suspendDrawing(e);
    if (typeof t == "function")
      try {
        t();
      } finally {
        for (const e of this._viewIndices)
          this._sc.resumeDrawing(e);
      }
  }
  resumeRendering(t) {
    this._sc.resumeDrawing(t);
  }
  resumeAllRendering() {
    for (const t of this._viewIndices)
      this._sc.resumeDrawing(t);
  }
  beginRequestBatch(t) {
    ++this._requestBatchCountByType[t];
  }
  endRequestBatch(t) {
    this._requestBatchCountByType[t] > 0 && --this._requestBatchCountByType[t], this._flushBatchedRequests(t);
  }
  _flushBatchedRequests(t) {
    const e = this._pendingRequestsByType[t];
    this._pendingRequestsByType[t] = [];
    const i = [];
    for (const n of e)
      for (const r of n.ids)
        i.push(r);
    switch (t) {
      case uc.MetaData:
        return this._flushBatchedMetaDataRequests(e, i);
      default:
        return console.assert(!1), Promise.resolve();
    }
  }
  async _flushBatchedMetaDataRequests(t, e) {
    const i = await this._getDataFromIds(e);
    let n = 0;
    for (const r of t) {
      const o = [], l = r.ids.length / 2;
      for (let h = 0; h < l; ++h) {
        const u = i[n++];
        o.push(u);
      }
      r.promise.resolve(o);
    }
    console.assert(n === i.length);
  }
  clearHighlight() {
    this._sc.unsetAllHighlighted(), this._sc.unsetAllXRay();
  }
  resetColors() {
    this._sc.unsetAllColors();
  }
  resetOpacity() {
    this._sc.unsetAllOpacity();
  }
  setPartOpacity(t, e) {
    this.pauseAllRendering(() => {
      this._sc.MeshInstance.setOpacity(t, an.Faces, e), this._sc.MeshInstance.setOpacity(t, an.Lines, e), this._sc.MeshInstance.setOpacity(t, an.Points, e);
    });
  }
  unsetPartOpacity(t) {
    this.pauseAllRendering(() => {
      this._sc.MeshInstance.unsetOpacity(t, an.Faces), this._sc.MeshInstance.unsetOpacity(t, an.Lines), this._sc.MeshInstance.unsetOpacity(t, an.Points);
    });
  }
  getPartOpacity(t) {
    return this._sc.MeshInstance.getOpacity(t, an.Faces);
  }
  getEffectivePartOpacity(t, e) {
    return this._sc.MeshInstance.getEffectiveOpacity(t, this._toElementType(e));
  }
  async getPartHasTransparency(t) {
    const e = [];
    e.push(this._sc.MeshInstance.hasTransparency(t, an.Faces)), e.push(this._sc.MeshInstance.hasTransparency(t, an.Lines)), e.push(this._sc.MeshInstance.hasTransparency(t, an.Points));
    const [i, n, r] = await Promise.all(e);
    for (let o = 0; o < i.length; ++o)
      i[o] || (i[o] = n[o] || r[o]);
    return i;
  }
  setPartColor(t, e, i) {
    this._sc.MeshInstance.setColor(
      t,
      this._toElementType(e),
      An.Base,
      i.getFloatArray()
    );
  }
  unsetPartColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Base);
  }
  getPartColor(t, e) {
    return this._sc.MeshInstance.getColor(
      t,
      this._toElementType(e),
      An.Base
    ).then((i) => i.map((n) => n ? yt.createFromFloatArray(n) : null));
  }
  async getEffectivePartColor(t, e) {
    const i = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveColor(t, i, An.Base)).map(yt.createFromFloatArray);
  }
  setPartAmbientColor(t, e, i) {
    this._sc.MeshInstance.setColor(
      t,
      this._toElementType(e),
      An.Ambient,
      i.getFloatArray()
    );
  }
  unsetPartAmbientColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Ambient);
  }
  getPartAmbientColor(t, e) {
    return this._sc.MeshInstance.getColor(
      t,
      this._toElementType(e),
      An.Ambient
    ).then((i) => i.map((n) => n ? yt.createFromFloatArray(n) : null));
  }
  getPartEffectiveAmbientColor(t, e) {
    return this._sc.MeshInstance.getEffectiveColor(
      t,
      this._toElementType(e),
      An.Ambient
    ).then((i) => i.map((n) => yt.createFromFloatArray(n)));
  }
  setPartAmbientMix(t, e, i) {
    this._sc.MeshInstance.setAmbientMix(t, this._toElementType(e), i);
  }
  setPartEmissiveColor(t, e, i) {
    this._sc.MeshInstance.setColor(
      t,
      this._toElementType(e),
      An.Emissive,
      i.getFloatArray()
    );
  }
  getPartEmissiveColor(t, e) {
    return this._sc.MeshInstance.getColor(
      t,
      this._toElementType(e),
      An.Emissive
    ).then((i) => i.map((n) => n ? yt.createFromFloatArray(n) : null));
  }
  getPartEffectiveEmissiveColor(t, e) {
    return this._sc.MeshInstance.getEffectiveColor(
      t,
      this._toElementType(e),
      An.Emissive
    ).then((i) => i.map((n) => yt.createFromFloatArray(n)));
  }
  unsetPartEmissiveColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Emissive);
  }
  setPartSpecularColor(t, e, i) {
    this._sc.MeshInstance.setColor(
      t,
      this._toElementType(e),
      An.Specular,
      i.getFloatArray()
    );
  }
  getPartSpecularColor(t, e) {
    return this._sc.MeshInstance.getColor(
      t,
      this._toElementType(e),
      An.Specular
    ).then((i) => i.map((n) => n ? yt.createFromFloatArray(n) : null));
  }
  getPartEffectiveSpecularColor(t, e) {
    return this._sc.MeshInstance.getEffectiveColor(
      t,
      this._toElementType(e),
      An.Specular
    ).then((i) => i.map((n) => yt.createFromFloatArray(n)));
  }
  unsetPartSpecularColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Specular);
  }
  setPartSpecularIntensity(t, e, i) {
    this._sc.MeshInstance.setSpecularIntensity(t, this._toElementType(e), i);
  }
  unsetPartSpecularIntensity(t, e) {
    this._sc.MeshInstance.unsetSpecularIntensity(t, this._toElementType(e));
  }
  setElementColor(t, e, i, n, r) {
    this._sc.MeshInstance.setElementColor(
      t,
      this._toElementType(e),
      i,
      n,
      r.getFloatArray()
    );
  }
  unsetElementColor(t, e, i, n) {
    this._sc.MeshInstance.unsetElementColor(
      t,
      this._toElementType(e),
      i,
      n
    );
  }
  getElementColor(t, e, i) {
    return this._sc.MeshInstance.getElementColor(
      t,
      this._toElementType(e),
      i
    ).then((n) => n.map((r) => r ? yt.createFromFloatArray(r) : null));
  }
  async getEffectiveElementColor(t, e, i, n) {
    const r = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveElementColor(
      t,
      n,
      r,
      i
    )).map(yt.createFromFloatArray);
  }
  synchronizeVisibilities(t, e) {
    t.length > 0 && this._sc.MeshInstance.synchronizeVisibilities(t, e);
  }
  setPartVisibility(t, e, i) {
    t.length > 0 && this._sc.MeshInstance.setVisible(t, e, i);
  }
  setElementVisibility(t, e, i, n, r) {
    t.length > 0 && this._sc.MeshInstance.setElementVisible(
      t,
      this._toElementType(e),
      i,
      n,
      r
    );
  }
  clearElementVisibility(t, e) {
    t.length > 0 && this._sc.MeshInstance.clearElementVisible(t, this._toElementType(e));
  }
  setVisibilityByAttachment(t, e) {
    this._sc.setVisibilityByAttachment(t, e);
  }
  requestMeshInstances(t) {
    this._sc.demandMeshInstances(t);
  }
  getRendererType() {
    return this._rendererType;
  }
  _toMeshDataBuilder(t) {
    const e = t._getFaceData(), i = t._getPointData(), n = t._getPolylineData(), r = new this._sc.MeshDataBuilder();
    for (const f of e)
      r.addFace(f.vertexData, {
        normals: f.normalData,
        rgba32s: f.rgba32data,
        uvs: f.uvData,
        bits: f.bits
      });
    for (const f of i)
      r.addPoints(f.vertexData, {
        rgba32s: f.rgba32data,
        bits: f.bits
      });
    for (const f of n)
      r.addPolyline(f.vertexData, {
        rgba32s: f.rgba32data,
        bits: f.bits
      });
    let o;
    ((f) => {
      f[f.None = 0] = "None", f[f.ClockwiseWinding = 1] = "ClockwiseWinding", f[f.CounterClockwiseWinding = 2] = "CounterClockwiseWinding", f[f.TwoSided = 4] = "TwoSided", f[f.Manifold = 65536] = "Manifold";
    })(o || (o = {}));
    let l = 0;
    switch (t.getFaceWinding()) {
      case Qs.Clockwise:
        l = 1;
        break;
      case Qs.CounterClockwise:
        l = 2;
        break;
      case Qs.Unknown:
      default:
        l = 0;
        break;
    }
    const h = t.getBackfacesEnabled() ? 4 : 0, u = t.isManifold() ? 65536 : 0;
    return r.formatBits |= l | h | u, r;
  }
  createMesh(t) {
    const e = this._toMeshDataBuilder(t);
    return this._sc.MeshData.create(e);
  }
  replaceMesh(t, e) {
    const i = this._toMeshDataBuilder(e);
    return this._sc.MeshData.replace(t, i);
  }
  destroyMeshes(t) {
    return this._sc.MeshData.destroy(t);
  }
  _toImageFormat(t) {
    switch (t) {
      case ys.Gray8:
        return Mo.Gray8;
      case ys.GrayAlpha16:
        return Mo.GrayAlpha16;
      case ys.Rgb24:
        return Mo.Rgb24;
      case ys.Rgba32:
        return Mo.Rgba32;
      case ys.Jpeg:
        return Mo.Jpeg;
      case ys.Png:
        return Mo.Png;
    }
  }
  _validateImage(t) {
    if (t.format === void 0)
      throw new Rs("missing 'format' property");
    if (t.data === void 0)
      throw new Rs("missing 'data' property");
    if ((t.format === ys.Gray8 || t.format === ys.GrayAlpha16 || t.format === ys.Rgb24 || t.format === ys.Rgba32) && (t.width === void 0 || t.width <= 0 || t.height === void 0 || t.height <= 0))
      throw new Rs("uncompressed format requested but missing width or height");
  }
  async _pngImageHasAlpha(t) {
    let e;
    try {
      e = await new Promise((l, h) => {
        const u = new Image();
        u.onload = () => {
          l(u);
        }, u.onerror = () => {
          h();
        }, u.src = `data:image/png;base64, ${vv(t)}`;
      });
    } catch {
      return console.warn(
        "Unable to read PNG image to check alpha component. Will be considered with alpha."
      ), !0;
    }
    const i = document.createElement("canvas"), n = i.getContext("2d");
    if (n === null)
      return console.warn(
        "Unable to create 2d context to check alpha component. Will be considered with alpha."
      ), !0;
    i.width = e.width, i.height = e.height, n.drawImage(e, 0, 0);
    const o = n.getImageData(0, 0, e.width, e.height).data;
    for (let l = 0; l < o.length; l += 4)
      if (o[l + 3] < 255)
        return !0;
    return !1;
  }
  async createImage(t, e) {
    this._validateImage(t);
    let i = !1;
    if (t.format === ys.Png && (i = await this._pngImageHasAlpha(t.data)), e !== void 0) {
      this._validateImage(e);
      let n = !1;
      return e.format === ys.Png && (n = await this._pngImageHasAlpha(e.data)), this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height,
        this._toImageFormat(e.format),
        e.data,
        n,
        e.width,
        e.height
      );
    } else
      return this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height
      );
  }
  destroyImages(t) {
    return this._sc.Image.destroy(t);
  }
  _toTextureTiling(t) {
    switch (t) {
      default:
      case Tf.Repeat:
        return Uu.Repeat;
      case Tf.Clamp:
        return Uu.Clamp;
    }
  }
  _toTextureInterpolation(t) {
    return t === !1 ? Vu.Off : Vu.On;
  }
  _toTextureMipMapping(t) {
    return t === !1 ? zu.Off : zu.On;
  }
  _toTextureParameterization(t) {
    switch (t) {
      default:
      case Hu.UV:
        return Hu.UV;
    }
  }
  _toTextureModifier(t) {
    switch (t) {
      default:
      case 0:
        return Ic.None;
      case Ic.Decal:
        return Ic.Decal;
    }
  }
  async setTexture(t, e) {
    if (e.imageId === void 0)
      throw new Rs("missing 'imageId' property");
    return this._sc.MeshInstance.setTexture(
      t,
      an.Faces,
      e.imageId,
      e.matrix !== void 0 ? e.matrix.m : new wt().m,
      this._toTextureTiling(e.tiling),
      this._toTextureInterpolation(e.interpolation),
      this._toTextureMipMapping(e.mipMapping),
      this._toTextureParameterization(e.parameterization),
      this._toTextureModifier(e.modifiers)
    );
  }
  unsetTexture(t) {
    this._sc.MeshInstance.unsetTexture(t, an.Faces);
  }
  createMatrix(t) {
    return this._sc.Matrix.create(t);
  }
  createIdentityMatrix() {
    return this._sc.Matrix.create();
  }
  async createMeshInstance(t) {
    const e = t.getMeshId();
    if (e === null)
      throw new oe("MeshId is not set");
    let i = this._matrixCache.getIdentityInc();
    const n = [], r = t.getMatrix();
    if (r) {
      const g = this.createMatrix(r.m).then((y) => {
        i = y;
      });
      n.push(g);
    }
    const o = new yt(255, 0, 0), l = this._toRgba(
      t.getFaceColor() || o,
      t.getOpacity()
    ), h = this._toRgba(
      t.getLineColor() || o,
      t.getLineOpacity()
    ), u = this._toRgba(
      t.getPointColor() || o,
      t.getPointOpacity()
    );
    await Promise.all(n);
    const f = await this._sc.MeshInstance.create(
      e,
      i,
      l,
      h,
      u,
      t.getCreationFlags(),
      t.overlayId.overayIndex,
      t.overlayId.viewKey
    );
    return this._callbackManager.trigger("_geometryCreated", f), f;
  }
  destroyLocalInstances(t) {
    return this._sc.MeshInstance.destroy(t);
  }
  _fromScCamera(t) {
    let e = ri.Orthographic;
    return t.projection() === ri.Perspective && (e = ri.Perspective), Sn.create(
      m.createFromArray(t.position()),
      m.createFromArray(t.target()),
      m.createFromArray(t.upVector()),
      e,
      t.fieldWidth(),
      t.fieldHeight(),
      t.nearLimit()
    );
  }
  async getCameraPromise(t) {
    const e = await this._sc.getCameraPromise(t);
    return this._fromScCamera(e);
  }
  getCamera(t) {
    const e = this._sc.getCamera(t);
    return this._fromScCamera(e);
  }
  resize(t) {
    t === void 0 && (t = Ae.Default);
    let e = 1;
    this.getAllowHighDpi() && (e = window.devicePixelRatio || 1);
    const i = this._canvases.get(t), n = this._canvasContainers.get(t);
    i.width = n.clientWidth * e, i.height = n.clientHeight * e;
    const r = this._windowSizes.get(t);
    r === void 0 ? this._windowSizes.set(
      t,
      new X(n.offsetWidth, n.offsetHeight)
    ) : r.set(n.offsetWidth, n.offsetHeight), this._resizeRenderCanvas(), this._sc.onResize(t);
  }
  _resizeRenderCanvas() {
    const t = this._sc.canvas;
    let e = 0, i = 0;
    this._canvases.forEach((n) => {
      e = Math.max(e, n.width), i = Math.max(i, n.height);
    }), t.width = e, t.height = i;
  }
  setFaceVisibility(t, e) {
    this._sc.setFacesVisible(t, e);
  }
  setLineVisibility(t, e) {
    this._sc.setLinesVisible(t, e);
  }
  getCanvasSize(t) {
    const e = this._windowSizes.get(t);
    return e === void 0 ? X.zero() : e.copy();
  }
  setBackgroundGradient(t, e, i) {
    this._sc.setBackgroundGradient(
      t,
      e ? this._toRgba(e, 1) : [0, 0, 0, 0],
      i ? this._toRgba(i, 1) : [0, 0, 0, 0]
    );
  }
  setBoundingPreviewUnderDrawColor(t, e) {
    this._sc.setBoundingPreviewUnderdrawColor(e, this._toRgba(t, 0.7));
  }
  setBoundingPreviewTestedColor(t, e) {
    this._sc.setBoundingPreviewTestedColor(e, this._toRgba(t, 0.7));
  }
  setBoundingPreviewEjectedColor(t, e) {
    this._sc.setBoundingPreviewEjectedColor(e, this._toRgba(t, 0.7));
  }
  setBoundingPreviewUnderDraw(t, e) {
    this._sc.setBoundingPreviewUnderdraw(
      t.reduce((i, n) => (i.push(this._toVector3(n.min), this._toVector3(n.max)), i), []),
      e
    );
  }
  setBoundingDebugLevel(t, e) {
    this._sc.setBoundingDebugLevel(e, t);
  }
  setBoundingPreviewTested(t, e) {
    this._sc.setBoundingPreviewTested(
      t.reduce((i, n) => (i.push(this._toVector3(n.min), this._toVector3(n.max)), i), []),
      e
    );
  }
  setBoundingPreviewEjected(t, e) {
    this._sc.setBoundingPreviewEjected(
      t.reduce((i, n) => (i.push(this._toVector3(n.min), this._toVector3(n.max)), i), []),
      e
    );
  }
  setServerRenderQuality(t, e, i, n) {
    this._sc.setSsrQuality({
      jpegQualityLow: t,
      jpegQualityHigh: e,
      scaleLow: i,
      scaleHigh: n
    });
  }
  setMinimumFramerate(t, e) {
    this._sc.setMinFrameRate(t, e);
  }
  getMinimumFramerate(t) {
    return this._sc.getMinFrameRate(t);
  }
  setBackFacesVisible(t, e) {
    this._sc.setBackFacesVisible(t, e);
  }
  setDrawMode(t, e) {
    this._sc.setDrawMode(t, e);
  }
  enableHiddenLineRendering(t, e) {
    this.setDrawMode(t, fr.HiddenLine), this._sc.setHiddenLineVisibleLineColor(
      t,
      this._toRgba(e.getVisibleLineColor(), e.getVisibleLineOpacity())
    ), this._sc.setHiddenLineHiddenLineColor(
      t,
      this._toRgba(e.getObscuredLineColor(), e.getObscuredLineOpacity())
    );
  }
  setAntiAliasingMode(t, e) {
    const i = e == pg.SMAA ? il.SMAA : il.None;
    this._sc.setAntiAliasingMode(t, i);
  }
  setInstanceModifier(t, e, i) {
    switch (t) {
      case tn.DoNotCut:
        this._sc.MeshInstance.setDoNotCut(e, i);
        break;
      case tn.DoNotExplode:
        this._sc.MeshInstance.setDoNotExplode(e, i);
        break;
      case tn.DoNotSelect:
        this._sc.MeshInstance.setDoNotSelect(e, i);
        break;
      case tn.SuppressCameraScale:
        this._sc.MeshInstance.setSuppressCameraScale(e, i);
        break;
      case tn.OverrideSceneVisibility:
        this._sc.MeshInstance.setOverrideSceneVisibility(e, i);
        break;
      case tn.DoNotLight:
        this._sc.MeshInstance.setDoNotLight(e, i);
        break;
      case tn.DoNotOutlineHighlight:
        this._sc.MeshInstance.setDoNotOutlineHighlight(e, i);
        break;
      case tn.ExcludeBounding:
        this._sc.MeshInstance.setExcludeBounding(e, i);
        break;
      case tn.DoNotUseVertexColors:
        this._sc.MeshInstance.setDoNotUseVertexColors(e, i);
        break;
      case tn.AlwaysDraw:
        this._sc.MeshInstance.setAlwaysDraw(e, i);
        break;
      case tn.DoNotXRay:
        this._sc.MeshInstance.setDoNotXRay(e, i);
        break;
      case tn.ScreenOriented:
        this._sc.MeshInstance.setScreenOriented(e, i);
        break;
      case tn.ScreenSpace:
        this._sc.MeshInstance.setScreenSpace(e, i);
        break;
      case tn.ScreenSpaceStretched:
        this._sc.MeshInstance.setScreenSpaceStretched(e, i);
        break;
    }
  }
  attachModel(t, e, i, n, r) {
    const o = [e, i];
    return this._attachModels(t, [o], n, r);
  }
  attachScsModelByKey(t, e, i, n, r) {
    return console.assert(this._sessionType === nn.Scs), this._sc.attachScsModelByKey(
      t,
      i,
      e,
      n,
      r
    );
  }
  async _attachModels(t, e, i, n) {
    await this._sc.attachModels(
      t,
      e,
      i,
      n
    ), this._callbackManager.trigger("_attached", t);
  }
  async attachScsBuffer(t, e, i, n, r, o, l, h) {
    await this._sc.attachScsBuffer(
      t,
      e,
      i,
      n,
      r,
      o,
      l,
      h
    ), this._callbackManager.trigger("_attached", t);
  }
  feedScsBuffer(t, e) {
    this._sc.feedScsBuffer(t, e);
  }
  _parseKeyInfo(t, e, i) {
    if (t || e)
      return i;
    const n = /* @__PURE__ */ new Map();
    for (let r = 0; r < i.length; ++r) {
      const o = i[r++], l = [];
      for (; r < i.length && i[r] !== Is.Invalid; ++r)
        l.push(i[r]);
      n.set(o, l);
    }
    return n;
  }
  async instanceKeyInfo(t, e, i) {
    const n = e === Gu.Model, r = i === $u.KeyCountOnly, o = await this._sc.meshInstanceKeyInfo(t, n, r);
    return this._parseKeyInfo(n, r, o);
  }
  async metaDataKeyInfo(t, e, i) {
    const n = await this._sc.metaDataKeyInfo(t, e, i);
    return this._parseKeyInfo(e, i, n);
  }
  modelKeysFromInclusionKeys(t) {
    return this._sc.modelKeysFromInclusionKeys(t);
  }
  detachInclusions(t) {
    return this._sc.detachInclusions(t);
  }
  async resetToEmpty(t, e) {
    for (let i = 0; i < this._requestBatchCountByType.length; ++i) {
      this._requestBatchCountByType[i] = 0;
      for (const n of this._pendingRequestsByType[i])
        n.promise.reject(n.ids);
      this._pendingRequestsByType[i].length = 0;
    }
    await this._sc.resetToEmpty(t, e), this.flushMetaDataCache();
  }
  setDrawStrategy(t, e) {
    console.warn(
      "This API has been deactivated for lack of stability it is recommended not to use it"
    ), this._sc.setDrawStrategy(t, e);
  }
  redraw(t) {
    this._sc.queueRedraw(t);
  }
  disconnectNetwork() {
    this._sc.disconnectNetwork();
  }
  shutdown() {
    this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._sessionType = nn.Uninitialized, this._sc.shutDown();
  }
  getVersionString() {
    return this._sc.getStreamVersion().toString();
  }
  setAllowHighDpi(t) {
    this._sc.allowHighDpi = t, this.resize();
  }
  getAllowHighDpi() {
    return this._sc.allowHighDpi;
  }
  setMeshLevel(t, e) {
    this._sc.MeshInstance.setMeshLevel(t, e);
  }
  setMetallicRoughness(t, e, i) {
    this._sc.MeshInstance.setMetallicRoughness(t, e, i);
  }
  setMetallicRoughnessMaterialOverride(t, e) {
    this._sc.setMetallicRoughnessMaterialOverride(t, e);
  }
  async getMetallicRoughness(t) {
    const e = await this._sc.MeshInstance.getMetallicRoughness(t), i = [];
    for (let n = 0; n < e.length; n += 2) {
      if (e[n] < 0 || e[n + 1] < 0) {
        i.push(null);
        continue;
      }
      i.push({
        metallic: e[n],
        roughness: e[n + 1]
      });
    }
    return i;
  }
  unsetMetallicRoughness(t) {
    this._sc.MeshInstance.unsetMetallicRoughness(t);
  }
  setOverlayVisibility(t, e, i) {
    this._sc.Overlay.setVisible(i, t, e);
  }
  setOverlayCamera(t, e, i) {
    const n = this._toCamera(i, e);
    this._sc.Overlay.setCamera(i, t, n);
  }
  destroyOverlay(t, e) {
    this._sc.Overlay.destroy(e, t);
  }
  _overlayUnit(t) {
    switch (t) {
      case Fe.ProportionOfCanvas:
        return nl.ProportionOfScreen;
      case Fe.MinimumProportionOfCanvas:
        return nl.MinimumProportionOfScreen;
      case Fe.ProportionOfOtherDimension:
        return nl.ProportionOfOtherDimension;
      default:
        return nl.Pixels;
    }
  }
  getMaxOverlayIndex() {
    return this._sc.Overlay.maxIndex();
  }
  _overlayAnchor(t) {
    switch (t) {
      case qe.BottomCenter:
        return dr.BottomCenter;
      case qe.Center:
        return dr.Center;
      case qe.LeftCenter:
        return dr.LeftCenter;
      case qe.LowerLeftCorner:
        return dr.LowerLeftCorner;
      case qe.LowerRightCorner:
        return dr.LowerRightCorner;
      case qe.RightCenter:
        return dr.RightCenter;
      case qe.TopCenter:
        return dr.TopCenter;
      case qe.UpperRightCorner:
        return dr.UpperRightCorner;
      default:
        return dr.UpperLeftCorner;
    }
  }
  setOverlayViewport(t, e, i, n, r, o, l, h, u, f, g) {
    this._sc.Overlay.setViewport(
      g,
      t,
      this._overlayAnchor(e),
      i,
      this._overlayUnit(n),
      r,
      this._overlayUnit(o),
      l,
      this._overlayUnit(h),
      u,
      this._overlayUnit(f)
    );
  }
  addNodesToOverlay(t, e, i) {
    this._sc.MeshInstance.setOverlayId(t, e, i);
  }
  getInstancesMeshData(t) {
    return this._sc.MeshInstance.getMeshData(t);
  }
  getInstancesCappingMeshData(t) {
    return this._sc.MeshInstance.getCappingMeshData(t);
  }
  getMeshData(t) {
    return this._sc.MeshData.getData(t);
  }
  _toElementType(t) {
    switch (t) {
      case Jt.Faces:
        return an.Faces;
      case Jt.Lines:
        return an.Lines;
      case Jt.Points:
        return an.Points;
    }
  }
  _toXRayGroup(t) {
    switch (t) {
      case rh.Selected:
        return ju.Selected;
      case rh.Unselected:
        return ju.Unselected;
    }
  }
  setXRayColor(t, e, i, n) {
    this._sc.setXRayMaterial(
      t,
      this._toXRayGroup(e),
      this._toElementType(i),
      this._toRgba(n, 1)
    );
  }
  unsetXRayColor(t, e, i) {
    return this._sc.unsetXRayMaterial(
      t,
      this._toXRayGroup(e),
      this._toElementType(i)
    );
  }
  setXRayOpacity(t, e, i) {
    i !== void 0 ? this._sc.setXRayOpacity(t, this._toElementType(i), e) : (this._sc.setXRayOpacity(t, an.Faces, e), this._sc.setXRayOpacity(t, an.Lines, e), this._sc.setXRayOpacity(t, an.Points, e));
  }
  setXRayTransparencyMode(t, e) {
    this._sc.setXRayTransparencyMode(t, e);
  }
  setGoochBlue(t, e) {
    this._sc.setGoochBlue(t, e);
  }
  setGoochBaseColorProminence(t, e) {
    this._sc.setGoochBaseColorProminence(t, e);
  }
  setGoochYellow(t, e) {
    this._sc.setGoochYellow(t, e);
  }
  setGoochLuminanceShiftStrength(t, e) {
    this._sc.setGoochLuminanceShiftStrength(t, e);
  }
  setToonShadingBandCount(t, e) {
    this._sc.setToonBandCount(t, e);
  }
  setToonShadingSpecularFactor(t, e) {
    this._sc.setToonSpecularFactor(t, e);
  }
  setTransparencyMode(t, e) {
    this._sc.setTransparencyMode(t, e);
  }
  setPointSize(t, e, i) {
    this._sc.setPointSize(t, e, i);
  }
  async getPointSize(t) {
    const e = await Promise.all([
      this._sc.getPointSize(t),
      this._sc.getPointSizeUnit(t)
    ]);
    return [e[0], e[1]];
  }
  setPointShape(t, e) {
    this._sc.setPointShape(t, e);
  }
  async getPointShape(t) {
    return await this._sc.getPointShape(t);
  }
  setEyeDomeLightingEnabled(t, e) {
    this._sc.setEyeDomeLightingEnabled(t, e);
  }
  getEyeDomeLightingEnabled(t) {
    return this._sc.getEyeDomeLightingEnabled(t);
  }
  setEyeDomeLightingBlurSamples(t, e) {
    this._sc.setEyeDomeLightingBlurSamples(t, e);
  }
  getEyeDomeLightingBlurSamples(t) {
    return this._sc.getEyeDomeLightingBlurSamples(t);
  }
  setEyeDomeLightingBlurInterval(t, e) {
    this._sc.setEyeDomeLightingBlurInterval(t, e);
  }
  getEyeDomeLightingBlurInterval(t) {
    return this._sc.getEyeDomeLightingBlurInterval(t);
  }
  setEyeDomeLightingBlurEdgeDistance(t, e) {
    this._sc.setEyeDomeLightingBlurEdgeDistance(t, e);
  }
  getEyeDomeLightingBlurEdgeDistance(t) {
    return this._sc.getEyeDomeLightingBlurEdgeDistance(t);
  }
  setEyeDomeLightingShadingEdgeDistance(t, e) {
    this._sc.setEyeDomeLightingShadingEdgeDistance(t, e);
  }
  getEyeDomeLightingShadingEdgeDistance(t) {
    return this._sc.getEyeDomeLightingShadingEdgeDistance(t);
  }
  setEyeDomeLightingOpacity(t, e) {
    this._sc.setEyeDomeLightingOpacity(t, e);
  }
  getEyeDomeLightingOpacity(t) {
    return this._sc.getEyeDomeLightingOpacity(t);
  }
  setDisplayIncompleteFrames(t, e) {
    this._sc.setDisplayIncompleteFrames(e, t);
  }
  setInteractiveDrawDelay(t, e) {
    this._sc.setPostInputDelay(e, t);
  }
  setInteractiveDrawLimitIncreaseEnabled(t, e) {
    this._sc.setInteractiveDrawLimitIncreaseEnabled(e, t);
  }
  getInteractiveDrawLimitIncreaseEnabled(t) {
    return this._sc.getInteractiveDrawLimitIncreaseEnabled(t);
  }
  setCullingVector(t, e, i, n) {
    this._sc.MeshInstance.setCullingVector(
      t,
      e,
      [i.x, i.y, i.z],
      n
    );
  }
  unsetCullingVector(t) {
    this._sc.MeshInstance.unsetCullingVector(t);
  }
  async getCullingVector(t) {
    const e = await this._sc.MeshInstance.getCullingVector(t), i = [];
    for (const n of e)
      n.vector[0] === 0 && n.vector[1] === 0 && n.vector[2] === 0 ? i.push(null) : i.push({
        space: n.space,
        vector: m.createFromArray(n.vector),
        toleranceDegrees: n.toleranceDegrees
      });
    return i;
  }
  _setStreamCutoffScale(t) {
    this._streamCutoffScale = Math.max(0, Math.min(t, 2));
  }
  setStreamCutoffScale(t) {
    this._setStreamCutoffScale(t), this._sc.setStreamCutoffScale(this._streamCutoffScale);
  }
  getStreamCutoffScale() {
    return this._streamCutoffScale;
  }
  loseWebGlContext() {
    return this._sc._loseWebGlContext();
  }
  triangulatePolygon(t, e) {
    const i = this._sc.triangulatePolygon(t, e);
    return new Float32Array(i);
  }
  debug_log(t) {
    return this._sc.debug_log(t);
  }
  debug_stateFailure(t) {
    return this._sc.debug_stateFailure(t);
  }
  debug_sync() {
    return this._sc.debug_sync();
  }
  setLinePattern(t, e, i, n) {
    this._sc.MeshInstance.setLinePattern(t, e, i, n);
  }
  unsetLinePattern(t) {
    this._sc.MeshInstance.unsetLinePattern(t);
  }
  async createFloorplanMesh(t) {
    return this._sc.createFloorplanMesh(t);
  }
  async exportToSvg(t) {
    return (await this._sc.exportToSvg(t)).map((n) => String.fromCharCode(n)).join("");
  }
  async beginExportToSvg(t) {
    return this._sc.beginExportToSvg(t);
  }
  async advanceExportToSvg() {
    const t = await this._sc.advanceExportToSvg();
    if (t.length !== 0)
      return t.reduce((e, i) => {
        const n = String.fromCharCode(i);
        switch (n) {
          case `
`:
            return e;
          case "'":
            return `${e}"`;
          default:
            return `${e}${n}`;
        }
      }, "");
  }
  waitForImageDecoding() {
    return this._sc.waitForImageDecoding();
  }
  registerBimInstances(t, e) {
    return this._sc.registerBimInstances(t, e);
  }
  setAmbientLightColor(t, e) {
    this._sc.setAmbientLightColor(t, this._toRgb(e));
  }
  getLightKeys(t) {
    return this._sc.getLightKeys(t);
  }
  async getLight(t, e) {
    try {
      const i = await this._sc.getLight(t, e);
      switch (i.type.value) {
        case Fu.Point: {
          const r = i;
          return new yx(
            i.type.value,
            i.space.value,
            new m(...i.position),
            yt.createFromFloatArray(i.color),
            r.power,
            r.decay
          );
        }
        case Fu.Directional:
          return new _x(
            i.type.value,
            i.space.value,
            new m(...i.position),
            yt.createFromFloatArray(i.color)
          );
        default:
          console.error(`No light of type ${i.type} could be instanciated.`);
          return;
      }
    } catch {
      return;
    }
  }
  clearLights(t) {
    this._sc.clearLights(t);
  }
  addLight(t, e) {
    return this._sc.addLight(
      t,
      e.type,
      e.space,
      this._toVector3(e.position),
      this._toRgb(e.color)
    );
  }
  async addPointLight(t, e) {
    const i = await this._sc.addLight(
      t,
      e.type,
      e.space,
      this._toVector3(e.position),
      this._toRgb(e.color)
    );
    return this._sc.setLightPower(t, i, e.power), this._sc.setLightDecay(t, i, e.decay), i;
  }
  removeLight(t, e) {
    this._sc.removeLight(t, e);
  }
  updateLight(t, e, i) {
    this._sc.updateLight(
      t,
      e,
      i.type,
      i.space,
      this._toVector3(i.position),
      this._toRgb(i.color)
    );
  }
  setBloomEnabled(t, e) {
    this._sc.setBloomEnabled(t, e);
  }
  setBloomThreshold(t, e) {
    this._sc.setBloomThreshold(t, e);
  }
  setBloomThresholdRampWidth(t, e) {
    this._sc.setBloomThresholdRampWidth(t, e);
  }
  setBloomIntensityScale(t, e) {
    this._sc.setBloomIntensityScale(t, e);
  }
  _toBlurIntervalUnit(t) {
    switch (t) {
      default:
      case Xs.Pixels:
        return xc.Pixels;
      case Xs.ProportionOfWidth:
        return xc.ProportionOfWidth;
      case Xs.ProportionOfHeight:
        return xc.ProportionOfHeight;
    }
  }
  setBloomLayers(t, e) {
    for (const i of e)
      if (i.blurInterval !== void 0 && i.blurInterval.length !== 2)
        throw new oe(
          "'blurInterval' must be an array containing a number followed by a BlurIntervalUnit"
        );
    this._sc.suspendDrawing(t), this._sc.setBloomLayerCount(t, e.length);
    for (let i = 0; i < e.length; ++i) {
      const n = e[i];
      n.intensity !== void 0 && this._sc.setBloomIntensity(t, i, n.intensity), n.blurSamples !== void 0 && this._sc.setBloomBlurSamples(t, i, n.blurSamples), n.blurInterval !== void 0 && this._sc.setBloomBlurInterval(
        t,
        i,
        n.blurInterval[0],
        this._toBlurIntervalUnit(n.blurInterval[1])
      );
    }
    this._sc.resumeDrawing(t);
  }
  startComparison(t, e, i, n) {
    const r = n != null && n.sameColor ? this._toRgb(n.sameColor) : [0, 0, 0], o = n != null && n.only1Color ? this._toRgb(n.only1Color) : [1, 0, 0], l = n != null && n.only2Color ? this._toRgb(n.only2Color) : [0, 1, 0];
    this._sc.setComparisonColors(t, r, o, l), this._sc.startComparison(t, e, i);
  }
  endComparison(t) {
    this._sc.endComparison(t);
  }
  setSimpleShadowColor(t, e) {
    this._sc.setSimpleShadowColor(t, this._toRgb(e));
  }
  setSimpleShadowEnabled(t, e) {
    this._sc.setSimpleShadowEnabled(t, e);
  }
  setSimpleShadowOpacity(t, e) {
    this._sc.setSimpleShadowOpacity(t, e);
  }
  setGroundPlane(t, e, i) {
    i !== void 0 ? this._sc.setGroundPlaneWithPosition(
      t,
      this._toVector3(e),
      this._toVector3(i)
    ) : this._sc.setGroundPlane(t, this._toVector3(e));
  }
  setSimpleShadowResolution(t, e) {
    this._sc.setSimpleShadowResolution(t, e);
  }
  setSimpleShadowBlurSamples(t, e) {
    this._sc.setSimpleShadowBlurSamples(t, e);
  }
  setSimpleShadowBlurInterval(t, e) {
    this._sc.setSimpleShadowBlurInterval(t, e);
  }
  setSimpleShadowInteractiveUpdateEnabled(t, e = !0) {
    this._sc.setSimpleShadowInteractiveUpdateEnabled(t, e);
  }
  setSilhouetteColor(t, e) {
    this._sc.setSilhouetteColor(t, this._toRgb(e));
  }
  setSilhouetteEnabled(t, e = !0) {
    this._sc.setSilhouetteEnabled(t, e);
  }
  setSilhouetteOpacity(t, e) {
    this._sc.setSilhouetteOpacity(t, e);
  }
  setSilhouetteThreshold(t, e) {
    this._sc.setSilhouetteThreshold(t, e);
  }
  setSilhouetteThresholdRampWidth(t, e) {
    this._sc.setSilhouetteThresholdRampWidth(t, e);
  }
  setHardEdgeColor(t, e) {
    this._sc.setHardEdgeColor(t, this._toRgb(e));
  }
  setHardEdgesEnabled(t, e = !0) {
    this._sc.setHardEdgesEnabled(t, e);
  }
  setHardEdgeOpacity(t, e) {
    this._sc.setHardEdgeOpacity(t, e);
  }
  setHardEdgeThreshold(t, e) {
    this._sc.setHardEdgeThreshold(t, e);
  }
  setHardEdgeThresholdRampWidth(t, e) {
    this._sc.setHardEdgeThresholdRampWidth(t, e);
  }
  setSimpleReflectionEnabled(t, e = !0) {
    this._sc.setSimpleReflectionEnabled(t, e);
  }
  setSimpleReflectionBlurInterval(t, e, i) {
    this._sc.setSimpleReflectionBlurInterval(t, e, this._toBlurIntervalUnit(i));
  }
  setSimpleReflectionBlurSamples(t, e) {
    this._sc.setSimpleReflectionBlurSamples(t, e);
  }
  setSimpleReflectionFadeAngle(t, e) {
    this._sc.setSimpleReflectionFadeAngle(t, e);
  }
  setSimpleReflectionOpacity(t, e) {
    this._sc.setSimpleReflectionOpacity(t, e);
  }
  setSimpleReflectionAttenuation(t, e, i, n = ig.World) {
    this._sc.setSimpleReflectionAttenuation(t, e, i, n);
  }
  throttleLoad(t, e) {
    this._sc.throttleLoad(t, e);
  }
  _toVector3Array(t) {
    const e = [];
    for (const i of t)
      e.push([i.x, i.y, i.z]);
    return e;
  }
  testPointVisibility(t, e) {
    return this._sc.testPointVisibility(this._toVector3Array(e), t);
  }
  setPointVisibilityTest(t, e) {
    this._sc.setPointVisibilityTest(this._toVector3Array(e), t);
  }
  setImageBasedLightingEnabled(t, e) {
    this._sc.setImageBasedLightingEnabled(t, e);
  }
  setImageBasedLightingIntensity(t, e) {
    this._sc.setImageBasedLightingIntensity(t, e);
  }
  _toMatrix9(t) {
    return [
      t.m[0],
      t.m[1],
      t.m[2],
      t.m[4],
      t.m[5],
      t.m[6],
      t.m[8],
      t.m[9],
      t.m[10]
    ];
  }
  setImageBasedLightingMatrix(t, e) {
    this._sc.setImageBasedLightingMatrix(t, this._toMatrix9(e));
  }
  setImageBasedLightingEnvironment(t, e) {
    this._sc.setImageBasedLightingEnvironment(t, e);
  }
  setImageBasedLightingEnvironmentToDefault(t) {
    this._sc.setImageBasedLightingEnvironmentToDefault(t);
  }
  setLineJitterEnabled(t, e) {
    this._sc.setLineJitterEnabled(t, e);
  }
  setLineJitterInstanceCount(t, e) {
    this._sc.setLineJitterInstanceCount(t, e);
  }
  setLineJitterRadius(t, e) {
    this._sc.setLineJitterRadius(t, e);
  }
  setLineJitterFrequency(t, e) {
    this._sc.setLineJitterFrequency(t, e);
  }
}
const uI = () => new window.XMLHttpRequest();
function dI(s, t) {
  let e, i, n, r;
  t || (t = {}), typeof t == "function" ? (r = t, t = {}) : typeof t.callback == "function" && (r = t.callback), !r && typeof Promise < "u" ? e = new Promise(function(o, l) {
    i = o, n = l;
  }) : (i = function(o) {
    r(null, o);
  }, n = function(o) {
    r(o, null);
  });
  try {
    const o = uI();
    if (o.open("GET", s, !0), "responseType" in o && (o.responseType = "arraybuffer"), o.overrideMimeType && o.overrideMimeType("text/plain; charset=x-user-defined"), o.onreadystatechange = function() {
      if (o.readyState === 4)
        if (o.status === 200 || o.status === 0)
          try {
            i(o.response ?? o.responseText);
          } catch (l) {
            n(l);
          }
        else
          n(new Error("Ajax error for " + s + " : " + this.status + " " + this.statusText));
    }, t.progress) {
      const l = t.progress;
      o.onprogress = function(h) {
        l({
          path: s,
          originalEvent: h,
          percent: h.loaded / h.total * 100,
          loaded: h.loaded,
          total: h.total
        });
      };
    }
    o.send();
  } catch (o) {
    n(o, null);
  }
  return e;
}
class fI {
  constructor(t) {
    this._id = 0, this._bcfMap = /* @__PURE__ */ new Map(), this._viewer = t;
  }
  _getId() {
    return ++this._id;
  }
  /**
   * Gets a map containing BCF data correlated with the BCF filename.
   */
  getBCFMap() {
    return this._bcfMap;
  }
  /**
   * Gets the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  getBCFData(t) {
    return this._bcfMap.get(t) || null;
  }
  /**
   * Removes the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  removeBCFData(t) {
    this._bcfMap.delete(t), this._viewer.trigger("bcfRemoved", t);
  }
  /**
   * Creates a BCF file.
   * @param filename
   */
  createBCFData(t) {
    const e = this._getId(), i = new Eu(t, e);
    return this._bcfMap.set(e, i), this._viewer.trigger("bcfLoaded", i.getId(), i.getFilename()), i;
  }
  /**
   * Imports BCF data from a BCF file.
   * @param filename
   */
  async addBCFFromFile(t) {
    const e = this._getId(), i = new Eu(t, e);
    this._bcfMap.set(e, i);
    const n = await new A_.external.Promise((r, o) => {
      dI(t, (l, h) => {
        l ? o(l) : r(h);
      });
    });
    await this._loadBCFData(n, i);
  }
  /**
   * Imports BCF data from a buffer.
   * @param buffer
   * @param filename
   */
  async addBCFFromBuffer(t, e) {
    const i = this._getId(), n = new Eu(e, i);
    this._bcfMap.set(i, n), await this._loadBCFData(t, n);
  }
  async _getVersion(t) {
    const e = t.file("bcf.version");
    if (e === null)
      return Js.v1_0;
    {
      const r = (await this._getDocument(e)).documentElement.firstElementChild;
      if (r != null && r.textContent)
        switch (r.textContent) {
          case "2.0 RC":
            return Js.v2_0;
          case "2.1":
            return Js.v2_1;
        }
      return Js.Unknown;
    }
  }
  async _loadBCFData(t, e) {
    const i = this._viewer.model, n = await i.getModelBounding(!0, !1), r = i.getNodeUnitMultiplier(i.getAbsoluteRootNode()), o = e.getId(), l = e.getFilename(), h = await _g.loadAsync(t);
    e.setVersion(await this._getVersion(h));
    const u = [];
    h.forEach(async (f) => {
      const g = vi();
      u.push(g);
      const y = this._getFileType(f);
      if (y === Yn.Markup || y === Yn.Snapshot || y === Yn.Viewpoint) {
        const _ = f.split("/"), x = _[0], b = _[1];
        let I = e.getTopic(x);
        if (I === null && (I = new md(o, l, x, this._viewer), e.addTopic(x, I)), b.length) {
          const C = h.file(f);
          if (C !== null)
            switch (y) {
              case Yn.Markup:
                I.addMarkup(b, await this._getDocument(C));
                break;
              case Yn.Viewpoint:
                I.addViewpoint(
                  b,
                  await this._getDocument(C),
                  e.getVersion(),
                  n,
                  r
                );
                break;
              case Yn.Snapshot:
                I.addSnapshot(b, await C.async("uint8array"));
                break;
            }
        }
      }
      g.resolve();
    }), await We(u), this._viewer.trigger("bcfLoaded", o, l);
  }
  async _getDocument(t) {
    return new DOMParser().parseFromString(await t.async("text"), "application/xml");
  }
  _getFileType(t) {
    if (t.slice(-1) === "/")
      return Yn.TopicFolder;
    const e = t.split(".");
    switch (console.assert(e.length === 2), e[1]) {
      case "bcf":
        return Yn.Markup;
      case "bcfv":
        return Yn.Viewpoint;
      case "png":
        return Yn.Snapshot;
      case "version":
        return Yn.Version;
      case "xsd":
        return Yn.Schema;
      case "bcfp":
        return Yn.Project;
    }
    return Yn.Unknown;
  }
}
class gI {
  constructor() {
    this._activeInterpolation = null, this._updateTimer = new Ko(), this._updateInterval = 16;
  }
  stop() {
    this._activeInterpolation && this._activeInterpolation.stop(), this._activeInterpolation = null, this._updateTimer.clear();
  }
  start(t, e = !0) {
    return this._activeInterpolation && !e ? !1 : (this.stop(), this._activeInterpolation = t, this._activeInterpolation.start(), this.update(), !0);
  }
  update() {
    if (this._activeInterpolation)
      if (this._activeInterpolation.update(), this._activeInterpolation.isComplete()) {
        const t = this._activeInterpolation.getCallback();
        t !== null && t();
      } else this._updateTimer.isIdle(Nn.BeforeAction) && this._updateTimer.set(this._updateInterval, () => {
        this.update();
      });
  }
}
var nc = { exports: {} }, la = { exports: {} }, pI = la.exports, Qp;
function mI() {
  return Qp || (Qp = 1, (function() {
    var s, t, e, i, n, r;
    typeof performance < "u" && performance !== null && performance.now ? la.exports = function() {
      return performance.now();
    } : typeof process < "u" && process !== null && process.hrtime ? (la.exports = function() {
      return (s() - n) / 1e6;
    }, t = process.hrtime, s = function() {
      var o;
      return o = t(), o[0] * 1e9 + o[1];
    }, i = s(), r = process.uptime() * 1e9, n = i - r) : Date.now ? (la.exports = function() {
      return Date.now() - e;
    }, e = Date.now()) : (la.exports = function() {
      return (/* @__PURE__ */ new Date()).getTime() - e;
    }, e = (/* @__PURE__ */ new Date()).getTime());
  }).call(pI)), la.exports;
}
var tm;
function _I() {
  if (tm) return nc.exports;
  tm = 1;
  for (var s = mI(), t = typeof window > "u" ? ac : window, e = ["moz", "webkit"], i = "AnimationFrame", n = t["request" + i], r = t["cancel" + i] || t["cancelRequest" + i], o = 0; !n && o < e.length; o++)
    n = t[e[o] + "Request" + i], r = t[e[o] + "Cancel" + i] || t[e[o] + "CancelRequest" + i];
  if (!n || !r) {
    var l = 0, h = 0, u = [], f = 1e3 / 60;
    n = function(g) {
      if (u.length === 0) {
        var y = s(), _ = Math.max(0, f - (y - l));
        l = _ + y, setTimeout(function() {
          var x = u.slice(0);
          u.length = 0;
          for (var b = 0; b < x.length; b++)
            if (!x[b].cancelled)
              try {
                x[b].callback(l);
              } catch (I) {
                setTimeout(function() {
                  throw I;
                }, 0);
              }
        }, Math.round(_));
      }
      return u.push({
        handle: ++h,
        callback: g,
        cancelled: !1
      }), h;
    }, r = function(g) {
      for (var y = 0; y < u.length; y++)
        u[y].handle === g && (u[y].cancelled = !0);
    };
  }
  return nc.exports = function(g) {
    return n.call(t, g);
  }, nc.exports.cancel = function() {
    r.apply(t, arguments);
  }, nc.exports.polyfill = function(g) {
    g || (g = t), g.requestAnimationFrame = n, g.cancelAnimationFrame = r;
  }, nc.exports;
}
var yI = _I();
const hf = /* @__PURE__ */ ld(yI);
var uf, em;
function wI() {
  return em || (em = 1, uf = function(s) {
    this.ok = !1, this.alpha = 1, s.charAt(0) == "#" && (s = s.substr(1, 6)), s = s.replace(/ /g, ""), s = s.toLowerCase();
    var t = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dodgerblue: "1e90ff",
      feldspar: "d19275",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgrey: "d3d3d3",
      lightgreen: "90ee90",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslateblue: "8470ff",
      lightslategray: "778899",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "00ff00",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "ff00ff",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370d8",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "d87093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "ff0000",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      violetred: "d02090",
      wheat: "f5deb3",
      white: "ffffff",
      whitesmoke: "f5f5f5",
      yellow: "ffff00",
      yellowgreen: "9acd32"
    };
    s = t[s] || s;
    for (var e = [
      {
        re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
        example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
        process: function(h) {
          return [
            parseInt(h[1]),
            parseInt(h[2]),
            parseInt(h[3]),
            parseFloat(h[4])
          ];
        }
      },
      {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
        process: function(h) {
          return [
            parseInt(h[1]),
            parseInt(h[2]),
            parseInt(h[3])
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        example: ["#00ff00", "336699"],
        process: function(h) {
          return [
            parseInt(h[1], 16),
            parseInt(h[2], 16),
            parseInt(h[3], 16)
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        example: ["#fb0", "f0f"],
        process: function(h) {
          return [
            parseInt(h[1] + h[1], 16),
            parseInt(h[2] + h[2], 16),
            parseInt(h[3] + h[3], 16)
          ];
        }
      }
    ], i = 0; i < e.length; i++) {
      var n = e[i].re, r = e[i].process, o = n.exec(s);
      if (o) {
        var l = r(o);
        this.r = l[0], this.g = l[1], this.b = l[2], l.length > 3 && (this.alpha = l[3]), this.ok = !0;
      }
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    }, this.toRGBA = function() {
      return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
    }, this.toHex = function() {
      var h = this.r.toString(16), u = this.g.toString(16), f = this.b.toString(16);
      return h.length == 1 && (h = "0" + h), u.length == 1 && (u = "0" + u), f.length == 1 && (f = "0" + f), "#" + h + u + f;
    }, this.getHelpXML = function() {
      for (var h = new Array(), u = 0; u < e.length; u++)
        for (var f = e[u].example, g = 0; g < f.length; g++)
          h[h.length] = f[g];
      for (var y in t)
        h[h.length] = y;
      var _ = document.createElement("ul");
      _.setAttribute("id", "rgbcolor-examples");
      for (var u = 0; u < h.length; u++)
        try {
          var x = document.createElement("li"), b = new RGBColor(h[u]), I = document.createElement("div");
          I.style.cssText = "margin: 3px; border: 1px solid black; background:" + b.toHex() + "; color:" + b.toHex(), I.appendChild(document.createTextNode("test"));
          var C = document.createTextNode(
            " " + h[u] + " -> " + b.toRGB() + " -> " + b.toHex()
          );
          x.appendChild(I), x.appendChild(C), _.appendChild(x);
        } catch {
        }
      return _;
    };
  }), uf;
}
var vI = wI();
const Xf = /* @__PURE__ */ ld(vI);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Wy = function(s, t) {
  return (Wy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);
  })(s, t);
};
function Gy(s, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = s;
  }
  Wy(s, t), s.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function bI(s) {
  var t = "";
  Array.isArray(s) || (s = [s]);
  for (var e = 0; e < s.length; e++) {
    var i = s[e];
    if (i.type === Et.CLOSE_PATH) t += "z";
    else if (i.type === Et.HORIZ_LINE_TO) t += (i.relative ? "h" : "H") + i.x;
    else if (i.type === Et.VERT_LINE_TO) t += (i.relative ? "v" : "V") + i.y;
    else if (i.type === Et.MOVE_TO) t += (i.relative ? "m" : "M") + i.x + " " + i.y;
    else if (i.type === Et.LINE_TO) t += (i.relative ? "l" : "L") + i.x + " " + i.y;
    else if (i.type === Et.CURVE_TO) t += (i.relative ? "c" : "C") + i.x1 + " " + i.y1 + " " + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === Et.SMOOTH_CURVE_TO) t += (i.relative ? "s" : "S") + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === Et.QUAD_TO) t += (i.relative ? "q" : "Q") + i.x1 + " " + i.y1 + " " + i.x + " " + i.y;
    else if (i.type === Et.SMOOTH_QUAD_TO) t += (i.relative ? "t" : "T") + i.x + " " + i.y;
    else {
      if (i.type !== Et.ARC) throw new Error('Unexpected command type "' + i.type + '" at index ' + e + ".");
      t += (i.relative ? "a" : "A") + i.rX + " " + i.rY + " " + i.xRot + " " + +i.lArcFlag + " " + +i.sweepFlag + " " + i.x + " " + i.y;
    }
  }
  return t;
}
function Jf(s, t) {
  var e = s[0], i = s[1];
  return [e * Math.cos(t) - i * Math.sin(t), e * Math.sin(t) + i * Math.cos(t)];
}
function ur() {
  for (var s = [], t = 0; t < arguments.length; t++) s[t] = arguments[t];
  for (var e = 0; e < s.length; e++) if (typeof s[e] != "number") throw new Error("assertNumbers arguments[" + e + "] is not a number. " + typeof s[e] + " == typeof " + s[e]);
  return !0;
}
var ko = Math.PI;
function df(s, t, e) {
  s.lArcFlag = s.lArcFlag === 0 ? 0 : 1, s.sweepFlag = s.sweepFlag === 0 ? 0 : 1;
  var i = s.rX, n = s.rY, r = s.x, o = s.y;
  i = Math.abs(s.rX), n = Math.abs(s.rY);
  var l = Jf([(t - r) / 2, (e - o) / 2], -s.xRot / 180 * ko), h = l[0], u = l[1], f = Math.pow(h, 2) / Math.pow(i, 2) + Math.pow(u, 2) / Math.pow(n, 2);
  1 < f && (i *= Math.sqrt(f), n *= Math.sqrt(f)), s.rX = i, s.rY = n;
  var g = Math.pow(i, 2) * Math.pow(u, 2) + Math.pow(n, 2) * Math.pow(h, 2), y = (s.lArcFlag !== s.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(i, 2) * Math.pow(n, 2) - g) / g)), _ = i * u / n * y, x = -n * h / i * y, b = Jf([_, x], s.xRot / 180 * ko);
  s.cX = b[0] + (t + r) / 2, s.cY = b[1] + (e + o) / 2, s.phi1 = Math.atan2((u - x) / n, (h - _) / i), s.phi2 = Math.atan2((-u - x) / n, (-h - _) / i), s.sweepFlag === 0 && s.phi2 > s.phi1 && (s.phi2 -= 2 * ko), s.sweepFlag === 1 && s.phi2 < s.phi1 && (s.phi2 += 2 * ko), s.phi1 *= 180 / ko, s.phi2 *= 180 / ko;
}
function im(s, t, e) {
  ur(s, t, e);
  var i = s * s + t * t - e * e;
  if (0 > i) return [];
  if (i === 0) return [[s * e / (s * s + t * t), t * e / (s * s + t * t)]];
  var n = Math.sqrt(i);
  return [[(s * e + t * n) / (s * s + t * t), (t * e - s * n) / (s * s + t * t)], [(s * e - t * n) / (s * s + t * t), (t * e + s * n) / (s * s + t * t)]];
}
var mn, to = Math.PI / 180;
function nm(s, t, e) {
  return (1 - e) * s + e * t;
}
function sm(s, t, e, i) {
  return s + Math.cos(i / 180 * ko) * t + Math.sin(i / 180 * ko) * e;
}
function rm(s, t, e, i) {
  var n = 1e-6, r = t - s, o = e - t, l = 3 * r + 3 * (i - e) - 6 * o, h = 6 * (o - r), u = 3 * r;
  return Math.abs(l) < n ? [-u / h] : function(f, g, y) {
    var _ = f * f / 4 - g;
    if (_ < -1e-6) return [];
    if (_ <= y) return [-f / 2];
    var x = Math.sqrt(_);
    return [-f / 2 - x, -f / 2 + x];
  }(h / l, u / l, n);
}
function om(s, t, e, i, n) {
  var r = 1 - n;
  return s * (r * r * r) + t * (3 * r * r * n) + e * (3 * r * n * n) + i * (n * n * n);
}
(function(s) {
  function t() {
    return n(function(l, h, u) {
      return l.relative && (l.x1 !== void 0 && (l.x1 += h), l.y1 !== void 0 && (l.y1 += u), l.x2 !== void 0 && (l.x2 += h), l.y2 !== void 0 && (l.y2 += u), l.x !== void 0 && (l.x += h), l.y !== void 0 && (l.y += u), l.relative = !1), l;
    });
  }
  function e() {
    var l = NaN, h = NaN, u = NaN, f = NaN;
    return n(function(g, y, _) {
      return g.type & Et.SMOOTH_CURVE_TO && (g.type = Et.CURVE_TO, l = isNaN(l) ? y : l, h = isNaN(h) ? _ : h, g.x1 = g.relative ? y - l : 2 * y - l, g.y1 = g.relative ? _ - h : 2 * _ - h), g.type & Et.CURVE_TO ? (l = g.relative ? y + g.x2 : g.x2, h = g.relative ? _ + g.y2 : g.y2) : (l = NaN, h = NaN), g.type & Et.SMOOTH_QUAD_TO && (g.type = Et.QUAD_TO, u = isNaN(u) ? y : u, f = isNaN(f) ? _ : f, g.x1 = g.relative ? y - u : 2 * y - u, g.y1 = g.relative ? _ - f : 2 * _ - f), g.type & Et.QUAD_TO ? (u = g.relative ? y + g.x1 : g.x1, f = g.relative ? _ + g.y1 : g.y1) : (u = NaN, f = NaN), g;
    });
  }
  function i() {
    var l = NaN, h = NaN;
    return n(function(u, f, g) {
      if (u.type & Et.SMOOTH_QUAD_TO && (u.type = Et.QUAD_TO, l = isNaN(l) ? f : l, h = isNaN(h) ? g : h, u.x1 = u.relative ? f - l : 2 * f - l, u.y1 = u.relative ? g - h : 2 * g - h), u.type & Et.QUAD_TO) {
        l = u.relative ? f + u.x1 : u.x1, h = u.relative ? g + u.y1 : u.y1;
        var y = u.x1, _ = u.y1;
        u.type = Et.CURVE_TO, u.x1 = ((u.relative ? 0 : f) + 2 * y) / 3, u.y1 = ((u.relative ? 0 : g) + 2 * _) / 3, u.x2 = (u.x + 2 * y) / 3, u.y2 = (u.y + 2 * _) / 3;
      } else l = NaN, h = NaN;
      return u;
    });
  }
  function n(l) {
    var h = 0, u = 0, f = NaN, g = NaN;
    return function(y) {
      if (isNaN(f) && !(y.type & Et.MOVE_TO)) throw new Error("path must start with moveto");
      var _ = l(y, h, u, f, g);
      return y.type & Et.CLOSE_PATH && (h = f, u = g), y.x !== void 0 && (h = y.relative ? h + y.x : y.x), y.y !== void 0 && (u = y.relative ? u + y.y : y.y), y.type & Et.MOVE_TO && (f = h, g = u), _;
    };
  }
  function r(l, h, u, f, g, y) {
    return ur(l, h, u, f, g, y), n(function(_, x, b, I) {
      var C = _.x1, M = _.x2, P = _.relative && !isNaN(I), O = _.x !== void 0 ? _.x : P ? 0 : x, B = _.y !== void 0 ? _.y : P ? 0 : b;
      function j(ot) {
        return ot * ot;
      }
      _.type & Et.HORIZ_LINE_TO && h !== 0 && (_.type = Et.LINE_TO, _.y = _.relative ? 0 : b), _.type & Et.VERT_LINE_TO && u !== 0 && (_.type = Et.LINE_TO, _.x = _.relative ? 0 : x), _.x !== void 0 && (_.x = _.x * l + B * u + (P ? 0 : g)), _.y !== void 0 && (_.y = O * h + _.y * f + (P ? 0 : y)), _.x1 !== void 0 && (_.x1 = _.x1 * l + _.y1 * u + (P ? 0 : g)), _.y1 !== void 0 && (_.y1 = C * h + _.y1 * f + (P ? 0 : y)), _.x2 !== void 0 && (_.x2 = _.x2 * l + _.y2 * u + (P ? 0 : g)), _.y2 !== void 0 && (_.y2 = M * h + _.y2 * f + (P ? 0 : y));
      var F = l * f - h * u;
      if (_.xRot !== void 0 && (l !== 1 || h !== 0 || u !== 0 || f !== 1)) if (F === 0) delete _.rX, delete _.rY, delete _.xRot, delete _.lArcFlag, delete _.sweepFlag, _.type = Et.LINE_TO;
      else {
        var K = _.xRot * Math.PI / 180, J = Math.sin(K), rt = Math.cos(K), ft = 1 / j(_.rX), H = 1 / j(_.rY), $ = j(rt) * ft + j(J) * H, D = 2 * J * rt * (ft - H), R = j(J) * ft + j(rt) * H, U = $ * f * f - D * h * f + R * h * h, it = D * (l * f + h * u) - 2 * ($ * u * f + R * l * h), at = $ * u * u - D * l * u + R * l * l, mt = (Math.atan2(it, U - at) + Math.PI) % Math.PI / 2, Nt = Math.sin(mt), lt = Math.cos(mt);
        _.rX = Math.abs(F) / Math.sqrt(U * j(lt) + it * Nt * lt + at * j(Nt)), _.rY = Math.abs(F) / Math.sqrt(U * j(Nt) - it * Nt * lt + at * j(lt)), _.xRot = 180 * mt / Math.PI;
      }
      return _.sweepFlag !== void 0 && 0 > F && (_.sweepFlag = +!_.sweepFlag), _;
    });
  }
  function o() {
    return function(l) {
      var h = {};
      for (var u in l) h[u] = l[u];
      return h;
    };
  }
  s.ROUND = function(l) {
    function h(u) {
      return Math.round(u * l) / l;
    }
    return l === void 0 && (l = 1e13), ur(l), function(u) {
      return u.x1 !== void 0 && (u.x1 = h(u.x1)), u.y1 !== void 0 && (u.y1 = h(u.y1)), u.x2 !== void 0 && (u.x2 = h(u.x2)), u.y2 !== void 0 && (u.y2 = h(u.y2)), u.x !== void 0 && (u.x = h(u.x)), u.y !== void 0 && (u.y = h(u.y)), u.rX !== void 0 && (u.rX = h(u.rX)), u.rY !== void 0 && (u.rY = h(u.rY)), u;
    };
  }, s.TO_ABS = t, s.TO_REL = function() {
    return n(function(l, h, u) {
      return l.relative || (l.x1 !== void 0 && (l.x1 -= h), l.y1 !== void 0 && (l.y1 -= u), l.x2 !== void 0 && (l.x2 -= h), l.y2 !== void 0 && (l.y2 -= u), l.x !== void 0 && (l.x -= h), l.y !== void 0 && (l.y -= u), l.relative = !0), l;
    });
  }, s.NORMALIZE_HVZ = function(l, h, u) {
    return l === void 0 && (l = !0), h === void 0 && (h = !0), u === void 0 && (u = !0), n(function(f, g, y, _, x) {
      if (isNaN(_) && !(f.type & Et.MOVE_TO)) throw new Error("path must start with moveto");
      return h && f.type & Et.HORIZ_LINE_TO && (f.type = Et.LINE_TO, f.y = f.relative ? 0 : y), u && f.type & Et.VERT_LINE_TO && (f.type = Et.LINE_TO, f.x = f.relative ? 0 : g), l && f.type & Et.CLOSE_PATH && (f.type = Et.LINE_TO, f.x = f.relative ? _ - g : _, f.y = f.relative ? x - y : x), f.type & Et.ARC && (f.rX === 0 || f.rY === 0) && (f.type = Et.LINE_TO, delete f.rX, delete f.rY, delete f.xRot, delete f.lArcFlag, delete f.sweepFlag), f;
    });
  }, s.NORMALIZE_ST = e, s.QT_TO_C = i, s.INFO = n, s.SANITIZE = function(l) {
    l === void 0 && (l = 0), ur(l);
    var h = NaN, u = NaN, f = NaN, g = NaN;
    return n(function(y, _, x, b, I) {
      var C = Math.abs, M = !1, P = 0, O = 0;
      if (y.type & Et.SMOOTH_CURVE_TO && (P = isNaN(h) ? 0 : _ - h, O = isNaN(u) ? 0 : x - u), y.type & (Et.CURVE_TO | Et.SMOOTH_CURVE_TO) ? (h = y.relative ? _ + y.x2 : y.x2, u = y.relative ? x + y.y2 : y.y2) : (h = NaN, u = NaN), y.type & Et.SMOOTH_QUAD_TO ? (f = isNaN(f) ? _ : 2 * _ - f, g = isNaN(g) ? x : 2 * x - g) : y.type & Et.QUAD_TO ? (f = y.relative ? _ + y.x1 : y.x1, g = y.relative ? x + y.y1 : y.y2) : (f = NaN, g = NaN), y.type & Et.LINE_COMMANDS || y.type & Et.ARC && (y.rX === 0 || y.rY === 0 || !y.lArcFlag) || y.type & Et.CURVE_TO || y.type & Et.SMOOTH_CURVE_TO || y.type & Et.QUAD_TO || y.type & Et.SMOOTH_QUAD_TO) {
        var B = y.x === void 0 ? 0 : y.relative ? y.x : y.x - _, j = y.y === void 0 ? 0 : y.relative ? y.y : y.y - x;
        P = isNaN(f) ? y.x1 === void 0 ? P : y.relative ? y.x : y.x1 - _ : f - _, O = isNaN(g) ? y.y1 === void 0 ? O : y.relative ? y.y : y.y1 - x : g - x;
        var F = y.x2 === void 0 ? 0 : y.relative ? y.x : y.x2 - _, K = y.y2 === void 0 ? 0 : y.relative ? y.y : y.y2 - x;
        C(B) <= l && C(j) <= l && C(P) <= l && C(O) <= l && C(F) <= l && C(K) <= l && (M = !0);
      }
      return y.type & Et.CLOSE_PATH && C(_ - b) <= l && C(x - I) <= l && (M = !0), M ? [] : y;
    });
  }, s.MATRIX = r, s.ROTATE = function(l, h, u) {
    h === void 0 && (h = 0), u === void 0 && (u = 0), ur(l, h, u);
    var f = Math.sin(l), g = Math.cos(l);
    return r(g, f, -f, g, h - h * g + u * f, u - h * f - u * g);
  }, s.TRANSLATE = function(l, h) {
    return h === void 0 && (h = 0), ur(l, h), r(1, 0, 0, 1, l, h);
  }, s.SCALE = function(l, h) {
    return h === void 0 && (h = l), ur(l, h), r(l, 0, 0, h, 0, 0);
  }, s.SKEW_X = function(l) {
    return ur(l), r(1, 0, Math.atan(l), 1, 0, 0);
  }, s.SKEW_Y = function(l) {
    return ur(l), r(1, Math.atan(l), 0, 1, 0, 0);
  }, s.X_AXIS_SYMMETRY = function(l) {
    return l === void 0 && (l = 0), ur(l), r(-1, 0, 0, 1, l, 0);
  }, s.Y_AXIS_SYMMETRY = function(l) {
    return l === void 0 && (l = 0), ur(l), r(1, 0, 0, -1, 0, l);
  }, s.A_TO_C = function() {
    return n(function(l, h, u) {
      return Et.ARC === l.type ? function(f, g, y) {
        var _, x, b, I;
        f.cX || df(f, g, y);
        for (var C = Math.min(f.phi1, f.phi2), M = Math.max(f.phi1, f.phi2) - C, P = Math.ceil(M / 90), O = new Array(P), B = g, j = y, F = 0; F < P; F++) {
          var K = nm(f.phi1, f.phi2, F / P), J = nm(f.phi1, f.phi2, (F + 1) / P), rt = J - K, ft = 4 / 3 * Math.tan(rt * to / 4), H = [Math.cos(K * to) - ft * Math.sin(K * to), Math.sin(K * to) + ft * Math.cos(K * to)], $ = H[0], D = H[1], R = [Math.cos(J * to), Math.sin(J * to)], U = R[0], it = R[1], at = [U + ft * Math.sin(J * to), it - ft * Math.cos(J * to)], mt = at[0], Nt = at[1];
          O[F] = { relative: f.relative, type: Et.CURVE_TO };
          var lt = function(ot, Ht) {
            var St = Jf([ot * f.rX, Ht * f.rY], f.xRot), Rt = St[0], ei = St[1];
            return [f.cX + Rt, f.cY + ei];
          };
          _ = lt($, D), O[F].x1 = _[0], O[F].y1 = _[1], x = lt(mt, Nt), O[F].x2 = x[0], O[F].y2 = x[1], b = lt(U, it), O[F].x = b[0], O[F].y = b[1], f.relative && (O[F].x1 -= B, O[F].y1 -= j, O[F].x2 -= B, O[F].y2 -= j, O[F].x -= B, O[F].y -= j), B = (I = [O[F].x, O[F].y])[0], j = I[1];
        }
        return O;
      }(l, l.relative ? 0 : h, l.relative ? 0 : u) : l;
    });
  }, s.ANNOTATE_ARCS = function() {
    return n(function(l, h, u) {
      return l.relative && (h = 0, u = 0), Et.ARC === l.type && df(l, h, u), l;
    });
  }, s.CLONE = o, s.CALCULATE_BOUNDS = function() {
    var l = function(y) {
      var _ = {};
      for (var x in y) _[x] = y[x];
      return _;
    }, h = t(), u = i(), f = e(), g = n(function(y, _, x) {
      var b = f(u(h(l(y))));
      function I(Nt) {
        Nt > g.maxX && (g.maxX = Nt), Nt < g.minX && (g.minX = Nt);
      }
      function C(Nt) {
        Nt > g.maxY && (g.maxY = Nt), Nt < g.minY && (g.minY = Nt);
      }
      if (b.type & Et.DRAWING_COMMANDS && (I(_), C(x)), b.type & Et.HORIZ_LINE_TO && I(b.x), b.type & Et.VERT_LINE_TO && C(b.y), b.type & Et.LINE_TO && (I(b.x), C(b.y)), b.type & Et.CURVE_TO) {
        I(b.x), C(b.y);
        for (var M = 0, P = rm(_, b.x1, b.x2, b.x); M < P.length; M++)
          0 < (mt = P[M]) && 1 > mt && I(om(_, b.x1, b.x2, b.x, mt));
        for (var O = 0, B = rm(x, b.y1, b.y2, b.y); O < B.length; O++)
          0 < (mt = B[O]) && 1 > mt && C(om(x, b.y1, b.y2, b.y, mt));
      }
      if (b.type & Et.ARC) {
        I(b.x), C(b.y), df(b, _, x);
        for (var j = b.xRot / 180 * Math.PI, F = Math.cos(j) * b.rX, K = Math.sin(j) * b.rX, J = -Math.sin(j) * b.rY, rt = Math.cos(j) * b.rY, ft = b.phi1 < b.phi2 ? [b.phi1, b.phi2] : -180 > b.phi2 ? [b.phi2 + 360, b.phi1 + 360] : [b.phi2, b.phi1], H = ft[0], $ = ft[1], D = function(Nt) {
          var lt = Nt[0], ot = Nt[1], Ht = 180 * Math.atan2(ot, lt) / Math.PI;
          return Ht < H ? Ht + 360 : Ht;
        }, R = 0, U = im(J, -F, 0).map(D); R < U.length; R++)
          (mt = U[R]) > H && mt < $ && I(sm(b.cX, F, J, mt));
        for (var it = 0, at = im(rt, -K, 0).map(D); it < at.length; it++) {
          var mt;
          (mt = at[it]) > H && mt < $ && C(sm(b.cY, K, rt, mt));
        }
      }
      return y;
    });
    return g.minX = 1 / 0, g.maxX = -1 / 0, g.minY = 1 / 0, g.maxY = -1 / 0, g;
  };
})(mn || (mn = {}));
var ar, $y = function() {
  function s() {
  }
  return s.prototype.round = function(t) {
    return this.transform(mn.ROUND(t));
  }, s.prototype.toAbs = function() {
    return this.transform(mn.TO_ABS());
  }, s.prototype.toRel = function() {
    return this.transform(mn.TO_REL());
  }, s.prototype.normalizeHVZ = function(t, e, i) {
    return this.transform(mn.NORMALIZE_HVZ(t, e, i));
  }, s.prototype.normalizeST = function() {
    return this.transform(mn.NORMALIZE_ST());
  }, s.prototype.qtToC = function() {
    return this.transform(mn.QT_TO_C());
  }, s.prototype.aToC = function() {
    return this.transform(mn.A_TO_C());
  }, s.prototype.sanitize = function(t) {
    return this.transform(mn.SANITIZE(t));
  }, s.prototype.translate = function(t, e) {
    return this.transform(mn.TRANSLATE(t, e));
  }, s.prototype.scale = function(t, e) {
    return this.transform(mn.SCALE(t, e));
  }, s.prototype.rotate = function(t, e, i) {
    return this.transform(mn.ROTATE(t, e, i));
  }, s.prototype.matrix = function(t, e, i, n, r, o) {
    return this.transform(mn.MATRIX(t, e, i, n, r, o));
  }, s.prototype.skewX = function(t) {
    return this.transform(mn.SKEW_X(t));
  }, s.prototype.skewY = function(t) {
    return this.transform(mn.SKEW_Y(t));
  }, s.prototype.xSymmetry = function(t) {
    return this.transform(mn.X_AXIS_SYMMETRY(t));
  }, s.prototype.ySymmetry = function(t) {
    return this.transform(mn.Y_AXIS_SYMMETRY(t));
  }, s.prototype.annotateArcs = function() {
    return this.transform(mn.ANNOTATE_ARCS());
  }, s;
}(), xI = function(s) {
  return s === " " || s === "	" || s === "\r" || s === `
`;
}, am = function(s) {
  return 48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57;
}, II = function(s) {
  function t() {
    var e = s.call(this) || this;
    return e.curNumber = "", e.curCommandType = -1, e.curCommandRelative = !1, e.canParseCommandOrComma = !0, e.curNumberHasExp = !1, e.curNumberHasExpDigits = !1, e.curNumberHasDecimal = !1, e.curArgs = [], e;
  }
  return Gy(t, s), t.prototype.finish = function(e) {
    if (e === void 0 && (e = []), this.parse(" ", e), this.curArgs.length !== 0 || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
    return e;
  }, t.prototype.parse = function(e, i) {
    var n = this;
    i === void 0 && (i = []);
    for (var r = function(g) {
      i.push(g), n.curArgs.length = 0, n.canParseCommandOrComma = !0;
    }, o = 0; o < e.length; o++) {
      var l = e[o], h = !(this.curCommandType !== Et.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), u = am(l) && (this.curNumber === "0" && l === "0" || h);
      if (!am(l) || u) if (l !== "e" && l !== "E") if (l !== "-" && l !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits) if (l !== "." || this.curNumberHasExp || this.curNumberHasDecimal || h) {
        if (this.curNumber && this.curCommandType !== -1) {
          var f = Number(this.curNumber);
          if (isNaN(f)) throw new SyntaxError("Invalid number ending at " + o);
          if (this.curCommandType === Et.ARC) {
            if (this.curArgs.length === 0 || this.curArgs.length === 1) {
              if (0 > f) throw new SyntaxError('Expected positive number, got "' + f + '" at index "' + o + '"');
            } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1") throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + o + '"');
          }
          this.curArgs.push(f), this.curArgs.length === CI[this.curCommandType] && (Et.HORIZ_LINE_TO === this.curCommandType ? r({ type: Et.HORIZ_LINE_TO, relative: this.curCommandRelative, x: f }) : Et.VERT_LINE_TO === this.curCommandType ? r({ type: Et.VERT_LINE_TO, relative: this.curCommandRelative, y: f }) : this.curCommandType === Et.MOVE_TO || this.curCommandType === Et.LINE_TO || this.curCommandType === Et.SMOOTH_QUAD_TO ? (r({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), Et.MOVE_TO === this.curCommandType && (this.curCommandType = Et.LINE_TO)) : this.curCommandType === Et.CURVE_TO ? r({ type: Et.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === Et.SMOOTH_CURVE_TO ? r({ type: Et.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Et.QUAD_TO ? r({ type: Et.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Et.ARC && r({ type: Et.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
        }
        if (!xI(l)) if (l === "," && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;
        else if (l !== "+" && l !== "-" && l !== ".") if (u) this.curNumber = l, this.curNumberHasDecimal = !1;
        else {
          if (this.curArgs.length !== 0) throw new SyntaxError("Unterminated command at index " + o + ".");
          if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + l + '" at index ' + o + ". Command cannot follow comma");
          if (this.canParseCommandOrComma = !1, l !== "z" && l !== "Z") if (l === "h" || l === "H") this.curCommandType = Et.HORIZ_LINE_TO, this.curCommandRelative = l === "h";
          else if (l === "v" || l === "V") this.curCommandType = Et.VERT_LINE_TO, this.curCommandRelative = l === "v";
          else if (l === "m" || l === "M") this.curCommandType = Et.MOVE_TO, this.curCommandRelative = l === "m";
          else if (l === "l" || l === "L") this.curCommandType = Et.LINE_TO, this.curCommandRelative = l === "l";
          else if (l === "c" || l === "C") this.curCommandType = Et.CURVE_TO, this.curCommandRelative = l === "c";
          else if (l === "s" || l === "S") this.curCommandType = Et.SMOOTH_CURVE_TO, this.curCommandRelative = l === "s";
          else if (l === "q" || l === "Q") this.curCommandType = Et.QUAD_TO, this.curCommandRelative = l === "q";
          else if (l === "t" || l === "T") this.curCommandType = Et.SMOOTH_QUAD_TO, this.curCommandRelative = l === "t";
          else {
            if (l !== "a" && l !== "A") throw new SyntaxError('Unexpected character "' + l + '" at index ' + o + ".");
            this.curCommandType = Et.ARC, this.curCommandRelative = l === "a";
          }
          else i.push({ type: Et.CLOSE_PATH }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
        }
        else this.curNumber = l, this.curNumberHasDecimal = l === ".";
      } else this.curNumber += l, this.curNumberHasDecimal = !0;
      else this.curNumber += l;
      else this.curNumber += l, this.curNumberHasExp = !0;
      else this.curNumber += l, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return i;
  }, t.prototype.transform = function(e) {
    return Object.create(this, { parse: { value: function(i, n) {
      n === void 0 && (n = []);
      for (var r = 0, o = Object.getPrototypeOf(this).parse.call(this, i); r < o.length; r++) {
        var l = o[r], h = e(l);
        Array.isArray(h) ? n.push.apply(n, h) : n.push(h);
      }
      return n;
    } } });
  }, t;
}($y), Et = function(s) {
  function t(e) {
    var i = s.call(this) || this;
    return i.commands = typeof e == "string" ? t.parse(e) : e, i;
  }
  return Gy(t, s), t.prototype.encode = function() {
    return t.encode(this.commands);
  }, t.prototype.getBounds = function() {
    var e = mn.CALCULATE_BOUNDS();
    return this.transform(e), e;
  }, t.prototype.transform = function(e) {
    for (var i = [], n = 0, r = this.commands; n < r.length; n++) {
      var o = e(r[n]);
      Array.isArray(o) ? i.push.apply(i, o) : i.push(o);
    }
    return this.commands = i, this;
  }, t.encode = function(e) {
    return bI(e);
  }, t.parse = function(e) {
    var i = new II(), n = [];
    return i.parse(e, n), i.finish(n), n;
  }, t.CLOSE_PATH = 1, t.MOVE_TO = 2, t.HORIZ_LINE_TO = 4, t.VERT_LINE_TO = 8, t.LINE_TO = 16, t.CURVE_TO = 32, t.SMOOTH_CURVE_TO = 64, t.QUAD_TO = 128, t.SMOOTH_QUAD_TO = 256, t.ARC = 512, t.LINE_COMMANDS = t.LINE_TO | t.HORIZ_LINE_TO | t.VERT_LINE_TO, t.DRAWING_COMMANDS = t.HORIZ_LINE_TO | t.VERT_LINE_TO | t.LINE_TO | t.CURVE_TO | t.SMOOTH_CURVE_TO | t.QUAD_TO | t.SMOOTH_QUAD_TO | t.ARC, t;
}($y), CI = ((ar = {})[Et.MOVE_TO] = 2, ar[Et.LINE_TO] = 2, ar[Et.HORIZ_LINE_TO] = 1, ar[Et.VERT_LINE_TO] = 1, ar[Et.CLOSE_PATH] = 0, ar[Et.QUAD_TO] = 4, ar[Et.SMOOTH_QUAD_TO] = 2, ar[Et.CURVE_TO] = 6, ar[Et.SMOOTH_CURVE_TO] = 4, ar[Et.ARC] = 7, ar);
function Du(s) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Du = function(t) {
    return typeof t;
  } : Du = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Du(s);
}
function SI(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
var MI = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], PI = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function kI(s, t, e, i, n) {
  if (typeof s == "string" && (s = document.getElementById(s)), !s || Du(s) !== "object" || !("getContext" in s))
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var r = s.getContext("2d");
  try {
    return r.getImageData(t, e, i, n);
  } catch (o) {
    throw new Error("unable to access image data: " + o);
  }
}
function EI(s, t, e, i, n, r) {
  if (!(isNaN(r) || r < 1)) {
    r |= 0;
    var o = kI(s, t, e, i, n);
    o = AI(o, t, e, i, n, r), s.getContext("2d").putImageData(o, t, e);
  }
}
function AI(s, t, e, i, n, r) {
  for (var o = s.data, l = 2 * r + 1, h = i - 1, u = n - 1, f = r + 1, g = f * (f + 1) / 2, y = new lm(), _ = y, x, b = 1; b < l; b++)
    _ = _.next = new lm(), b === f && (x = _);
  _.next = y;
  for (var I = null, C = null, M = 0, P = 0, O = MI[r], B = PI[r], j = 0; j < n; j++) {
    _ = y;
    for (var F = o[P], K = o[P + 1], J = o[P + 2], rt = o[P + 3], ft = 0; ft < f; ft++)
      _.r = F, _.g = K, _.b = J, _.a = rt, _ = _.next;
    for (var H = 0, $ = 0, D = 0, R = 0, U = f * F, it = f * K, at = f * J, mt = f * rt, Nt = g * F, lt = g * K, ot = g * J, Ht = g * rt, St = 1; St < f; St++) {
      var Rt = P + ((h < St ? h : St) << 2), ei = o[Rt], ai = o[Rt + 1], re = o[Rt + 2], Se = o[Rt + 3], Be = f - St;
      Nt += (_.r = ei) * Be, lt += (_.g = ai) * Be, ot += (_.b = re) * Be, Ht += (_.a = Se) * Be, H += ei, $ += ai, D += re, R += Se, _ = _.next;
    }
    I = y, C = x;
    for (var pe = 0; pe < i; pe++) {
      var ki = Ht * O >>> B;
      if (o[P + 3] = ki, ki !== 0) {
        var ii = 255 / ki;
        o[P] = (Nt * O >>> B) * ii, o[P + 1] = (lt * O >>> B) * ii, o[P + 2] = (ot * O >>> B) * ii;
      } else
        o[P] = o[P + 1] = o[P + 2] = 0;
      Nt -= U, lt -= it, ot -= at, Ht -= mt, U -= I.r, it -= I.g, at -= I.b, mt -= I.a;
      var T = pe + r + 1;
      T = M + (T < h ? T : h) << 2, H += I.r = o[T], $ += I.g = o[T + 1], D += I.b = o[T + 2], R += I.a = o[T + 3], Nt += H, lt += $, ot += D, Ht += R, I = I.next;
      var vt = C, pt = vt.r, q = vt.g, W = vt.b, st = vt.a;
      U += pt, it += q, at += W, mt += st, H -= pt, $ -= q, D -= W, R -= st, C = C.next, P += 4;
    }
    M += i;
  }
  for (var xt = 0; xt < i; xt++) {
    P = xt << 2;
    var It = o[P], nt = o[P + 1], kt = o[P + 2], Lt = o[P + 3], Tt = f * It, Yt = f * nt, Ve = f * kt, xe = f * Lt, Ri = g * It, Fn = g * nt, cn = g * kt, ns = g * Lt;
    _ = y;
    for (var di = 0; di < f; di++)
      _.r = It, _.g = nt, _.b = kt, _.a = Lt, _ = _.next;
    for (var Vs = i, zs = 0, te = 0, Ki = 0, vn = 0, qn = 1; qn <= r; qn++) {
      P = Vs + xt << 2;
      var Bn = f - qn;
      Ri += (_.r = It = o[P]) * Bn, Fn += (_.g = nt = o[P + 1]) * Bn, cn += (_.b = kt = o[P + 2]) * Bn, ns += (_.a = Lt = o[P + 3]) * Bn, vn += It, zs += nt, te += kt, Ki += Lt, _ = _.next, qn < u && (Vs += i);
    }
    P = xt, I = y, C = x;
    for (var kn = 0; kn < n; kn++) {
      var Je = P << 2;
      o[Je + 3] = Lt = ns * O >>> B, Lt > 0 ? (Lt = 255 / Lt, o[Je] = (Ri * O >>> B) * Lt, o[Je + 1] = (Fn * O >>> B) * Lt, o[Je + 2] = (cn * O >>> B) * Lt) : o[Je] = o[Je + 1] = o[Je + 2] = 0, Ri -= Tt, Fn -= Yt, cn -= Ve, ns -= xe, Tt -= I.r, Yt -= I.g, Ve -= I.b, xe -= I.a, Je = xt + ((Je = kn + f) < u ? Je : u) * i << 2, Ri += vn += I.r = o[Je], Fn += zs += I.g = o[Je + 1], cn += te += I.b = o[Je + 2], ns += Ki += I.a = o[Je + 3], I = I.next, Tt += It = C.r, Yt += nt = C.g, Ve += kt = C.b, xe += Lt = C.a, vn -= It, zs -= nt, te -= kt, Ki -= Lt, C = C.next, P += i;
    }
  }
  return s;
}
var lm = (
  /**
   * Set properties.
   */
  function s() {
    SI(this, s), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
function Dl(s) {
  return s.replace(/(?!\u3000)\s+/gm, " ");
}
function TI(s) {
  return s.replace(/^[\n \t]+/, "");
}
function DI(s) {
  return s.replace(/[\n \t]+$/, "");
}
function Fs(s) {
  const t = s.match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm);
  return t ? t.map(parseFloat) : [];
}
function NI(s) {
  const t = Fs(s);
  return [
    t[0] || 0,
    t[1] || 0,
    t[2] || 0,
    t[3] || 0,
    t[4] || 0,
    t[5] || 0
  ];
}
const OI = /^[A-Z-]+$/;
function RI(s) {
  return OI.test(s) ? s.toLowerCase() : s;
}
function qy(s) {
  const t = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(s);
  return t && (t[2] || t[3] || t[4]) || "";
}
function LI(s) {
  if (!s.startsWith("rgb"))
    return s;
  let t = 3;
  return s.replace(
    /\d+(\.\d+)?/g,
    (i, n) => t-- && n ? String(Math.round(parseFloat(i))) : i
  );
}
const FI = /(\[[^\]]+\])/g, BI = /(#[^\s+>~.[:]+)/g, VI = /(\.[^\s+>~.[:]+)/g, zI = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi, HI = /(:[\w-]+\([^)]*\))/gi, UI = /(:[^\s+>~.[:]+)/g, jI = /([^\s+>~.[:]+)/g;
function ra(s, t) {
  const e = t.exec(s);
  return e ? [
    s.replace(t, " "),
    e.length
  ] : [
    s,
    0
  ];
}
function WI(s) {
  const t = [
    0,
    0,
    0
  ];
  let e = s.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " "), i = 0;
  return [e, i] = ra(e, FI), t[1] += i, [e, i] = ra(e, BI), t[0] += i, [e, i] = ra(e, VI), t[1] += i, [e, i] = ra(e, zI), t[2] += i, [e, i] = ra(e, HI), t[1] += i, [e, i] = ra(e, UI), t[1] += i, e = e.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " "), [e, i] = ra(e, jI), t[2] += i, t.join("");
}
const dl = 1e-8;
function cm(s) {
  return Math.sqrt(Math.pow(s[0], 2) + Math.pow(s[1], 2));
}
function Yf(s, t) {
  return (s[0] * t[0] + s[1] * t[1]) / (cm(s) * cm(t));
}
function hm(s, t) {
  return (s[0] * t[1] < s[1] * t[0] ? -1 : 1) * Math.acos(Yf(s, t));
}
function um(s) {
  return s * s * s;
}
function dm(s) {
  return 3 * s * s * (1 - s);
}
function fm(s) {
  return 3 * s * (1 - s) * (1 - s);
}
function gm(s) {
  return (1 - s) * (1 - s) * (1 - s);
}
function pm(s) {
  return s * s;
}
function mm(s) {
  return 2 * s * (1 - s);
}
function _m(s) {
  return (1 - s) * (1 - s);
}
class se {
  static empty(t) {
    return new se(t, "EMPTY", "");
  }
  split() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
    const { document: e, name: i } = this;
    return Dl(this.getString()).trim().split(t).map(
      (n) => new se(e, i, n)
    );
  }
  hasValue(t) {
    const e = this.value;
    return e !== null && e !== "" && (t || e !== 0) && typeof e < "u";
  }
  isString(t) {
    const { value: e } = this, i = typeof e == "string";
    return !i || !t ? i : t.test(e);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue())
      return !1;
    const t = this.getString();
    switch (!0) {
      case t.endsWith("px"):
      case /^[0-9]+$/.test(t):
        return !0;
      default:
        return !1;
    }
  }
  setValue(t) {
    return this.value = t, this;
  }
  getValue(t) {
    return typeof t > "u" || this.hasValue() ? this.value : t;
  }
  getNumber(t) {
    if (!this.hasValue())
      return typeof t > "u" ? 0 : parseFloat(t);
    const { value: e } = this;
    let i = parseFloat(e);
    return this.isString(/%$/) && (i /= 100), i;
  }
  getString(t) {
    return typeof t > "u" || this.hasValue() ? typeof this.value > "u" ? "" : String(this.value) : String(t);
  }
  getColor(t) {
    let e = this.getString(t);
    return this.isNormalizedColor || (this.isNormalizedColor = !0, e = LI(e), this.value = e), e;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!this.hasValue())
      return 0;
    const [i, n] = typeof t == "boolean" ? [
      void 0,
      t
    ] : [
      t
    ], { viewPort: r } = this.document.screen;
    switch (!0) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * r.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * r.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && n):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * r.computeSize(i);
      default: {
        const o = this.getNumber();
        return e && o < 1 ? o * r.computeSize(i) : o;
      }
    }
  }
  getMilliseconds() {
    return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;
  }
  getRadians() {
    if (!this.hasValue())
      return 0;
    switch (!0) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    const t = this.getString(), e = /#([^)'"]+)/.exec(t), i = (e == null ? void 0 : e[1]) || t;
    return this.document.definitions[i];
  }
  getFillStyleDefinition(t, e) {
    let i = this.getDefinition();
    if (!i)
      return null;
    if (typeof i.createGradient == "function" && "getBoundingBox" in t)
      return i.createGradient(this.document.ctx, t, e);
    if (typeof i.createPattern == "function") {
      if (i.getHrefAttribute().hasValue()) {
        const n = i.getAttribute("patternTransform");
        i = i.getHrefAttribute().getDefinition(), i && n.hasValue() && i.getAttribute("patternTransform", !0).setValue(n.value);
      }
      if (i)
        return i.createPattern(this.document.ctx, t, e);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue())
      return null;
    const t = this.getString();
    return se.textBaselineMapping[t] || null;
  }
  addOpacity(t) {
    let e = this.getColor();
    const i = e.length;
    let n = 0;
    for (let r = 0; r < i && (e[r] === "," && n++, n !== 3); r++)
      ;
    if (t.hasValue() && this.isString() && n !== 3) {
      const r = new Xf(e);
      r.ok && (r.alpha = t.getNumber(), e = r.toRGBA());
    }
    return new se(this.document, this.name, e);
  }
  constructor(t, e, i) {
    this.document = t, this.name = e, this.value = i, this.isNormalizedColor = !1;
  }
}
se.textBaselineMapping = {
  baseline: "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  middle: "middle",
  central: "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  ideographic: "ideographic",
  alphabetic: "alphabetic",
  hanging: "hanging",
  mathematical: "alphabetic"
};
class uh {
  clear() {
    this.viewPorts = [];
  }
  setCurrent(t, e) {
    this.viewPorts.push({
      width: t,
      height: e
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getRoot() {
    const [t] = this.viewPorts;
    return t || ym();
  }
  getCurrent() {
    const { viewPorts: t } = this, e = t[t.length - 1];
    return e || ym();
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(t) {
    return typeof t == "number" ? t : t === "x" ? this.width : t === "y" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
  constructor() {
    this.viewPorts = [];
  }
}
uh.DEFAULT_VIEWPORT_WIDTH = 800;
uh.DEFAULT_VIEWPORT_HEIGHT = 600;
function ym() {
  return {
    width: uh.DEFAULT_VIEWPORT_WIDTH,
    height: uh.DEFAULT_VIEWPORT_HEIGHT
  };
}
class Ui {
  static parse(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const [i = e, n = e] = Fs(t);
    return new Ui(i, n);
  }
  static parseScale(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const [i = e, n = i] = Fs(t);
    return new Ui(i, n);
  }
  static parsePath(t) {
    const e = Fs(t), i = e.length, n = [];
    for (let r = 0; r < i; r += 2)
      n.push(new Ui(e[r], e[r + 1]));
    return n;
  }
  angleTo(t) {
    return Math.atan2(t.y - this.y, t.x - this.x);
  }
  applyTransform(t) {
    const { x: e, y: i } = this, n = e * t[0] + i * t[2] + t[4], r = e * t[1] + i * t[3] + t[5];
    this.x = n, this.y = r;
  }
  constructor(t, e) {
    this.x = t, this.y = e;
  }
}
class GI {
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working)
      return;
    const { screen: t, onClick: e, onMouseMove: i } = this, n = t.ctx.canvas;
    n.onclick = e, n.onmousemove = i, this.working = !0;
  }
  stop() {
    if (!this.working)
      return;
    const t = this.screen.ctx.canvas;
    this.working = !1, t.onclick = null, t.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working)
      return;
    const { screen: t, events: e, eventElements: i } = this, { style: n } = t.ctx.canvas;
    let r;
    n && (n.cursor = ""), e.forEach((o, l) => {
      let { run: h } = o;
      for (r = i[l]; r; )
        h(r), r = r.parent;
    }), this.events = [], this.eventElements = [];
  }
  checkPath(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: n } = this;
    i.forEach((r, o) => {
      let { x: l, y: h } = r;
      !n[o] && e.isPointInPath && e.isPointInPath(l, h) && (n[o] = t);
    });
  }
  checkBoundingBox(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: n } = this;
    i.forEach((r, o) => {
      let { x: l, y: h } = r;
      !n[o] && e.isPointInBox(l, h) && (n[o] = t);
    });
  }
  mapXY(t, e) {
    const { window: i, ctx: n } = this.screen, r = new Ui(t, e);
    let o = n.canvas;
    for (; o; )
      r.x -= o.offsetLeft, r.y -= o.offsetTop, o = o.offsetParent;
    return i != null && i.scrollX && (r.x += i.scrollX), i != null && i.scrollY && (r.y += i.scrollY), r;
  }
  onClick(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onclick",
      x: e,
      y: i,
      run(n) {
        n.onClick && n.onClick();
      }
    });
  }
  onMouseMove(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onmousemove",
      x: e,
      y: i,
      run(n) {
        n.onMouseMove && n.onMouseMove();
      }
    });
  }
  constructor(t) {
    this.screen = t, this.working = !1, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);
  }
}
const Ky = typeof window < "u" ? window : null, Xy = typeof fetch < "u" ? fetch.bind(void 0) : void 0;
class po {
  wait(t) {
    this.waits.push(t);
  }
  ready() {
    return this.readyPromise ? this.readyPromise : Promise.resolve();
  }
  isReady() {
    if (this.isReadyLock)
      return !0;
    const t = this.waits.every(
      (e) => e()
    );
    return t && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = t, t;
  }
  setDefaults(t) {
    t.strokeStyle = "rgba(0,0,0,0)", t.lineCap = "butt", t.lineJoin = "miter", t.miterLimit = 4;
  }
  setViewBox(t) {
    let { document: e, ctx: i, aspectRatio: n, width: r, desiredWidth: o, height: l, desiredHeight: h, minX: u = 0, minY: f = 0, refX: g, refY: y, clip: _ = !1, clipX: x = 0, clipY: b = 0 } = t;
    const I = Dl(n).replace(/^defer\s/, ""), [C, M] = I.split(" "), P = C || "xMidYMid", O = M || "meet", B = r / o, j = l / h, F = Math.min(B, j), K = Math.max(B, j);
    let J = o, rt = h;
    O === "meet" && (J *= F, rt *= F), O === "slice" && (J *= K, rt *= K);
    const ft = new se(e, "refX", g), H = new se(e, "refY", y), $ = ft.hasValue() && H.hasValue();
    if ($ && i.translate(-F * ft.getPixels("x"), -F * H.getPixels("y")), _) {
      const D = F * x, R = F * b;
      i.beginPath(), i.moveTo(D, R), i.lineTo(r, R), i.lineTo(r, l), i.lineTo(D, l), i.closePath(), i.clip();
    }
    if (!$) {
      const D = O === "meet" && F === j, R = O === "slice" && K === j, U = O === "meet" && F === B, it = O === "slice" && K === B;
      P.startsWith("xMid") && (D || R) && i.translate(r / 2 - J / 2, 0), P.endsWith("YMid") && (U || it) && i.translate(0, l / 2 - rt / 2), P.startsWith("xMax") && (D || R) && i.translate(r - J, 0), P.endsWith("YMax") && (U || it) && i.translate(0, l - rt);
    }
    switch (!0) {
      case P === "none":
        i.scale(B, j);
        break;
      case O === "meet":
        i.scale(F, F);
        break;
      case O === "slice":
        i.scale(K, K);
        break;
    }
    i.translate(-u, -f);
  }
  start(t) {
    let { enableRedraw: e = !1, ignoreMouse: i = !1, ignoreAnimation: n = !1, ignoreDimensions: r = !1, ignoreClear: o = !1, forceRedraw: l, scaleWidth: h, scaleHeight: u, offsetX: f, offsetY: g } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { mouse: y } = this, _ = 1e3 / po.FRAMERATE;
    if (this.isReadyLock = !1, this.frameDuration = _, this.readyPromise = new Promise((M) => {
      this.resolveReady = M;
    }), this.isReady() && this.render(t, r, o, h, u, f, g), !e)
      return;
    let x = Date.now(), b = x, I = 0;
    const C = () => {
      x = Date.now(), I = x - b, I >= _ && (b = x - I % _, this.shouldUpdate(n, l) && (this.render(t, r, o, h, u, f, g), y.runEvents())), this.intervalId = hf(C);
    };
    i || y.start(), this.intervalId = hf(C);
  }
  stop() {
    this.intervalId && (hf.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();
  }
  shouldUpdate(t, e) {
    if (!t) {
      const { frameDuration: i } = this;
      if (this.animations.reduce(
        (r, o) => o.update(i) || r,
        !1
      ))
        return !0;
    }
    return !!(typeof e == "function" && e() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());
  }
  render(t, e, i, n, r, o, l) {
    const { viewPort: h, ctx: u, isFirstRender: f } = this, g = u.canvas;
    h.clear(), g.width && g.height && h.setCurrent(g.width, g.height);
    const y = t.getStyle("width"), _ = t.getStyle("height");
    !e && (f || typeof n != "number" && typeof r != "number") && (y.hasValue() && (g.width = y.getPixels("x"), g.style && (g.style.width = "".concat(g.width, "px"))), _.hasValue() && (g.height = _.getPixels("y"), g.style && (g.style.height = "".concat(g.height, "px"))));
    let x = g.clientWidth || g.width, b = g.clientHeight || g.height;
    if (e && y.hasValue() && _.hasValue() && (x = y.getPixels("x"), b = _.getPixels("y")), h.setCurrent(x, b), typeof o == "number" && t.getAttribute("x", !0).setValue(o), typeof l == "number" && t.getAttribute("y", !0).setValue(l), typeof n == "number" || typeof r == "number") {
      const I = Fs(t.getAttribute("viewBox").getString());
      let C = 0, M = 0;
      if (typeof n == "number") {
        const O = t.getStyle("width");
        O.hasValue() ? C = O.getPixels("x") / n : I[2] && !isNaN(I[2]) && (C = I[2] / n);
      }
      if (typeof r == "number") {
        const O = t.getStyle("height");
        O.hasValue() ? M = O.getPixels("y") / r : I[3] && !isNaN(I[3]) && (M = I[3] / r);
      }
      C || (C = M), M || (M = C), t.getAttribute("width", !0).setValue(n), t.getAttribute("height", !0).setValue(r);
      const P = t.getStyle("transform", !0, !0);
      P.setValue("".concat(P.getString(), " scale(").concat(1 / C, ", ").concat(1 / M, ")"));
    }
    i || u.clearRect(0, 0, x, b), t.render(u), f && (this.isFirstRender = !1);
  }
  constructor(t, { fetch: e = Xy, window: i = Ky } = {}) {
    if (this.ctx = t, this.viewPort = new uh(), this.mouse = new GI(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = !1, this.isFirstRender = !0, this.intervalId = null, this.window = i, !e)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    this.fetch = e;
  }
}
po.defaultWindow = Ky;
po.defaultFetch = Xy;
po.FRAMERATE = 30;
po.MAX_VIRTUAL_PIXELS = 3e4;
const { defaultFetch: $I } = po, qI = typeof DOMParser < "u" ? DOMParser : void 0;
class ff {
  async parse(t) {
    return t.startsWith("<") ? this.parseFromString(t) : this.load(t);
  }
  parseFromString(t) {
    const e = new this.DOMParser();
    try {
      return this.checkDocument(e.parseFromString(t, "image/svg+xml"));
    } catch {
      return this.checkDocument(e.parseFromString(t, "text/xml"));
    }
  }
  checkDocument(t) {
    const e = t.getElementsByTagName("parsererror")[0];
    if (e)
      throw new Error(e.textContent || "Unknown parse error");
    return t;
  }
  async load(t) {
    const i = await (await this.fetch(t)).text();
    return this.parseFromString(i);
  }
  constructor({ fetch: t = $I, DOMParser: e = qI } = {}) {
    if (!t)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    if (!e)
      throw new Error("Can't find 'DOMParser' in 'globalThis', please provide it via options");
    this.fetch = t, this.DOMParser = e;
  }
}
class KI {
  apply(t) {
    const { x: e, y: i } = this.point;
    t.translate(e || 0, i || 0);
  }
  unapply(t) {
    const { x: e, y: i } = this.point;
    t.translate(-1 * e || 0, -1 * i || 0);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.point;
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
    ]);
  }
  constructor(t, e) {
    this.type = "translate", this.point = Ui.parse(e);
  }
}
class XI {
  apply(t) {
    const { cx: e, cy: i, originX: n, originY: r, angle: o } = this, l = e + n.getPixels("x"), h = i + r.getPixels("y");
    t.translate(l, h), t.rotate(o.getRadians()), t.translate(-l, -h);
  }
  unapply(t) {
    const { cx: e, cy: i, originX: n, originY: r, angle: o } = this, l = e + n.getPixels("x"), h = i + r.getPixels("y");
    t.translate(l, h), t.rotate(-1 * o.getRadians()), t.translate(-l, -h);
  }
  applyToPoint(t) {
    const { cx: e, cy: i, angle: n } = this, r = n.getRadians();
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
      // this.p.y
    ]), t.applyTransform([
      Math.cos(r),
      Math.sin(r),
      -Math.sin(r),
      Math.cos(r),
      0,
      0
    ]), t.applyTransform([
      1,
      0,
      0,
      1,
      -e || 0,
      -i || 0
      // -this.p.y
    ]);
  }
  constructor(t, e, i) {
    this.type = "rotate";
    const n = Fs(e);
    this.angle = new se(t, "angle", n[0]), this.originX = i[0], this.originY = i[1], this.cx = n[1] || 0, this.cy = n[2] || 0;
  }
}
class JI {
  apply(t) {
    const { scale: { x: e, y: i }, originX: n, originY: r } = this, o = n.getPixels("x"), l = r.getPixels("y");
    t.translate(o, l), t.scale(e, i || e), t.translate(-o, -l);
  }
  unapply(t) {
    const { scale: { x: e, y: i }, originX: n, originY: r } = this, o = n.getPixels("x"), l = r.getPixels("y");
    t.translate(o, l), t.scale(1 / e, 1 / i || e), t.translate(-o, -l);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.scale;
    t.applyTransform([
      e || 0,
      0,
      0,
      i || 0,
      0,
      0
    ]);
  }
  constructor(t, e, i) {
    this.type = "scale";
    const n = Ui.parseScale(e);
    (n.x === 0 || n.y === 0) && (n.x = dl, n.y = dl), this.scale = n, this.originX = i[0], this.originY = i[1];
  }
}
class Jy {
  apply(t) {
    const { originX: e, originY: i, matrix: n } = this, r = e.getPixels("x"), o = i.getPixels("y");
    t.translate(r, o), t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), t.translate(-r, -o);
  }
  unapply(t) {
    const { originX: e, originY: i, matrix: n } = this, r = n[0], o = n[2], l = n[4], h = n[1], u = n[3], f = n[5], g = 0, y = 0, _ = 1, x = 1 / (r * (u * _ - f * y) - o * (h * _ - f * g) + l * (h * y - u * g)), b = e.getPixels("x"), I = i.getPixels("y");
    t.translate(b, I), t.transform(x * (u * _ - f * y), x * (f * g - h * _), x * (l * y - o * _), x * (r * _ - l * g), x * (o * f - l * u), x * (l * h - r * f)), t.translate(-b, -I);
  }
  applyToPoint(t) {
    t.applyTransform(this.matrix);
  }
  constructor(t, e, i) {
    this.type = "matrix", this.matrix = NI(e), this.originX = i[0], this.originY = i[1];
  }
}
class Yy extends Jy {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skew", this.angle = new se(t, "angle", e);
  }
}
class YI extends Yy {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewX", this.matrix = [
      1,
      0,
      Math.tan(this.angle.getRadians()),
      1,
      0,
      0
    ];
  }
}
class ZI extends Yy {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewY", this.matrix = [
      1,
      Math.tan(this.angle.getRadians()),
      0,
      1,
      0,
      0
    ];
  }
}
function QI(s) {
  return Dl(s).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function tC(s) {
  const [t = "", e = ""] = s.split("(");
  return [
    t.trim(),
    e.trim().replace(")", "")
  ];
}
class Oa {
  static fromElement(t, e) {
    const i = e.getStyle("transform", !1, !0);
    if (i.hasValue()) {
      const [n, r = n] = e.getStyle("transform-origin", !1, !0).split();
      if (n && r) {
        const o = [
          n,
          r
        ];
        return new Oa(t, i.getString(), o);
      }
    }
    return null;
  }
  apply(t) {
    this.transforms.forEach(
      (e) => e.apply(t)
    );
  }
  unapply(t) {
    this.transforms.forEach(
      (e) => e.unapply(t)
    );
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(t) {
    this.transforms.forEach(
      (e) => e.applyToPoint(t)
    );
  }
  constructor(t, e, i) {
    this.document = t, this.transforms = [], QI(e).forEach((r) => {
      if (r === "none")
        return;
      const [o, l] = tC(r), h = Oa.transformTypes[o];
      h && this.transforms.push(new h(this.document, l, i));
    });
  }
}
Oa.transformTypes = {
  translate: KI,
  rotate: XI,
  scale: JI,
  matrix: Jy,
  skewX: YI,
  skewY: ZI
};
let sn = class Zf {
  getAttribute(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const i = this.attributes[t];
    if (!i && e) {
      const n = new se(this.document, t, "");
      return this.attributes[t] = n, n;
    }
    return i || se.empty(this.document);
  }
  getHrefAttribute() {
    let t;
    for (const e in this.attributes)
      if (e === "href" || e.endsWith(":href")) {
        t = this.attributes[e];
        break;
      }
    return t || se.empty(this.document);
  }
  getStyle(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const n = this.styles[t];
    if (n)
      return n;
    const r = this.getAttribute(t);
    if (r.hasValue())
      return this.styles[t] = r, r;
    if (!i) {
      const { parent: o } = this;
      if (o) {
        const l = o.getStyle(t);
        if (l.hasValue())
          return l;
      }
    }
    if (e) {
      const o = new se(this.document, t, "");
      return this.styles[t] = o, o;
    }
    return se.empty(this.document);
  }
  render(t) {
    if (!(this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden")) {
      if (t.save(), this.getStyle("mask").hasValue()) {
        const e = this.getStyle("mask").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        const e = this.getStyle("filter").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else
        this.setContext(t), this.renderChildren(t), this.clearContext(t);
      t.restore();
    }
  }
  setContext(t) {
  }
  applyEffects(t) {
    const e = Oa.fromElement(this.document, this);
    e && e.apply(t);
    const i = this.getStyle("clip-path", !1, !0);
    if (i.hasValue()) {
      const n = i.getDefinition();
      n && n.apply(t);
    }
  }
  clearContext(t) {
  }
  renderChildren(t) {
    this.children.forEach((e) => {
      e.render(t);
    });
  }
  addChild(t) {
    const e = t instanceof Zf ? t : this.document.createElement(t);
    e.parent = this, Zf.ignoreChildTypes.includes(e.type) || this.children.push(e);
  }
  matchesSelector(t) {
    var e;
    const { node: i } = this;
    if (typeof i.matches == "function")
      return i.matches(t);
    const n = (e = i.getAttribute) === null || e === void 0 ? void 0 : e.call(i, "class");
    return !n || n === "" ? !1 : n.split(" ").some(
      (r) => ".".concat(r) === t
    );
  }
  addStylesFromStyleDefinition() {
    const { styles: t, stylesSpecificity: e } = this.document;
    let i;
    for (const n in t)
      if (!n.startsWith("@") && this.matchesSelector(n)) {
        const r = t[n], o = e[n];
        if (r)
          for (const l in r) {
            let h = this.stylesSpecificity[l];
            typeof h > "u" && (h = "000"), o && o >= h && (i = r[l], i && (this.styles[l] = i), this.stylesSpecificity[l] = o);
          }
      }
  }
  removeStyles(t, e) {
    return e.reduce((n, r) => {
      const o = t.getStyle(r);
      if (!o.hasValue())
        return n;
      const l = o.getString();
      return o.setValue(""), [
        ...n,
        [
          r,
          l
        ]
      ];
    }, []);
  }
  restoreStyles(t, e) {
    e.forEach((i) => {
      let [n, r] = i;
      t.getStyle(n, !0).setValue(r);
    });
  }
  isFirstChild() {
    var t;
    return ((t = this.parent) === null || t === void 0 ? void 0 : t.children.indexOf(this)) === 0;
  }
  constructor(t, e, i = !1) {
    if (this.document = t, this.node = e, this.captureTextNodes = i, this.type = "", this.attributes = {}, this.styles = {}, this.stylesSpecificity = {}, this.animationFrozen = !1, this.animationFrozenValue = "", this.parent = null, this.children = [], !e || e.nodeType !== 1)
      return;
    Array.from(e.attributes).forEach((o) => {
      const l = RI(o.nodeName);
      this.attributes[l] = new se(t, l, o.value);
    }), this.addStylesFromStyleDefinition(), this.getAttribute("style").hasValue() && this.getAttribute("style").getString().split(";").map(
      (l) => l.trim()
    ).forEach((l) => {
      if (!l)
        return;
      const [h, u] = l.split(":").map(
        (f) => f.trim()
      );
      h && (this.styles[h] = new se(t, h, u));
    });
    const { definitions: n } = t, r = this.getAttribute("id");
    r.hasValue() && (n[r.getString()] || (n[r.getString()] = this)), Array.from(e.childNodes).forEach((o) => {
      if (o.nodeType === 1)
        this.addChild(o);
      else if (i && (o.nodeType === 3 || o.nodeType === 4)) {
        const l = t.createTextNode(o);
        l.getText().length > 0 && this.addChild(l);
      }
    });
  }
};
sn.ignoreChildTypes = [
  "title"
];
class eC extends sn {
  constructor(t, e, i) {
    super(t, e, i);
  }
}
function iC(s) {
  const t = s.trim();
  return /^('|")/.test(t) ? t : '"'.concat(t, '"');
}
function nC(s) {
  return typeof process > "u" ? s : s.trim().split(",").map(iC).join(",");
}
function sC(s) {
  if (!s)
    return "";
  const t = s.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^oblique\s+(-|)\d+deg$/.test(t) ? t : "";
  }
}
function rC(s) {
  if (!s)
    return "";
  const t = s.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^[\d.]+$/.test(t) ? t : "";
  }
}
class hs {
  static parse() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0, i = "", n = "", r = "", o = "", l = "";
    const h = Dl(t).trim().split(" "), u = {
      fontSize: !1,
      fontStyle: !1,
      fontWeight: !1,
      fontVariant: !1
    };
    return h.forEach((f) => {
      switch (!0) {
        case (!u.fontStyle && hs.styles.includes(f)):
          f !== "inherit" && (i = f), u.fontStyle = !0;
          break;
        case (!u.fontVariant && hs.variants.includes(f)):
          f !== "inherit" && (n = f), u.fontStyle = !0, u.fontVariant = !0;
          break;
        case (!u.fontWeight && hs.weights.includes(f)):
          f !== "inherit" && (r = f), u.fontStyle = !0, u.fontVariant = !0, u.fontWeight = !0;
          break;
        case !u.fontSize:
          f !== "inherit" && (o = f.split("/")[0] || ""), u.fontStyle = !0, u.fontVariant = !0, u.fontWeight = !0, u.fontSize = !0;
          break;
        default:
          f !== "inherit" && (l += f);
      }
    }), new hs(i, n, r, o, l, e);
  }
  toString() {
    return [
      sC(this.fontStyle),
      this.fontVariant,
      rC(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      nC(this.fontFamily)
    ].join(" ").trim();
  }
  constructor(t, e, i, n, r, o) {
    const l = o ? typeof o == "string" ? hs.parse(o) : o : {};
    this.fontFamily = r || l.fontFamily, this.fontSize = n || l.fontSize, this.fontStyle = t || l.fontStyle, this.fontWeight = i || l.fontWeight, this.fontVariant = e || l.fontVariant;
  }
}
hs.styles = "normal|italic|oblique|inherit";
hs.variants = "normal|small-caps|inherit";
hs.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class br {
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(t, e) {
    typeof t < "u" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = t, this.x2 = t), t < this.x1 && (this.x1 = t), t > this.x2 && (this.x2 = t)), typeof e < "u" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = e, this.y2 = e), e < this.y1 && (this.y1 = e), e > this.y2 && (this.y2 = e));
  }
  addX(t) {
    this.addPoint(t, 0);
  }
  addY(t) {
    this.addPoint(0, t);
  }
  addBoundingBox(t) {
    if (!t)
      return;
    const { x1: e, y1: i, x2: n, y2: r } = t;
    this.addPoint(e, i), this.addPoint(n, r);
  }
  sumCubic(t, e, i, n, r) {
    return Math.pow(1 - t, 3) * e + 3 * Math.pow(1 - t, 2) * t * i + 3 * (1 - t) * Math.pow(t, 2) * n + Math.pow(t, 3) * r;
  }
  bezierCurveAdd(t, e, i, n, r) {
    const o = 6 * e - 12 * i + 6 * n, l = -3 * e + 9 * i - 9 * n + 3 * r, h = 3 * i - 3 * e;
    if (l === 0) {
      if (o === 0)
        return;
      const y = -h / o;
      0 < y && y < 1 && (t ? this.addX(this.sumCubic(y, e, i, n, r)) : this.addY(this.sumCubic(y, e, i, n, r)));
      return;
    }
    const u = Math.pow(o, 2) - 4 * h * l;
    if (u < 0)
      return;
    const f = (-o + Math.sqrt(u)) / (2 * l);
    0 < f && f < 1 && (t ? this.addX(this.sumCubic(f, e, i, n, r)) : this.addY(this.sumCubic(f, e, i, n, r)));
    const g = (-o - Math.sqrt(u)) / (2 * l);
    0 < g && g < 1 && (t ? this.addX(this.sumCubic(g, e, i, n, r)) : this.addY(this.sumCubic(g, e, i, n, r)));
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(t, e, i, n, r, o, l, h) {
    this.addPoint(t, e), this.addPoint(l, h), this.bezierCurveAdd(!0, t, i, r, l), this.bezierCurveAdd(!1, e, n, o, h);
  }
  addQuadraticCurve(t, e, i, n, r, o) {
    const l = t + 0.6666666666666666 * (i - t), h = e + 2 / 3 * (n - e), u = l + 1 / 3 * (r - t), f = h + 1 / 3 * (o - e);
    this.addBezierCurve(t, e, l, u, h, f, r, o);
  }
  isPointInBox(t, e) {
    const { x1: i, y1: n, x2: r, y2: o } = this;
    return i <= t && t <= r && n <= e && e <= o;
  }
  constructor(t = Number.NaN, e = Number.NaN, i = Number.NaN, n = Number.NaN) {
    this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.addPoint(t, e), this.addPoint(i, n);
  }
}
class Fa extends sn {
  calculateOpacity() {
    let t = 1, e = this;
    for (; e; ) {
      const i = e.getStyle("opacity", !1, !0);
      i.hasValue(!0) && (t *= i.getNumber()), e = e.parent;
    }
    return t;
  }
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!e) {
      const i = this.getStyle("fill"), n = this.getStyle("fill-opacity"), r = this.getStyle("stroke"), o = this.getStyle("stroke-opacity");
      if (i.isUrlDefinition()) {
        const _ = i.getFillStyleDefinition(this, n);
        _ && (t.fillStyle = _);
      } else if (i.hasValue()) {
        i.getString() === "currentColor" && i.setValue(this.getStyle("color").getColor());
        const _ = i.getColor();
        _ !== "inherit" && (t.fillStyle = _ === "none" ? "rgba(0,0,0,0)" : _);
      }
      if (n.hasValue()) {
        const _ = new se(this.document, "fill", t.fillStyle).addOpacity(n).getColor();
        t.fillStyle = _;
      }
      if (r.isUrlDefinition()) {
        const _ = r.getFillStyleDefinition(this, o);
        _ && (t.strokeStyle = _);
      } else if (r.hasValue()) {
        r.getString() === "currentColor" && r.setValue(this.getStyle("color").getColor());
        const _ = r.getString();
        _ !== "inherit" && (t.strokeStyle = _ === "none" ? "rgba(0,0,0,0)" : _);
      }
      if (o.hasValue()) {
        const _ = new se(this.document, "stroke", t.strokeStyle).addOpacity(o).getString();
        t.strokeStyle = _;
      }
      const l = this.getStyle("stroke-width");
      if (l.hasValue()) {
        const _ = l.getPixels();
        t.lineWidth = _ || dl;
      }
      const h = this.getStyle("stroke-linecap"), u = this.getStyle("stroke-linejoin"), f = this.getStyle("stroke-miterlimit"), g = this.getStyle("stroke-dasharray"), y = this.getStyle("stroke-dashoffset");
      if (h.hasValue() && (t.lineCap = h.getString()), u.hasValue() && (t.lineJoin = u.getString()), f.hasValue() && (t.miterLimit = f.getNumber()), g.hasValue() && g.getString() !== "none") {
        const _ = Fs(g.getString());
        typeof t.setLineDash < "u" ? t.setLineDash(_) : typeof t.webkitLineDash < "u" ? t.webkitLineDash = _ : typeof t.mozDash < "u" && !(_.length === 1 && _[0] === 0) && (t.mozDash = _);
        const x = y.getPixels();
        typeof t.lineDashOffset < "u" ? t.lineDashOffset = x : typeof t.webkitLineDashOffset < "u" ? t.webkitLineDashOffset = x : typeof t.mozDashOffset < "u" && (t.mozDashOffset = x);
      }
    }
    if (this.modifiedEmSizeStack = !1, typeof t.font < "u") {
      const i = this.getStyle("font"), n = this.getStyle("font-style"), r = this.getStyle("font-variant"), o = this.getStyle("font-weight"), l = this.getStyle("font-size"), h = this.getStyle("font-family"), u = new hs(n.getString(), r.getString(), o.getString(), l.hasValue() ? "".concat(l.getPixels(!0), "px") : "", h.getString(), hs.parse(i.getString(), t.font));
      n.setValue(u.fontStyle), r.setValue(u.fontVariant), o.setValue(u.fontWeight), l.setValue(u.fontSize), h.setValue(u.fontFamily), t.font = u.toString(), l.isPixels() && (this.document.emSize = l.getPixels(), this.modifiedEmSizeStack = !0);
    }
    e || (this.applyEffects(t), t.globalAlpha = this.calculateOpacity());
  }
  clearContext(t) {
    super.clearContext(t), this.modifiedEmSizeStack && this.document.popEmSize();
  }
  constructor(...t) {
    super(...t), this.modifiedEmSizeStack = !1;
  }
}
class $o extends Fa {
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    super.setContext(t, e);
    const i = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    i && (t.textBaseline = i);
  }
  initializeCoordinates() {
    this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY;
  }
  getBoundingBox(t) {
    if (this.type !== "text")
      return this.getTElementBoundingBox(t);
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t);
    let e = null;
    return this.children.forEach((i, n) => {
      const r = this.getChildBoundingBox(t, this, this, n);
      e ? e.addBoundingBox(r) : e = r;
    }), e;
  }
  getFontSize() {
    const { document: t, parent: e } = this, i = hs.parse(t.ctx.font).fontSize;
    return e.getStyle("font-size").getNumber(i);
  }
  getTElementBoundingBox(t) {
    const e = this.getFontSize();
    return new br(this.x, this.y - e, this.x + this.measureText(t), this.y);
  }
  getGlyph(t, e, i) {
    const n = e[i];
    let r;
    if (t.isArabic) {
      var o;
      const l = e.length, h = e[i - 1], u = e[i + 1];
      let f = "isolated";
      (i === 0 || h === " ") && i < l - 1 && u !== " " && (f = "terminal"), i > 0 && h !== " " && i < l - 1 && u !== " " && (f = "medial"), i > 0 && h !== " " && (i === l - 1 || u === " ") && (f = "initial"), r = ((o = t.arabicGlyphs[n]) === null || o === void 0 ? void 0 : o[f]) || t.glyphs[n];
    } else
      r = t.glyphs[n];
    return r || (r = t.missingGlyph), r;
  }
  getText() {
    return "";
  }
  getTextFromNode(t) {
    const e = t || this.node, i = Array.from(e.parentNode.childNodes), n = i.indexOf(e), r = i.length - 1;
    let o = Dl(
      // textNode.value
      // || textNode.text
      e.textContent || ""
    );
    return n === 0 && (o = TI(o)), n === r && (o = DI(o)), o;
  }
  renderChildren(t) {
    if (this.type !== "text") {
      this.renderTElementChildren(t);
      return;
    }
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t), this.children.forEach((i, n) => {
      this.renderChild(t, this, this, n);
    });
    const { mouse: e } = this.document.screen;
    e.isWorking() && e.checkBoundingBox(this, this.getBoundingBox(t));
  }
  renderTElementChildren(t) {
    const { document: e, parent: i } = this, n = this.getText(), r = i.getStyle("font-family").getDefinition();
    if (r) {
      const { unitsPerEm: h } = r.fontFace, u = hs.parse(e.ctx.font), f = i.getStyle("font-size").getNumber(u.fontSize), g = i.getStyle("font-style").getString(u.fontStyle), y = f / h, _ = r.isRTL ? n.split("").reverse().join("") : n, x = Fs(i.getAttribute("dx").getString()), b = _.length;
      for (let I = 0; I < b; I++) {
        const C = this.getGlyph(r, _, I);
        t.translate(this.x, this.y), t.scale(y, -y);
        const M = t.lineWidth;
        t.lineWidth = t.lineWidth * h / f, g === "italic" && t.transform(1, 0, 0.4, 1, 0, 0), C.render(t), g === "italic" && t.transform(1, 0, -0.4, 1, 0, 0), t.lineWidth = M, t.scale(1 / y, -1 / y), t.translate(-this.x, -this.y), this.x += f * (C.horizAdvX || r.horizAdvX) / h, typeof x[I] < "u" && !isNaN(x[I]) && (this.x += x[I]);
      }
      return;
    }
    const { x: o, y: l } = this;
    t.fillStyle && t.fillText(n, o, l), t.strokeStyle && t.strokeText(n, o, l);
  }
  applyAnchoring() {
    if (this.textChunkStart >= this.leafTexts.length)
      return;
    const t = this.leafTexts[this.textChunkStart], e = t.getStyle("text-anchor").getString("start"), i = !1;
    let n = 0;
    e === "start" || e === "end" && i ? n = t.x - this.minX : e === "end" || e === "start" && i ? n = t.x - this.maxX : n = t.x - (this.minX + this.maxX) / 2;
    for (let r = this.textChunkStart; r < this.leafTexts.length; r++)
      this.leafTexts[r].x += n;
    this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.textChunkStart = this.leafTexts.length;
  }
  adjustChildCoordinatesRecursive(t) {
    this.children.forEach((e, i) => {
      this.adjustChildCoordinatesRecursiveCore(t, this, this, i);
    }), this.applyAnchoring();
  }
  adjustChildCoordinatesRecursiveCore(t, e, i, n) {
    const r = i.children[n];
    r.children.length > 0 ? r.children.forEach((o, l) => {
      e.adjustChildCoordinatesRecursiveCore(t, e, r, l);
    }) : this.adjustChildCoordinates(t, e, i, n);
  }
  adjustChildCoordinates(t, e, i, n) {
    const r = i.children[n];
    if (typeof r.measureText != "function")
      return r;
    t.save(), r.setContext(t, !0);
    const o = r.getAttribute("x"), l = r.getAttribute("y"), h = r.getAttribute("dx"), u = r.getAttribute("dy"), f = r.getStyle("font-family").getDefinition(), g = !!(f != null && f.isRTL);
    n === 0 && (o.hasValue() || o.setValue(r.getInheritedAttribute("x")), l.hasValue() || l.setValue(r.getInheritedAttribute("y")), h.hasValue() || h.setValue(r.getInheritedAttribute("dx")), u.hasValue() || u.setValue(r.getInheritedAttribute("dy")));
    const y = r.measureText(t);
    return g && (e.x -= y), o.hasValue() ? (e.applyAnchoring(), r.x = o.getPixels("x"), h.hasValue() && (r.x += h.getPixels("x"))) : (h.hasValue() && (e.x += h.getPixels("x")), r.x = e.x), e.x = r.x, g || (e.x += y), l.hasValue() ? (r.y = l.getPixels("y"), u.hasValue() && (r.y += u.getPixels("y"))) : (u.hasValue() && (e.y += u.getPixels("y")), r.y = e.y), e.y = r.y, e.leafTexts.push(r), e.minX = Math.min(e.minX, r.x, r.x + y), e.maxX = Math.max(e.maxX, r.x, r.x + y), r.clearContext(t), t.restore(), r;
  }
  getChildBoundingBox(t, e, i, n) {
    const r = i.children[n];
    if (typeof r.getBoundingBox != "function")
      return null;
    const o = r.getBoundingBox(t);
    return o && r.children.forEach((l, h) => {
      const u = e.getChildBoundingBox(t, e, r, h);
      o.addBoundingBox(u);
    }), o;
  }
  renderChild(t, e, i, n) {
    const r = i.children[n];
    r.render(t), r.children.forEach((o, l) => {
      e.renderChild(t, e, r, l);
    });
  }
  measureText(t) {
    const { measureCache: e } = this;
    if (~e)
      return e;
    const i = this.getText(), n = this.measureTargetText(t, i);
    return this.measureCache = n, n;
  }
  measureTargetText(t, e) {
    if (!e.length)
      return 0;
    const { parent: i } = this, n = i.getStyle("font-family").getDefinition();
    if (n) {
      const o = this.getFontSize(), l = n.isRTL ? e.split("").reverse().join("") : e, h = Fs(i.getAttribute("dx").getString()), u = l.length;
      let f = 0;
      for (let g = 0; g < u; g++) {
        const y = this.getGlyph(n, l, g);
        f += (y.horizAdvX || n.horizAdvX) * o / n.fontFace.unitsPerEm, typeof h[g] < "u" && !isNaN(h[g]) && (f += h[g]);
      }
      return f;
    }
    if (!t.measureText)
      return e.length * 10;
    t.save(), this.setContext(t, !0);
    const { width: r } = t.measureText(e);
    return this.clearContext(t), t.restore(), r;
  }
  /**
  * Inherits positional attributes from {@link TextElement} parent(s). Attributes
  * are only inherited from a parent to its first child.
  * @param name - The attribute name.
  * @returns The attribute value or null.
  */
  getInheritedAttribute(t) {
    let e = this;
    for (; e instanceof $o && e.isFirstChild() && e.parent; ) {
      const i = e.parent.getAttribute(t);
      if (i.hasValue(!0))
        return i.getString("0");
      e = e.parent;
    }
    return null;
  }
  constructor(t, e, i) {
    super(t, e, new.target === $o ? !0 : i), this.type = "text", this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.measureCache = -1;
  }
}
class xd extends $o {
  getText() {
    return this.text;
  }
  constructor(t, e, i) {
    super(t, e, new.target === xd ? !0 : i), this.type = "tspan", this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
}
class oC extends xd {
  constructor(...t) {
    super(...t), this.type = "textNode";
  }
}
class Ce extends Et {
  reset() {
    this.i = -1, this.command = null, this.previousCommand = null, this.start = new Ui(0, 0), this.control = new Ui(0, 0), this.current = new Ui(0, 0), this.points = [], this.angles = [];
  }
  isEnd() {
    const { i: t, commands: e } = this;
    return t >= e.length - 1;
  }
  next() {
    const t = this.commands[++this.i];
    return this.previousCommand = this.command, this.command = t, t;
  }
  getPoint() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
    const i = new Ui(this.command[t], this.command[e]);
    return this.makeAbsolute(i);
  }
  getAsControlPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.control = i, i;
  }
  getAsCurrentPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.current = i, i;
  }
  getReflectedControlPoint() {
    const t = this.previousCommand.type;
    if (t !== Et.CURVE_TO && t !== Et.SMOOTH_CURVE_TO && t !== Et.QUAD_TO && t !== Et.SMOOTH_QUAD_TO)
      return this.current;
    const { current: { x: e, y: i }, control: { x: n, y: r } } = this;
    return new Ui(2 * e - n, 2 * i - r);
  }
  makeAbsolute(t) {
    if (this.command.relative) {
      const { x: e, y: i } = this.current;
      t.x += e, t.y += i;
    }
    return t;
  }
  addMarker(t, e, i) {
    const { points: n, angles: r } = this;
    i && r.length > 0 && !r[r.length - 1] && (r[r.length - 1] = n[n.length - 1].angleTo(i)), this.addMarkerAngle(t, e ? e.angleTo(t) : null);
  }
  addMarkerAngle(t, e) {
    this.points.push(t), this.angles.push(e);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    const { angles: t } = this, e = t.length;
    for (let i = 0; i < e; i++)
      if (!t[i]) {
        for (let n = i + 1; n < e; n++)
          if (t[n]) {
            t[i] = t[n];
            break;
          }
      }
    return t;
  }
  constructor(t) {
    super(t.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, "")), this.control = new Ui(0, 0), this.start = new Ui(0, 0), this.current = new Ui(0, 0), this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];
  }
}
class wi extends Fa {
  path(t) {
    const { pathParser: e } = this, i = new br();
    for (e.reset(), t && t.beginPath(); !e.isEnd(); )
      switch (e.next().type) {
        case Ce.MOVE_TO:
          this.pathM(t, i);
          break;
        case Ce.LINE_TO:
          this.pathL(t, i);
          break;
        case Ce.HORIZ_LINE_TO:
          this.pathH(t, i);
          break;
        case Ce.VERT_LINE_TO:
          this.pathV(t, i);
          break;
        case Ce.CURVE_TO:
          this.pathC(t, i);
          break;
        case Ce.SMOOTH_CURVE_TO:
          this.pathS(t, i);
          break;
        case Ce.QUAD_TO:
          this.pathQ(t, i);
          break;
        case Ce.SMOOTH_QUAD_TO:
          this.pathT(t, i);
          break;
        case Ce.ARC:
          this.pathA(t, i);
          break;
        case Ce.CLOSE_PATH:
          this.pathZ(t, i);
          break;
      }
    return i;
  }
  getBoundingBox(t) {
    return this.path();
  }
  getMarkers() {
    const { pathParser: t } = this, e = t.getMarkerPoints(), i = t.getMarkerAngles();
    return e.map(
      (r, o) => [
        r,
        i[o]
      ]
    );
  }
  renderChildren(t) {
    this.path(t), this.document.screen.mouse.checkPath(this, t);
    const e = this.getStyle("fill-rule");
    t.fillStyle !== "" && (e.getString("inherit") !== "inherit" ? t.fill(e.getString()) : t.fill()), t.strokeStyle !== "" && (this.getAttribute("vector-effect").getString() === "non-scaling-stroke" ? (t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.stroke(), t.restore()) : t.stroke());
    const i = this.getMarkers();
    if (i) {
      const n = i.length - 1, r = this.getStyle("marker-start"), o = this.getStyle("marker-mid"), l = this.getStyle("marker-end");
      if (r.isUrlDefinition()) {
        const h = r.getDefinition(), [u, f] = i[0];
        h.render(t, u, f);
      }
      if (o.isUrlDefinition()) {
        const h = o.getDefinition();
        for (let u = 1; u < n; u++) {
          const [f, g] = i[u];
          h.render(t, f, g);
        }
      }
      if (l.isUrlDefinition()) {
        const h = l.getDefinition(), [u, f] = i[n];
        h.render(t, u, f);
      }
    }
  }
  static pathM(t) {
    const e = t.getAsCurrentPoint();
    return t.start = t.current, {
      point: e
    };
  }
  pathM(t, e) {
    const { pathParser: i } = this, { point: n } = wi.pathM(i), { x: r, y: o } = n;
    i.addMarker(n), e.addPoint(r, o), t && t.moveTo(r, o);
  }
  static pathL(t) {
    const { current: e } = t, i = t.getAsCurrentPoint();
    return {
      current: e,
      point: i
    };
  }
  pathL(t, e) {
    const { pathParser: i } = this, { current: n, point: r } = wi.pathL(i), { x: o, y: l } = r;
    i.addMarker(r, n), e.addPoint(o, l), t && t.lineTo(o, l);
  }
  static pathH(t) {
    const { current: e, command: i } = t, n = new Ui((i.relative ? e.x : 0) + i.x, e.y);
    return t.current = n, {
      current: e,
      point: n
    };
  }
  pathH(t, e) {
    const { pathParser: i } = this, { current: n, point: r } = wi.pathH(i), { x: o, y: l } = r;
    i.addMarker(r, n), e.addPoint(o, l), t && t.lineTo(o, l);
  }
  static pathV(t) {
    const { current: e, command: i } = t, n = new Ui(e.x, (i.relative ? e.y : 0) + i.y);
    return t.current = n, {
      current: e,
      point: n
    };
  }
  pathV(t, e) {
    const { pathParser: i } = this, { current: n, point: r } = wi.pathV(i), { x: o, y: l } = r;
    i.addMarker(r, n), e.addPoint(o, l), t && t.lineTo(o, l);
  }
  static pathC(t) {
    const { current: e } = t, i = t.getPoint("x1", "y1"), n = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: n,
      currentPoint: r
    };
  }
  pathC(t, e) {
    const { pathParser: i } = this, { current: n, point: r, controlPoint: o, currentPoint: l } = wi.pathC(i);
    i.addMarker(l, o, r), e.addBezierCurve(n.x, n.y, r.x, r.y, o.x, o.y, l.x, l.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, l.x, l.y);
  }
  static pathS(t) {
    const { current: e } = t, i = t.getReflectedControlPoint(), n = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: n,
      currentPoint: r
    };
  }
  pathS(t, e) {
    const { pathParser: i } = this, { current: n, point: r, controlPoint: o, currentPoint: l } = wi.pathS(i);
    i.addMarker(l, o, r), e.addBezierCurve(n.x, n.y, r.x, r.y, o.x, o.y, l.x, l.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, l.x, l.y);
  }
  static pathQ(t) {
    const { current: e } = t, i = t.getAsControlPoint("x1", "y1"), n = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: n
    };
  }
  pathQ(t, e) {
    const { pathParser: i } = this, { current: n, controlPoint: r, currentPoint: o } = wi.pathQ(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(n.x, n.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathT(t) {
    const { current: e } = t, i = t.getReflectedControlPoint();
    t.control = i;
    const n = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: n
    };
  }
  pathT(t, e) {
    const { pathParser: i } = this, { current: n, controlPoint: r, currentPoint: o } = wi.pathT(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(n.x, n.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathA(t) {
    const { current: e, command: i } = t;
    let { rX: n, rY: r, xRot: o, lArcFlag: l, sweepFlag: h } = i;
    const u = o * (Math.PI / 180), f = t.getAsCurrentPoint(), g = new Ui(Math.cos(u) * (e.x - f.x) / 2 + Math.sin(u) * (e.y - f.y) / 2, -Math.sin(u) * (e.x - f.x) / 2 + Math.cos(u) * (e.y - f.y) / 2), y = Math.pow(g.x, 2) / Math.pow(n, 2) + Math.pow(g.y, 2) / Math.pow(r, 2);
    y > 1 && (n *= Math.sqrt(y), r *= Math.sqrt(y));
    let _ = (l === h ? -1 : 1) * Math.sqrt((Math.pow(n, 2) * Math.pow(r, 2) - Math.pow(n, 2) * Math.pow(g.y, 2) - Math.pow(r, 2) * Math.pow(g.x, 2)) / (Math.pow(n, 2) * Math.pow(g.y, 2) + Math.pow(r, 2) * Math.pow(g.x, 2)));
    isNaN(_) && (_ = 0);
    const x = new Ui(_ * n * g.y / r, _ * -r * g.x / n), b = new Ui((e.x + f.x) / 2 + Math.cos(u) * x.x - Math.sin(u) * x.y, (e.y + f.y) / 2 + Math.sin(u) * x.x + Math.cos(u) * x.y), I = hm([
      1,
      0
    ], [
      (g.x - x.x) / n,
      (g.y - x.y) / r
    ]), C = [
      (g.x - x.x) / n,
      (g.y - x.y) / r
    ], M = [
      (-g.x - x.x) / n,
      (-g.y - x.y) / r
    ];
    let P = hm(C, M);
    return Yf(C, M) <= -1 && (P = Math.PI), Yf(C, M) >= 1 && (P = 0), {
      currentPoint: f,
      rX: n,
      rY: r,
      sweepFlag: h,
      xAxisRotation: u,
      centp: b,
      a1: I,
      ad: P
    };
  }
  pathA(t, e) {
    const { pathParser: i } = this, { currentPoint: n, rX: r, rY: o, sweepFlag: l, xAxisRotation: h, centp: u, a1: f, ad: g } = wi.pathA(i), y = 1 - l ? 1 : -1, _ = f + y * (g / 2), x = new Ui(u.x + r * Math.cos(_), u.y + o * Math.sin(_));
    if (i.addMarkerAngle(x, _ - y * Math.PI / 2), i.addMarkerAngle(n, _ - y * Math.PI), e.addPoint(n.x, n.y), t && !isNaN(f) && !isNaN(g)) {
      const b = r > o ? r : o, I = r > o ? 1 : r / o, C = r > o ? o / r : 1;
      t.translate(u.x, u.y), t.rotate(h), t.scale(I, C), t.arc(0, 0, b, f, f + g, !!(1 - l)), t.scale(1 / I, 1 / C), t.rotate(-h), t.translate(-u.x, -u.y);
    }
  }
  static pathZ(t) {
    t.current = t.start;
  }
  pathZ(t, e) {
    wi.pathZ(this.pathParser), t && e.x1 !== e.x2 && e.y1 !== e.y2 && t.closePath();
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "path", this.pathParser = new Ce(this.getAttribute("d").getString());
  }
}
class Lh extends Fa {
  setContext(t) {
    var e;
    const { document: i } = this, { screen: n, window: r } = i, o = t.canvas;
    if (n.setDefaults(t), "style" in o && typeof t.font < "u" && r && typeof r.getComputedStyle < "u") {
      t.font = r.getComputedStyle(o).getPropertyValue("font");
      const M = new se(i, "fontSize", hs.parse(t.font).fontSize);
      M.hasValue() && (i.rootEmSize = M.getPixels("y"), i.emSize = i.rootEmSize);
    }
    this.getAttribute("x").hasValue() || this.getAttribute("x", !0).setValue(0), this.getAttribute("y").hasValue() || this.getAttribute("y", !0).setValue(0);
    let { width: l, height: h } = n.viewPort;
    this.getStyle("width").hasValue() || this.getStyle("width", !0).setValue("100%"), this.getStyle("height").hasValue() || this.getStyle("height", !0).setValue("100%"), this.getStyle("color").hasValue() || this.getStyle("color", !0).setValue("black");
    const u = this.getAttribute("refX"), f = this.getAttribute("refY"), g = this.getAttribute("viewBox"), y = g.hasValue() ? Fs(g.getString()) : null, _ = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
    let x = 0, b = 0, I = 0, C = 0;
    y && (x = y[0], b = y[1]), this.root || (l = this.getStyle("width").getPixels("x"), h = this.getStyle("height").getPixels("y"), this.type === "marker" && (I = x, C = b, x = 0, b = 0)), n.viewPort.setCurrent(l, h), this.node && (!this.parent || ((e = this.node.parentNode) === null || e === void 0 ? void 0 : e.nodeName) === "foreignObject") && this.getStyle("transform", !1, !0).hasValue() && !this.getStyle("transform-origin", !1, !0).hasValue() && this.getStyle("transform-origin", !0, !0).setValue("50% 50%"), super.setContext(t), t.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y")), y && (l = y[2], h = y[3]), i.setViewBox({
      ctx: t,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: n.viewPort.width,
      desiredWidth: l,
      height: n.viewPort.height,
      desiredHeight: h,
      minX: x,
      minY: b,
      refX: u.getValue(),
      refY: f.getValue(),
      clip: _,
      clipX: I,
      clipY: C
    }), y && (n.viewPort.removeCurrent(), n.viewPort.setCurrent(l, h));
  }
  clearContext(t) {
    super.clearContext(t), this.document.screen.viewPort.removeCurrent();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const n = this.getAttribute("width", !0), r = this.getAttribute("height", !0), o = this.getAttribute("viewBox"), l = this.getAttribute("style"), h = n.getNumber(0), u = r.getNumber(0);
    if (i)
      if (typeof i == "string")
        this.getAttribute("preserveAspectRatio", !0).setValue(i);
      else {
        const f = this.getAttribute("preserveAspectRatio");
        f.hasValue() && f.setValue(f.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
      }
    if (n.setValue(t), r.setValue(e), o.hasValue() || o.setValue("0 0 ".concat(h || t, " ").concat(u || e)), l.hasValue()) {
      const f = this.getStyle("width"), g = this.getStyle("height");
      f.hasValue() && f.setValue("".concat(t, "px")), g.hasValue() && g.setValue("".concat(e, "px"));
    }
  }
  constructor(...t) {
    super(...t), this.type = "svg", this.root = !1;
  }
}
class Zy extends wi {
  path(t) {
    const e = this.getAttribute("x").getPixels("x"), i = this.getAttribute("y").getPixels("y"), n = this.getStyle("width", !1, !0).getPixels("x"), r = this.getStyle("height", !1, !0).getPixels("y"), o = this.getAttribute("rx"), l = this.getAttribute("ry");
    let h = o.getPixels("x"), u = l.getPixels("y");
    if (o.hasValue() && !l.hasValue() && (u = h), l.hasValue() && !o.hasValue() && (h = u), h = Math.min(h, n / 2), u = Math.min(u, r / 2), t) {
      const f = 4 * ((Math.sqrt(2) - 1) / 3);
      t.beginPath(), r > 0 && n > 0 && (t.moveTo(e + h, i), t.lineTo(e + n - h, i), t.bezierCurveTo(e + n - h + f * h, i, e + n, i + u - f * u, e + n, i + u), t.lineTo(e + n, i + r - u), t.bezierCurveTo(e + n, i + r - u + f * u, e + n - h + f * h, i + r, e + n - h, i + r), t.lineTo(e + h, i + r), t.bezierCurveTo(e + h - f * h, i + r, e, i + r - u + f * u, e, i + r - u), t.lineTo(e, i + u), t.bezierCurveTo(e, i + u - f * u, e + h - f * h, i, e + h, i), t.closePath());
    }
    return new br(e, i, e + n, i + r);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "rect";
  }
}
class aC extends wi {
  path(t) {
    const e = this.getAttribute("cx").getPixels("x"), i = this.getAttribute("cy").getPixels("y"), n = this.getAttribute("r").getPixels();
    return t && n > 0 && (t.beginPath(), t.arc(e, i, n, 0, Math.PI * 2, !1), t.closePath()), new br(e - n, i - n, e + n, i + n);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "circle";
  }
}
class lC extends wi {
  path(t) {
    const e = 4 * ((Math.sqrt(2) - 1) / 3), i = this.getAttribute("rx").getPixels("x"), n = this.getAttribute("ry").getPixels("y"), r = this.getAttribute("cx").getPixels("x"), o = this.getAttribute("cy").getPixels("y");
    return t && i > 0 && n > 0 && (t.beginPath(), t.moveTo(r + i, o), t.bezierCurveTo(r + i, o + e * n, r + e * i, o + n, r, o + n), t.bezierCurveTo(r - e * i, o + n, r - i, o + e * n, r - i, o), t.bezierCurveTo(r - i, o - e * n, r - e * i, o - n, r, o - n), t.bezierCurveTo(r + e * i, o - n, r + i, o - e * n, r + i, o), t.closePath()), new br(r - i, o - n, r + i, o + n);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "ellipse";
  }
}
class cC extends wi {
  getPoints() {
    return [
      new Ui(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")),
      new Ui(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))
    ];
  }
  path(t) {
    const [{ x: e, y: i }, { x: n, y: r }] = this.getPoints();
    return t && (t.beginPath(), t.moveTo(e, i), t.lineTo(n, r)), new br(e, i, n, r);
  }
  getMarkers() {
    const [t, e] = this.getPoints(), i = t.angleTo(e);
    return [
      [
        t,
        i
      ],
      [
        e,
        i
      ]
    ];
  }
  constructor(...t) {
    super(...t), this.type = "line";
  }
}
class Qy extends wi {
  path(t) {
    const { points: e } = this, [{ x: i, y: n }] = e, r = new br(i, n);
    return t && (t.beginPath(), t.moveTo(i, n)), e.forEach((o) => {
      let { x: l, y: h } = o;
      r.addPoint(l, h), t && t.lineTo(l, h);
    }), r;
  }
  getMarkers() {
    const { points: t } = this, e = t.length - 1, i = [];
    return t.forEach((n, r) => {
      r !== e && i.push([
        n,
        n.angleTo(t[r + 1])
      ]);
    }), i.length > 0 && i.push([
      t[t.length - 1],
      i[i.length - 1][1]
    ]), i;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "polyline", this.points = [], this.points = Ui.parsePath(this.getAttribute("points").getString());
  }
}
class hC extends Qy {
  path(t) {
    const e = super.path(t), [{ x: i, y: n }] = this.points;
    return t && (t.lineTo(i, n), t.closePath()), e;
  }
  constructor(...t) {
    super(...t), this.type = "polygon";
  }
}
class uC extends sn {
  createPattern(t, e, i) {
    const n = this.getStyle("width").getPixels("x", !0), r = this.getStyle("height").getPixels("y", !0), o = new Lh(this.document, null);
    o.attributes.viewBox = new se(this.document, "viewBox", this.getAttribute("viewBox").getValue()), o.attributes.width = new se(this.document, "width", "".concat(n, "px")), o.attributes.height = new se(this.document, "height", "".concat(r, "px")), o.attributes.transform = new se(this.document, "transform", this.getAttribute("patternTransform").getValue()), o.children = this.children;
    const l = this.document.createCanvas(n, r), h = l.getContext("2d"), u = this.getAttribute("x"), f = this.getAttribute("y");
    u.hasValue() && f.hasValue() && h.translate(u.getPixels("x", !0), f.getPixels("y", !0)), i.hasValue() ? this.styles["fill-opacity"] = i : Reflect.deleteProperty(this.styles, "fill-opacity");
    for (let y = -1; y <= 1; y++)
      for (let _ = -1; _ <= 1; _++)
        h.save(), o.attributes.x = new se(this.document, "x", y * l.width), o.attributes.y = new se(this.document, "y", _ * l.height), o.render(h), h.restore();
    return t.createPattern(l, "repeat");
  }
  constructor(...t) {
    super(...t), this.type = "pattern";
  }
}
class dC extends sn {
  render(t, e, i) {
    if (!e)
      return;
    const { x: n, y: r } = e, o = this.getAttribute("orient").getString("auto"), l = this.getAttribute("markerUnits").getString("strokeWidth");
    t.translate(n, r), o === "auto" && t.rotate(i), l === "strokeWidth" && t.scale(t.lineWidth, t.lineWidth), t.save();
    const h = new Lh(this.document);
    h.type = this.type, h.attributes.viewBox = new se(this.document, "viewBox", this.getAttribute("viewBox").getValue()), h.attributes.refX = new se(this.document, "refX", this.getAttribute("refX").getValue()), h.attributes.refY = new se(this.document, "refY", this.getAttribute("refY").getValue()), h.attributes.width = new se(this.document, "width", this.getAttribute("markerWidth").getValue()), h.attributes.height = new se(this.document, "height", this.getAttribute("markerHeight").getValue()), h.attributes.overflow = new se(this.document, "overflow", this.getAttribute("overflow").getValue()), h.attributes.fill = new se(this.document, "fill", this.getAttribute("fill").getColor("black")), h.attributes.stroke = new se(this.document, "stroke", this.getAttribute("stroke").getValue("none")), h.children = this.children, h.render(t), t.restore(), l === "strokeWidth" && t.scale(1 / t.lineWidth, 1 / t.lineWidth), o === "auto" && t.rotate(-i), t.translate(-n, -r);
  }
  constructor(...t) {
    super(...t), this.type = "marker";
  }
}
class fC extends sn {
  render() {
  }
  constructor(...t) {
    super(...t), this.type = "defs";
  }
}
class Ng extends Fa {
  getBoundingBox(t) {
    const e = new br();
    return this.children.forEach((i) => {
      e.addBoundingBox(i.getBoundingBox(t));
    }), e;
  }
  constructor(...t) {
    super(...t), this.type = "g";
  }
}
class tw extends sn {
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(t, e, i) {
    let n = this;
    this.getHrefAttribute().hasValue() && (n = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(n));
    const { stops: r } = n, o = this.getGradient(t, e);
    if (!o)
      return this.addParentOpacity(i, r[r.length - 1].color);
    if (r.forEach((l) => {
      o.addColorStop(l.offset, this.addParentOpacity(i, l.color));
    }), this.getAttribute("gradientTransform").hasValue()) {
      const { document: l } = this, { MAX_VIRTUAL_PIXELS: h } = po, { viewPort: u } = l.screen, f = u.getRoot(), g = new Zy(l);
      g.attributes.x = new se(l, "x", -h / 3), g.attributes.y = new se(l, "y", -h / 3), g.attributes.width = new se(l, "width", h), g.attributes.height = new se(l, "height", h);
      const y = new Ng(l);
      y.attributes.transform = new se(l, "transform", this.getAttribute("gradientTransform").getValue()), y.children = [
        g
      ];
      const _ = new Lh(l);
      _.attributes.x = new se(l, "x", 0), _.attributes.y = new se(l, "y", 0), _.attributes.width = new se(l, "width", f.width), _.attributes.height = new se(l, "height", f.height), _.children = [
        y
      ];
      const x = l.createCanvas(f.width, f.height), b = x.getContext("2d");
      return b.fillStyle = o, _.render(b), b.createPattern(x, "no-repeat");
    }
    return o;
  }
  inheritStopContainer(t) {
    this.attributesToInherit.forEach((e) => {
      !this.getAttribute(e).hasValue() && t.getAttribute(e).hasValue() && this.getAttribute(e, !0).setValue(t.getAttribute(e).getValue());
    });
  }
  addParentOpacity(t, e) {
    return t.hasValue() ? new se(this.document, "color", e).addOpacity(t).getColor() : e;
  }
  constructor(t, e, i) {
    super(t, e, i), this.attributesToInherit = [
      "gradientUnits"
    ], this.stops = [];
    const { stops: n, children: r } = this;
    r.forEach((o) => {
      o.type === "stop" && n.push(o);
    });
  }
}
class gC extends tw {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", n = i ? e.getBoundingBox(t) : null;
    if (i && !n)
      return null;
    !this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue() && (this.getAttribute("x1", !0).setValue(0), this.getAttribute("y1", !0).setValue(0), this.getAttribute("x2", !0).setValue(1), this.getAttribute("y2", !0).setValue(0));
    const r = i ? n.x + n.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x"), o = i ? n.y + n.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y"), l = i ? n.x + n.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x"), h = i ? n.y + n.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    return r === l && o === h ? null : t.createLinearGradient(r, o, l, h);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "linearGradient", this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
}
class pC extends tw {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", n = e.getBoundingBox(t);
    if (i && !n)
      return null;
    this.getAttribute("cx").hasValue() || this.getAttribute("cx", !0).setValue("50%"), this.getAttribute("cy").hasValue() || this.getAttribute("cy", !0).setValue("50%"), this.getAttribute("r").hasValue() || this.getAttribute("r", !0).setValue("50%");
    const r = i ? n.x + n.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x"), o = i ? n.y + n.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
    let l = r, h = o;
    this.getAttribute("fx").hasValue() && (l = i ? n.x + n.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x")), this.getAttribute("fy").hasValue() && (h = i ? n.y + n.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y"));
    const u = i ? (n.width + n.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels(), f = this.getAttribute("fr").getPixels();
    return t.createRadialGradient(l, h, f, r, o, u);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "radialGradient", this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
}
class mC extends sn {
  constructor(t, e, i) {
    super(t, e, i), this.type = "stop";
    const n = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber())), r = this.getStyle("stop-opacity");
    let o = this.getStyle("stop-color", !0);
    o.getString() === "" && o.setValue("#000"), r.hasValue() && (o = o.addOpacity(r)), this.offset = n, this.color = o.getColor();
  }
}
class Og extends sn {
  getProperty() {
    const t = this.getAttribute("attributeType").getString(), e = this.getAttribute("attributeName").getString();
    return t === "CSS" ? this.parent.getStyle(e, !0) : this.parent.getAttribute(e, !0);
  }
  calcValue() {
    const { initialUnits: t } = this, { progress: e, from: i, to: n } = this.getProgress();
    let r = i.getNumber() + (n.getNumber() - i.getNumber()) * e;
    return t === "%" && (r *= 100), "".concat(r).concat(t);
  }
  update(t) {
    const { parent: e } = this, i = this.getProperty();
    if (this.initialValue || (this.initialValue = i.getString(), this.initialUnits = i.getUnits()), this.duration > this.maxDuration) {
      const r = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite")
        this.duration = 0;
      else if (r === "freeze" && !this.frozen)
        this.frozen = !0, e && i && (e.animationFrozen = !0, e.animationFrozenValue = i.getString());
      else if (r === "remove" && !this.removed)
        return this.removed = !0, e && i && i.setValue(e.animationFrozen ? e.animationFrozenValue : this.initialValue), !0;
      return !1;
    }
    this.duration += t;
    let n = !1;
    if (this.begin < this.duration) {
      let r = this.calcValue();
      const o = this.getAttribute("type");
      if (o.hasValue()) {
        const l = o.getString();
        r = "".concat(l, "(").concat(r, ")");
      }
      i.setValue(r), n = !0;
    }
    return n;
  }
  getProgress() {
    const { document: t, values: e } = this;
    let i = (this.duration - this.begin) / (this.maxDuration - this.begin), n, r;
    if (e.hasValue()) {
      const o = i * (e.getValue().length - 1), l = Math.floor(o), h = Math.ceil(o);
      let u;
      u = e.getValue()[l], n = new se(t, "from", u ? parseFloat(u) : 0), u = e.getValue()[h], r = new se(t, "to", u ? parseFloat(u) : 0), i = (o - l) / (h - l);
    } else
      n = this.from, r = this.to;
    return {
      progress: i,
      from: n,
      to: r
    };
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "animate", this.duration = 0, this.initialUnits = "", this.removed = !1, this.frozen = !1, t.screen.animations.push(this), this.begin = this.getAttribute("begin").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds(), this.from = this.getAttribute("from"), this.to = this.getAttribute("to"), this.values = new se(t, "values", null);
    const n = this.getAttribute("values");
    n.hasValue() && this.values.setValue(n.getString().split(";"));
  }
}
class _C extends Og {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), n = new Xf(e.getColor()), r = new Xf(i.getColor());
    if (n.ok && r.ok) {
      const o = n.r + (r.r - n.r) * t, l = n.g + (r.g - n.g) * t, h = n.b + (r.b - n.b) * t;
      return "rgb(".concat(Math.floor(o), ", ").concat(Math.floor(l), ", ").concat(Math.floor(h), ")");
    }
    return this.getAttribute("from").getColor();
  }
  constructor(...t) {
    super(...t), this.type = "animateColor";
  }
}
class yC extends Og {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), n = Fs(e.getString()), r = Fs(i.getString());
    return n.map((l, h) => {
      const u = r[h];
      return l + (u - l) * t;
    }).join(" ");
  }
  constructor(...t) {
    super(...t), this.type = "animateTransform";
  }
}
class ew extends sn {
  constructor(t, e, i) {
    super(t, e, i), this.type = "font-face", this.ascent = this.getAttribute("ascent").getNumber(), this.descent = this.getAttribute("descent").getNumber(), this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class Rg extends wi {
  constructor(t, e, i) {
    super(t, e, i), this.type = "glyph", this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber(), this.unicode = this.getAttribute("unicode").getString(), this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class iw extends Rg {
  constructor(...t) {
    super(...t), this.type = "missing-glyph", this.horizAdvX = 0;
  }
}
class wC extends sn {
  render() {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "font", this.isArabic = !1, this.glyphs = {}, this.arabicGlyphs = {}, this.isRTL = !1, this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    const { definitions: n } = t, { children: r } = this;
    for (const o of r)
      if (o instanceof ew) {
        this.fontFace = o;
        const l = o.getStyle("font-family");
        l.hasValue() && (n[l.getString()] = this);
      } else if (o instanceof iw)
        this.missingGlyph = o;
      else if (o instanceof Rg)
        if (o.arabicForm) {
          this.isRTL = !0, this.isArabic = !0;
          const l = this.arabicGlyphs[o.unicode];
          typeof l > "u" ? this.arabicGlyphs[o.unicode] = {
            [o.arabicForm]: o
          } : l[o.arabicForm] = o;
        } else
          this.glyphs[o.unicode] = o;
  }
}
class vC extends $o {
  getText() {
    const t = this.getHrefAttribute().getDefinition();
    if (t) {
      const e = t.children[0];
      if (e)
        return e.getText();
    }
    return "";
  }
  constructor(...t) {
    super(...t), this.type = "tref";
  }
}
class bC extends $o {
  getText() {
    return this.text;
  }
  renderChildren(t) {
    if (this.hasText) {
      super.renderChildren(t);
      const { document: e, x: i, y: n } = this, { mouse: r } = e.screen, o = new se(e, "fontSize", hs.parse(e.ctx.font).fontSize);
      r.isWorking() && r.checkBoundingBox(this, new br(i, n - o.getPixels("y"), i + this.measureText(t), n));
    } else if (this.children.length > 0) {
      const e = new Ng(this.document);
      e.children = this.children, e.parent = this, e.render(t);
    }
  }
  onClick() {
    const { window: t } = this.document;
    t && t.open(this.getHrefAttribute().getString());
  }
  onMouseMove() {
    const t = this.document.ctx;
    t.canvas.style.cursor = "pointer";
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "a";
    const { childNodes: n } = e, r = n[0], o = n.length > 0 && Array.from(n).every(
      (l) => l.nodeType === 3
    );
    this.hasText = o, this.text = o ? this.getTextFromNode(r) : "";
  }
}
class xC extends $o {
  getText() {
    return this.text;
  }
  path(t) {
    const { dataArray: e } = this;
    t && t.beginPath(), e.forEach((i) => {
      let { type: n, points: r } = i;
      switch (n) {
        case Ce.LINE_TO:
          t && t.lineTo(r[0], r[1]);
          break;
        case Ce.MOVE_TO:
          t && t.moveTo(r[0], r[1]);
          break;
        case Ce.CURVE_TO:
          t && t.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]);
          break;
        case Ce.QUAD_TO:
          t && t.quadraticCurveTo(r[0], r[1], r[2], r[3]);
          break;
        case Ce.ARC: {
          const [o, l, h, u, f, g, y, _] = r, x = h > u ? h : u, b = h > u ? 1 : h / u, I = h > u ? u / h : 1;
          t && (t.translate(o, l), t.rotate(y), t.scale(b, I), t.arc(0, 0, x, f, f + g, !!(1 - _)), t.scale(1 / b, 1 / I), t.rotate(-y), t.translate(-o, -l));
          break;
        }
        case Ce.CLOSE_PATH:
          t && t.closePath();
          break;
      }
    });
  }
  renderChildren(t) {
    this.setTextData(t), t.save();
    const e = this.parent.getStyle("text-decoration").getString(), i = this.getFontSize(), { glyphInfo: n } = this, r = t.fillStyle;
    e === "underline" && t.beginPath(), n.forEach((o, l) => {
      const { p0: h, p1: u, rotation: f, text: g } = o;
      t.save(), t.translate(h.x, h.y), t.rotate(f), t.fillStyle && t.fillText(g, 0, 0), t.strokeStyle && t.strokeText(g, 0, 0), t.restore(), e === "underline" && (l === 0 && t.moveTo(h.x, h.y + i / 8), t.lineTo(u.x, u.y + i / 5));
    }), e === "underline" && (t.lineWidth = i / 20, t.strokeStyle = r, t.stroke(), t.closePath()), t.restore();
  }
  getLetterSpacingAt() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[t] || 0;
  }
  findSegmentToFitChar(t, e, i, n, r, o, l, h, u) {
    let f = o, g = this.measureText(t, h);
    h === " " && e === "justify" && i < n && (g += (n - i) / r), u > -1 && (f += this.getLetterSpacingAt(u));
    const y = this.textHeight / 20, _ = this.getEquidistantPointOnPath(f, y, 0), x = this.getEquidistantPointOnPath(f + g, y, 0), b = {
      p0: _,
      p1: x
    }, I = _ && x ? Math.atan2(x.y - _.y, x.x - _.x) : 0;
    if (l) {
      const C = Math.cos(Math.PI / 2 + I) * l, M = Math.cos(-I) * l;
      b.p0 = {
        ..._,
        x: _.x + C,
        y: _.y + M
      }, b.p1 = {
        ...x,
        x: x.x + C,
        y: x.y + M
      };
    }
    return f += g, {
      offset: f,
      segment: b,
      rotation: I
    };
  }
  measureText(t, e) {
    const { measuresCache: i } = this, n = e || this.getText();
    if (i.has(n))
      return i.get(n);
    const r = this.measureTargetText(t, n);
    return i.set(n, r), r;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(t) {
    if (this.glyphInfo)
      return;
    const e = this.getText(), i = e.split(""), n = e.split(" ").length - 1, r = this.parent.getAttribute("dx").split().map(
      (P) => P.getPixels("x")
    ), o = this.parent.getAttribute("dy").getPixels("y"), l = this.parent.getStyle("text-anchor").getString("start"), h = this.getStyle("letter-spacing"), u = this.parent.getStyle("letter-spacing");
    let f = 0;
    !h.hasValue() || h.getValue() === "inherit" ? f = u.getPixels() : h.hasValue() && h.getValue() !== "initial" && h.getValue() !== "unset" && (f = h.getPixels());
    const g = [], y = e.length;
    this.letterSpacingCache = g;
    for (let P = 0; P < y; P++)
      g.push(typeof r[P] < "u" ? r[P] : f);
    const _ = g.reduce(
      (P, O, B) => B === 0 ? 0 : P + O || 0,
      0
    ), x = this.measureText(t), b = Math.max(x + _, 0);
    this.textWidth = x, this.textHeight = this.getFontSize(), this.glyphInfo = [];
    const I = this.getPathLength(), C = this.getStyle("startOffset").getNumber(0) * I;
    let M = 0;
    (l === "middle" || l === "center") && (M = -b / 2), (l === "end" || l === "right") && (M = -b), M += C, i.forEach((P, O) => {
      const { offset: B, segment: j, rotation: F } = this.findSegmentToFitChar(t, l, b, I, n, M, o, P, O);
      M = B, !(!j.p0 || !j.p1) && this.glyphInfo.push({
        // transposeX: midpoint.x,
        // transposeY: midpoint.y,
        text: i[O],
        p0: j.p0,
        p1: j.p1,
        rotation: F
      });
    });
  }
  parsePathData(t) {
    if (this.pathLength = -1, !t)
      return [];
    const e = [], { pathParser: i } = t;
    for (i.reset(); !i.isEnd(); ) {
      const { current: n } = i, r = n ? n.x : 0, o = n ? n.y : 0, l = i.next();
      let h = l.type, u = [];
      switch (l.type) {
        case Ce.MOVE_TO:
          this.pathM(i, u);
          break;
        case Ce.LINE_TO:
          h = this.pathL(i, u);
          break;
        case Ce.HORIZ_LINE_TO:
          h = this.pathH(i, u);
          break;
        case Ce.VERT_LINE_TO:
          h = this.pathV(i, u);
          break;
        case Ce.CURVE_TO:
          this.pathC(i, u);
          break;
        case Ce.SMOOTH_CURVE_TO:
          h = this.pathS(i, u);
          break;
        case Ce.QUAD_TO:
          this.pathQ(i, u);
          break;
        case Ce.SMOOTH_QUAD_TO:
          h = this.pathT(i, u);
          break;
        case Ce.ARC:
          u = this.pathA(i);
          break;
        case Ce.CLOSE_PATH:
          wi.pathZ(i);
          break;
      }
      l.type !== Ce.CLOSE_PATH ? e.push({
        type: h,
        points: u,
        start: {
          x: r,
          y: o
        },
        pathLength: this.calcLength(r, o, h, u)
      }) : e.push({
        type: Ce.CLOSE_PATH,
        points: [],
        pathLength: 0
      });
    }
    return e;
  }
  pathM(t, e) {
    const { x: i, y: n } = wi.pathM(t).point;
    e.push(i, n);
  }
  pathL(t, e) {
    const { x: i, y: n } = wi.pathL(t).point;
    return e.push(i, n), Ce.LINE_TO;
  }
  pathH(t, e) {
    const { x: i, y: n } = wi.pathH(t).point;
    return e.push(i, n), Ce.LINE_TO;
  }
  pathV(t, e) {
    const { x: i, y: n } = wi.pathV(t).point;
    return e.push(i, n), Ce.LINE_TO;
  }
  pathC(t, e) {
    const { point: i, controlPoint: n, currentPoint: r } = wi.pathC(t);
    e.push(i.x, i.y, n.x, n.y, r.x, r.y);
  }
  pathS(t, e) {
    const { point: i, controlPoint: n, currentPoint: r } = wi.pathS(t);
    return e.push(i.x, i.y, n.x, n.y, r.x, r.y), Ce.CURVE_TO;
  }
  pathQ(t, e) {
    const { controlPoint: i, currentPoint: n } = wi.pathQ(t);
    e.push(i.x, i.y, n.x, n.y);
  }
  pathT(t, e) {
    const { controlPoint: i, currentPoint: n } = wi.pathT(t);
    return e.push(i.x, i.y, n.x, n.y), Ce.QUAD_TO;
  }
  pathA(t) {
    let { rX: e, rY: i, sweepFlag: n, xAxisRotation: r, centp: o, a1: l, ad: h } = wi.pathA(t);
    return n === 0 && h > 0 && (h -= 2 * Math.PI), n === 1 && h < 0 && (h += 2 * Math.PI), [
      o.x,
      o.y,
      e,
      i,
      l,
      h,
      r,
      n
    ];
  }
  calcLength(t, e, i, n) {
    let r = 0, o = null, l = null, h = 0;
    switch (i) {
      case Ce.LINE_TO:
        return this.getLineLength(t, e, n[0], n[1]);
      case Ce.CURVE_TO:
        for (r = 0, o = this.getPointOnCubicBezier(0, t, e, n[0], n[1], n[2], n[3], n[4], n[5]), h = 0.01; h <= 1; h += 0.01)
          l = this.getPointOnCubicBezier(h, t, e, n[0], n[1], n[2], n[3], n[4], n[5]), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        return r;
      case Ce.QUAD_TO:
        for (r = 0, o = this.getPointOnQuadraticBezier(0, t, e, n[0], n[1], n[2], n[3]), h = 0.01; h <= 1; h += 0.01)
          l = this.getPointOnQuadraticBezier(h, t, e, n[0], n[1], n[2], n[3]), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        return r;
      case Ce.ARC: {
        r = 0;
        const u = n[4], f = n[5], g = n[4] + f;
        let y = Math.PI / 180;
        if (Math.abs(u - g) < y && (y = Math.abs(u - g)), o = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], u, 0), f < 0)
          for (h = u - y; h > g; h -= y)
            l = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], h, 0), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        else
          for (h = u + y; h < g; h += y)
            l = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], h, 0), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        return l = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], g, 0), r += this.getLineLength(o.x, o.y, l.x, l.y), r;
      }
    }
    return 0;
  }
  getPointOnLine(t, e, i, n, r) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : e, l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : i;
    const h = (r - i) / (n - e + dl);
    let u = Math.sqrt(t * t / (1 + h * h));
    n < e && (u *= -1);
    let f = h * u, g = null;
    if (n === e)
      g = {
        x: o,
        y: l + f
      };
    else if ((l - i) / (o - e + dl) === h)
      g = {
        x: o + u,
        y: l + f
      };
    else {
      let y = 0, _ = 0;
      const x = this.getLineLength(e, i, n, r);
      if (x < dl)
        return null;
      let b = (o - e) * (n - e) + (l - i) * (r - i);
      b /= x * x, y = e + b * (n - e), _ = i + b * (r - i);
      const I = this.getLineLength(o, l, y, _), C = Math.sqrt(t * t - I * I);
      u = Math.sqrt(C * C / (1 + h * h)), n < e && (u *= -1), f = h * u, g = {
        x: y + u,
        y: _ + f
      };
    }
    return g;
  }
  getPointOnPath(t) {
    const e = this.getPathLength();
    let i = 0, n = null;
    if (t < -5e-5 || t - 5e-5 > e)
      return null;
    const { dataArray: r } = this;
    for (const o of r) {
      if (o && (o.pathLength < 5e-5 || i + o.pathLength + 5e-5 < t)) {
        i += o.pathLength;
        continue;
      }
      const l = t - i;
      let h = 0;
      switch (o.type) {
        case Ce.LINE_TO:
          n = this.getPointOnLine(l, o.start.x, o.start.y, o.points[0], o.points[1], o.start.x, o.start.y);
          break;
        case Ce.ARC: {
          const u = o.points[4], f = o.points[5], g = o.points[4] + f;
          if (h = u + l / o.pathLength * f, f < 0 && h < g || f >= 0 && h > g)
            break;
          n = this.getPointOnEllipticalArc(o.points[0], o.points[1], o.points[2], o.points[3], h, o.points[6]);
          break;
        }
        case Ce.CURVE_TO:
          h = l / o.pathLength, h > 1 && (h = 1), n = this.getPointOnCubicBezier(h, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3], o.points[4], o.points[5]);
          break;
        case Ce.QUAD_TO:
          h = l / o.pathLength, h > 1 && (h = 1), n = this.getPointOnQuadraticBezier(h, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3]);
          break;
      }
      if (n)
        return n;
      break;
    }
    return null;
  }
  getLineLength(t, e, i, n) {
    return Math.sqrt((i - t) * (i - t) + (n - e) * (n - e));
  }
  getPathLength() {
    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce(
      (t, e) => e.pathLength > 0 ? t + e.pathLength : t,
      0
    )), this.pathLength;
  }
  getPointOnCubicBezier(t, e, i, n, r, o, l, h, u) {
    const f = h * um(t) + o * dm(t) + n * fm(t) + e * gm(t), g = u * um(t) + l * dm(t) + r * fm(t) + i * gm(t);
    return {
      x: f,
      y: g
    };
  }
  getPointOnQuadraticBezier(t, e, i, n, r, o, l) {
    const h = o * pm(t) + n * mm(t) + e * _m(t), u = l * pm(t) + r * mm(t) + i * _m(t);
    return {
      x: h,
      y: u
    };
  }
  getPointOnEllipticalArc(t, e, i, n, r, o) {
    const l = Math.cos(o), h = Math.sin(o), u = {
      x: i * Math.cos(r),
      y: n * Math.sin(r)
    };
    return {
      x: t + (u.x * l - u.y * h),
      y: e + (u.x * h + u.y * l)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(t, e) {
    const i = this.getPathLength(), n = e || 0.25, r = t || i / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== r || this.equidistantCache.precision !== n) {
      this.equidistantCache = {
        step: r,
        precision: n,
        points: []
      };
      let o = 0;
      for (let l = 0; l <= i; l += n) {
        const h = this.getPointOnPath(l), u = this.getPointOnPath(l + n);
        !h || !u || (o += this.getLineLength(h.x, h.y, u.x, u.y), o >= r && (this.equidistantCache.points.push({
          x: h.x,
          y: h.y,
          distance: l
        }), o -= r));
      }
    }
  }
  getEquidistantPointOnPath(t, e, i) {
    if (this.buildEquidistantCache(e, i), t < 0 || t - this.getPathLength() > 5e-5)
      return null;
    const n = Math.round(t / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[n] || null;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "textPath", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */ new Map([
      [
        "",
        0
      ]
    ]);
    const n = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(n);
  }
}
const IC = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class CC extends Fa {
  async loadImage(t) {
    try {
      const e = await this.document.createImage(t);
      this.image = e;
    } catch (e) {
      console.error('Error while loading image "'.concat(t, '":'), e);
    }
    this.loaded = !0;
  }
  async loadSvg(t) {
    const e = IC.exec(t);
    if (e) {
      const i = e[5];
      i && (e[4] === "base64" ? this.image = atob(i) : this.image = decodeURIComponent(i));
    } else
      try {
        const n = await (await this.document.fetch(t)).text();
        this.image = n;
      } catch (i) {
        console.error('Error while loading image "'.concat(t, '":'), i);
      }
    this.loaded = !0;
  }
  renderChildren(t) {
    const { document: e, image: i, loaded: n } = this, r = this.getAttribute("x").getPixels("x"), o = this.getAttribute("y").getPixels("y"), l = this.getStyle("width").getPixels("x"), h = this.getStyle("height").getPixels("y");
    if (!(!n || !i || !l || !h)) {
      if (t.save(), t.translate(r, o), typeof i == "string") {
        const u = e.canvg.forkString(t, i, {
          ignoreMouse: !0,
          ignoreAnimation: !0,
          ignoreDimensions: !0,
          ignoreClear: !0,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: l,
          scaleHeight: h
        }), { documentElement: f } = u.document;
        f && (f.parent = this), u.render();
      } else
        e.setViewBox({
          ctx: t,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: l,
          desiredWidth: i.width,
          height: h,
          desiredHeight: i.height
        }), this.loaded && (!("complete" in i) || i.complete) && t.drawImage(i, 0, 0);
      t.restore();
    }
  }
  getBoundingBox() {
    const t = this.getAttribute("x").getPixels("x"), e = this.getAttribute("y").getPixels("y"), i = this.getStyle("width").getPixels("x"), n = this.getStyle("height").getPixels("y");
    return new br(t, e, t + i, e + n);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "image", this.loaded = !1;
    const n = this.getHrefAttribute().getString();
    if (!n)
      return;
    const r = n.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(n);
    t.images.push(this), r ? this.loadSvg(n) : this.loadImage(n);
  }
}
class SC extends Fa {
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "symbol";
  }
}
class MC {
  async load(t, e) {
    try {
      const { document: i } = this, r = (await i.canvg.parser.load(e)).getElementsByTagName("font");
      Array.from(r).forEach((o) => {
        const l = i.createElement(o);
        i.definitions[t] = l;
      });
    } catch (i) {
      console.error('Error while loading font "'.concat(e, '":'), i);
    }
    this.loaded = !0;
  }
  constructor(t) {
    this.document = t, this.loaded = !1, t.fonts.push(this);
  }
}
class nw extends sn {
  constructor(t, e, i) {
    super(t, e, i), this.type = "style", Dl(
      Array.from(e.childNodes).map(
        (o) => o.textContent
      ).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    ).split("}").forEach((o) => {
      const l = o.trim();
      if (!l)
        return;
      const h = l.split("{"), u = h[0].split(","), f = h[1].split(";");
      u.forEach((g) => {
        const y = g.trim();
        if (!y)
          return;
        const _ = t.styles[y] || {};
        if (f.forEach((x) => {
          const b = x.indexOf(":"), I = x.substr(0, b).trim(), C = x.substr(b + 1, x.length - b).trim();
          I && C && (_[I] = new se(t, I, C));
        }), t.styles[y] = _, t.stylesSpecificity[y] = WI(y), y === "@font-face") {
          const x = _["font-family"].getString().replace(/"|'/g, "");
          _.src.getString().split(",").forEach((I) => {
            if (I.indexOf('format("svg")') > 0) {
              const C = qy(I);
              C && new MC(t).load(x, C);
            }
          });
        }
      });
    });
  }
}
nw.parseExternalUrl = qy;
class PC extends Fa {
  setContext(t) {
    super.setContext(t);
    const e = this.getAttribute("x"), i = this.getAttribute("y");
    e.hasValue() && t.translate(e.getPixels("x"), 0), i.hasValue() && t.translate(0, i.getPixels("y"));
  }
  path(t) {
    const { element: e } = this;
    e && e.path(t);
  }
  renderChildren(t) {
    const { document: e, element: i } = this;
    if (i) {
      let n = i;
      if (i.type === "symbol" && (n = new Lh(e), n.attributes.viewBox = new se(e, "viewBox", i.getAttribute("viewBox").getString()), n.attributes.preserveAspectRatio = new se(e, "preserveAspectRatio", i.getAttribute("preserveAspectRatio").getString()), n.attributes.overflow = new se(e, "overflow", i.getAttribute("overflow").getString()), n.children = i.children, i.styles.opacity = new se(e, "opacity", this.calculateOpacity())), n.type === "svg") {
        const o = this.getStyle("width", !1, !0), l = this.getStyle("height", !1, !0);
        o.hasValue() && (n.attributes.width = new se(e, "width", o.getString())), l.hasValue() && (n.attributes.height = new se(e, "height", l.getString()));
      }
      const r = n.parent;
      n.parent = this, n.render(t), n.parent = r;
    }
  }
  getBoundingBox(t) {
    const { element: e } = this;
    return e ? e.getBoundingBox(t) : null;
  }
  elementTransform() {
    const { document: t, element: e } = this;
    return e ? Oa.fromElement(t, e) : null;
  }
  get element() {
    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;
  }
  constructor(...t) {
    super(...t), this.type = "use";
  }
}
function _u(s, t, e, i, n, r) {
  return s[e * i * 4 + t * 4 + r];
}
function yu(s, t, e, i, n, r, o) {
  s[e * i * 4 + t * 4 + r] = o;
}
function gn(s, t, e) {
  return s[t] * e;
}
function eo(s, t, e, i) {
  return t + Math.cos(s) * e + Math.sin(s) * i;
}
class sw extends sn {
  apply(t, e, i, n, r) {
    const { includeOpacity: o, matrix: l } = this, h = t.getImageData(0, 0, n, r);
    for (let u = 0; u < r; u++)
      for (let f = 0; f < n; f++) {
        const g = _u(h.data, f, u, n, r, 0), y = _u(h.data, f, u, n, r, 1), _ = _u(h.data, f, u, n, r, 2), x = _u(h.data, f, u, n, r, 3);
        let b = gn(l, 0, g) + gn(l, 1, y) + gn(l, 2, _) + gn(l, 3, x) + gn(l, 4, 1), I = gn(l, 5, g) + gn(l, 6, y) + gn(l, 7, _) + gn(l, 8, x) + gn(l, 9, 1), C = gn(l, 10, g) + gn(l, 11, y) + gn(l, 12, _) + gn(l, 13, x) + gn(l, 14, 1), M = gn(l, 15, g) + gn(l, 16, y) + gn(l, 17, _) + gn(l, 18, x) + gn(l, 19, 1);
        o && (b = 0, I = 0, C = 0, M *= x / 255), yu(h.data, f, u, n, r, 0, b), yu(h.data, f, u, n, r, 1, I), yu(h.data, f, u, n, r, 2, C), yu(h.data, f, u, n, r, 3, M);
      }
    t.clearRect(0, 0, n, r), t.putImageData(h, 0, 0);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feColorMatrix";
    let n = Fs(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        const r = n[0];
        n = [
          0.213 + 0.787 * r,
          0.715 - 0.715 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 + 0.285 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 - 0.715 * r,
          0.072 + 0.928 * r,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "hueRotate": {
        const r = n[0] * Math.PI / 180;
        n = [
          eo(r, 0.213, 0.787, -0.213),
          eo(r, 0.715, -0.715, -0.715),
          eo(r, 0.072, -0.072, 0.928),
          0,
          0,
          eo(r, 0.213, -0.213, 0.143),
          eo(r, 0.715, 0.285, 0.14),
          eo(r, 0.072, -0.072, -0.283),
          0,
          0,
          eo(r, 0.213, -0.213, -0.787),
          eo(r, 0.715, -0.715, 0.715),
          eo(r, 0.072, 0.928, 0.072),
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "luminanceToAlpha":
        n = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0.2125,
          0.7154,
          0.0721,
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
    }
    this.matrix = n, this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
}
class Id extends sn {
  apply(t, e) {
    const { document: i } = this;
    let n = this.getAttribute("x").getPixels("x"), r = this.getAttribute("y").getPixels("y"), o = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y");
    if (!o && !l) {
      const _ = new br();
      this.children.forEach((x) => {
        _.addBoundingBox(x.getBoundingBox(t));
      }), n = Math.floor(_.x1), r = Math.floor(_.y1), o = Math.floor(_.width), l = Math.floor(_.height);
    }
    const h = this.removeStyles(e, Id.ignoreStyles), u = i.createCanvas(n + o, r + l), f = u.getContext("2d");
    i.screen.setDefaults(f), this.renderChildren(f), new sw(i, {
      nodeType: 1,
      childNodes: [],
      attributes: [
        {
          nodeName: "type",
          value: "luminanceToAlpha"
        },
        {
          nodeName: "includeOpacity",
          value: "true"
        }
      ]
    }).apply(f, 0, 0, n + o, r + l);
    const g = i.createCanvas(n + o, r + l), y = g.getContext("2d");
    i.screen.setDefaults(y), e.render(y), y.globalCompositeOperation = "destination-in", y.fillStyle = f.createPattern(u, "no-repeat"), y.fillRect(0, 0, n + o, r + l), t.fillStyle = y.createPattern(g, "no-repeat"), t.fillRect(0, 0, n + o, r + l), this.restoreStyles(e, h);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "mask";
  }
}
Id.ignoreStyles = [
  "mask",
  "transform",
  "clip-path"
];
const wm = () => {
};
class kC extends sn {
  apply(t) {
    const { document: e } = this, i = Reflect.getPrototypeOf(t), { beginPath: n, closePath: r } = t;
    i && (i.beginPath = wm, i.closePath = wm), Reflect.apply(n, t, []), this.children.forEach((o) => {
      if (!("path" in o))
        return;
      let l = "elementTransform" in o ? o.elementTransform() : null;
      l || (l = Oa.fromElement(e, o)), l && l.apply(t), o.path(t), i && (i.closePath = r), l && l.unapply(t);
    }), Reflect.apply(r, t, []), t.clip(), i && (i.beginPath = n, i.closePath = r);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "clipPath";
  }
}
class Cd extends sn {
  apply(t, e) {
    const { document: i, children: n } = this, r = "getBoundingBox" in e ? e.getBoundingBox(t) : null;
    if (!r)
      return;
    let o = 0, l = 0;
    n.forEach((C) => {
      const M = C.extraFilterDistance || 0;
      o = Math.max(o, M), l = Math.max(l, M);
    });
    const h = Math.floor(r.width), u = Math.floor(r.height), f = h + 2 * o, g = u + 2 * l;
    if (f < 1 || g < 1)
      return;
    const y = Math.floor(r.x), _ = Math.floor(r.y), x = this.removeStyles(e, Cd.ignoreStyles), b = i.createCanvas(f, g), I = b.getContext("2d");
    i.screen.setDefaults(I), I.translate(-y + o, -_ + l), e.render(I), n.forEach((C) => {
      typeof C.apply == "function" && C.apply(I, 0, 0, f, g);
    }), t.drawImage(b, 0, 0, f, g, y - o, _ - l, f, g), this.restoreStyles(e, x);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "filter";
  }
}
Cd.ignoreStyles = [
  "filter",
  "transform",
  "clip-path"
];
class EC extends sn {
  apply(t, e, i, n, r) {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feDropShadow", this.addStylesFromStyleDefinition();
  }
}
class AC extends sn {
  apply(t, e, i, n, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feMorphology";
  }
}
class TC extends sn {
  apply(t, e, i, n, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feComposite";
  }
}
class DC extends sn {
  apply(t, e, i, n, r) {
    const { document: o, blurRadius: l } = this, h = o.window ? o.window.document.body : null, u = t.canvas;
    u.id = o.getUniqueId(), h && (u.style.display = "none", h.appendChild(u)), EI(u, e, i, n, r, l), h && h.removeChild(u);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feGaussianBlur", this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber()), this.extraFilterDistance = this.blurRadius;
  }
}
class NC extends sn {
  constructor(...t) {
    super(...t), this.type = "title";
  }
}
class OC extends sn {
  constructor(...t) {
    super(...t), this.type = "desc";
  }
}
const RC = {
  svg: Lh,
  rect: Zy,
  circle: aC,
  ellipse: lC,
  line: cC,
  polyline: Qy,
  polygon: hC,
  path: wi,
  pattern: uC,
  marker: dC,
  defs: fC,
  linearGradient: gC,
  radialGradient: pC,
  stop: mC,
  animate: Og,
  animateColor: _C,
  animateTransform: yC,
  font: wC,
  "font-face": ew,
  "missing-glyph": iw,
  glyph: Rg,
  text: $o,
  tspan: xd,
  tref: vC,
  a: bC,
  textPath: xC,
  image: CC,
  g: Ng,
  symbol: SC,
  style: nw,
  use: PC,
  mask: Id,
  clipPath: kC,
  filter: Cd,
  feDropShadow: EC,
  feMorphology: AC,
  feComposite: TC,
  feColorMatrix: sw,
  feGaussianBlur: DC,
  title: NC,
  desc: OC
};
function LC(s, t) {
  const e = document.createElement("canvas");
  return e.width = s, e.height = t, e;
}
async function FC(s) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const e = document.createElement("img");
  return t && (e.crossOrigin = "Anonymous"), new Promise((i, n) => {
    e.onload = () => {
      i(e);
    }, e.onerror = (r, o, l, h, u) => {
      n(u);
    }, e.src = s;
  });
}
const gf = 12;
class Bo {
  bindCreateImage(t, e) {
    return typeof e == "boolean" ? (i, n) => t(i, typeof n == "boolean" ? n : e) : t;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    const { emSizeStack: t } = this;
    return t[t.length - 1] || gf;
  }
  set emSize(t) {
    const { emSizeStack: e } = this;
    e.push(t);
  }
  popEmSize() {
    const { emSizeStack: t } = this;
    t.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every(
      (t) => t.loaded
    );
  }
  isFontsLoaded() {
    return this.fonts.every(
      (t) => t.loaded
    );
  }
  createDocumentElement(t) {
    const e = this.createElement(t.documentElement);
    return e.root = !0, e.addStylesFromStyleDefinition(), this.documentElement = e, e;
  }
  createElement(t) {
    const e = t.nodeName.replace(/^[^:]+:/, ""), i = Bo.elementTypes[e];
    return i ? new i(this, t) : new eC(this, t);
  }
  createTextNode(t) {
    return new oC(this, t);
  }
  setViewBox(t) {
    this.screen.setViewBox({
      document: this,
      ...t
    });
  }
  constructor(t, { rootEmSize: e = gf, emSize: i = gf, createCanvas: n = Bo.createCanvas, createImage: r = Bo.createImage, anonymousCrossOrigin: o } = {}) {
    this.canvg = t, this.definitions = {}, this.styles = {}, this.stylesSpecificity = {}, this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = t.screen, this.rootEmSize = e, this.emSize = i, this.createCanvas = n, this.createImage = this.bindCreateImage(r, o), this.screen.wait(
      () => this.isImagesLoaded()
    ), this.screen.wait(
      () => this.isFontsLoaded()
    );
  }
}
Bo.createCanvas = LC;
Bo.createImage = FC;
Bo.elementTypes = RC;
class ma {
  /**
  * Create Canvg instance from SVG source string or URL.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static async from(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = await new ff(i).parse(e);
    return new ma(t, r, i);
  }
  /**
  * Create Canvg instance from SVG source string.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static fromString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = new ff(i).parseFromString(e);
    return new ma(t, r, i);
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  fork(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ma.from(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  forkString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ma.fromString(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Document is ready promise.
  * @returns Ready promise.
  */
  ready() {
    return this.screen.ready();
  }
  /**
  * Document is ready value.
  * @returns Is ready or not.
  */
  isReady() {
    return this.screen.isReady();
  }
  /**
  * Render only first frame, ignoring animations and mouse.
  * @param options - Rendering options.
  */
  async render() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.start({
      enableRedraw: !0,
      ignoreAnimation: !0,
      ignoreMouse: !0,
      ...t
    }), await this.ready(), this.stop();
  }
  /**
  * Start rendering.
  * @param options - Render options.
  */
  start() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { documentElement: e, screen: i, options: n } = this;
    i.start(e, {
      enableRedraw: !0,
      ...n,
      ...t
    });
  }
  /**
  * Stop rendering.
  */
  stop() {
    this.screen.stop();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    this.documentElement.resize(t, e, i);
  }
  /**
  * Main constructor.
  * @param ctx - Rendering context.
  * @param svg - SVG Document.
  * @param options - Rendering options.
  */
  constructor(t, e, i = {}) {
    this.parser = new ff(i), this.screen = new po(t, i), this.options = i;
    const n = new Bo(this, i), r = n.createDocumentElement(e);
    this.document = n, this.documentElement = r;
  }
}
(function(s, t, e, i, n, r) {
  function o(v, S, E, V, Y) {
    return _(v, v, E, V, S, v.defaultView.pageXOffset, v.defaultView.pageYOffset).then(function(tt) {
      R("Document cloned");
      var Pt = "data-html2canvas-node" + Y, _t = "[" + Pt + "='" + Y + "']";
      v.querySelector(_t).removeAttribute(Pt);
      var Pt = tt.contentWindow, zt = Pt.document.querySelector(_t);
      return (typeof S.onclone == "function" ? Promise.resolve(S.onclone(Pt.document)) : Promise.resolve(!0)).then(function() {
        return l(zt, tt, S, E, V);
      });
    });
  }
  function l(v, S, E, V, Y) {
    var tt = S.contentWindow, _t = new Bn(tt.document), Pt = new $(E, _t), zt = ot(v);
    V = E.type === "view" ? V : u(tt.document), Y = E.type === "view" ? Y : f(tt.document);
    var me = new E.renderer(V, Y, Pt, E, t);
    return new St(v, me, _t, Pt, E).ready.then(function() {
      R("Finished rendering");
      var ni;
      return ni = E.type === "view" ? h(me.canvas, {
        width: me.canvas.width,
        height: me.canvas.height,
        top: 0,
        left: 0,
        x: 0,
        y: 0
      }) : v === tt.document.body || v === tt.document.documentElement || E.canvas != null ? me.canvas : h(me.canvas, {
        width: E.width != null ? E.width : zt.width,
        height: E.height != null ? E.height : zt.height,
        top: zt.top,
        left: zt.left,
        x: tt.pageXOffset,
        y: tt.pageYOffset
      }), E.removeContainer && (S.parentNode.removeChild(S), R("Cleaned up container")), ni;
    });
  }
  function h(v, S) {
    var E = t.createElement("canvas"), V = Math.min(v.width - 1, Math.max(0, S.left)), Y = Math.min(v.width, Math.max(1, S.left + S.width)), tt = Math.min(v.height - 1, Math.max(0, S.top)), _t = Math.min(v.height, Math.max(1, S.top + S.height));
    return E.width = S.width, E.height = S.height, R("Cropping canvas at:", "left:", S.left, "top:", S.top, "width:", Y - V, "height:", _t - tt), R("Resulting crop with width", S.width, "and height", S.height, " with x", V, "and y", tt), E.getContext("2d").drawImage(v, V, tt, Y - V, _t - tt, S.x, S.y, Y - V, _t - tt), E;
  }
  function u(v) {
    return Math.max(
      Math.max(v.body.scrollWidth, v.documentElement.scrollWidth),
      Math.max(v.body.offsetWidth, v.documentElement.offsetWidth),
      Math.max(v.body.clientWidth, v.documentElement.clientWidth)
    );
  }
  function f(v) {
    return Math.max(
      Math.max(v.body.scrollHeight, v.documentElement.scrollHeight),
      Math.max(v.body.offsetHeight, v.documentElement.offsetHeight),
      Math.max(v.body.clientHeight, v.documentElement.clientHeight)
    );
  }
  function g() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  }
  function y(v, S) {
    for (var E = v.nodeType === 3 ? t.createTextNode(v.nodeValue) : v.cloneNode(!1), V = v.firstChild; V; )
      S !== !0 && V.nodeType === 1 && V.nodeName === "SCRIPT" || E.appendChild(y(V, S)), V = V.nextSibling;
    return E;
  }
  function _(v, S, E, V, Y, tt, _t) {
    C(v);
    var Pt = t.documentMode && 9 >= t.documentMode ? y(v.documentElement, Y.javascriptEnabled) : v.documentElement.cloneNode(!0), zt = S.createElement("iframe");
    return zt.className = "html2canvas-container", zt.style.visibility = "hidden", zt.style.position = "fixed", zt.style.left = "-10000px", zt.style.top = "0px", zt.style.border = "0", zt.width = E, zt.height = V, zt.scrolling = "no", S.body.appendChild(zt), new Promise(function(me) {
      var ni = zt.contentWindow.document;
      x(v.documentElement, Pt, "textarea"), x(v.documentElement, Pt, "select"), zt.contentWindow.onload = zt.onload = function() {
        var Wi = setInterval(function() {
          0 < ni.body.childNodes.length && (M(v, ni), clearInterval(Wi), Y.type === "view" && zt.contentWindow.scrollTo(tt, _t), me(zt));
        }, 50);
      }, ni.open(), ni.write("<!DOCTYPE html><html></html>"), !v.defaultView || tt === v.defaultView.pageXOffset && _t === v.defaultView.pageYOffset || v.defaultView.scrollTo(tt, _t), ni.replaceChild(
        Y.javascriptEnabled === !0 ? ni.adoptNode(Pt) : P(ni.adoptNode(Pt)),
        ni.documentElement
      ), ni.close();
    });
  }
  function x(v, S, E) {
    v = v.getElementsByTagName(E), S = S.getElementsByTagName(E), E = v.length;
    for (var V = 0; V < E; V++) S[V].value = v[V].value;
  }
  function b(v, S, E, V, Y, tt) {
    return new cn(v, S, s.document).then(I(v)).then(function(_t) {
      return _(_t, E, V, Y, tt, 0, 0);
    });
  }
  function I(v) {
    return function(S) {
      var E = new DOMParser(), V;
      try {
        V = E.parseFromString(S, "text/html");
      } catch {
        R("DOMParser not supported, falling back to createHTMLDocument"), V = t.implementation.createHTMLDocument("");
        try {
          V.open(), V.write(S), V.close();
        } catch {
          R("createHTMLDocument write not supported, falling back to document.body.innerHTML"), V.body.innerHTML = S;
        }
      }
      return S = V.querySelector("base"), S && S.href.host || (S = V.createElement("base"), S.href = v, V.head.insertBefore(S, V.head.firstChild)), V;
    };
  }
  function C(v) {
    [].slice.call(v.querySelectorAll("canvas"), 0).forEach(function(S) {
      S.setAttribute("data-html2canvas-canvas-clone", "canvas-" + Fh++);
    });
  }
  function M(v, S) {
    [].slice.call(v.querySelectorAll("[data-html2canvas-canvas-clone]"), 0).forEach(function(E) {
      try {
        var V = S.querySelector(
          '[data-html2canvas-canvas-clone="' + E.getAttribute("data-html2canvas-canvas-clone") + '"]'
        );
        V && (V.width = E.width, V.height = E.height, V.getContext("2d").putImageData(E.getContext("2d").getImageData(0, 0, E.width, E.height), 0, 0));
      } catch (Y) {
        R("Unable to copy canvas content from", E, Y);
      }
      E.removeAttribute("data-html2canvas-canvas-clone");
    });
  }
  function P(v) {
    return [].slice.call(v.childNodes, 0).filter(O).forEach(function(S) {
      S.tagName === "SCRIPT" ? v.removeChild(S) : P(S);
    }), v;
  }
  function O(v) {
    return v.nodeType === Node.ELEMENT_NODE;
  }
  function B(v) {
    var S = t.createElement("a");
    return S.href = v, S.href = S.href, S;
  }
  function j(v) {
    this.b = this.g = this.r = 0, this.a = null, this.fromArray(v) || this.namedColor(v) || this.rgb(v) || this.rgba(v) || this.hex6(v) || this.hex3(v);
  }
  function F(v) {
    if (this.src = v, R("DummyImageContainer for", v), !this.promise || !this.image) {
      R("Initiating DummyImageContainer"), F.prototype.image = new Image();
      var S = this.image;
      F.prototype.promise = new Promise(function(E, V) {
        S.onload = E, S.onerror = V, S.src = g(), S.complete === !0 && E(S);
      });
    }
  }
  function K(v, S) {
    var E = t.createElement("div"), V = t.createElement("img"), Y = t.createElement("span"), tt;
    E.style.visibility = "hidden", E.style.fontFamily = v, E.style.fontSize = S, E.style.margin = 0, E.style.padding = 0, t.body.appendChild(E), V.src = g(), V.width = 1, V.height = 1, V.style.margin = 0, V.style.padding = 0, V.style.verticalAlign = "baseline", Y.style.fontFamily = v, Y.style.fontSize = S, Y.style.margin = 0, Y.style.padding = 0, Y.appendChild(t.createTextNode("Hidden Text")), E.appendChild(Y), E.appendChild(V), tt = V.offsetTop - Y.offsetTop + 1, E.removeChild(Y), E.appendChild(t.createTextNode("Hidden Text")), E.style.lineHeight = "normal", V.style.verticalAlign = "super", V = V.offsetTop - E.offsetTop + 1, t.body.removeChild(E), this.baseline = tt, this.lineWidth = 1, this.middle = V;
  }
  function J() {
    this.data = {};
  }
  function rt(v, S, E) {
    this.image = null, this.src = v;
    var V = this, Y = ot(v);
    this.promise = (S ? new Promise(function(tt) {
      v.contentWindow.document.URL === "about:blank" || v.contentWindow.document.documentElement == null ? v.contentWindow.onload = v.onload = function() {
        tt(v);
      } : tt(v);
    }) : this.proxyLoad(E.proxy, Y, E)).then(function(tt) {
      return html2canvas(tt.contentWindow.document.documentElement, {
        type: "view",
        width: tt.width,
        height: tt.height,
        proxy: E.proxy,
        javascriptEnabled: E.javascriptEnabled,
        removeContainer: E.removeContainer,
        allowTaint: E.allowTaint,
        imageTimeout: E.imageTimeout / 2
      });
    }).then(function(tt) {
      return V.image = tt;
    });
  }
  function ft(v) {
    this.src = v.value, this.colorStops = [], this.type = null, this.y1 = this.x1 = this.y0 = this.x0 = 0.5, this.promise = Promise.resolve(!0);
  }
  function H(v, S) {
    this.src = v, this.image = new Image();
    var E = this;
    this.tainted = null, this.promise = new Promise(function(V, Y) {
      E.image.onload = V, E.image.onerror = Y, S && (E.image.crossOrigin = "anonymous"), E.image.src = v, E.image.complete === !0 && V(E.image);
    });
  }
  function $(v, S) {
    this.link = null, this.options = v, this.support = S, this.origin = this.getOrigin(s.location.href);
  }
  function D(v) {
    ft.apply(this, arguments), this.type = this.TYPES.LINEAR;
    var S = v.args[0].match(this.stepRegExp) === null;
    S ? v.args[0].split(" ").reverse().forEach(function(E) {
      switch (E) {
        case "left":
          this.x0 = 0, this.x1 = 1;
          break;
        case "top":
          this.y0 = 0, this.y1 = 1;
          break;
        case "right":
          this.x0 = 1, this.x1 = 0;
          break;
        case "bottom":
          this.y0 = 1, this.y1 = 0;
          break;
        case "to":
          E = this.y0;
          var V = this.x0;
          this.y0 = this.y1, this.x0 = this.x1, this.x1 = V, this.y1 = E;
      }
    }, this) : (this.y0 = 0, this.y1 = 1), this.colorStops = v.args.slice(S ? 1 : 0).map(function(E) {
      return E = E.match(this.stepRegExp), { color: new j(E[1]), stop: E[3] === "%" ? E[2] / 100 : null };
    }, this), this.colorStops[0].stop === null && (this.colorStops[0].stop = 0), this.colorStops[this.colorStops.length - 1].stop === null && (this.colorStops[this.colorStops.length - 1].stop = 1), this.colorStops.forEach(function(E, V) {
      E.stop === null && this.colorStops.slice(V).some(function(Y, tt) {
        return Y.stop !== null ? (E.stop = (Y.stop - this.colorStops[V - 1].stop) / (tt + 1) + this.colorStops[V - 1].stop, !0) : !1;
      }, this);
    }, this);
  }
  function R() {
    s.html2canvas.logging && s.console && s.console.log && Function.prototype.bind.call(s.console.log, s.console).apply(
      s.console,
      [Date.now() - s.html2canvas.start + "ms", "html2canvas:"].concat(
        [].slice.call(arguments, 0)
      )
    );
  }
  function U(v, S) {
    this.node = v, this.parent = S, this.borders = this.bounds = this.stack = null, this.clip = [], this.backgroundClip = [], this.computedStyles = this.visible = this.offsetBounds = null, this.colors = {}, this.styles = {}, this.transformMatrix = this.transformData = this.backgroundImages = null, this.isPseudoElement = !1, this.opacity = null;
  }
  function it(v) {
    if (v && v[1] === "matrix")
      return v[2].split(",").map(function(S) {
        return parseFloat(S.trim());
      });
  }
  function at(v) {
    return v.toString().indexOf("%") !== -1;
  }
  function mt(v) {
    var S, E, V, Y, tt, _t = [], Pt = 0, zt = 0, me, ni, Wi = function() {
      S && (E.substr(0, 1) === '"' && (E = E.substr(1, E.length - 2)), E && ni.push(E), S.substr(0, 1) === "-" && 0 < (Y = S.indexOf("-", 1) + 1) && (V = S.substr(0, Y), S = S.substr(Y)), _t.push({ prefix: V, method: S.toLowerCase(), value: tt, args: ni, image: null })), ni = [], S = V = E = tt = "";
    };
    return ni = [], S = V = E = tt = "", v.split("").forEach(function(bi) {
      if (!(Pt === 0 && -1 < ` \r
	`.indexOf(bi))) {
        switch (bi) {
          case '"':
            me ? me === bi && (me = null) : me = bi;
            break;
          case "(":
            if (!me) {
              if (Pt === 0) {
                Pt = 1, tt += bi;
                return;
              }
              zt++;
            }
            break;
          case ")":
            if (!me && Pt === 1) {
              if (zt === 0) {
                Pt = 0, tt += bi, Wi();
                return;
              }
              zt--;
            }
            break;
          case ",":
            if (!me) {
              if (Pt === 0) {
                Wi();
                return;
              }
              if (Pt === 1 && zt === 0 && !S.match(/^url$/i)) {
                ni.push(E), E = "", tt += bi;
                return;
              }
            }
        }
        tt += bi, Pt === 0 ? S += bi : E += bi;
      }
    }), Wi(), _t;
  }
  function Nt(v) {
    return v.replace("px", "");
  }
  function lt(v) {
    return parseFloat(v);
  }
  function ot(v) {
    if (v.getBoundingClientRect) {
      var S = v.getBoundingClientRect(), E = v.offsetWidth == null ? S.width : v.offsetWidth;
      return {
        top: S.top,
        bottom: S.bottom || S.top + S.height,
        right: S.left + E,
        left: S.left,
        width: E,
        height: v.offsetHeight == null ? S.height : v.offsetHeight
      };
    }
    return {};
  }
  function Ht(v) {
    var S = v.offsetParent ? Ht(v.offsetParent) : { top: 0, left: 0 };
    return {
      top: v.offsetTop + S.top,
      bottom: v.offsetTop + v.offsetHeight + S.top,
      right: v.offsetLeft + S.left + v.offsetWidth,
      left: v.offsetLeft + S.left,
      width: v.offsetWidth,
      height: v.offsetHeight
    };
  }
  function St(v, S, E, V, Y) {
    if (R("Starting NodeParser"), this.renderer = S, this.options = Y, this.range = null, this.support = E, this.renderQueue = [], this.stack = new qn(!0, 1, v.ownerDocument, null), E = new U(v, null), Y.background && S.rectangle(0, 0, S.width, S.height, new j(Y.background)), v === v.ownerDocument.documentElement) {
      var tt = new U(
        E.color("backgroundColor").isTransparent() ? v.ownerDocument.body : v.ownerDocument.documentElement,
        null
      );
      S.rectangle(0, 0, S.width, S.height, tt.color("backgroundColor"));
    }
    E.visibile = E.isElementVisible(), this.createPseudoHideStyles(v.ownerDocument), this.disableAnimations(v.ownerDocument), this.nodes = [].concat.apply(
      [],
      [E].concat(this.getChildren(E)).filter(function(_t) {
        return _t.visible = _t.isElementVisible();
      }).map(this.getPseudoElements, this)
    ), this.fontMetrics = new J(), R("Fetched nodes, total:", this.nodes.length), R("Calculate overflow clips"), this.calculateOverflowClips(), R("Start fetching images"), this.images = V.fetch(this.nodes.filter(kt)), this.ready = this.images.ready.then(
      Yt(function() {
        return R("Images loaded, starting parsing"), R("Creating stacking contexts"), this.createStackingContexts(), R("Sorting stacking contexts"), this.sortStackingContexts(this.stack), this.parse(this.stack), R("Render queue created with " + this.renderQueue.length + " items"), new Promise(
          Yt(function(_t) {
            Y.async ? typeof Y.async == "function" ? Y.async.call(this, this.renderQueue, _t) : 0 < this.renderQueue.length ? (this.renderIndex = 0, this.asyncRenderer(this.renderQueue, _t)) : _t() : (this.renderQueue.forEach(this.paint, this), _t());
          }, this)
        );
      }, this)
    );
  }
  function Rt(v) {
    return v.replace(/(\-[a-z])/g, function(S) {
      return S.toUpperCase().replace("-", "");
    });
  }
  function ei() {
  }
  function ai(v, S, E, V) {
    return v.map(function(Y, tt) {
      if (0 < Y.width) {
        var _t = S.left, Pt = S.top, zt = S.width, me = S.height - v[2].width;
        switch (tt) {
          case 0:
            me = v[0].width, Y.args = pe(
              {
                c1: [_t, Pt],
                c2: [_t + zt, Pt],
                c3: [_t + zt - v[1].width, Pt + me],
                c4: [_t + v[3].width, Pt + me]
              },
              V[0],
              V[1],
              E.topLeftOuter,
              E.topLeftInner,
              E.topRightOuter,
              E.topRightInner
            );
            break;
          case 1:
            _t = S.left + S.width - v[1].width, zt = v[1].width, Y.args = pe(
              {
                c1: [_t + zt, Pt],
                c2: [_t + zt, Pt + me + v[2].width],
                c3: [_t, Pt + me],
                c4: [_t, Pt + v[0].width]
              },
              V[1],
              V[2],
              E.topRightOuter,
              E.topRightInner,
              E.bottomRightOuter,
              E.bottomRightInner
            );
            break;
          case 2:
            Pt = Pt + S.height - v[2].width, me = v[2].width, Y.args = pe(
              {
                c1: [_t + zt, Pt + me],
                c2: [_t, Pt + me],
                c3: [_t + v[3].width, Pt],
                c4: [_t + zt - v[3].width, Pt]
              },
              V[2],
              V[3],
              E.bottomRightOuter,
              E.bottomRightInner,
              E.bottomLeftOuter,
              E.bottomLeftInner
            );
            break;
          case 3:
            zt = v[3].width, Y.args = pe(
              {
                c1: [_t, Pt + me + v[2].width],
                c2: [_t, Pt],
                c3: [_t + zt, Pt + v[0].width],
                c4: [_t + zt, Pt + me]
              },
              V[3],
              V[0],
              E.bottomLeftOuter,
              E.bottomLeftInner,
              E.topLeftOuter,
              E.topLeftInner
            );
        }
      }
      return Y;
    });
  }
  function re(v, S, E, V) {
    var tt = (Math.sqrt(2) - 1) / 3 * 4, Y = E * tt, tt = V * tt;
    return E = v + E, V = S + V, {
      topLeft: Be({ x: v, y: V }, { x: v, y: V - tt }, { x: E - Y, y: S }, { x: E, y: S }),
      topRight: Be({ x: v, y: S }, { x: v + Y, y: S }, { x: E, y: V - tt }, { x: E, y: V }),
      bottomRight: Be({ x: E, y: S }, { x: E, y: S + tt }, { x: v + Y, y: V }, { x: v, y: V }),
      bottomLeft: Be({ x: E, y: V }, { x: E - Y, y: V }, { x: v, y: S + tt }, { x: v, y: S })
    };
  }
  function Se(v, S, E) {
    var V = v.left, Y = v.top, tt = v.width;
    v = v.height;
    var _t = S[0][0], Pt = S[0][1], zt = S[1][0], me = S[1][1], ni = S[2][0], Wi = S[2][1], bi = S[3][0];
    S = S[3][1];
    var Gi = tt - zt, Ai = v - Wi, hn = tt - ni, Us = v - S;
    return {
      topLeftOuter: re(V, Y, _t, Pt).topLeft.subdivide(0.5),
      topLeftInner: re(
        V + E[3].width,
        Y + E[0].width,
        Math.max(0, _t - E[3].width),
        Math.max(0, Pt - E[0].width)
      ).topLeft.subdivide(0.5),
      topRightOuter: re(V + Gi, Y, zt, me).topRight.subdivide(0.5),
      topRightInner: re(
        V + Math.min(Gi, tt + E[3].width),
        Y + E[0].width,
        Gi > tt + E[3].width ? 0 : zt - E[3].width,
        me - E[0].width
      ).topRight.subdivide(0.5),
      bottomRightOuter: re(V + hn, Y + Ai, ni, Wi).bottomRight.subdivide(0.5),
      bottomRightInner: re(
        V + Math.min(hn, tt - E[3].width),
        Y + Math.min(Ai, v + E[0].width),
        Math.max(0, ni - E[1].width),
        Wi - E[2].width
      ).bottomRight.subdivide(0.5),
      bottomLeftOuter: re(V, Y + Us, bi, S).bottomLeft.subdivide(0.5),
      bottomLeftInner: re(
        V + E[3].width,
        Y + Us,
        Math.max(0, bi - E[3].width),
        S - E[2].width
      ).bottomLeft.subdivide(0.5)
    };
  }
  function Be(v, S, E, V) {
    var Y = function(tt, _t, Pt) {
      return { x: tt.x + (_t.x - tt.x) * Pt, y: tt.y + (_t.y - tt.y) * Pt };
    };
    return {
      start: v,
      startControl: S,
      endControl: E,
      end: V,
      subdivide: function(tt) {
        var _t = Y(v, S, tt), me = Y(S, E, tt), Pt = Y(E, V, tt), zt = Y(_t, me, tt), me = Y(me, Pt, tt);
        return tt = Y(zt, me, tt), [Be(v, _t, zt, tt), Be(tt, me, Pt, V)];
      },
      curveTo: function(tt) {
        tt.push(["bezierCurve", S.x, S.y, E.x, E.y, V.x, V.y]);
      },
      curveToReversed: function(tt) {
        tt.push(["bezierCurve", E.x, E.y, S.x, S.y, v.x, v.y]);
      }
    };
  }
  function pe(v, S, E, V, Y, tt, _t) {
    var Pt = [];
    return 0 < S[0] || 0 < S[1] ? (Pt.push(["line", V[1].start.x, V[1].start.y]), V[1].curveTo(Pt)) : Pt.push(["line", v.c1[0], v.c1[1]]), 0 < E[0] || 0 < E[1] ? (Pt.push(["line", tt[0].start.x, tt[0].start.y]), tt[0].curveTo(Pt), Pt.push(["line", _t[0].end.x, _t[0].end.y]), _t[0].curveToReversed(Pt)) : (Pt.push(["line", v.c2[0], v.c2[1]]), Pt.push(["line", v.c3[0], v.c3[1]])), 0 < S[0] || 0 < S[1] ? (Pt.push(["line", Y[1].end.x, Y[1].end.y]), Y[1].curveToReversed(Pt)) : Pt.push(["line", v.c4[0], v.c4[1]]), Pt;
  }
  function ki(v, S, E, V, Y, tt, _t) {
    0 < S[0] || 0 < S[1] ? (v.push(["line", V[0].start.x, V[0].start.y]), V[0].curveTo(v), V[1].curveTo(v)) : v.push(["line", tt, _t]), (0 < E[0] || 0 < E[1]) && v.push(["line", Y[0].start.x, Y[0].start.y]);
  }
  function ii(v) {
    return 0 > v.cssInt("zIndex");
  }
  function T(v) {
    return 0 < v.cssInt("zIndex");
  }
  function vt(v) {
    return v.cssInt("zIndex") === 0;
  }
  function pt(v) {
    return ["inline", "inline-block", "inline-table"].indexOf(v.css("display")) !== -1;
  }
  function q(v) {
    return 0 < v.node.data.trim().length;
  }
  function W(v) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(S) {
      return S = v.css("border" + S + "Radius").split(" "), 1 >= S.length && (S[1] = S[0]), S.map(Ve);
    });
  }
  function st(v) {
    return v.nodeType === Node.TEXT_NODE || v.nodeType === Node.ELEMENT_NODE;
  }
  function xt(v) {
    return v.css("position") !== "static";
  }
  function It(v) {
    return v.css("float") !== "none";
  }
  function nt(v) {
    var S = this;
    return function() {
      return !v.apply(S, arguments);
    };
  }
  function kt(v) {
    return v.node.nodeType === Node.ELEMENT_NODE;
  }
  function Lt(v) {
    return v.node.nodeType === Node.TEXT_NODE;
  }
  function Tt(v) {
    return function(S, E) {
      return S.cssInt("zIndex") + v.indexOf(S) / v.length - (E.cssInt("zIndex") + v.indexOf(E) / v.length);
    };
  }
  function Yt(v, S) {
    return function() {
      return v.apply(S, arguments);
    };
  }
  function Ve(v) {
    return parseInt(v, 10);
  }
  function xe(v) {
    return v.width;
  }
  function Ri(v) {
    return v.node.nodeType !== Node.ELEMENT_NODE || "SCRIPT HEAD TITLE OBJECT BR OPTION".split(" ").indexOf(v.node.nodeName) === -1;
  }
  function Fn(v) {
    for (var S = [], E = 0, V = !1, Y; v.length; )
      [32, 13, 10, 9, 45].indexOf(v[E]) !== -1 === V ? (Y = v.splice(0, E), Y.length && S.push(s.html2canvas.punycode.ucs2.encode(Y)), V = !V, E = 0) : E++, E >= v.length && (Y = v.splice(0, E), Y.length && S.push(s.html2canvas.punycode.ucs2.encode(Y)));
    return S;
  }
  function cn(v, S, E) {
    if (!S) return Promise.reject("No proxy configured");
    var V = Vs(Rl);
    return v = zs(S, v, V), Rl ? Xr(v) : di(E, v, V).then(function(Y) {
      return Je(Y.content);
    });
  }
  function ns(v, S, E) {
    var V = Vs(Vn);
    return v = zs(S, v, V), Vn ? Promise.resolve(v) : di(E, v, V).then(function(Y) {
      return "data:" + Y.type + ";base64," + Y.content;
    });
  }
  function di(v, S, E) {
    return new Promise(function(V, Y) {
      var tt = v.createElement("script"), _t = function() {
        delete s.html2canvas.proxy[E], v.body.removeChild(tt);
      };
      s.html2canvas.proxy[E] = function(Pt) {
        _t(), V(Pt);
      }, tt.src = S, tt.onerror = function(Pt) {
        _t(), Y(Pt);
      }, v.body.appendChild(tt);
    });
  }
  function Vs(v) {
    var S = new Uint32Array(1);
    return (window.crypto || window.msCrypto).getRandomValues(S), v ? "" : "html2canvas_" + Date.now() + "_" + ++Ol + "_" + Math.round(1e5 * (S[0] / 4294967295));
  }
  function zs(v, S, E) {
    return v + "?url=" + encodeURIComponent(S) + (E.length ? "&callback=html2canvas.proxy." + E : "");
  }
  function te(v, S) {
    t.createElement("script");
    var E = t.createElement("a");
    E.href = v, this.src = v = E.href, this.image = new Image();
    var V = this;
    this.promise = new Promise(function(Y, tt) {
      V.image.crossOrigin = "Anonymous", V.image.onload = Y, V.image.onerror = tt, new ns(v, S, t).then(function(_t) {
        V.image.src = _t;
      }).catch(tt);
    });
  }
  function Ki(v, S, E) {
    U.call(this, v, S), this.isPseudoElement = !0, this.before = E === ":before";
  }
  function vn(v, S, E, V, Y) {
    this.width = v, this.height = S, this.images = E, this.options = V, this.document = Y;
  }
  function qn(v, S, E, V) {
    U.call(this, E, V), this.ownStacking = v, this.contexts = [], this.children = [], this.opacity = (this.parent ? this.parent.stack.opacity : 1) * S;
  }
  function Bn(v) {
    this.rangeBounds = this.testRangeBounds(v), this.cors = this.testCORS(), this.svg = this.testSVG();
  }
  function kn(v) {
    this.src = v, this.image = null;
    var S = this;
    this.promise = this.hasFabric().then(function() {
      return S.isInline(v) ? Promise.resolve(S.inlineFormatting(v)) : Xr(v);
    }).then(function(E) {
      return new Promise(function(V) {
        html2canvas.fabric.loadSVGFromString(E, S.createCanvas.call(S, V));
      });
    });
  }
  function Je(v) {
    var S = v.length, E, V, Y, tt, _t, Pt, zt = "";
    for (E = 0; E < S; E += 4)
      V = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(v[E]), Y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(v[E + 1]), tt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(v[E + 2]), _t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(v[E + 3]), V = V << 2 | Y >> 4, Y = (Y & 15) << 4 | tt >> 2, Pt = (tt & 3) << 6 | _t, zt = tt === 64 ? zt + String.fromCharCode(V) : _t === 64 || _t === -1 ? zt + String.fromCharCode(V, Y) : zt + String.fromCharCode(V, Y, Pt);
    return zt;
  }
  function xr(v, S) {
    this.src = v, this.image = null;
    var E = this;
    this.promise = S ? new Promise(function(V, Y) {
      E.image = new Image(), E.image.onload = V, E.image.onerror = Y, E.image.src = "data:image/svg+xml," + new XMLSerializer().serializeToString(v), E.image.complete === !0 && V(E.image);
    }) : this.hasFabric().then(function() {
      return new Promise(function(V) {
        html2canvas.fabric.parseSVGDocument(v, E.createCanvas.call(E, V));
      });
    });
  }
  function Ft(v, S) {
    U.call(this, v, S);
  }
  function Nl(v, S, E) {
    if (0 < v.length) return S + E.toUpperCase();
  }
  function Hs(v) {
    ft.apply(this, arguments), this.type = v.args[0] === "linear" ? this.TYPES.LINEAR : this.TYPES.RADIAL;
  }
  function Xr(v) {
    return new Promise(function(S, E) {
      var V = new XMLHttpRequest();
      V.open("GET", v), V.onload = function() {
        V.status === 200 ? S(V.responseText) : E(Error(V.statusText));
      }, V.onerror = function() {
        E(Error("Network Error"));
      }, V.send();
    });
  }
  function Ei(v, S) {
    vn.apply(this, arguments), this.canvas = this.options.canvas || this.document.createElement("canvas"), this.options.canvas || (this.canvas.width = v, this.canvas.height = S), this.ctx = this.canvas.getContext("2d"), this.taintCtx = this.document.createElement("canvas").getContext("2d"), this.ctx.textBaseline = "bottom", this.variables = {}, R("Initialized CanvasRenderer with size", v, "x", S);
  }
  function mo(v) {
    return 0 < v.length;
  }
  if ((function() {
    function v(dt, Ot) {
      Ti[ce] = dt, Ti[ce + 1] = Ot, ce += 2, ce === 2 && xi();
    }
    function S(dt) {
      return typeof dt == "function";
    }
    function E() {
      return function() {
        process.nextTick(_t);
      };
    }
    function V() {
      var dt = 0, Ot = new Ee(_t), Gt = t.createTextNode("");
      return Ot.observe(Gt, { characterData: !0 }), function() {
        Gt.data = dt = ++dt % 2;
      };
    }
    function Y() {
      var dt = new MessageChannel();
      return dt.port1.onmessage = _t, function() {
        dt.port2.postMessage(0);
      };
    }
    function tt() {
      return function() {
        setTimeout(_t, 1);
      };
    }
    function _t() {
      for (var dt = 0; dt < ce; dt += 2) (0, Ti[dt])(Ti[dt + 1]), Ti[dt] = void 0, Ti[dt + 1] = void 0;
      ce = 0;
    }
    function Pt() {
    }
    function zt(dt, Ot, Gt, de) {
      try {
        dt.call(Ot, Gt, de);
      } catch ($e) {
        return $e;
      }
    }
    function me(dt, Ot, Gt) {
      v(function(de) {
        var $e = !1, ze = zt(
          Gt,
          Ot,
          function(Xi) {
            $e || ($e = !0, Ot !== Xi ? Wi(de, Xi) : Gi(de, Xi));
          },
          function(Xi) {
            $e || ($e = !0, Ai(de, Xi));
          }
        );
        !$e && ze && ($e = !0, Ai(de, ze));
      }, dt);
    }
    function ni(dt, Ot) {
      Ot.a === 1 ? Gi(dt, Ot.b) : dt.a === 2 ? Ai(dt, Ot.b) : hn(
        Ot,
        void 0,
        function(Gt) {
          Wi(dt, Gt);
        },
        function(Gt) {
          Ai(dt, Gt);
        }
      );
    }
    function Wi(dt, Ot) {
      if (dt === Ot) Ai(dt, new TypeError("You cannot resolve a promise with itself"));
      else if (typeof Ot == "function" || typeof Ot == "object" && Ot !== null)
        if (Ot.constructor === dt.constructor) ni(dt, Ot);
        else {
          var Gt;
          try {
            Gt = Ot.then;
          } catch (de) {
            Ge.error = de, Gt = Ge;
          }
          Gt === Ge ? Ai(dt, Ge.error) : Gt === void 0 ? Gi(dt, Ot) : S(Gt) ? me(dt, Ot, Gt) : Gi(dt, Ot);
        }
      else Gi(dt, Ot);
    }
    function bi(dt) {
      dt.f && dt.f(dt.b), Us(dt);
    }
    function Gi(dt, Ot) {
      dt.a === void 0 && (dt.b = Ot, dt.a = 1, dt.e.length !== 0 && v(Us, dt));
    }
    function Ai(dt, Ot) {
      dt.a === void 0 && (dt.a = 2, dt.b = Ot, v(bi, dt));
    }
    function hn(dt, Ot, Gt, de) {
      var $e = dt.e, ze = $e.length;
      dt.f = null, $e[ze] = Ot, $e[ze + 1] = Gt, $e[ze + 2] = de, ze === 0 && dt.a && v(Us, dt);
    }
    function Us(dt) {
      var Ot = dt.e, Gt = dt.a;
      if (Ot.length !== 0) {
        for (var de, $e, ze = dt.b, Xi = 0; Xi < Ot.length; Xi += 3)
          de = Ot[Xi], $e = Ot[Xi + Gt], de ? Kn(Gt, de, $e, ze) : $e(ze);
        dt.e.length = 0;
      }
    }
    function Jo() {
      this.error = null;
    }
    function Kn(dt, Ot, Gt, de) {
      var $e = S(Gt), ze, Xi, js, Ll;
      if ($e) {
        try {
          ze = Gt(de);
        } catch (Ji) {
          fi.error = Ji, ze = fi;
        }
        if (ze === fi ? (Ll = !0, Xi = ze.error, ze = null) : js = !0, Ot === ze) {
          Ai(Ot, new TypeError("A promises callback cannot return that same promise."));
          return;
        }
      } else ze = de, js = !0;
      Ot.a === void 0 && ($e && js ? Wi(Ot, ze) : Ll ? Ai(Ot, Xi) : dt === 1 ? Gi(Ot, ze) : dt === 2 && Ai(Ot, ze));
    }
    function ss(dt, Ot) {
      try {
        Ot(
          function(Gt) {
            Wi(dt, Gt);
          },
          function(Gt) {
            Ai(dt, Gt);
          }
        );
      } catch (Gt) {
        Ai(dt, Gt);
      }
    }
    function un(dt, Ot, Gt, de) {
      this.n = dt, this.c = new dt(Pt, de), this.i = Gt, this.o(Ot) ? (this.m = Ot, this.d = this.length = Ot.length, this.l(), this.length === 0 ? Gi(this.c, this.b) : (this.length = this.length || 0, this.k(), this.d === 0 && Gi(this.c, this.b))) : Ai(this.c, this.p());
    }
    function Qt(dt) {
      if (this.b = this.a = void 0, this.e = [], Pt !== dt) {
        if (!S(dt))
          throw new TypeError(
            "You must pass a resolver function as the first argument to the promise constructor"
          );
        if (!(this instanceof Qt))
          throw new TypeError(
            "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
          );
        ss(this, dt);
      }
    }
    var ae = Array.isArray ? Array.isArray : function(dt) {
      return Object.prototype.toString.call(dt) === "[object Array]";
    }, ce = 0, mi = typeof s < "u" ? s : {}, Ee = mi.MutationObserver || mi.WebKitMutationObserver, mi = typeof Uint8ClampedArray < "u" && typeof importScripts < "u" && typeof MessageChannel < "u", Ti = Array(1e3), xi;
    xi = typeof process < "u" && {}.toString.call(process) === "[object process]" ? E() : Ee ? V() : mi ? Y() : tt();
    var Ge = new Jo(), fi = new Jo();
    un.prototype.o = function(dt) {
      return ae(dt);
    }, un.prototype.p = function() {
      return Error("Array Methods must be provided an Array");
    }, un.prototype.l = function() {
      this.b = Array(this.length);
    }, un.prototype.k = function() {
      for (var dt = this.length, Ot = this.c, Gt = this.m, de = 0; Ot.a === void 0 && de < dt; de++)
        this.j(Gt[de], de);
    }, un.prototype.j = function(dt, Ot) {
      var Gt = this.n;
      typeof dt == "object" && dt !== null ? dt.constructor === Gt && dt.a !== void 0 ? (dt.f = null, this.g(dt.a, Ot, dt.b)) : this.q(Gt.resolve(dt), Ot) : (this.d--, this.b[Ot] = this.h(dt));
    }, un.prototype.g = function(dt, Ot, Gt) {
      var de = this.c;
      de.a === void 0 && (this.d--, this.i && dt === 2 ? Ai(de, Gt) : this.b[Ot] = this.h(Gt)), this.d === 0 && Gi(de, this.b);
    }, un.prototype.h = function(dt) {
      return dt;
    }, un.prototype.q = function(dt, Ot) {
      var Gt = this;
      hn(
        dt,
        void 0,
        function(de) {
          Gt.g(1, Ot, de);
        },
        function(de) {
          Gt.g(2, Ot, de);
        }
      );
    }, Qt.all = function(dt, Ot) {
      return new un(this, dt, !0, Ot).c;
    }, Qt.race = function(dt, Ot) {
      function Gt(js) {
        Wi($e, js);
      }
      function de(js) {
        Ai($e, js);
      }
      var $e = new this(Pt, Ot);
      if (!ae(dt)) return Ai($e, new TypeError("You must pass an array to race.")), $e;
      for (var ze = dt.length, Xi = 0; $e.a === void 0 && Xi < ze; Xi++)
        hn(this.resolve(dt[Xi]), void 0, Gt, de);
      return $e;
    }, Qt.resolve = function(dt, Ot) {
      if (dt && typeof dt == "object" && dt.constructor === this) return dt;
      var Gt = new this(Pt, Ot);
      return Wi(Gt, dt), Gt;
    }, Qt.reject = function(dt, Ot) {
      var Gt = new this(Pt, Ot);
      return Ai(Gt, dt), Gt;
    }, Qt.prototype = {
      constructor: Qt,
      then: function(dt, Ot) {
        var Gt = this.a;
        if (Gt === 1 && !dt || Gt === 2 && !Ot) return this;
        var de = new this.constructor(Pt), $e = this.b;
        if (Gt) {
          var ze = arguments[Gt - 1];
          v(function() {
            Kn(Gt, de, ze, $e);
          });
        } else hn(this, de, dt, Ot);
        return de;
      },
      catch: function(dt) {
        return this.then(null, dt);
      }
    };
    var li = {
      Promise: Qt,
      polyfill: function() {
        var dt;
        dt = typeof i < "u" ? i : typeof s < "u" && s.document ? s : self, "Promise" in dt && "resolve" in dt.Promise && "reject" in dt.Promise && "all" in dt.Promise && "race" in dt.Promise && function() {
          var Ot;
          return new dt.Promise(function(Gt) {
            Ot = Gt;
          }), S(Ot);
        }() || (dt.Promise = Qt);
      }
    };
    typeof n == "function" && n.amd ? n(function() {
      return li;
    }) : typeof module < "u" && module.exports ? module.exports = li : typeof this < "u" && (this.ES6Promise = li);
  }).call(s), s && s.ES6Promise && s.ES6Promise.polyfill(), typeof t > "u" || typeof Object.create != "function" || typeof t.createElement("canvas").getContext != "function")
    (s || module.exports).html2canvas = function() {
      return Promise.reject("No canvas support");
    };
  else {
    (function(v) {
      function S(Qt) {
        throw RangeError(Jo[Qt]);
      }
      function E(Qt, ae) {
        for (var ce = Qt.length, Ee = []; ce--; ) Ee[ce] = ae(Qt[ce]);
        return Ee;
      }
      function V(Qt, ae) {
        var ce = Qt.split("@"), Ee = "";
        return 1 < ce.length && (Ee = ce[0] + "@", Qt = ce[1]), ce = Qt.split(Us), ce = E(ce, ae).join("."), Ee + ce;
      }
      function Y(Qt) {
        for (var ae = [], ce = 0, Ee = Qt.length, mi, Ti; ce < Ee; )
          mi = Qt.charCodeAt(ce++), 55296 <= mi && 56319 >= mi && ce < Ee ? (Ti = Qt.charCodeAt(ce++), (Ti & 64512) == 56320 ? ae.push(((mi & 1023) << 10) + (Ti & 1023) + 65536) : (ae.push(mi), ce--)) : ae.push(mi);
        return ae;
      }
      function tt(Qt) {
        return E(Qt, function(ae) {
          var ce = "";
          return 65535 < ae && (ae -= 65536, ce += ss(ae >>> 10 & 1023 | 55296), ae = 56320 | ae & 1023), ce += ss(ae);
        }).join("");
      }
      function _t(Qt, ae) {
        return Qt + 22 + 75 * (26 > Qt) - ((ae != 0) << 5);
      }
      function Pt(Qt, ae, ce) {
        var Ee = 0;
        for (Qt = ce ? Kn(Qt / 700) : Qt >> 1, Qt += Kn(Qt / ae); 455 < Qt; Ee += 36) Qt = Kn(Qt / 35);
        return Kn(Ee + 36 * Qt / (Qt + 38));
      }
      function zt(Qt) {
        var ae = [], ce = Qt.length, Ee, mi = 0, Ti = 128, xi = 72, Ge, fi, li, dt, Ot;
        for (Ge = Qt.lastIndexOf("-"), 0 > Ge && (Ge = 0), fi = 0; fi < Ge; ++fi) 128 <= Qt.charCodeAt(fi) && S("not-basic"), ae.push(Qt.charCodeAt(fi));
        for (Ge = 0 < Ge ? Ge + 1 : 0; Ge < ce; ) {
          for (fi = mi, Ee = 1, li = 36; Ge >= ce && S("invalid-input"), dt = Qt.charCodeAt(Ge++), dt = 10 > dt - 48 ? dt - 22 : 26 > dt - 65 ? dt - 65 : 26 > dt - 97 ? dt - 97 : 36, (36 <= dt || dt > Kn((2147483647 - mi) / Ee)) && S("overflow"), mi += dt * Ee, Ot = li <= xi ? 1 : li >= xi + 26 ? 26 : li - xi, !(dt < Ot); li += 36)
            dt = 36 - Ot, Ee > Kn(2147483647 / dt) && S("overflow"), Ee *= dt;
          Ee = ae.length + 1, xi = Pt(mi - fi, Ee, fi == 0), Kn(mi / Ee) > 2147483647 - Ti && S("overflow"), Ti += Kn(mi / Ee), mi %= Ee, ae.splice(mi++, 0, Ti);
        }
        return tt(ae);
      }
      function me(Qt) {
        var ae, ce, Ee, mi, Ti, xi, Ge, fi, li, dt = [], Ot, Gt, de;
        for (Qt = Y(Qt), Ot = Qt.length, ae = 128, ce = 0, Ti = 72, xi = 0; xi < Ot; ++xi) li = Qt[xi], 128 > li && dt.push(ss(li));
        for ((Ee = mi = dt.length) && dt.push("-"); Ee < Ot; ) {
          for (Ge = 2147483647, xi = 0; xi < Ot; ++xi) li = Qt[xi], li >= ae && li < Ge && (Ge = li);
          for (Gt = Ee + 1, Ge - ae > Kn((2147483647 - ce) / Gt) && S("overflow"), ce += (Ge - ae) * Gt, ae = Ge, xi = 0; xi < Ot; ++xi)
            if (li = Qt[xi], li < ae && 2147483647 < ++ce && S("overflow"), li == ae) {
              for (fi = ce, Ge = 36; li = Ge <= Ti ? 1 : Ge >= Ti + 26 ? 26 : Ge - Ti, !(fi < li); Ge += 36)
                de = fi - li, fi = 36 - li, dt.push(ss(_t(li + de % fi, 0))), fi = Kn(de / fi);
              dt.push(ss(_t(fi, 0))), Ti = Pt(ce, Gt, Ee == mi), ce = 0, ++Ee;
            }
          ++ce, ++ae;
        }
        return dt.join("");
      }
      var ni = typeof e == "object" && e && !e.nodeType && e, Wi = typeof module == "object" && module && !module.nodeType && module, bi = typeof i == "object" && i;
      (bi.global === bi || bi.window === bi || bi.self === bi) && (v = bi);
      var Gi, Ai = /^xn--/, hn = /[^\x20-\x7E]/, Us = /[\x2E\u3002\uFF0E\uFF61]/g, Jo = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, Kn = Math.floor, ss = String.fromCharCode, un;
      if (Gi = {
        version: "1.3.1",
        ucs2: { decode: Y, encode: tt },
        decode: zt,
        encode: me,
        toASCII: function(Qt) {
          return V(Qt, function(ae) {
            return hn.test(ae) ? "xn--" + me(ae) : ae;
          });
        },
        toUnicode: function(Qt) {
          return V(Qt, function(ae) {
            return Ai.test(ae) ? zt(ae.slice(4).toLowerCase()) : ae;
          });
        }
      }, typeof n == "function" && typeof n.amd == "object" && n.amd)
        n("punycode", function() {
          return Gi;
        });
      else if (ni && Wi)
        if (module.exports == ni) Wi.exports = Gi;
        else for (un in Gi) Gi.hasOwnProperty(un) && (ni[un] = Gi[un]);
      else v.punycode = Gi;
    })(this);
    var Fh = 0, Sd = 0;
    s.html2canvas = function(v, S) {
      var E = Sd++;
      if (S = S || {}, S.logging && (s.html2canvas.logging = !0, s.html2canvas.start = Date.now()), S.async = typeof S.async > "u" ? !0 : S.async, S.allowTaint = typeof S.allowTaint > "u" ? !1 : S.allowTaint, S.removeContainer = typeof S.removeContainer > "u" ? !0 : S.removeContainer, S.javascriptEnabled = typeof S.javascriptEnabled > "u" ? !1 : S.javascriptEnabled, S.imageTimeout = typeof S.imageTimeout > "u" ? 1e4 : S.imageTimeout, S.renderer = typeof S.renderer == "function" ? S.renderer : Ei, S.strict = !!S.strict, typeof v == "string") {
        if (typeof S.proxy != "string")
          return Promise.reject("Proxy must be used when rendering url");
        var V = S.width != null ? S.width : s.innerWidth, Y = S.height != null ? S.height : s.innerHeight;
        return b(B(v), S.proxy, t, V, Y, S).then(function(_t) {
          return l(_t.contentWindow.document.documentElement, _t, S, V, Y);
        });
      }
      var tt = (v === r ? [t.documentElement] : v.length ? v : [v])[0];
      return tt.setAttribute("data-html2canvas-node" + E, E), o(
        tt.ownerDocument,
        S,
        tt.ownerDocument.defaultView.innerWidth,
        tt.ownerDocument.defaultView.innerHeight,
        E
      ).then(function(_t) {
        return typeof S.onrendered == "function" && (R(
          "options.onrendered is deprecated, html2canvas returns a Promise containing the canvas"
        ), S.onrendered(_t)), _t;
      });
    }, s.html2canvas.punycode = this.punycode, s.html2canvas.proxy = {}, j.prototype.darken = function(v) {
      return v = 1 - v, new j([
        Math.round(this.r * v),
        Math.round(this.g * v),
        Math.round(this.b * v),
        this.a
      ]);
    }, j.prototype.isTransparent = function() {
      return this.a === 0;
    }, j.prototype.isBlack = function() {
      return this.r === 0 && this.g === 0 && this.b === 0;
    }, j.prototype.fromArray = function(v) {
      return Array.isArray(v) && (this.r = Math.min(v[0], 255), this.g = Math.min(v[1], 255), this.b = Math.min(v[2], 255), 3 < v.length && (this.a = v[3])), Array.isArray(v);
    };
    var Bh = /^#([a-f0-9]{3})$/i;
    j.prototype.hex3 = function(v) {
      return (v = v.match(Bh)) !== null && (this.r = parseInt(v[1][0] + v[1][0], 16), this.g = parseInt(v[1][1] + v[1][1], 16), this.b = parseInt(v[1][2] + v[1][2], 16)), v !== null;
    };
    var Xo = /^#([a-f0-9]{6})$/i;
    j.prototype.hex6 = function(v) {
      return (v = v.match(Xo)) !== null && (this.r = parseInt(v[1].substring(0, 2), 16), this.g = parseInt(v[1].substring(2, 4), 16), this.b = parseInt(v[1].substring(4, 6), 16)), v !== null;
    };
    var Vh = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/;
    j.prototype.rgb = function(v) {
      return (v = v.match(Vh)) !== null && (this.r = Number(v[1]), this.g = Number(v[2]), this.b = Number(v[3])), v !== null;
    };
    var Md = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/;
    j.prototype.rgba = function(v) {
      return (v = v.match(Md)) !== null && (this.r = Number(v[1]), this.g = Number(v[2]), this.b = Number(v[3]), this.a = Number(v[4])), v !== null;
    }, j.prototype.toString = function() {
      return this.a !== null && this.a !== 1 ? "rgba(" + [this.r, this.g, this.b, this.a].join() + ")" : "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, j.prototype.namedColor = function(v) {
      var S = zh[v.toLowerCase()];
      if (S) this.r = S[0], this.g = S[1], this.b = S[2];
      else if (v.toLowerCase() === "transparent")
        return this.r = this.g = this.b = this.a = 0, !0;
      return !!S;
    }, j.prototype.isColor = !0;
    var zh = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    J.prototype.getMetrics = function(v, S) {
      return this.data[v + "-" + S] === r && (this.data[v + "-" + S] = new K(v, S)), this.data[v + "-" + S];
    }, rt.prototype.proxyLoad = function(v, S, E) {
      var V = this.src;
      return b(V.src, v, V.ownerDocument, S.width, S.height, E);
    }, ft.prototype.TYPES = { LINEAR: 1, RADIAL: 2 }, $.prototype.findImages = function(v) {
      var S = [];
      return v.reduce(function(E, V) {
        switch (V.node.nodeName) {
          case "IMG":
            return E.concat([{ args: [V.node.src], method: "url" }]);
          case "svg":
          case "IFRAME":
            return E.concat([{ args: [V.node], method: V.node.nodeName }]);
        }
        return E;
      }, []).forEach(this.addImage(S, this.loadImage), this), S;
    }, $.prototype.findBackgroundImage = function(v, S) {
      return S.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(v, this.loadImage), this), v;
    }, $.prototype.addImage = function(v, S) {
      return function(E) {
        E.args.forEach(function(V) {
          this.imageExists(v, V) || (v.splice(0, 0, S.call(this, E)), R("Added image #" + v.length, typeof V == "string" ? V.substring(0, 100) : V));
        }, this);
      };
    }, $.prototype.hasImageBackground = function(v) {
      return v.method !== "none";
    }, $.prototype.loadImage = function(v) {
      return v.method === "url" ? (v = v.args[0], !this.isSVG(v) || this.support.svg || this.options.allowTaint ? v.match(/data:image\/.*;base64,/i) ? new H(v.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ""), !1) : this.isSameOrigin(v) || this.options.allowTaint === !0 || this.isSVG(v) ? new H(v, !1) : this.support.cors && !this.options.allowTaint && this.options.useCORS ? new H(v, !0) : this.options.proxy ? new te(v, this.options.proxy) : new F(v) : new kn(v)) : v.method === "linear-gradient" ? new D(v) : v.method === "gradient" ? new Hs(v) : v.method === "svg" ? new xr(v.args[0], this.support.svg) : v.method === "IFRAME" ? new rt(v.args[0], this.isSameOrigin(v.args[0].src), this.options) : new F(v);
    }, $.prototype.isSVG = function(v) {
      return v.substring(v.length - 3).toLowerCase() === "svg" || kn.prototype.isInline(v);
    }, $.prototype.imageExists = function(v, S) {
      return v.some(function(E) {
        return E.src === S;
      });
    }, $.prototype.isSameOrigin = function(v) {
      return this.getOrigin(v) === this.origin;
    }, $.prototype.getOrigin = function(v) {
      var S = this.link || (this.link = t.createElement("a"));
      return S.href = v, S.href = S.href, S.protocol + S.hostname + S.port;
    }, $.prototype.getPromise = function(v) {
      return this.timeout(v, this.options.imageTimeout).catch(function() {
        return new F(v.src).promise.then(function(S) {
          v.image = S;
        });
      });
    }, $.prototype.get = function(v) {
      var S = null;
      return this.images.some(function(E) {
        return (S = E).src === v;
      }) ? S : null;
    }, $.prototype.fetch = function(v) {
      return this.images = v.reduce(Yt(this.findBackgroundImage, this), this.findImages(v)), this.images.forEach(function(S, E) {
        S.promise.then(
          function() {
            R("Succesfully loaded image #" + (E + 1), S);
          },
          function(V) {
            R("Failed loading image #" + (E + 1), S, V);
          }
        );
      }), this.ready = Promise.all(this.images.map(this.getPromise, this)), R("Finished searching images"), this;
    }, $.prototype.timeout = function(v, S) {
      var E, V = Promise.race([
        v.promise,
        new Promise(function(Y, tt) {
          E = setTimeout(function() {
            R("Timed out loading image", v), tt(v);
          }, S);
        })
      ]).then(function(Y) {
        return clearTimeout(E), Y;
      });
      return V.catch(function() {
        clearTimeout(E);
      }), V;
    }, D.prototype = Object.create(ft.prototype), D.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/, U.prototype.cloneTo = function(v) {
      v.visible = this.visible, v.borders = this.borders, v.bounds = this.bounds, v.clip = this.clip, v.backgroundClip = this.backgroundClip, v.computedStyles = this.computedStyles, v.styles = this.styles, v.backgroundImages = this.backgroundImages, v.opacity = this.opacity;
    }, U.prototype.getOpacity = function() {
      return this.opacity === null ? this.opacity = this.cssFloat("opacity") : this.opacity;
    }, U.prototype.assignStack = function(v) {
      this.stack = v, v.children.push(this);
    }, U.prototype.isElementVisible = function() {
      return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : this.css("display") !== "none" && this.css("visibility") !== "hidden" && !this.node.hasAttribute("data-html2canvas-ignore") && (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden");
    }, U.prototype.css = function(v) {
      return this.computedStyles || (this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null)), this.styles[v] || (this.styles[v] = this.computedStyles[v]);
    }, U.prototype.prefixedCss = function(v) {
      var S = ["webkit", "moz", "ms", "o"], E = this.css(v);
      return E === r && S.some(function(V) {
        return E = this.css(V + v.substr(0, 1).toUpperCase() + v.substr(1)), E !== r;
      }, this), E === r ? null : E;
    }, U.prototype.computedStyle = function(v) {
      return this.node.ownerDocument.defaultView.getComputedStyle(this.node, v);
    }, U.prototype.cssInt = function(v) {
      return v = parseInt(this.css(v), 10), isNaN(v) ? 0 : v;
    }, U.prototype.color = function(v) {
      return this.colors[v] || (this.colors[v] = new j(this.css(v)));
    }, U.prototype.cssFloat = function(v) {
      return v = parseFloat(this.css(v)), isNaN(v) ? 0 : v;
    }, U.prototype.fontWeight = function() {
      var v = this.css("fontWeight");
      switch (parseInt(v, 10)) {
        case 401:
          v = "bold";
          break;
        case 400:
          v = "normal";
      }
      return v;
    }, U.prototype.parseClip = function() {
      var v = this.css("clip").match(this.CLIP);
      return v ? {
        top: parseInt(v[1], 10),
        right: parseInt(v[2], 10),
        bottom: parseInt(v[3], 10),
        left: parseInt(v[4], 10)
      } : null;
    }, U.prototype.parseBackgroundImages = function() {
      return this.backgroundImages || (this.backgroundImages = mt(this.css("backgroundImage")));
    }, U.prototype.cssList = function(v, S) {
      var E = (this.css(v) || "").split(","), E = E[S || 0] || E[0] || "auto", E = E.trim().split(" ");
      return E.length === 1 && (E = [E[0], E[0]]), E;
    }, U.prototype.parseBackgroundSize = function(v, S, E) {
      E = this.cssList("backgroundSize", E);
      var V;
      if (at(E[0])) V = v.width * parseFloat(E[0]) / 100;
      else {
        if (/contain|cover/.test(E[0]))
          return S = S.width / S.height, v.width / v.height < S ^ E[0] === "contain" ? { width: v.height * S, height: v.height } : { width: v.width, height: v.width / S };
        V = parseInt(E[0], 10);
      }
      return v = E[0] === "auto" && E[1] === "auto" ? S.height : E[1] === "auto" ? V / S.width * S.height : at(E[1]) ? v.height * parseFloat(E[1]) / 100 : parseInt(E[1], 10), E[0] === "auto" && (V = v / S.height * S.width), { width: V, height: v };
    }, U.prototype.parseBackgroundPosition = function(v, S, E, V) {
      E = this.cssList("backgroundPosition", E);
      var Y;
      return Y = at(E[0]) ? (v.width - (V || S).width) * (parseFloat(E[0]) / 100) : parseInt(E[0], 10), v = E[1] === "auto" ? Y / S.width * S.height : at(E[1]) ? (v.height - (V || S).height) * parseFloat(E[1]) / 100 : parseInt(E[1], 10), E[0] === "auto" && (Y = v / S.height * S.width), { left: Y, top: v };
    }, U.prototype.parseBackgroundRepeat = function(v) {
      return this.cssList("backgroundRepeat", v)[0];
    }, U.prototype.parseTextShadows = function() {
      var v = this.css("textShadow"), S = [];
      if (v && v !== "none")
        for (var v = v.match(this.TEXT_SHADOW_PROPERTY), E = 0; v && E < v.length; E++) {
          var V = v[E].match(this.TEXT_SHADOW_VALUES);
          S.push({
            color: new j(V[0]),
            offsetX: V[1] ? parseFloat(V[1].replace("px", "")) : 0,
            offsetY: V[2] ? parseFloat(V[2].replace("px", "")) : 0,
            blur: V[3] ? V[3].replace("px", "") : 0
          });
        }
      return S;
    }, U.prototype.parseTransform = function() {
      if (!this.transformData)
        if (this.hasTransform()) {
          var v = this.parseBounds(), S = this.prefixedCss("transformOrigin").split(" ").map(Nt).map(lt);
          S[0] += v.left, S[1] += v.top, this.transformData = { origin: S, matrix: this.parseTransformMatrix() };
        } else this.transformData = { origin: [0, 0], matrix: [1, 0, 0, 1, 0, 0] };
      return this.transformData;
    }, U.prototype.parseTransformMatrix = function() {
      if (!this.transformMatrix) {
        var v = this.prefixedCss("transform");
        this.transformMatrix = (v = v ? it(v.match(this.MATRIX_PROPERTY)) : null) ? v : [1, 0, 0, 1, 0, 0];
      }
      return this.transformMatrix;
    }, U.prototype.parseBounds = function() {
      return this.bounds || (this.bounds = this.hasTransform() ? Ht(this.node) : ot(this.node));
    }, U.prototype.hasTransform = function() {
      return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || this.parent && this.parent.hasTransform();
    }, U.prototype.getValue = function() {
      var v = this.node.value || "";
      return this.node.tagName === "SELECT" ? (v = this.node, v = (v = v.options[v.selectedIndex || 0]) && v.text || "") : this.node.type === "password" && (v = Array(v.length + 1).join("•")), v.length === 0 ? this.node.placeholder || "" : v;
    }, U.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/, U.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, U.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g, U.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/, St.prototype.calculateOverflowClips = function() {
      this.nodes.forEach(function(v) {
        if (kt(v)) {
          v.isPseudoElement === !0 && v.appendToDOM(), v.borders = this.parseBorders(v);
          var S = v.css("overflow") === "hidden" ? [v.borders.clip] : [], E = v.parseClip();
          E && ["absolute", "fixed"].indexOf(v.css("position")) !== -1 && S.push([
            [
              "rect",
              v.bounds.left + E.left,
              v.bounds.top + E.top,
              E.right - E.left,
              E.bottom - E.top
            ]
          ]), v.clip = v.parent && v.parent.clip.length ? v.parent.clip.concat(S) : S, v.backgroundClip = v.css("overflow") !== "hidden" ? v.clip.concat([v.borders.clip]) : v.clip, v.isPseudoElement === !0 && v.cleanDOM();
        } else Lt(v) && (v.clip = v.parent && v.parent.clip.length ? v.parent.clip : []);
        v.isPseudoElement !== !0 && (v.bounds = null);
      }, this);
    }, St.prototype.asyncRenderer = function(v, S, E) {
      E = E || Date.now(), this.paint(v[this.renderIndex++]), v.length === this.renderIndex ? S() : E + 20 > Date.now() ? this.asyncRenderer(v, S, E) : setTimeout(
        Yt(function() {
          this.asyncRenderer(v, S);
        }, this),
        0
      );
    }, St.prototype.createPseudoHideStyles = function(v) {
      this.createStyles(
        v,
        "." + Ki.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }.' + Ki.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }'
      );
    }, St.prototype.disableAnimations = function(v) {
      this.createStyles(
        v,
        "* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}"
      );
    }, St.prototype.createStyles = function(v, S) {
      var E = v.createElement("style");
      E.innerHTML = S, v.body.appendChild(E);
    }, St.prototype.getPseudoElements = function(v) {
      var S = [[v]];
      if (v.node.nodeType === Node.ELEMENT_NODE) {
        var E = this.getPseudoElement(v, ":before");
        v = this.getPseudoElement(v, ":after"), E && S.push(E), v && S.push(v);
      }
      return [].concat.apply([], S);
    }, St.prototype.getPseudoElement = function(v, S) {
      var E = v.computedStyle(S);
      if (!E || !E.content || E.content === "none" || E.content === "-moz-alt-content" || E.display === "none")
        return null;
      var V, Y = E.content, tt = Y.substr(0, 1);
      V = tt === Y.substr(Y.length - 1) && tt.match(/'|"/) ? Y.substr(1, Y.length - 2) : Y;
      for (var _t = V.substr(0, 3) === "url", Y = t.createElement(_t ? "img" : "html2canvaspseudoelement"), tt = new Ki(Y, v, S), Pt = E.length - 1; 0 <= Pt; Pt--) {
        var zt = Rt(E.item(Pt));
        Y.style[zt] = E[zt];
      }
      return Y.className = Ki.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + Ki.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER, _t ? (Y.src = mt(V)[0].args[0], [tt]) : (E = t.createTextNode(V), Y.appendChild(E), [tt, new Ft(E, tt)]);
    }, St.prototype.getChildren = function(v) {
      return [].concat.apply(
        [],
        [].filter.call(v.node.childNodes, st).map(function(S) {
          var E = [S.nodeType === Node.TEXT_NODE ? new Ft(S, v) : new U(S, v)].filter(Ri);
          return S.nodeType === Node.ELEMENT_NODE && E.length && S.tagName !== "TEXTAREA" ? E[0].isElementVisible() ? E.concat(this.getChildren(E[0])) : [] : E;
        }, this)
      );
    }, St.prototype.newStackingContext = function(v, S) {
      var E = new qn(S, v.getOpacity(), v.node, v.parent);
      v.cloneTo(E), (S ? E.getParentStack(this) : E.parent.stack).contexts.push(E), v.stack = E;
    }, St.prototype.createStackingContexts = function() {
      this.nodes.forEach(function(v) {
        var S;
        (S = kt(v)) && ((S = this.isRootElement(v) || 1 > v.getOpacity()) || (S = v.css("position"), S = (["absolute", "relative", "fixed"].indexOf(S) !== -1 ? v.css("zIndex") : "auto") !== "auto"), S = S || this.isBodyWithTransparentRoot(v) || v.hasTransform()), S ? this.newStackingContext(v, !0) : kt(v) && (xt(v) && vt(v) || ["inline-block", "inline-table"].indexOf(v.css("display")) !== -1 || It(v)) ? this.newStackingContext(v, !1) : v.assignStack(v.parent.stack);
      }, this);
    }, St.prototype.isBodyWithTransparentRoot = function(v) {
      return v.node.nodeName === "BODY" && v.parent.color("backgroundColor").isTransparent();
    }, St.prototype.isRootElement = function(v) {
      return v.parent === null;
    }, St.prototype.sortStackingContexts = function(v) {
      v.contexts.sort(Tt(v.contexts.slice(0))), v.contexts.forEach(this.sortStackingContexts, this);
    }, St.prototype.parseTextBounds = function(v) {
      return function(S, E, V) {
        if (v.parent.css("textDecoration").substr(0, 4) !== "none" || S.trim().length !== 0) {
          if (this.support.rangeBounds && !v.parent.hasTransform())
            return E = V.slice(0, E).join("").length, this.getRangeBounds(v.node, E, S.length);
          if (v.node && typeof v.node.data == "string")
            return S = v.node.splitText(S.length), E = this.getWrapperBounds(v.node, v.parent.hasTransform()), v.node = S, E;
        } else (!this.support.rangeBounds || v.parent.hasTransform()) && (v.node = v.node.splitText(S.length));
        return {};
      };
    }, St.prototype.getWrapperBounds = function(v, S) {
      var E = v.ownerDocument.createElement("html2canvaswrapper"), V = v.parentNode, Y = v.cloneNode(!0);
      E.appendChild(v.cloneNode(!0)), V.replaceChild(E, v);
      var tt = S ? Ht(E) : ot(E);
      return V.replaceChild(Y, E), tt;
    }, St.prototype.getRangeBounds = function(v, S, E) {
      var V = this.range || (this.range = v.ownerDocument.createRange());
      return V.setStart(v, S), V.setEnd(v, S + E), V.getBoundingClientRect();
    }, St.prototype.parse = function(v) {
      var S = v.contexts.filter(ii), V = v.children.filter(kt), tt = V.filter(nt(It)), E = tt.filter(nt(xt)).filter(nt(pt)), V = V.filter(nt(xt)).filter(It), Y = tt.filter(nt(xt)).filter(pt), tt = v.contexts.concat(tt.filter(xt)).filter(vt), _t = v.children.filter(Lt).filter(q);
      v = v.contexts.filter(T), S.concat(E).concat(V).concat(Y).concat(tt).concat(_t).concat(v).forEach(function(Pt) {
        this.renderQueue.push(Pt), Pt instanceof qn && (this.parse(Pt), this.renderQueue.push(new ei()));
      }, this);
    }, St.prototype.paint = function(v) {
      try {
        v instanceof ei ? this.renderer.ctx.restore() : Lt(v) ? (v.parent.isPseudoElement === !0 && v.parent.appendToDOM(), this.paintText(v), v.parent.isPseudoElement === !0 && v.parent.cleanDOM()) : this.paintNode(v);
      } catch (S) {
        if (R(S), this.options.strict) throw S;
      }
    }, St.prototype.paintNode = function(v) {
      v instanceof qn && (this.renderer.setOpacity(v.opacity), this.renderer.ctx.save(), v.hasTransform() && this.renderer.setTransform(v.parseTransform())), v.node.nodeName === "INPUT" && v.node.type === "checkbox" ? this.paintCheckbox(v) : v.node.nodeName === "INPUT" && v.node.type === "radio" ? this.paintRadio(v) : this.paintElement(v);
    }, St.prototype.paintElement = function(v) {
      var S = v.parseBounds();
      this.renderer.clip(
        v.backgroundClip,
        function() {
          this.renderer.renderBackground(v, S, v.borders.borders.map(xe));
        },
        this
      ), this.renderer.clip(
        v.clip,
        function() {
          this.renderer.renderBorders(v.borders.borders);
        },
        this
      ), this.renderer.clip(
        v.backgroundClip,
        function() {
          switch (v.node.nodeName) {
            case "svg":
            case "IFRAME":
              var E = this.images.get(v.node);
              E ? this.renderer.renderImage(v, S, v.borders, E) : R("Error loading <" + v.node.nodeName + ">", v.node);
              break;
            case "IMG":
              (E = this.images.get(v.node.src)) ? this.renderer.renderImage(v, S, v.borders, E) : R("Error loading <img>", v.node.src);
              break;
            case "CANVAS":
              this.renderer.renderImage(v, S, v.borders, { image: v.node });
              break;
            case "SELECT":
            case "INPUT":
            case "TEXTAREA":
              this.paintFormValue(v);
          }
        },
        this
      );
    }, St.prototype.paintCheckbox = function(v) {
      var V = v.parseBounds(), S = Math.min(V.width, V.height), E = { width: S - 1, height: S - 1, top: V.top, left: V.left }, V = [3, 3], Y = [V, V, V, V], tt = [1, 1, 1, 1].map(function(Pt) {
        return { color: new j("#A5A5A5"), width: Pt };
      }), _t = Se(E, Y, tt);
      this.renderer.clip(
        v.backgroundClip,
        function() {
          this.renderer.rectangle(
            E.left + 1,
            E.top + 1,
            E.width - 2,
            E.height - 2,
            new j("#DEDEDE")
          ), this.renderer.renderBorders(ai(tt, E, _t, Y)), v.node.checked && (this.renderer.font(
            new j("#424242"),
            "normal",
            "normal",
            "bold",
            S - 3 + "px",
            "arial"
          ), this.renderer.text("✔", E.left + S / 6, E.top + S - 1));
        },
        this
      );
    }, St.prototype.paintRadio = function(v) {
      var S = v.parseBounds(), E = Math.min(S.width, S.height) - 2;
      this.renderer.clip(
        v.backgroundClip,
        function() {
          this.renderer.circleStroke(
            S.left + 1,
            S.top + 1,
            E,
            new j("#DEDEDE"),
            1,
            new j("#A5A5A5")
          ), v.node.checked && this.renderer.circle(
            Math.ceil(S.left + E / 4) + 1,
            Math.ceil(S.top + E / 4) + 1,
            Math.floor(E / 2),
            new j("#424242")
          );
        },
        this
      );
    }, St.prototype.paintFormValue = function(v) {
      var S = v.getValue();
      if (0 < S.length) {
        var E = v.node.ownerDocument, V = E.createElement("html2canvaswrapper");
        "lineHeight textAlign fontFamily fontWeight fontSize color paddingLeft paddingTop paddingRight paddingBottom width height borderLeftStyle borderTopStyle borderLeftWidth borderTopWidth boxSizing whiteSpace wordWrap".split(" ").forEach(function(tt) {
          try {
            V.style[tt] = v.css(tt);
          } catch (_t) {
            R("html2canvas: Parse: Exception caught in renderFormValue: " + _t.message);
          }
        });
        var Y = v.parseBounds();
        V.style.position = "fixed", V.style.left = Y.left + "px", V.style.top = Y.top + "px", V.textContent = S, E.body.appendChild(V), this.paintText(new Ft(V.firstChild, v)), E.body.removeChild(V);
      }
    }, St.prototype.paintText = function(v) {
      v.applyTextTransform();
      var E = s.html2canvas.punycode.ucs2.decode(v.node.data), S = this.options.letterRendering && !/^(normal|none|0px)$/.test(v.parent.css("letterSpacing")) || /[^\u0000-\u00ff]/.test(v.node.data) ? E.map(function(_t) {
        return s.html2canvas.punycode.ucs2.encode([_t]);
      }) : Fn(E), E = v.parent.fontWeight(), V = v.parent.css("fontSize"), Y = v.parent.css("fontFamily"), tt = v.parent.parseTextShadows();
      this.renderer.font(
        v.parent.color("color"),
        v.parent.css("fontStyle"),
        v.parent.css("fontVariant"),
        E,
        V,
        Y
      ), tt.length ? this.renderer.fontShadow(tt[0].color, tt[0].offsetX, tt[0].offsetY, tt[0].blur) : this.renderer.clearShadow(), this.renderer.clip(
        v.parent.clip,
        function() {
          S.map(this.parseTextBounds(v), this).forEach(function(_t, Pt) {
            _t && (this.renderer.text(S[Pt], _t.left, _t.bottom), this.renderTextDecoration(v.parent, _t, this.fontMetrics.getMetrics(Y, V)));
          }, this);
        },
        this
      );
    }, St.prototype.renderTextDecoration = function(v, S, E) {
      switch (v.css("textDecoration").split(" ")[0]) {
        case "underline":
          this.renderer.rectangle(
            S.left,
            Math.round(S.top + E.baseline + E.lineWidth),
            S.width,
            1,
            v.color("color")
          );
          break;
        case "overline":
          this.renderer.rectangle(S.left, Math.round(S.top), S.width, 1, v.color("color"));
          break;
        case "line-through":
          this.renderer.rectangle(
            S.left,
            Math.ceil(S.top + E.middle + E.lineWidth),
            S.width,
            1,
            v.color("color")
          );
      }
    };
    var Hh = {
      inset: [
        ["darken", 0.6],
        ["darken", 0.1],
        ["darken", 0.1],
        ["darken", 0.6]
      ]
    };
    St.prototype.parseBorders = function(v) {
      var S = v.parseBounds(), E = W(v), V = ["Top", "Right", "Bottom", "Left"].map(function(tt, _t) {
        var Pt = v.css("border" + tt + "Style"), zt = v.color("border" + tt + "Color");
        return Pt === "inset" && zt.isBlack() && (zt = new j([255, 255, 255, zt.a])), Pt = Hh[Pt] ? Hh[Pt][_t] : null, {
          width: v.cssInt("border" + tt + "Width"),
          color: Pt ? zt[Pt[0]](Pt[1]) : zt,
          args: null
        };
      }), Y = Se(S, E, V);
      return { clip: this.parseBackgroundClip(v, Y, V, E, S), borders: ai(V, S, Y, E) };
    }, St.prototype.parseBackgroundClip = function(v, S, E, V, Y) {
      var tt = [];
      switch (v.css("backgroundClip")) {
        case "content-box":
        case "padding-box":
          ki(
            tt,
            V[0],
            V[1],
            S.topLeftInner,
            S.topRightInner,
            Y.left + E[3].width,
            Y.top + E[0].width
          ), ki(
            tt,
            V[1],
            V[2],
            S.topRightInner,
            S.bottomRightInner,
            Y.left + Y.width - E[1].width,
            Y.top + E[0].width
          ), ki(
            tt,
            V[2],
            V[3],
            S.bottomRightInner,
            S.bottomLeftInner,
            Y.left + Y.width - E[1].width,
            Y.top + Y.height - E[2].width
          ), ki(
            tt,
            V[3],
            V[0],
            S.bottomLeftInner,
            S.topLeftInner,
            Y.left + E[3].width,
            Y.top + Y.height - E[2].width
          );
          break;
        default:
          ki(tt, V[0], V[1], S.topLeftOuter, S.topRightOuter, Y.left, Y.top), ki(tt, V[1], V[2], S.topRightOuter, S.bottomRightOuter, Y.left + Y.width, Y.top), ki(
            tt,
            V[2],
            V[3],
            S.bottomRightOuter,
            S.bottomLeftOuter,
            Y.left + Y.width,
            Y.top + Y.height
          ), ki(tt, V[3], V[0], S.bottomLeftOuter, S.topLeftOuter, Y.left, Y.top + Y.height);
      }
      return tt;
    };
    var Ol = 0, Rl = "withCredentials" in new XMLHttpRequest(), Vn = "crossOrigin" in new Image();
    Ki.prototype.cloneTo = function(v) {
      Ki.prototype.cloneTo.call(this, v), v.isPseudoElement = !0, v.before = this.before;
    }, Ki.prototype = Object.create(U.prototype), Ki.prototype.appendToDOM = function() {
      this.before ? this.parent.node.insertBefore(this.node, this.parent.node.firstChild) : this.parent.node.appendChild(this.node), this.parent.node.className += " " + this.getHideClass();
    }, Ki.prototype.cleanDOM = function() {
      this.node.parentNode.removeChild(this.node), this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
    }, Ki.prototype.getHideClass = function() {
      return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
    }, Ki.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before", Ki.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after", vn.prototype.renderImage = function(v, S, E, V) {
      var Y = v.cssInt("paddingLeft"), tt = v.cssInt("paddingTop"), _t = v.cssInt("paddingRight");
      v = v.cssInt("paddingBottom"), E = E.borders, _t = S.width - (E[1].width + E[3].width + Y + _t), v = S.height - (E[0].width + E[2].width + tt + v), this.drawImage(
        V,
        0,
        0,
        V.image.width || _t,
        V.image.height || v,
        S.left + Y + E[3].width,
        S.top + tt + E[0].width,
        _t,
        v
      );
    }, vn.prototype.renderBackground = function(v, S, E) {
      0 < S.height && 0 < S.width && (this.renderBackgroundColor(v, S), this.renderBackgroundImage(v, S, E));
    }, vn.prototype.renderBackgroundColor = function(v, S) {
      var E = v.color("backgroundColor");
      E.isTransparent() || this.rectangle(S.left, S.top, S.width, S.height, E);
    }, vn.prototype.renderBorders = function(v) {
      v.forEach(this.renderBorder, this);
    }, vn.prototype.renderBorder = function(v) {
      v.color.isTransparent() || v.args === null || this.drawShape(v.args, v.color);
    }, vn.prototype.renderBackgroundImage = function(v, S, E) {
      v.parseBackgroundImages().reverse().forEach(function(V, Y, tt) {
        switch (V.method) {
          case "url":
            var _t = this.images.get(V.args[0]);
            _t ? this.renderBackgroundRepeating(v, S, _t, tt.length - (Y + 1), E) : R("Error loading background-image", V.args[0]);
            break;
          case "linear-gradient":
          case "gradient":
            (Y = this.images.get(V.value)) ? this.renderBackgroundGradient(Y, S, E) : R("Error loading background-image", V.args[0]);
            break;
          case "none":
            break;
          default:
            R("Unknown background-image type", V.args[0]);
        }
      }, this);
    }, vn.prototype.renderBackgroundRepeating = function(v, S, E, V, Y) {
      var tt = v.parseBackgroundSize(S, E.image, V), _t = v.parseBackgroundPosition(S, E.image, V, tt);
      switch (v.parseBackgroundRepeat(V)) {
        case "repeat-x":
        case "repeat no-repeat":
          this.backgroundRepeatShape(
            E,
            _t,
            tt,
            S,
            S.left + Y[3],
            S.top + _t.top + Y[0],
            99999,
            tt.height,
            Y
          );
          break;
        case "repeat-y":
        case "no-repeat repeat":
          this.backgroundRepeatShape(
            E,
            _t,
            tt,
            S,
            S.left + _t.left + Y[3],
            S.top + Y[0],
            tt.width,
            99999,
            Y
          );
          break;
        case "no-repeat":
          this.backgroundRepeatShape(
            E,
            _t,
            tt,
            S,
            S.left + _t.left + Y[3],
            S.top + _t.top + Y[0],
            tt.width,
            tt.height,
            Y
          );
          break;
        default:
          this.renderBackgroundRepeat(E, _t, tt, { top: S.top, left: S.left }, Y[3], Y[0]);
      }
    }, qn.prototype = Object.create(U.prototype), qn.prototype.getParentStack = function(v) {
      var S = this.parent ? this.parent.stack : null;
      return S ? S.ownStacking ? S : S.getParentStack(v) : v.stack;
    }, Bn.prototype.testRangeBounds = function(v) {
      var S, E, V = !1;
      return v.createRange && (S = v.createRange(), S.getBoundingClientRect && (E = v.createElement("boundtest"), E.style.height = "123px", E.style.display = "block", v.body.appendChild(E), S.selectNode(E), S = S.getBoundingClientRect(), S = S.height, S === 123 && (V = !0), v.body.removeChild(E))), V;
    }, Bn.prototype.testCORS = function() {
      return typeof new Image().crossOrigin < "u";
    }, Bn.prototype.testSVG = function() {
      var v = new Image(), S = t.createElement("canvas"), E = S.getContext("2d");
      v.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
        E.drawImage(v, 0, 0), S.toDataURL();
      } catch {
        return !1;
      }
      return !0;
    }, kn.prototype.hasFabric = function() {
      return html2canvas.fabric ? Promise.resolve() : Promise.reject(Error("html2canvas.svg.js is not loaded, cannot render svg"));
    }, kn.prototype.inlineFormatting = function(v) {
      return /^data:image\/svg\+xml;base64,/.test(v) ? this.decode64(this.removeContentType(v)) : this.removeContentType(v);
    }, kn.prototype.removeContentType = function(v) {
      return v.replace(/^data:image\/svg\+xml(;base64)?,/, "");
    }, kn.prototype.isInline = function(v) {
      return /^data:image\/svg\+xml/i.test(v);
    }, kn.prototype.createCanvas = function(v) {
      var S = this;
      return function(E, V) {
        var Y = new html2canvas.fabric.StaticCanvas("c");
        S.image = Y.lowerCanvasEl, Y.setWidth(V.width).setHeight(V.height).add(html2canvas.fabric.util.groupSVGElements(E, V)).renderAll(), v(Y.lowerCanvasEl);
      };
    }, kn.prototype.decode64 = function(v) {
      return typeof s.atob == "function" ? s.atob(v) : Je(v);
    }, xr.prototype = Object.create(kn.prototype), Ft.prototype = Object.create(U.prototype), Ft.prototype.applyTextTransform = function() {
      this.node.data = this.transform(this.parent.css("textTransform"));
    }, Ft.prototype.transform = function(v) {
      var S = this.node.data;
      switch (v) {
        case "lowercase":
          return S.toLowerCase();
        case "capitalize":
          return S.replace(/(^|\s|:|-|\(|\))([a-z])/g, Nl);
        case "uppercase":
          return S.toUpperCase();
        default:
          return S;
      }
    }, Hs.prototype = Object.create(ft.prototype), Ei.prototype = Object.create(vn.prototype), Ei.prototype.setFillStyle = function(v) {
      return this.ctx.fillStyle = typeof v == "object" && v.isColor ? v.toString() : v, this.ctx;
    }, Ei.prototype.rectangle = function(v, S, E, V, Y) {
      this.setFillStyle(Y).fillRect(v, S, E, V);
    }, Ei.prototype.circle = function(v, S, E, V) {
      this.setFillStyle(V), this.ctx.beginPath(), this.ctx.arc(v + E / 2, S + E / 2, E / 2, 0, 2 * Math.PI, !0), this.ctx.closePath(), this.ctx.fill();
    }, Ei.prototype.circleStroke = function(v, S, E, V, Y, tt) {
      this.circle(v, S, E, V), this.ctx.strokeStyle = tt.toString(), this.ctx.stroke();
    }, Ei.prototype.drawShape = function(v, S) {
      this.shape(v), this.setFillStyle(S).fill();
    }, Ei.prototype.taints = function(v) {
      if (v.tainted === null) {
        this.taintCtx.drawImage(v.image, 0, 0);
        try {
          this.taintCtx.getImageData(0, 0, 1, 1), v.tainted = !1;
        } catch {
          this.taintCtx = t.createElement("canvas").getContext("2d"), v.tainted = !0;
        }
      }
      return v.tainted;
    }, Ei.prototype.drawImage = function(v, S, E, V, Y, tt, _t, Pt, zt) {
      this.taints(v) && !this.options.allowTaint || this.ctx.drawImage(v.image, S, E, V, Y, tt, _t, Pt, zt);
    }, Ei.prototype.clip = function(v, S, E) {
      this.ctx.save(), v.filter(mo).forEach(function(V) {
        this.shape(V).clip();
      }, this), S.call(E), this.ctx.restore();
    }, Ei.prototype.shape = function(v) {
      return this.ctx.beginPath(), v.forEach(function(S, E) {
        S[0] === "rect" ? this.ctx.rect.apply(this.ctx, S.slice(1)) : this.ctx[E === 0 ? "moveTo" : S[0] + "To"].apply(this.ctx, S.slice(1));
      }, this), this.ctx.closePath(), this.ctx;
    }, Ei.prototype.font = function(v, S, E, V, Y, tt) {
      this.setFillStyle(v).font = [S, E, V, Y, tt].join(" ").split(",")[0];
    }, Ei.prototype.fontShadow = function(v, S, E, V) {
      this.setVariable("shadowColor", v.toString()).setVariable("shadowOffsetY", S).setVariable("shadowOffsetX", E).setVariable("shadowBlur", V);
    }, Ei.prototype.clearShadow = function() {
      this.setVariable("shadowColor", "rgba(0,0,0,0)");
    }, Ei.prototype.setOpacity = function(v) {
      this.ctx.globalAlpha = v;
    }, Ei.prototype.setTransform = function(v) {
      this.ctx.translate(v.origin[0], v.origin[1]), this.ctx.transform.apply(this.ctx, v.matrix), this.ctx.translate(-v.origin[0], -v.origin[1]);
    }, Ei.prototype.setVariable = function(v, S) {
      return this.variables[v] !== S && (this.variables[v] = this.ctx[v] = S), this;
    }, Ei.prototype.text = function(v, S, E) {
      this.ctx.fillText(v, S, E);
    }, Ei.prototype.backgroundRepeatShape = function(v, S, E, V, Y, tt, _t, Pt, zt) {
      this.clip(
        [
          [
            ["line", Math.round(Y), Math.round(tt)],
            ["line", Math.round(Y + _t), Math.round(tt)],
            ["line", Math.round(Y + _t), Math.round(Pt + tt)],
            ["line", Math.round(Y), Math.round(Pt + tt)]
          ]
        ],
        function() {
          this.renderBackgroundRepeat(v, S, E, V, zt[3], zt[0]);
        },
        this
      );
    }, Ei.prototype.renderBackgroundRepeat = function(v, S, E, V, Y, tt) {
      Y = Math.round(V.left + S.left + Y), S = Math.round(V.top + S.top + tt), this.setFillStyle(this.ctx.createPattern(this.resizeImage(v, E), "repeat")), this.ctx.translate(Y, S), this.ctx.fill(), this.ctx.translate(-Y, -S);
    }, Ei.prototype.renderBackgroundGradient = function(v, S) {
      if (v instanceof D) {
        var E = this.ctx.createLinearGradient(
          S.left + S.width * v.x0,
          S.top + S.height * v.y0,
          S.left + S.width * v.x1,
          S.top + S.height * v.y1
        );
        v.colorStops.forEach(function(V) {
          E.addColorStop(V.stop, V.color.toString());
        }), this.rectangle(S.left, S.top, S.width, S.height, E);
      }
    }, Ei.prototype.resizeImage = function(v, S) {
      var E = v.image;
      if (E.width === S.width && E.height === S.height) return E;
      var V = t.createElement("canvas");
      return V.width = S.width, V.height = S.height, V.getContext("2d").drawImage(E, 0, 0, E.width, E.height, 0, 0, S.width, S.height), V;
    };
  }
}).call(
  {},
  typeof window < "u" ? window : void 0,
  typeof document < "u" ? document : void 0
);
function pf(s) {
  const t = document.createElement("canvas");
  return t.width = s.width, t.height = s.height, t.getContext("2d").drawImage(s, 0, 0), t;
}
function rw(s) {
  if (s instanceof HTMLCanvasElement) {
    const t = s;
    if (t.clientWidth > 0 && t.clientHeight > 0)
      return s;
  }
  for (let t = 0; t < s.childNodes.length; t++) {
    const e = s.childNodes.item(t), i = rw(e);
    if (i)
      return i;
  }
  return null;
}
function BC(s) {
  const e = new DOMParser().parseFromString(s, "text/xml"), i = e.getElementsByTagName("defs"), n = [];
  for (let u = 0; u < i.length; u++) {
    const g = i.item(u).getElementsByTagName("marker");
    for (let y = 0; y < g.length; y++) {
      const _ = g.item(y);
      n.push(_);
    }
  }
  const r = [], o = e.getElementsByTagName("line");
  for (let u = 0; u < o.length; u++) {
    const f = o.item(u);
    if (f.style.marker !== null && f.style.marker.length > 0) {
      const g = f.style.marker.indexOf("#") + 1, y = f.style.marker.indexOf('"', g + 1), _ = f.style.marker.substring(g, y);
      let x = null, b = null;
      for (let C = 0; C < n.length; C++)
        if (n[C].id === _) {
          x = n[C], b = n[C + 1];
          break;
        }
      const I = { line: f, start: x, end: b };
      r.push(I);
    }
  }
  const l = "marker: url";
  let h = s.indexOf(l);
  for (; h >= 0; ) {
    const u = s.indexOf(")", h) + 1, f = s.substring(h, u), g = f.indexOf("#") + 1, y = f.indexOf('"', g), _ = f.indexOf(
      "&quot",
      g + l.length + 1
    );
    let x = y;
    (y < 0 || _ < y) && (x = _);
    const b = f.substring(g, x);
    for (const I of r) {
      const C = I.start, M = I.end;
      if (C !== null && M !== null && C.id === b) {
        let P = `marker-start: url('#${C.id}');`;
        P += `marker-end: url('#${M.id}')`, s = s.slice(0, h) + P + s.slice(u);
        break;
      }
    }
    h = s.indexOf(l, u + 1);
  }
  return s;
}
function VC(s, t) {
  const e = s.getContext("2d");
  if (e === null)
    throw new oe("failed to create 2D canvas context");
  for (const r of t)
    e.drawImage(r, 0, 0);
  const i = vi(), n = new Image();
  return n.src = s.toDataURL(), n.onload = () => {
    i.resolve(n);
  }, i;
}
class zC {
  constructor(t, e) {
    this._domElements = t, this._config = e;
  }
  _initSVGCanvasSize(t) {
    const e = t.parentElement;
    e && (e.clientWidth && (t.width = e.clientWidth), e.clientHeight && (t.height = e.clientHeight));
  }
  async _extractMarkupSvgAsCanvas() {
    const t = this._domElements.getMarkupSvgElement();
    let e = new XMLSerializer().serializeToString(t);
    e = BC(e);
    const i = document.createElement("canvas");
    document.body.appendChild(i), this._initSVGCanvasSize(i);
    const n = i.getContext("2d");
    if (!n)
      return i;
    await (await ma.from(n, e)).render();
    const o = pf(i);
    return document.body.removeChild(i), o;
  }
  async _extractRedlineSvgAsCanvas(t, e) {
    const i = this._domElements.getRedlineSvgElement();
    i.setAttribute("width", `${t}`), i.setAttribute("height", `${e}`);
    let n = new XMLSerializer().serializeToString(i);
    n = n.replace("width: 100%;", `width: ${t};`), n = n.replace("height: 100%;", `height: ${e};`);
    const r = document.createElement("canvas");
    document.body.appendChild(r);
    const o = r.getContext("2d");
    if (!o)
      return r;
    await (await ma.from(o, n)).render();
    const h = pf(r);
    return document.body.removeChild(r), h;
  }
  async _extractRedlineAsCanvas() {
    const t = this._domElements.getRedlineElement();
    return html2canvas(t, {
      background: void 0,
      letterRendering: !0
      // Fixes word break issue
    });
  }
  async capture(t) {
    const e = rw(t);
    if (e === null)
      throw new oe("failed to find canvas");
    const i = document.createElement("canvas");
    i.width = this._config.width || t.clientWidth, i.height = this._config.height || t.clientHeight, i.style.width = "100%", i.style.height = "100%";
    const n = [];
    return this._config.layers & Ec.Model && n.push(pf(e)), this._config.layers & Ec.Svg && (n.push(await this._extractMarkupSvgAsCanvas()), n.push(
      await this._extractRedlineSvgAsCanvas(i.width, i.height)
    )), this._config.layers & Ec.Html && n.push(await this._extractRedlineAsCanvas()), VC(i, n);
  }
}
class HC {
  constructor(t) {
    this._timeoutDurationMinutes = 15, this._timeoutWarningMinutes = 14, this._timer = new Ko(), this._enabled = !0, this._callbackManager = t, this.resetTimeout();
  }
  setTimeoutDurations(t, e) {
    return this._timeoutDurationMinutes = t, this._timeoutWarningMinutes = e, this.resetTimeout(), !0;
  }
  shutdown() {
    this._enabled = !1, this._timer.clear();
  }
  resetTimeout() {
    if (!this._enabled) return;
    const t = Math.round(this._timeoutWarningMinutes * 60 * 1e3);
    this._timer.set(t, () => {
      this._warn();
    });
  }
  _warn() {
    console.assert(this._timer.isIdle(Nn.BeforeAction));
    const t = this._timeoutDurationMinutes - this._timeoutWarningMinutes, e = Math.round(t * 60 * 1e3);
    this._callbackManager.trigger("timeoutWarning", t), this._timer.set(e, () => {
      this._timeout();
    });
  }
  _timeout() {
    this._callbackManager.trigger("timeout"), this._callbackManager.trigger("_timeout");
  }
}
const UC = "004b324", jC = `${Gm(dg)} Build ${UC}`;
class fl {
  constructor(t, e, i, n, r) {
    this._container = t, this._canvasContainerElement = e, this._markupSvgElement = i, this._redlineSvgElement = n, this._redlineElement = r;
  }
  getCanvasContainerElement() {
    return this._canvasContainerElement;
  }
  getMarkupSvgElement() {
    return this._markupSvgElement;
  }
  getRedlineSvgElement() {
    return this._redlineSvgElement;
  }
  getRedlineElement() {
    return this._redlineElement;
  }
  shutdown() {
    this._container.removeChild(this._markupSvgElement), this._container.removeChild(this._redlineSvgElement), this._container.removeChild(this._redlineElement), this._container.removeChild(this._canvasContainerElement);
  }
  static create(t) {
    return t instanceof HTMLElement ? this.createFromElement(t) : this.createFromId(t);
  }
  static createFromElement(t) {
    let e = t.id;
    e.length === 0 && (e = Ms());
    const i = `${e}-canvas-container`, n = `${e}-svg`, r = `${e}-redline-svg`, o = `${e}-redline`, l = document.createElement("div");
    l.id = i, l.style.width = "100%", l.style.height = "100%", l.style.position = "absolute", l.tabIndex = -1, l.classList.add("webviewer-canvas"), l.oncontextmenu = () => !1, t.appendChild(l);
    const h = fl._createSvgElement(n);
    t.appendChild(h);
    const u = fl._createSvgElement(r);
    t.appendChild(u);
    const f = document.createElement("div");
    return f.id = o, f.style.position = "absolute", f.style.width = "100%", f.style.height = "100%", f.style.pointerEvents = "none", t.appendChild(f), new fl(
      t,
      l,
      h,
      u,
      f
    );
  }
  static createFromId(t) {
    const e = document.getElementById(t);
    return e === null ? null : this.createFromElement(e);
  }
  static _createSvgElement(t) {
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return e.id = t, e.style.width = "100%", e.style.height = "100%", e.style.position = "absolute", e.style.pointerEvents = "none", e.style.overflow = "hidden", e.setAttributeNS(
      "http://www.w3.org/2000/xmlns/",
      "xmlns:xlink",
      "http://www.w3.org/1999/xlink"
    ), e;
  }
}
class cS {
  /**
   * Creates a new Web Viewer instance. You must pass in a **containerId** key with the ID of an element or a **container** element to use for your viewer.
   * The system will create any required elements inside the supplied container.
   *
   * @param inputParams object containing key-value pairs for viewer to set
   */
  constructor(t) {
    this._interpolationManager = new gI(), this._streamingMode = Ro.Interactive, this._rendererType = nh.Client, this._alreadyShutDown = !1, this._shutdownTimer = new Ko(), this._sceneReadyPromise = hd(), this._modelReady = !1, this._modelLoadFailure = !1, this._seenPriorityMetaDataSent = !1, this._views = [], this.config = { ...t }, this._contextMenuActiveFlag = !1;
    const e = t.container ?? t.containerId;
    if (e === void 0)
      throw new Rs("must supply 'container' or 'containerId'");
    this._callbackManager = new Ev(), this._timeoutMonitor = new HC(this._callbackManager), this._setInitialOptions(this.config), this._engine = new hI(this._callbackManager, this.config), this.model = new Pc(this._engine, this._callbackManager), this.measureManager = new xx(this, this._callbackManager), this.lineManager = new wx(this, this._callbackManager);
    const i = sl(
      this.config.disableAutomaticBackgroundSheets,
      !1
    );
    this.sheetManager = new Cx(
      this,
      this._engine,
      this._callbackManager,
      i
    ), this.noteTextManager = new ch(this), this.cuttingManager = new px(this, this.model, this._callbackManager, this._engine), this.explodeManager = new mx(this.model, this._engine, this._callbackManager), this.markupManager = new bx(
      this.measureManager,
      this.lineManager,
      this._callbackManager,
      this.sheetManager,
      this.noteTextManager,
      this
    );
    const n = fl.create(e);
    if (n === null)
      throw new Rs("Failed to create DOM container");
    this._views = [
      new $p(
        this,
        this._engine,
        this._callbackManager,
        this._timeoutMonitor,
        this._interpolationManager,
        {
          id: Ae.Default,
          domElements: n
        }
      )
    ], this.model._setDefaultView(this._views[0]);
    const r = {
      disableAutomaticFitWorld: sl(this.config.disableAutomaticFitWorld, !1),
      markImplicitNodesOutOfHierarchy: sl(
        this.config._markImplicitNodesOutOfHierarchy,
        !0
      ),
      streamingMode: sl(this.config.streamingMode, Ro.Default)
    };
    this._modelStructure = new sI(
      r,
      this._engine,
      this._callbackManager,
      this.cuttingManager,
      this.model
    ), this._modelStructure.init(this.view, this.config._maxConcurrentAttachments || null), this.model._setModelStructure(this._modelStructure), this.BCFManager = new fI(this), this.selectionManager = new wd(
      this,
      this._callbackManager,
      this._engine,
      this.model,
      this._modelStructure
    ), this.animationManager = new k_(this);
    const o = () => {
      this.model.setPmiColor(yt.black());
    }, l = (y) => {
      this.model.isDrawing() && (y = this.sheetManager.get3DNodes());
      const _ = Wt.PmiBody | Wt.ViewFrame;
      this.model._setInstanceModifier(
        tn.OverrideSceneVisibility,
        y,
        !0,
        _
      );
      for (const x of y)
        this.model.setPmiColorOverride(!0, x);
    }, h = async (y) => {
      y ? await Promise.all([
        this.view.setPointSize(3e-3, kf.ProportionOfBoundingDiagonal),
        this.view.setEyeDomeLightingEnabled(!0),
        this.view.setPointShape(Ef.Disk)
      ]) : await Promise.all([
        //reset to defaults
        this.view.setPointSize(1, kf.ScreenPixels),
        this.view.setEyeDomeLightingEnabled(!1),
        this.view.setPointShape(Ef.Square)
      ]);
    }, u = async (y) => {
      for (const _ of y) {
        const x = this.model.getModelFileTypeFromNode(_);
        if (x !== null && x !== kc.Unknown) {
          await h(!1);
          break;
        }
      }
    }, f = async (y) => {
      const _ = [];
      if (this.model.getModelFileTypeFromNode(y[0]) === kc.Ifc)
        for (const x of y) {
          const b = this.model.registerIfcNodes(x);
          _.push(b);
        }
      await Promise.all(_);
    }, g = (y) => {
      const _ = this.selectionManager.getSelectionFilter(), x = this.model.getModelFileTypeFromNode(y[0]) === kc.Ifc;
      if (!_ && x) {
        this.selectionManager.setSelectionFilter(Ff);
        return;
      }
      _ === Ff && !x && this.selectionManager.setSelectionFilter(null);
    };
    this.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        o();
      },
      _sessionStarted: () => h(!0),
      _firstModelLoaded: async (y, _, x, b) => {
        if (o(), g(y), l([this.model.getAbsoluteRootNode()]), await Promise.all([f(y), u(y)]), !b.attachInvisibly) {
          const I = this.model.getDefaultCadView() !== null;
          this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() && await this.model.activateDefaultCadConfiguration(!I, this.view), I && await this.model.activateDefaultCadView(void 0, void 0, this.view);
        }
      },
      _modelSwitched: async (y, _) => {
        g(_), l(_), await Promise.all([f(_), u(_)]);
      },
      _subtreeLoaded: async (y) => {
        l(y), await f(y);
      },
      modelLoadFailure: () => {
        this._modelLoadFailure = !0;
      }
    });
  }
  static get defaultEnginePath() {
    return oo.defaultEnginePath;
  }
  static set defaultEnginePath(t) {
    oo.defaultEnginePath = t;
  }
  static get defaultEngineBinary() {
    return oo.defaultBinary;
  }
  static set defaultEngineBinary(t) {
    oo.defaultBinary = t;
  }
  // Added for compatibility when overlay manager became a property of View
  /**
   * @deprecated OverlayManagers are now properties of Views.
   */
  get overlayManager() {
    return this.view.overlayManager;
  }
  // Added for compatibility when floorplan manager became a property of View
  /**
   * @deprecated FloorplanManagers are now properties of Views.
   */
  get floorplanManager() {
    return this.view.floorplanManager;
  }
  /**
   * Adds another 3D view of the scene to the page.
   * @param config configuration to be used for the new view.
   * @returns A promise with the created View.
   */
  async addView(t) {
    const e = fl.create(t.container);
    if (e === null)
      throw new Rs("container is undefined");
    const i = e.getCanvasContainerElement(), n = await this._engine.addView(i), r = new $p(
      this,
      this._engine,
      this._callbackManager,
      this._timeoutMonitor,
      this._interpolationManager,
      {
        id: n,
        domElements: e
      }
    );
    return r.inputMonitor.bindEvents(e.getCanvasContainerElement()), this._views.push(r), this._callbackManager.trigger("_drawContextCreated", n), r;
  }
  /**
   * Removes an existing view from the page. Note that the default view cannot be removed.
   * @param view The view to remove.
   */
  removeView(t) {
    if (t.id === Ae.Default)
      throw new oe("WebViewer.removeView: Cannot remove default view");
    const e = this._views.findIndex((i) => i.id === t.id);
    if (e === void 0)
      throw new oe(
        `WebViewer.removeView: Cannot remove view with id '${t.id}' (not found)`
      );
    this.markupManager._viewDeleted(t), this._engine.removeView(t.id), this._views.splice(e, 1), this._callbackManager.trigger("_drawContextDestroyed", t.id);
  }
  /**
   * Gets a view with the provided key.
   * @param viewKey The key of the view to be returned.
   * @returns The view, or undefined if it doesn't exist.
   */
  getView(t) {
    return this._views.find((e) => e.id === t);
  }
  get view() {
    return this._views[Ae.Default];
  }
  get views() {
    return this._views;
  }
  /**
   * @deprecated OperatorManagers are now properties of Views.
   */
  get operatorManager() {
    return this.view.operatorManager;
  }
  /**
   * Sets a boolean with the status of the context menu
   * @param isActive
   */
  setContextMenuStatus(t) {
    this._contextMenuActiveFlag = t;
  }
  /**
   * @returns boolean true if the context menu is active, false otherwise
   */
  getContextMenuStatus() {
    return this._contextMenuActiveFlag;
  }
  /**
   * @param options
   */
  _setInitialOptions(t) {
    t.streamingMode !== void 0 ? this._streamingMode = t.streamingMode : t.streamingMode = this._streamingMode, t.rendererType !== void 0 ? this._rendererType = t.rendererType : t.rendererType = this._rendererType;
  }
  /**
   * Returns the viewer version string.
   * @returns string containing version information for the viewer.
   */
  getViewerVersionString() {
    return jC;
  }
  /**
   * Returns the format version string.
   * @returns string containing version information for the format.
   */
  getFormatVersionString() {
    return this._engine.getVersionString();
  }
  /**
   * Starts the viewer and begins the loading process
   */
  start() {
    const t = this.view.domElements.getCanvasContainerElement();
    return this._engine.start(t, {
      enginePath: this.config.enginePath,
      engineReady: async (e) => {
        await e, await this._modelStructure.waitForReady(), await this._scEngineReady();
      },
      sceneReady: () => {
        this._sceneReady();
      },
      renderComplete: () => {
        this._renderComplete();
      },
      streamingActivated: () => {
        this._streamingActivated();
      },
      streamingDeactivated: () => {
        this._streamingDeactivated();
      },
      priorityMetaDataSent: (e, i) => {
        this._priorityMetaDataSent(e, i);
      }
    });
  }
  /**
   * Associates a custom operator object with a system generated operatorId.
   * @param operatorId the ID of the operator that is to be unregistered
   * @returns an operatorId to be used for this operator.
   */
  registerCustomOperator(t) {
    return this.operatorManager.registerCustomOperator(t);
  }
  /**
   * Removes a previously registered custom operator from the system.
   * @param operatorId the ID of the operator that is to be unregistered
   */
  unregisterCustomOperator(t) {
    this.operatorManager.unregisterCustomOperator(t);
  }
  /**
   * Sets whether keyboard input should be directed to this Web Viewer.
   * @param focus if true, the Web Viewer will be focused and accept keyboard input, otherwise it will be blurred and not accept keyboard input
   */
  focusInput(t) {
    this.view.inputMonitor.focusInput(t);
  }
  /**
   * Registers callbacks that will be called when their corresponding events occur.
   * @param callbacks object with property names set to corresponding functions to be called when the event occurs.
   */
  setCallbacks(t) {
    this._callbackManager.bind(t);
  }
  /**
   * Unregisters callbacks from the system. Note the actual function object passed in must be the same as the one that was registered using setCallbacks.
   * @param callbacks object with property names set to corresponding functions to be unregistered.
   */
  unsetCallbacks(t) {
    this._callbackManager.unbind(t);
  }
  /**
   * This method should be called after the container element is moved or resized.
   */
  resizeCanvas() {
    this._alreadyShutDown || (this._engine.resize(), this.view.inputMonitor.elementResize());
  }
  /**
   * This method should be called when the viewer is being moved to a new window. An example use case would be opening a new pop up window.
   * @param win the new document that this viewer will be associated with.
   */
  moveToWindow(t) {
    this.view.inputMonitor.setDocument(t.document);
  }
  /**
   * Forces the viewer to perform a full redraw of all views.
   * @param callback A function to be called once the draw is complete.
   * This is provided instead of a `Promise` to ensure the callback is
   * called before the start of another redraw.
   */
  redraw(t) {
    if (t) {
      const e = (i) => {
        this._callbackManager.unbind({ _drawComplete: e }), t();
      };
      this._callbackManager.bind({ _drawComplete: e });
    }
    for (const e of this.views)
      this._engine.redraw(e.id);
  }
  /**
   * Selects a part with the given Id.
   * @param nodeId nodeId of the part to select. Pass null to clear the selection.
   */
  selectPart(t, e = In.Set) {
    return this.selectionManager.selectNode(t, e);
  }
  /**
   * Used to trigger Web Viewer events from operators. Refer to the overloaded method signatures for acceptable invocations of this method. Refer to [[CallbackMap]] for additional details for each event.
   * @param name
   * @param args
   */
  trigger(t, ...e) {
    this._callbackManager.unsafeTrigger(t, e);
  }
  /** @hidden */
  _getCallbackManager() {
    return this._callbackManager;
  }
  /** @hidden */
  _setStreamIdleMarker() {
    return this._engine.setStreamIdleMarker();
  }
  /**
   * Gets viewer statistics for the current rendered frame. Statistics marked with a (*) below must be calculated and will not be included in the results unless the calculateTotals parameter is true.
   * The values of these items will be cached and only updated during the next call to this method with calculateTotals set to true.
   * @param calculateTotals Forces an update of the total count elements. Please note that repeatedly calculating these items can cause a performance impact.
   * @returns an object containing informational key/value pairs
   *
   * | Statistic Name| Description                                          |
   * | ----------------------- | -----------------------------------------------------|
   * | draw_call_count  | number of draw calls made when rendering the frame             |
   * | frames_per_second  | frames per second estimation    |
   * | triangle_count  | the number of triangles rendered    |
   * | line_segment_count  | the number of line segments rendered    |
   * | point_count  | the number of points rendered    |
   * | total_element_count(*)  | the total number of elements in the scene    |
   * | total_triangle_count(*)  | the total number of triangles in the scene   |
   *
   */
  getStatistics(t = !1) {
    return this._engine.getStatistics(t);
  }
  /**
   * Sets a minimum frame rate that will be maintained by all views.
   * Views will use various culling techniques in order to maintain the value passed in.
   *
   * Passing `0` will cause the entire scene to be drawn for every frame.
   * @param value The frame rate for the views to maintain.
   * @returns Promise that is resolved when the operation has completed.
   */
  setMinimumFramerate(t) {
    return this._setMinimumFramerate(t), Promise.resolve();
  }
  _setMinimumFramerate(t) {
    for (const e of this.views)
      this._engine.setMinimumFramerate(e.id, t);
  }
  /**
   * Gets the minimum framerate that will be maintained by the viewer. The viewer will use various culling techniques in order to maintain the value returned.
   * @returns Promise that is resolved when the operation has completed.
   * @deprecated Views can have independent framerates. This should be set using `View.getMinimumFramerate`.
   */
  getMinimumFramerate() {
    return this._engine.getMinimumFramerate(Ae.Default);
  }
  /**
   * Sets the image quality settings for the high quality and low quality server side render. The low quality settings will be applied during model interaction (camera changes, selection, etc)
   * @param jpegQualityLow The JPEG quality of the low quality render frame
   * @param jpegQualityHigh The JPEG quality of the high quality render frame
   * @param scaleLow The scale factor for the low quality render frame
   * @param scaleHigh The scale factor for the high quality render frame
   */
  setServerRenderQuality(t, e, i, n) {
    return this._engine.setServerRenderQuality(
      t,
      e,
      i,
      n
    );
  }
  /**
   * Gets the streaming mode this viewer was created with.
   * @returns the streaming mode.
   */
  getStreamingMode() {
    return this._streamingMode;
  }
  /**
   * Gets the RendererType this viewer was created with.
   * @returns the render mode.
   */
  getRendererType() {
    return this._engine.getRendererType();
  }
  /**
   * Gets the view element for this viewer. This element contains the canvas
   * @returns the view element
   */
  getViewElement() {
    return this.view.domElements.getCanvasContainerElement();
  }
  /**
   * Releases the resources used by the viewer. This method should be called when the viewer is no longer needed but the page is not being reloaded.
   */
  shutdown() {
    if (!this._alreadyShutDown) {
      if (this._shutdownTimer.clear(), !this._modelStructure.isReady() && !this._modelLoadFailure) {
        this._shutdownTimer.set(500, () => {
          this.shutdown();
        });
        return;
      }
      this._callbackManager.trigger("_shutdownBegin"), this.operatorManager._shutdown(), this.markupManager._shutdown(), this._timeoutMonitor.shutdown(), this._modelStructure.shutdown();
      for (const t of this._views)
        t.domElements.shutdown(), t.inputMonitor.shutdown();
      this._engine.shutdown(), this.animationManager._shutdown(), this._alreadyShutDown = !0;
    }
  }
  /**
   * Sets the parameters for client driven timeout monitoring.
   * If no input is recorded for the the duration, the viewer will disconnect and free server resources.
   * Calling this method will reset any pending timeout duration.
   * No timeout will occur when viewing SCS Files.
   * The default value is to disconnect after 15 minutes, with a warning issued after 14 minutes of inactivity.
   * <br><br> <strong>Please note:</strong> Both parameters are required.
   * @param timeoutDuration the total time in minutes of inactivity that is allowed before a timeout event occurs
   * @param warningTime the number of minutes before issuing a timeoutWarning event
   * @returns boolean value indicating whether the timeout values were sucessfully updated
   */
  setClientTimeout(t, e) {
    return this._timeoutMonitor.setTimeoutDurations(t, e);
  }
  /**
   * Resets the client timeout to the duration set with setClientTimeout.
   */
  resetClientTimeout() {
    this._timeoutMonitor.resetTimeout();
  }
  /**
   * Pauses rendering updates for all views. This function is useful when
   * performing large batches of updates and you would like the result
   * to appear all at once.
   *
   * @param callback If provided, rendering will be paused, the callback
   * will be called, and then rendering will be resumed once the callback
   * returns or throws an exception.
   */
  pauseRendering(t) {
    return this._pauseRendering(t), Promise.resolve();
  }
  _pauseRendering(t) {
    this._engine.pauseAllRendering(t);
  }
  /**
   * Resumes rendering for all views.
   */
  resumeRendering() {
    return this._resumeRendering(), Promise.resolve();
  }
  _resumeRendering() {
    this._engine.resumeAllRendering();
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this.cuttingManager.delayCapping();
  }
  /**
   * Reset the camera, visibility, and transforms to their default state
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   * @returns Promise that resolves when the operation has completed.
   */
  async reset(t = cs) {
    await this.model.reset();
    const e = this.model.getDefaultCadView() !== null;
    this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() ? await this.model.activateDefaultCadConfiguration(!e, this.view) : !this.sheetManager.isDrawingSheetActive() && !e && await this.view.resetCamera(t), e && await this.model.activateDefaultCadView(t, !0, this.view);
  }
  /**
   * Disconnects the network connection when in CSR mode.
   */
  closeConnection() {
    this.view.setCamera(this.view.getCamera()), this._engine.disconnectNetwork(), this._timeoutMonitor.shutdown();
  }
  /**
   * Controls rendering on high DPI displays. If true, the image will be rendered at full resolution when a high-DPI display is detected. If false, the image may be rendered at a lower resolution. The default value is false.
   * This method may be called any time during or after the sceneReady callback has triggered.
   * @param allow controls the high DPI Setting.
   */
  setAllowHighDpi(t) {
    this._engine.setAllowHighDpi(t);
  }
  /**
   * Gets the current value for high DPI rendering
   * @returns current high DPI setting
   */
  getAllowHighDpi() {
    return this._engine.getAllowHighDpi();
  }
  /**
   * Creates an Image of the current canvas
   */
  takeSnapshot(t = new Sx()) {
    const e = vi(), i = new zC(this.view.domElements, t), n = this.view.domElements.getCanvasContainerElement(), r = this.view.domElements.getRedlineElement(), o = t.width > 0 && t.height > 0;
    if (o) {
      const h = `${100 * (t.width / n.clientWidth)}%`, u = `${100 * (t.height / n.clientHeight)}%`;
      n.style.width = h, n.style.height = u, r.style.width = h, r.style.height = u;
    }
    const l = this.getAllowHighDpi();
    return this._engine.setAllowHighDpi(!1), this._engine.resize(), this.redraw(async () => {
      const h = await i.capture(n);
      o && (n.style.width = "100%", n.style.height = "100%", r.style.width = "100%", r.style.height = "100%"), this._engine.setAllowHighDpi(l), this._engine.resize(), e.resolve(h);
    }), e;
  }
  fitWorld(t = cs) {
    return this.view.fitWorld(t);
  }
  /**
   * Sets the orientation of the current model view.
   * @param orientation a [[ViewOrientation]] object specifying back, front, top, etc.
   * @param duration the time in milliseconds for the model to transition to the new view orientation.
   */
  async setViewOrientation(t, e = cs) {
    await this.view.setViewOrientation(t, e), this.view.injectViewOrientationChangeEvent();
  }
  _applyMetallicRoughnessDefaults() {
    let t = 1, e = 1, i = !1;
    this.config.defaultMetallicFactor != null && (t = this.config.defaultMetallicFactor, i = !0), this.config.defaultRoughnessFactor != null && (e = this.config.defaultRoughnessFactor, i = !0), i && this._engine.setMetallicRoughnessMaterialOverride(
      t,
      e
    );
  }
  async _scEngineReady() {
    console.assert(this._modelStructure.isReady());
    const t = this.model.getAbsoluteRootNode(), e = this._engine.getSessionType();
    try {
      this.cuttingManager._init(), await this._sceneReadyPromise, await this._callbackManager.promiseTrigger("_assemblyTreeReady", "assemblyTreeReady"), this._modelReady = !0;
      let i = "";
      try {
        const n = new Ma();
        n._allowSubtreeLoadedCallback = !1;
        let r = 0;
        if (this._applyMetallicRoughnessDefaults(), e === nn.Network)
          i = this._engine.getNetworkModelName(), i === wa || await this.model.loadSubtreeFromModel(t, i, n);
        else if (e === nn.Scs) {
          this._timeoutMonitor.shutdown();
          const o = this._engine.getScsInfo();
          typeof o == "string" ? await this.model.loadSubtreeFromScsFile(t, o, n) : o !== null && await this.model.loadSubtreeFromScsBuffer(t, o, n), this.config.streamCutoffScale !== void 0 && (r = this.config.streamCutoffScale);
        } else
          throw new oi();
        this._modelStructure.setPrefetchScsCutoffScale(r);
      } catch (n) {
        throw this._callbackManager.trigger("modelLoadFailure", i, `${n}`, n), n;
      }
    } finally {
      console.assert(this._modelStructure.isReady());
    }
    return this._callbackManager.promiseTrigger("_modelStructureReady", "modelStructureReady");
  }
  _sceneReady() {
    this.view.inputMonitor.bindEvents(this.view.domElements.getCanvasContainerElement()), this.selectionManager._init(), this._callbackManager.bind({
      _timeout: () => {
        this.shutdown();
      }
    }), this._callbackManager.trigger("sceneReady"), this._sceneReadyPromise && this._sceneReadyPromise.resolve();
  }
  getSceneReady() {
    return this._sceneReadyPromise.state === Wr.Resolved;
  }
  getModelReady() {
    return this._modelReady;
  }
  _priorityMetaDataSent(t, e) {
    if (this._callbackManager.trigger("_priorityMetaDataSent", t, e), !this._seenPriorityMetaDataSent) {
      if (t !== ba.OfInitialEmptyModel || e !== 0)
        throw new oi();
      this._seenPriorityMetaDataSent = !0, this._callbackManager.trigger("_attached", ba.OfInitialEmptyModel);
    }
  }
  _renderComplete() {
    this.markupManager._update();
  }
  _streamingActivated() {
    this._callbackManager.trigger("streamingActivated");
  }
  _streamingDeactivated() {
    this._callbackManager.trigger("streamingDeactivated");
  }
  /**
   * Specifies a scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff.
   *
   * This value may also be set for file-based sessions.  In that case, when loading
   * an SCS file based assembly via XML, projected size will be calculated on a
   * per-file basis using the bounding information provided in the XML.
   * For additional information, refer to [[Model.loadSubtreeFromXmlBuffer]].
   *
   * A value of 0 will disable the cutoff.  The value should be in the interval of [0.0, 2.0].
   */
  setStreamCutoffScale(t) {
    return this._setStreamCutoffScale(t), Promise.resolve();
  }
  _setStreamCutoffScale(t) {
    this._engine.setStreamCutoffScale(t), this._modelStructure.setPrefetchScsCutoffScale(t);
  }
  /**
   * Returns the scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff. A value of 0 disables the cutoff.
   */
  getStreamCutoffScale() {
    return this._engine.getStreamCutoffScale();
  }
  /** @hidden */
  _loseWebGlContext() {
    return this._engine.loseWebGlContext();
  }
  /** @hidden */
  _getScEngine() {
    return this._engine;
  }
  /** @hidden */
  _debug_log(t) {
    return this._engine.debug_log(t);
  }
  /** @hidden */
  _debug_stateFailure(t) {
    return this._engine.debug_stateFailure(t);
  }
  /** @hidden */
  _debug_sync() {
    return this._engine.debug_sync();
  }
  /**
   * Exports the current scene to a two-dimensional SVG representation.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to the created SVG string.
   */
  async exportToSvg(t = new Gp()) {
    let e;
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), e = await this._engine.exportToSvg(t);
    } finally {
      this.cuttingManager._setStandinGeometryVisible(!0);
    }
    return e ?? "";
  }
  /**
   * Setup the env to export the current scene to a two-dimensional SVG representation through stream.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to void when the env is ready.
   */
  async beginExportToSvg(t = new Gp()) {
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), await this._engine.beginExportToSvg(t);
    } catch {
      await this.endExportToSvg();
    }
  }
  /**
   * Reset the env after SVG stream export.
   *
   * @return A promise that resolves to void when the env is reset.
   */
  async endExportToSvg() {
    return this.cuttingManager._setStandinGeometryVisible(!0);
  }
  /**
   * Get the next chunk of the SVG code
   *
   * @return A promise that resolves to a string containing the next chunk or undefined on completed..
   */
  async advanceExportToSvg() {
    return this._engine.advanceExportToSvg();
  }
  /**
   * Returns a Promise that will resolve after streaming and associated
   * asynchronous operations complete and the scene is fully drawn.
   */
  async waitForIdle(t = {}) {
    if (this._alreadyShutDown)
      return;
    await this._setStreamIdleMarker();
    const e = [];
    if (this.cuttingManager.hasActiveCuttingSection() && (await this.cuttingManager.enableCappingIdleCallback(!0) || e.push(this.cuttingManager.waitForCappingIdle())), e.push(this._engine.waitForImageDecoding()), await Promise.all(e), t.redraw !== !1) {
      const i = vi();
      this.redraw(() => {
        i.resolve();
      }), await i;
    }
  }
  applyFilter(t) {
    this._modelStructure.applyFilters([t]);
  }
}
export {
  tS as Animation,
  pg as AntiAliasingMode,
  Pa as AssemblyDataParseError,
  Hr as AttributeType,
  Ze as Axis,
  $f as AxisTriad,
  gi as BasicUnit,
  eS as Bcf,
  iS as Bim,
  _n as BimMask,
  Xs as BlurIntervalUnit,
  So as BoundingPreviewMode,
  wn as Box,
  ue as BranchVisibility,
  be as BuiltinOverlayIndex,
  Te as Button,
  ws as Buttons,
  Sn as Camera,
  yt as Color,
  oe as CommunicatorError,
  Pb as CullingVectorSpace,
  px as CuttingManager,
  Wp as CuttingPlane,
  gx as CuttingSection,
  cs as DefaultTransitionDuration,
  Gf as DepthRange,
  _x as DirectionalLight,
  cr as DrawMode,
  C_ as DrawStrategy,
  Jt as ElementType,
  wa as EmptyModelName,
  oS as Event,
  le as EventType,
  mx as ExplodeManager,
  kb as FaceFaceDistanceItem,
  Av as FaceMeshData,
  Qs as FaceWinding,
  kc as FileType,
  bb as FilterId,
  zp as FilteredNodes,
  sS as Floorplan,
  ol as FloorplanOrientation,
  Co as HandleEventType,
  zr as HandleType,
  ys as ImageFormat,
  _d as IncrementalPickConfig,
  Cb as InfoType,
  tn as InstanceModifier,
  oi as InternalLogicError,
  mg as InvalidIndexError,
  gg as InvalidNodeId,
  Ns as InvalidNodeIdError,
  os as InvalidNodeTypeError,
  Qe as KeyCode,
  Pf as KeyInputType,
  Mi as KeyModifiers,
  xb as LayerId,
  By as Light,
  wx as LineManager,
  Eb as LinePatternLengthUnit,
  dd as LoadCancelledError,
  Kr as LoadError,
  Ma as LoadSubtreeConfig,
  aS as Markup,
  bx as MarkupManager,
  bd as MarkupTypeManager,
  wt as Matrix,
  xx as MeasureManager,
  Ss as MeshData,
  ee as MeshInstanceCreationFlags,
  tr as MeshInstanceData,
  fd as MissingModelError,
  Pc as Model,
  _r as MouseInputType,
  qf as NavCube,
  uo as NodeSource,
  Le as NodeType,
  Zw as Ohm,
  ve as OperatorId,
  Ix as OperatorManager,
  lS as Operators,
  gc as OrbitFallbackMode,
  nS as Overlay,
  qe as OverlayAnchor,
  Fe as OverlayUnit,
  Rs as ParseError,
  Pi as PickConfig,
  No as PickOutsideCanvasError,
  ln as Plane,
  x_ as PmiSubType,
  sh as PmiTopoRef,
  b_ as PmiType,
  X as Point2,
  m as Point3,
  Ur as Point4,
  yx as PointLight,
  Dv as PointMeshData,
  Ef as PointShape,
  kf as PointSizeUnit,
  Tv as PolylineMeshData,
  ri as Projection,
  ts as Quaternion,
  vr as Ray,
  Mb as RefOnTopoItem,
  I_ as RelationshipType,
  nh as RendererType,
  $C as Sc,
  Ib as ScreenConfiguration,
  rS as Selection,
  Dr as SelectionHighlightMode,
  so as SelectionInvalidatedError,
  Pe as SelectionMask,
  In as SelectionMode,
  On as SelectionType,
  Cx as SheetManager,
  Af as SimpleReflectionAttenuationUnit,
  Sx as SnapshotConfig,
  Ec as SnapshotLayer,
  Ro as StreamingMode,
  Mc as SubentityAttributes,
  Yw as Subscript1,
  Sp as Subscript2,
  Mp as Subscript3,
  Zd as SubscriptNeg,
  Gp as SvgConfig,
  Nb as TextureModifier,
  Db as TextureParameterization,
  Tf as TextureTiling,
  Su as TouchInputType,
  Sb as TransparencyMode,
  Tb as TreeWalkMode,
  qC as Util,
  Vy as VerticalGradient,
  $p as View,
  Vp as ViewAxes,
  Ae as ViewKey,
  Ct as ViewOrientation,
  Ab as VisibilityState,
  Re as WalkDirection,
  pc as WalkMode,
  cS as WebViewer,
  rh as XRayGroup,
  si as XmlParseError,
  rv as closestPointFromPointToSegment,
  Sm as closestPointScalarFromPointToSegment,
  wr as computeAngleBetweenVector,
  rc as computeOffaxisRotation,
  io as computePointToLineDistance,
  WC as core,
  Ms as createUuid,
  Lo as degreesToRadians,
  sv as distanceLineLine,
  Hc as formatWithUnit,
  mf as generateArcPoints,
  nv as generatePointsOnCircle,
  uv as get3dBaseFromVector,
  lv as getLongUnitString,
  hv as getOrthogonalVector,
  ev as intersect3d2Planes,
  Vo as intersectionPlaneLine,
  Im as intersectionPlaneLine2,
  fv as isIColor,
  vm as isIPoint2,
  bm as isIPoint3,
  GC as isIPoint4,
  Mm as isPointInRect2d,
  ov as isPointOnLineSegment,
  oc as isPointOnLineSegment2d,
  Cm as lineLineIntersect,
  xm as oneVectorCross,
  Qf as radiansToDegrees,
  dv as sortVerticesCounterClockwise
};
